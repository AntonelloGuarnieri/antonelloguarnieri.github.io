var MR = Object.defineProperty;
var AR = (n,e,t)=>e in n ? MR(n, e, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: t
}) : n[e] = t;
var ly = (n,e,t)=>(AR(n, typeof e != "symbol" ? e + "" : e, t),
t);
(function() {
    const e = document.createElement("link").relList;
    if (e && e.supports && e.supports("modulepreload"))
        return;
    for (const i of document.querySelectorAll('link[rel="modulepreload"]'))
        r(i);
    new MutationObserver(i=>{
        for (const s of i)
            if (s.type === "childList")
                for (const o of s.addedNodes)
                    o.tagName === "LINK" && o.rel === "modulepreload" && r(o)
    }
    ).observe(document, {
        childList: !0,
        subtree: !0
    });
    function t(i) {
        const s = {};
        return i.integrity && (s.integrity = i.integrity),
        i.referrerpolicy && (s.referrerPolicy = i.referrerpolicy),
        i.crossorigin === "use-credentials" ? s.credentials = "include" : i.crossorigin === "anonymous" ? s.credentials = "omit" : s.credentials = "same-origin",
        s
    }
    function r(i) {
        if (i.ep)
            return;
        i.ep = !0;
        const s = t(i);
        fetch(i.href, s)
    }
}
)();
var Xb = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function CR(n) {
    return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n
}
var ot = {}
  , ER = {
    get exports() {
        return ot
    },
    set exports(n) {
        ot = n
    }
}
  , Zv = {}
  , we = {}
  , bR = {
    get exports() {
        return we
    },
    set exports(n) {
        we = n
    }
}
  , rr = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Dm = Symbol.for("react.element")
  , TR = Symbol.for("react.portal")
  , DR = Symbol.for("react.fragment")
  , PR = Symbol.for("react.strict_mode")
  , RR = Symbol.for("react.profiler")
  , BR = Symbol.for("react.provider")
  , IR = Symbol.for("react.context")
  , LR = Symbol.for("react.forward_ref")
  , FR = Symbol.for("react.suspense")
  , kR = Symbol.for("react.memo")
  , OR = Symbol.for("react.lazy")
  , hA = Symbol.iterator;
function NR(n) {
    return n === null || typeof n != "object" ? null : (n = hA && n[hA] || n["@@iterator"],
    typeof n == "function" ? n : null)
}
var Jb = {
    isMounted: function() {
        return !1
    },
    enqueueForceUpdate: function() {},
    enqueueReplaceState: function() {},
    enqueueSetState: function() {}
}
  , jb = Object.assign
  , Yb = {};
function Eh(n, e, t) {
    this.props = n,
    this.context = e,
    this.refs = Yb,
    this.updater = t || Jb
}
Eh.prototype.isReactComponent = {};
Eh.prototype.setState = function(n, e) {
    if (typeof n != "object" && typeof n != "function" && n != null)
        throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
    this.updater.enqueueSetState(this, n, e, "setState")
}
;
Eh.prototype.forceUpdate = function(n) {
    this.updater.enqueueForceUpdate(this, n, "forceUpdate")
}
;
function Kb() {}
Kb.prototype = Eh.prototype;
function Nw(n, e, t) {
    this.props = n,
    this.context = e,
    this.refs = Yb,
    this.updater = t || Jb
}
var zw = Nw.prototype = new Kb;
zw.constructor = Nw;
jb(zw, Eh.prototype);
zw.isPureReactComponent = !0;
var pA = Array.isArray
  , qb = Object.prototype.hasOwnProperty
  , Gw = {
    current: null
}
  , Qb = {
    key: !0,
    ref: !0,
    __self: !0,
    __source: !0
};
function Zb(n, e, t) {
    var r, i = {}, s = null, o = null;
    if (e != null)
        for (r in e.ref !== void 0 && (o = e.ref),
        e.key !== void 0 && (s = "" + e.key),
        e)
            qb.call(e, r) && !Qb.hasOwnProperty(r) && (i[r] = e[r]);
    var a = arguments.length - 2;
    if (a === 1)
        i.children = t;
    else if (1 < a) {
        for (var l = Array(a), f = 0; f < a; f++)
            l[f] = arguments[f + 2];
        i.children = l
    }
    if (n && n.defaultProps)
        for (r in a = n.defaultProps,
        a)
            i[r] === void 0 && (i[r] = a[r]);
    return {
        $$typeof: Dm,
        type: n,
        key: s,
        ref: o,
        props: i,
        _owner: Gw.current
    }
}
function zR(n, e) {
    return {
        $$typeof: Dm,
        type: n.type,
        key: e,
        ref: n.ref,
        props: n.props,
        _owner: n._owner
    }
}
function Uw(n) {
    return typeof n == "object" && n !== null && n.$$typeof === Dm
}
function GR(n) {
    var e = {
        "=": "=0",
        ":": "=2"
    };
    return "$" + n.replace(/[=:]/g, function(t) {
        return e[t]
    })
}
var mA = /\/+/g;
function uy(n, e) {
    return typeof n == "object" && n !== null && n.key != null ? GR("" + n.key) : e.toString(36)
}
function V0(n, e, t, r, i) {
    var s = typeof n;
    (s === "undefined" || s === "boolean") && (n = null);
    var o = !1;
    if (n === null)
        o = !0;
    else
        switch (s) {
        case "string":
        case "number":
            o = !0;
            break;
        case "object":
            switch (n.$$typeof) {
            case Dm:
            case TR:
                o = !0
            }
        }
    if (o)
        return o = n,
        i = i(o),
        n = r === "" ? "." + uy(o, 0) : r,
        pA(i) ? (t = "",
        n != null && (t = n.replace(mA, "$&/") + "/"),
        V0(i, e, t, "", function(f) {
            return f
        })) : i != null && (Uw(i) && (i = zR(i, t + (!i.key || o && o.key === i.key ? "" : ("" + i.key).replace(mA, "$&/") + "/") + n)),
        e.push(i)),
        1;
    if (o = 0,
    r = r === "" ? "." : r + ":",
    pA(n))
        for (var a = 0; a < n.length; a++) {
            s = n[a];
            var l = r + uy(s, a);
            o += V0(s, e, t, l, i)
        }
    else if (l = NR(n),
    typeof l == "function")
        for (n = l.call(n),
        a = 0; !(s = n.next()).done; )
            s = s.value,
            l = r + uy(s, a++),
            o += V0(s, e, t, l, i);
    else if (s === "object")
        throw e = String(n),
        Error("Objects are not valid as a React child (found: " + (e === "[object Object]" ? "object with keys {" + Object.keys(n).join(", ") + "}" : e) + "). If you meant to render a collection of children, use an array instead.");
    return o
}
function yg(n, e, t) {
    if (n == null)
        return n;
    var r = []
      , i = 0;
    return V0(n, r, "", "", function(s) {
        return e.call(t, s, i++)
    }),
    r
}
function UR(n) {
    if (n._status === -1) {
        var e = n._result;
        e = e(),
        e.then(function(t) {
            (n._status === 0 || n._status === -1) && (n._status = 1,
            n._result = t)
        }, function(t) {
            (n._status === 0 || n._status === -1) && (n._status = 2,
            n._result = t)
        }),
        n._status === -1 && (n._status = 0,
        n._result = e)
    }
    if (n._status === 1)
        return n._result.default;
    throw n._result
}
var Po = {
    current: null
}
  , W0 = {
    transition: null
}
  , HR = {
    ReactCurrentDispatcher: Po,
    ReactCurrentBatchConfig: W0,
    ReactCurrentOwner: Gw
};
rr.Children = {
    map: yg,
    forEach: function(n, e, t) {
        yg(n, function() {
            e.apply(this, arguments)
        }, t)
    },
    count: function(n) {
        var e = 0;
        return yg(n, function() {
            e++
        }),
        e
    },
    toArray: function(n) {
        return yg(n, function(e) {
            return e
        }) || []
    },
    only: function(n) {
        if (!Uw(n))
            throw Error("React.Children.only expected to receive a single React element child.");
        return n
    }
};
rr.Component = Eh;
rr.Fragment = DR;
rr.Profiler = RR;
rr.PureComponent = Nw;
rr.StrictMode = PR;
rr.Suspense = FR;
rr.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = HR;
rr.cloneElement = function(n, e, t) {
    if (n == null)
        throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + n + ".");
    var r = jb({}, n.props)
      , i = n.key
      , s = n.ref
      , o = n._owner;
    if (e != null) {
        if (e.ref !== void 0 && (s = e.ref,
        o = Gw.current),
        e.key !== void 0 && (i = "" + e.key),
        n.type && n.type.defaultProps)
            var a = n.type.defaultProps;
        for (l in e)
            qb.call(e, l) && !Qb.hasOwnProperty(l) && (r[l] = e[l] === void 0 && a !== void 0 ? a[l] : e[l])
    }
    var l = arguments.length - 2;
    if (l === 1)
        r.children = t;
    else if (1 < l) {
        a = Array(l);
        for (var f = 0; f < l; f++)
            a[f] = arguments[f + 2];
        r.children = a
    }
    return {
        $$typeof: Dm,
        type: n.type,
        key: i,
        ref: s,
        props: r,
        _owner: o
    }
}
;
rr.createContext = function(n) {
    return n = {
        $$typeof: IR,
        _currentValue: n,
        _currentValue2: n,
        _threadCount: 0,
        Provider: null,
        Consumer: null,
        _defaultValue: null,
        _globalName: null
    },
    n.Provider = {
        $$typeof: BR,
        _context: n
    },
    n.Consumer = n
}
;
rr.createElement = Zb;
rr.createFactory = function(n) {
    var e = Zb.bind(null, n);
    return e.type = n,
    e
}
;
rr.createRef = function() {
    return {
        current: null
    }
}
;
rr.forwardRef = function(n) {
    return {
        $$typeof: LR,
        render: n
    }
}
;
rr.isValidElement = Uw;
rr.lazy = function(n) {
    return {
        $$typeof: OR,
        _payload: {
            _status: -1,
            _result: n
        },
        _init: UR
    }
}
;
rr.memo = function(n, e) {
    return {
        $$typeof: kR,
        type: n,
        compare: e === void 0 ? null : e
    }
}
;
rr.startTransition = function(n) {
    var e = W0.transition;
    W0.transition = {};
    try {
        n()
    } finally {
        W0.transition = e
    }
}
;
rr.unstable_act = function() {
    throw Error("act(...) is not supported in production builds of React.")
}
;
rr.useCallback = function(n, e) {
    return Po.current.useCallback(n, e)
}
;
rr.useContext = function(n) {
    return Po.current.useContext(n)
}
;
rr.useDebugValue = function() {}
;
rr.useDeferredValue = function(n) {
    return Po.current.useDeferredValue(n)
}
;
rr.useEffect = function(n, e) {
    return Po.current.useEffect(n, e)
}
;
rr.useId = function() {
    return Po.current.useId()
}
;
rr.useImperativeHandle = function(n, e, t) {
    return Po.current.useImperativeHandle(n, e, t)
}
;
rr.useInsertionEffect = function(n, e) {
    return Po.current.useInsertionEffect(n, e)
}
;
rr.useLayoutEffect = function(n, e) {
    return Po.current.useLayoutEffect(n, e)
}
;
rr.useMemo = function(n, e) {
    return Po.current.useMemo(n, e)
}
;
rr.useReducer = function(n, e, t) {
    return Po.current.useReducer(n, e, t)
}
;
rr.useRef = function(n) {
    return Po.current.useRef(n)
}
;
rr.useState = function(n) {
    return Po.current.useState(n)
}
;
rr.useSyncExternalStore = function(n, e, t) {
    return Po.current.useSyncExternalStore(n, e, t)
}
;
rr.useTransition = function() {
    return Po.current.useTransition()
}
;
rr.version = "18.2.0";
(function(n) {
    n.exports = rr
}
)(bR);
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var VR = we
  , WR = Symbol.for("react.element")
  , XR = Symbol.for("react.fragment")
  , JR = Object.prototype.hasOwnProperty
  , jR = VR.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner
  , YR = {
    key: !0,
    ref: !0,
    __self: !0,
    __source: !0
};
function $b(n, e, t) {
    var r, i = {}, s = null, o = null;
    t !== void 0 && (s = "" + t),
    e.key !== void 0 && (s = "" + e.key),
    e.ref !== void 0 && (o = e.ref);
    for (r in e)
        JR.call(e, r) && !YR.hasOwnProperty(r) && (i[r] = e[r]);
    if (n && n.defaultProps)
        for (r in e = n.defaultProps,
        e)
            i[r] === void 0 && (i[r] = e[r]);
    return {
        $$typeof: WR,
        type: n,
        key: s,
        ref: o,
        props: i,
        _owner: jR.current
    }
}
Zv.Fragment = XR;
Zv.jsx = $b;
Zv.jsxs = $b;
(function(n) {
    n.exports = Zv
}
)(ER);
var Gx = {}
  , KR = {
    get exports() {
        return Gx
    },
    set exports(n) {
        Gx = n
    }
}
  , Ca = {}
  , Ux = {}
  , qR = {
    get exports() {
        return Ux
    },
    set exports(n) {
        Ux = n
    }
}
  , eT = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
(function(n) {
    function e(G, z) {
        var U = G.length;
        G.push(z);
        e: for (; 0 < U; ) {
            var fe = U - 1 >>> 1
              , oe = G[fe];
            if (0 < i(oe, z))
                G[fe] = z,
                G[U] = oe,
                U = fe;
            else
                break e
        }
    }
    function t(G) {
        return G.length === 0 ? null : G[0]
    }
    function r(G) {
        if (G.length === 0)
            return null;
        var z = G[0]
          , U = G.pop();
        if (U !== z) {
            G[0] = U;
            e: for (var fe = 0, oe = G.length, Ae = oe >>> 1; fe < Ae; ) {
                var Ue = 2 * (fe + 1) - 1
                  , je = G[Ue]
                  , de = Ue + 1
                  , qe = G[de];
                if (0 > i(je, U))
                    de < oe && 0 > i(qe, je) ? (G[fe] = qe,
                    G[de] = U,
                    fe = de) : (G[fe] = je,
                    G[Ue] = U,
                    fe = Ue);
                else if (de < oe && 0 > i(qe, U))
                    G[fe] = qe,
                    G[de] = U,
                    fe = de;
                else
                    break e
            }
        }
        return z
    }
    function i(G, z) {
        var U = G.sortIndex - z.sortIndex;
        return U !== 0 ? U : G.id - z.id
    }
    if (typeof performance == "object" && typeof performance.now == "function") {
        var s = performance;
        n.unstable_now = function() {
            return s.now()
        }
    } else {
        var o = Date
          , a = o.now();
        n.unstable_now = function() {
            return o.now() - a
        }
    }
    var l = []
      , f = []
      , h = 1
      , d = null
      , p = 3
      , m = !1
      , _ = !1
      , y = !1
      , x = typeof setTimeout == "function" ? setTimeout : null
      , S = typeof clearTimeout == "function" ? clearTimeout : null
      , M = typeof setImmediate < "u" ? setImmediate : null;
    typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
    function w(G) {
        for (var z = t(f); z !== null; ) {
            if (z.callback === null)
                r(f);
            else if (z.startTime <= G)
                r(f),
                z.sortIndex = z.expirationTime,
                e(l, z);
            else
                break;
            z = t(f)
        }
    }
    function T(G) {
        if (y = !1,
        w(G),
        !_)
            if (t(l) !== null)
                _ = !0,
                ce(P);
            else {
                var z = t(f);
                z !== null && xe(T, z.startTime - G)
            }
    }
    function P(G, z) {
        _ = !1,
        y && (y = !1,
        S(R),
        R = -1),
        m = !0;
        var U = p;
        try {
            for (w(z),
            d = t(l); d !== null && (!(d.expirationTime > z) || G && !W()); ) {
                var fe = d.callback;
                if (typeof fe == "function") {
                    d.callback = null,
                    p = d.priorityLevel;
                    var oe = fe(d.expirationTime <= z);
                    z = n.unstable_now(),
                    typeof oe == "function" ? d.callback = oe : d === t(l) && r(l),
                    w(z)
                } else
                    r(l);
                d = t(l)
            }
            if (d !== null)
                var Ae = !0;
            else {
                var Ue = t(f);
                Ue !== null && xe(T, Ue.startTime - z),
                Ae = !1
            }
            return Ae
        } finally {
            d = null,
            p = U,
            m = !1
        }
    }
    var I = !1
      , k = null
      , R = -1
      , O = 5
      , H = -1;
    function W() {
        return !(n.unstable_now() - H < O)
    }
    function te() {
        if (k !== null) {
            var G = n.unstable_now();
            H = G;
            var z = !0;
            try {
                z = k(!0, G)
            } finally {
                z ? ne() : (I = !1,
                k = null)
            }
        } else
            I = !1
    }
    var ne;
    if (typeof M == "function")
        ne = function() {
            M(te)
        }
        ;
    else if (typeof MessageChannel < "u") {
        var re = new MessageChannel
          , pe = re.port2;
        re.port1.onmessage = te,
        ne = function() {
            pe.postMessage(null)
        }
    } else
        ne = function() {
            x(te, 0)
        }
        ;
    function ce(G) {
        k = G,
        I || (I = !0,
        ne())
    }
    function xe(G, z) {
        R = x(function() {
            G(n.unstable_now())
        }, z)
    }
    n.unstable_IdlePriority = 5,
    n.unstable_ImmediatePriority = 1,
    n.unstable_LowPriority = 4,
    n.unstable_NormalPriority = 3,
    n.unstable_Profiling = null,
    n.unstable_UserBlockingPriority = 2,
    n.unstable_cancelCallback = function(G) {
        G.callback = null
    }
    ,
    n.unstable_continueExecution = function() {
        _ || m || (_ = !0,
        ce(P))
    }
    ,
    n.unstable_forceFrameRate = function(G) {
        0 > G || 125 < G ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : O = 0 < G ? Math.floor(1e3 / G) : 5
    }
    ,
    n.unstable_getCurrentPriorityLevel = function() {
        return p
    }
    ,
    n.unstable_getFirstCallbackNode = function() {
        return t(l)
    }
    ,
    n.unstable_next = function(G) {
        switch (p) {
        case 1:
        case 2:
        case 3:
            var z = 3;
            break;
        default:
            z = p
        }
        var U = p;
        p = z;
        try {
            return G()
        } finally {
            p = U
        }
    }
    ,
    n.unstable_pauseExecution = function() {}
    ,
    n.unstable_requestPaint = function() {}
    ,
    n.unstable_runWithPriority = function(G, z) {
        switch (G) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
            break;
        default:
            G = 3
        }
        var U = p;
        p = G;
        try {
            return z()
        } finally {
            p = U
        }
    }
    ,
    n.unstable_scheduleCallback = function(G, z, U) {
        var fe = n.unstable_now();
        switch (typeof U == "object" && U !== null ? (U = U.delay,
        U = typeof U == "number" && 0 < U ? fe + U : fe) : U = fe,
        G) {
        case 1:
            var oe = -1;
            break;
        case 2:
            oe = 250;
            break;
        case 5:
            oe = 1073741823;
            break;
        case 4:
            oe = 1e4;
            break;
        default:
            oe = 5e3
        }
        return oe = U + oe,
        G = {
            id: h++,
            callback: z,
            priorityLevel: G,
            startTime: U,
            expirationTime: oe,
            sortIndex: -1
        },
        U > fe ? (G.sortIndex = U,
        e(f, G),
        t(l) === null && G === t(f) && (y ? (S(R),
        R = -1) : y = !0,
        xe(T, U - fe))) : (G.sortIndex = oe,
        e(l, G),
        _ || m || (_ = !0,
        ce(P))),
        G
    }
    ,
    n.unstable_shouldYield = W,
    n.unstable_wrapCallback = function(G) {
        var z = p;
        return function() {
            var U = p;
            p = z;
            try {
                return G.apply(this, arguments)
            } finally {
                p = U
            }
        }
    }
}
)(eT);
(function(n) {
    n.exports = eT
}
)(qR);
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var tT = we
  , Ma = Ux;
function mt(n) {
    for (var e = "https://reactjs.org/docs/error-decoder.html?invariant=" + n, t = 1; t < arguments.length; t++)
        e += "&args[]=" + encodeURIComponent(arguments[t]);
    return "Minified React error #" + n + "; visit " + e + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
}
var nT = new Set
  , qp = {};
function qf(n, e) {
    lh(n, e),
    lh(n + "Capture", e)
}
function lh(n, e) {
    for (qp[n] = e,
    n = 0; n < e.length; n++)
        nT.add(e[n])
}
var Au = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u")
  , Hx = Object.prototype.hasOwnProperty
  , QR = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/
  , gA = {}
  , vA = {};
function ZR(n) {
    return Hx.call(vA, n) ? !0 : Hx.call(gA, n) ? !1 : QR.test(n) ? vA[n] = !0 : (gA[n] = !0,
    !1)
}
function $R(n, e, t, r) {
    if (t !== null && t.type === 0)
        return !1;
    switch (typeof e) {
    case "function":
    case "symbol":
        return !0;
    case "boolean":
        return r ? !1 : t !== null ? !t.acceptsBooleans : (n = n.toLowerCase().slice(0, 5),
        n !== "data-" && n !== "aria-");
    default:
        return !1
    }
}
function eB(n, e, t, r) {
    if (e === null || typeof e > "u" || $R(n, e, t, r))
        return !0;
    if (r)
        return !1;
    if (t !== null)
        switch (t.type) {
        case 3:
            return !e;
        case 4:
            return e === !1;
        case 5:
            return isNaN(e);
        case 6:
            return isNaN(e) || 1 > e
        }
    return !1
}
function Ro(n, e, t, r, i, s, o) {
    this.acceptsBooleans = e === 2 || e === 3 || e === 4,
    this.attributeName = r,
    this.attributeNamespace = i,
    this.mustUseProperty = t,
    this.propertyName = n,
    this.type = e,
    this.sanitizeURL = s,
    this.removeEmptyString = o
}
var Xs = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(n) {
    Xs[n] = new Ro(n,0,!1,n,null,!1,!1)
});
[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(n) {
    var e = n[0];
    Xs[e] = new Ro(e,1,!1,n[1],null,!1,!1)
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function(n) {
    Xs[n] = new Ro(n,2,!1,n.toLowerCase(),null,!1,!1)
});
["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(n) {
    Xs[n] = new Ro(n,2,!1,n,null,!1,!1)
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(n) {
    Xs[n] = new Ro(n,3,!1,n.toLowerCase(),null,!1,!1)
});
["checked", "multiple", "muted", "selected"].forEach(function(n) {
    Xs[n] = new Ro(n,3,!0,n,null,!1,!1)
});
["capture", "download"].forEach(function(n) {
    Xs[n] = new Ro(n,4,!1,n,null,!1,!1)
});
["cols", "rows", "size", "span"].forEach(function(n) {
    Xs[n] = new Ro(n,6,!1,n,null,!1,!1)
});
["rowSpan", "start"].forEach(function(n) {
    Xs[n] = new Ro(n,5,!1,n.toLowerCase(),null,!1,!1)
});
var Hw = /[\-:]([a-z])/g;
function Vw(n) {
    return n[1].toUpperCase()
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(n) {
    var e = n.replace(Hw, Vw);
    Xs[e] = new Ro(e,1,!1,n,null,!1,!1)
});
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(n) {
    var e = n.replace(Hw, Vw);
    Xs[e] = new Ro(e,1,!1,n,"http://www.w3.org/1999/xlink",!1,!1)
});
["xml:base", "xml:lang", "xml:space"].forEach(function(n) {
    var e = n.replace(Hw, Vw);
    Xs[e] = new Ro(e,1,!1,n,"http://www.w3.org/XML/1998/namespace",!1,!1)
});
["tabIndex", "crossOrigin"].forEach(function(n) {
    Xs[n] = new Ro(n,1,!1,n.toLowerCase(),null,!1,!1)
});
Xs.xlinkHref = new Ro("xlinkHref",1,!1,"xlink:href","http://www.w3.org/1999/xlink",!0,!1);
["src", "href", "action", "formAction"].forEach(function(n) {
    Xs[n] = new Ro(n,1,!1,n.toLowerCase(),null,!0,!0)
});
function Ww(n, e, t, r) {
    var i = Xs.hasOwnProperty(e) ? Xs[e] : null;
    (i !== null ? i.type !== 0 : r || !(2 < e.length) || e[0] !== "o" && e[0] !== "O" || e[1] !== "n" && e[1] !== "N") && (eB(e, t, i, r) && (t = null),
    r || i === null ? ZR(e) && (t === null ? n.removeAttribute(e) : n.setAttribute(e, "" + t)) : i.mustUseProperty ? n[i.propertyName] = t === null ? i.type === 3 ? !1 : "" : t : (e = i.attributeName,
    r = i.attributeNamespace,
    t === null ? n.removeAttribute(e) : (i = i.type,
    t = i === 3 || i === 4 && t === !0 ? "" : "" + t,
    r ? n.setAttributeNS(r, e, t) : n.setAttribute(e, t))))
}
var Pu = tT.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED
  , xg = Symbol.for("react.element")
  , Bd = Symbol.for("react.portal")
  , Id = Symbol.for("react.fragment")
  , Xw = Symbol.for("react.strict_mode")
  , Vx = Symbol.for("react.profiler")
  , rT = Symbol.for("react.provider")
  , iT = Symbol.for("react.context")
  , Jw = Symbol.for("react.forward_ref")
  , Wx = Symbol.for("react.suspense")
  , Xx = Symbol.for("react.suspense_list")
  , jw = Symbol.for("react.memo")
  , tc = Symbol.for("react.lazy")
  , sT = Symbol.for("react.offscreen")
  , _A = Symbol.iterator;
function Wh(n) {
    return n === null || typeof n != "object" ? null : (n = _A && n[_A] || n["@@iterator"],
    typeof n == "function" ? n : null)
}
var Oi = Object.assign, cy;
function yp(n) {
    if (cy === void 0)
        try {
            throw Error()
        } catch (t) {
            var e = t.stack.trim().match(/\n( *(at )?)/);
            cy = e && e[1] || ""
        }
    return `
` + cy + n
}
var fy = !1;
function dy(n, e) {
    if (!n || fy)
        return "";
    fy = !0;
    var t = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
        if (e)
            if (e = function() {
                throw Error()
            }
            ,
            Object.defineProperty(e.prototype, "props", {
                set: function() {
                    throw Error()
                }
            }),
            typeof Reflect == "object" && Reflect.construct) {
                try {
                    Reflect.construct(e, [])
                } catch (f) {
                    var r = f
                }
                Reflect.construct(n, [], e)
            } else {
                try {
                    e.call()
                } catch (f) {
                    r = f
                }
                n.call(e.prototype)
            }
        else {
            try {
                throw Error()
            } catch (f) {
                r = f
            }
            n()
        }
    } catch (f) {
        if (f && r && typeof f.stack == "string") {
            for (var i = f.stack.split(`
`), s = r.stack.split(`
`), o = i.length - 1, a = s.length - 1; 1 <= o && 0 <= a && i[o] !== s[a]; )
                a--;
            for (; 1 <= o && 0 <= a; o--,
            a--)
                if (i[o] !== s[a]) {
                    if (o !== 1 || a !== 1)
                        do
                            if (o--,
                            a--,
                            0 > a || i[o] !== s[a]) {
                                var l = `
` + i[o].replace(" at new ", " at ");
                                return n.displayName && l.includes("<anonymous>") && (l = l.replace("<anonymous>", n.displayName)),
                                l
                            }
                        while (1 <= o && 0 <= a);
                    break
                }
        }
    } finally {
        fy = !1,
        Error.prepareStackTrace = t
    }
    return (n = n ? n.displayName || n.name : "") ? yp(n) : ""
}
function tB(n) {
    switch (n.tag) {
    case 5:
        return yp(n.type);
    case 16:
        return yp("Lazy");
    case 13:
        return yp("Suspense");
    case 19:
        return yp("SuspenseList");
    case 0:
    case 2:
    case 15:
        return n = dy(n.type, !1),
        n;
    case 11:
        return n = dy(n.type.render, !1),
        n;
    case 1:
        return n = dy(n.type, !0),
        n;
    default:
        return ""
    }
}
function Jx(n) {
    if (n == null)
        return null;
    if (typeof n == "function")
        return n.displayName || n.name || null;
    if (typeof n == "string")
        return n;
    switch (n) {
    case Id:
        return "Fragment";
    case Bd:
        return "Portal";
    case Vx:
        return "Profiler";
    case Xw:
        return "StrictMode";
    case Wx:
        return "Suspense";
    case Xx:
        return "SuspenseList"
    }
    if (typeof n == "object")
        switch (n.$$typeof) {
        case iT:
            return (n.displayName || "Context") + ".Consumer";
        case rT:
            return (n._context.displayName || "Context") + ".Provider";
        case Jw:
            var e = n.render;
            return n = n.displayName,
            n || (n = e.displayName || e.name || "",
            n = n !== "" ? "ForwardRef(" + n + ")" : "ForwardRef"),
            n;
        case jw:
            return e = n.displayName || null,
            e !== null ? e : Jx(n.type) || "Memo";
        case tc:
            e = n._payload,
            n = n._init;
            try {
                return Jx(n(e))
            } catch {}
        }
    return null
}
function nB(n) {
    var e = n.type;
    switch (n.tag) {
    case 24:
        return "Cache";
    case 9:
        return (e.displayName || "Context") + ".Consumer";
    case 10:
        return (e._context.displayName || "Context") + ".Provider";
    case 18:
        return "DehydratedFragment";
    case 11:
        return n = e.render,
        n = n.displayName || n.name || "",
        e.displayName || (n !== "" ? "ForwardRef(" + n + ")" : "ForwardRef");
    case 7:
        return "Fragment";
    case 5:
        return e;
    case 4:
        return "Portal";
    case 3:
        return "Root";
    case 6:
        return "Text";
    case 16:
        return Jx(e);
    case 8:
        return e === Xw ? "StrictMode" : "Mode";
    case 22:
        return "Offscreen";
    case 12:
        return "Profiler";
    case 21:
        return "Scope";
    case 13:
        return "Suspense";
    case 19:
        return "SuspenseList";
    case 25:
        return "TracingMarker";
    case 1:
    case 0:
    case 17:
    case 2:
    case 14:
    case 15:
        if (typeof e == "function")
            return e.displayName || e.name || null;
        if (typeof e == "string")
            return e
    }
    return null
}
function Ac(n) {
    switch (typeof n) {
    case "boolean":
    case "number":
    case "string":
    case "undefined":
        return n;
    case "object":
        return n;
    default:
        return ""
    }
}
function oT(n) {
    var e = n.type;
    return (n = n.nodeName) && n.toLowerCase() === "input" && (e === "checkbox" || e === "radio")
}
function rB(n) {
    var e = oT(n) ? "checked" : "value"
      , t = Object.getOwnPropertyDescriptor(n.constructor.prototype, e)
      , r = "" + n[e];
    if (!n.hasOwnProperty(e) && typeof t < "u" && typeof t.get == "function" && typeof t.set == "function") {
        var i = t.get
          , s = t.set;
        return Object.defineProperty(n, e, {
            configurable: !0,
            get: function() {
                return i.call(this)
            },
            set: function(o) {
                r = "" + o,
                s.call(this, o)
            }
        }),
        Object.defineProperty(n, e, {
            enumerable: t.enumerable
        }),
        {
            getValue: function() {
                return r
            },
            setValue: function(o) {
                r = "" + o
            },
            stopTracking: function() {
                n._valueTracker = null,
                delete n[e]
            }
        }
    }
}
function wg(n) {
    n._valueTracker || (n._valueTracker = rB(n))
}
function aT(n) {
    if (!n)
        return !1;
    var e = n._valueTracker;
    if (!e)
        return !0;
    var t = e.getValue()
      , r = "";
    return n && (r = oT(n) ? n.checked ? "true" : "false" : n.value),
    n = r,
    n !== t ? (e.setValue(n),
    !0) : !1
}
function _v(n) {
    if (n = n || (typeof document < "u" ? document : void 0),
    typeof n > "u")
        return null;
    try {
        return n.activeElement || n.body
    } catch {
        return n.body
    }
}
function jx(n, e) {
    var t = e.checked;
    return Oi({}, e, {
        defaultChecked: void 0,
        defaultValue: void 0,
        value: void 0,
        checked: t ?? n._wrapperState.initialChecked
    })
}
function yA(n, e) {
    var t = e.defaultValue == null ? "" : e.defaultValue
      , r = e.checked != null ? e.checked : e.defaultChecked;
    t = Ac(e.value != null ? e.value : t),
    n._wrapperState = {
        initialChecked: r,
        initialValue: t,
        controlled: e.type === "checkbox" || e.type === "radio" ? e.checked != null : e.value != null
    }
}
function lT(n, e) {
    e = e.checked,
    e != null && Ww(n, "checked", e, !1)
}
function Yx(n, e) {
    lT(n, e);
    var t = Ac(e.value)
      , r = e.type;
    if (t != null)
        r === "number" ? (t === 0 && n.value === "" || n.value != t) && (n.value = "" + t) : n.value !== "" + t && (n.value = "" + t);
    else if (r === "submit" || r === "reset") {
        n.removeAttribute("value");
        return
    }
    e.hasOwnProperty("value") ? Kx(n, e.type, t) : e.hasOwnProperty("defaultValue") && Kx(n, e.type, Ac(e.defaultValue)),
    e.checked == null && e.defaultChecked != null && (n.defaultChecked = !!e.defaultChecked)
}
function xA(n, e, t) {
    if (e.hasOwnProperty("value") || e.hasOwnProperty("defaultValue")) {
        var r = e.type;
        if (!(r !== "submit" && r !== "reset" || e.value !== void 0 && e.value !== null))
            return;
        e = "" + n._wrapperState.initialValue,
        t || e === n.value || (n.value = e),
        n.defaultValue = e
    }
    t = n.name,
    t !== "" && (n.name = ""),
    n.defaultChecked = !!n._wrapperState.initialChecked,
    t !== "" && (n.name = t)
}
function Kx(n, e, t) {
    (e !== "number" || _v(n.ownerDocument) !== n) && (t == null ? n.defaultValue = "" + n._wrapperState.initialValue : n.defaultValue !== "" + t && (n.defaultValue = "" + t))
}
var xp = Array.isArray;
function Zd(n, e, t, r) {
    if (n = n.options,
    e) {
        e = {};
        for (var i = 0; i < t.length; i++)
            e["$" + t[i]] = !0;
        for (t = 0; t < n.length; t++)
            i = e.hasOwnProperty("$" + n[t].value),
            n[t].selected !== i && (n[t].selected = i),
            i && r && (n[t].defaultSelected = !0)
    } else {
        for (t = "" + Ac(t),
        e = null,
        i = 0; i < n.length; i++) {
            if (n[i].value === t) {
                n[i].selected = !0,
                r && (n[i].defaultSelected = !0);
                return
            }
            e !== null || n[i].disabled || (e = n[i])
        }
        e !== null && (e.selected = !0)
    }
}
function qx(n, e) {
    if (e.dangerouslySetInnerHTML != null)
        throw Error(mt(91));
    return Oi({}, e, {
        value: void 0,
        defaultValue: void 0,
        children: "" + n._wrapperState.initialValue
    })
}
function wA(n, e) {
    var t = e.value;
    if (t == null) {
        if (t = e.children,
        e = e.defaultValue,
        t != null) {
            if (e != null)
                throw Error(mt(92));
            if (xp(t)) {
                if (1 < t.length)
                    throw Error(mt(93));
                t = t[0]
            }
            e = t
        }
        e == null && (e = ""),
        t = e
    }
    n._wrapperState = {
        initialValue: Ac(t)
    }
}
function uT(n, e) {
    var t = Ac(e.value)
      , r = Ac(e.defaultValue);
    t != null && (t = "" + t,
    t !== n.value && (n.value = t),
    e.defaultValue == null && n.defaultValue !== t && (n.defaultValue = t)),
    r != null && (n.defaultValue = "" + r)
}
function SA(n) {
    var e = n.textContent;
    e === n._wrapperState.initialValue && e !== "" && e !== null && (n.value = e)
}
function cT(n) {
    switch (n) {
    case "svg":
        return "http://www.w3.org/2000/svg";
    case "math":
        return "http://www.w3.org/1998/Math/MathML";
    default:
        return "http://www.w3.org/1999/xhtml"
    }
}
function Qx(n, e) {
    return n == null || n === "http://www.w3.org/1999/xhtml" ? cT(e) : n === "http://www.w3.org/2000/svg" && e === "foreignObject" ? "http://www.w3.org/1999/xhtml" : n
}
var Sg, fT = function(n) {
    return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function(e, t, r, i) {
        MSApp.execUnsafeLocalFunction(function() {
            return n(e, t, r, i)
        })
    }
    : n
}(function(n, e) {
    if (n.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML"in n)
        n.innerHTML = e;
    else {
        for (Sg = Sg || document.createElement("div"),
        Sg.innerHTML = "<svg>" + e.valueOf().toString() + "</svg>",
        e = Sg.firstChild; n.firstChild; )
            n.removeChild(n.firstChild);
        for (; e.firstChild; )
            n.appendChild(e.firstChild)
    }
});
function Qp(n, e) {
    if (e) {
        var t = n.firstChild;
        if (t && t === n.lastChild && t.nodeType === 3) {
            t.nodeValue = e;
            return
        }
    }
    n.textContent = e
}
var Dp = {
    animationIterationCount: !0,
    aspectRatio: !0,
    borderImageOutset: !0,
    borderImageSlice: !0,
    borderImageWidth: !0,
    boxFlex: !0,
    boxFlexGroup: !0,
    boxOrdinalGroup: !0,
    columnCount: !0,
    columns: !0,
    flex: !0,
    flexGrow: !0,
    flexPositive: !0,
    flexShrink: !0,
    flexNegative: !0,
    flexOrder: !0,
    gridArea: !0,
    gridRow: !0,
    gridRowEnd: !0,
    gridRowSpan: !0,
    gridRowStart: !0,
    gridColumn: !0,
    gridColumnEnd: !0,
    gridColumnSpan: !0,
    gridColumnStart: !0,
    fontWeight: !0,
    lineClamp: !0,
    lineHeight: !0,
    opacity: !0,
    order: !0,
    orphans: !0,
    tabSize: !0,
    widows: !0,
    zIndex: !0,
    zoom: !0,
    fillOpacity: !0,
    floodOpacity: !0,
    stopOpacity: !0,
    strokeDasharray: !0,
    strokeDashoffset: !0,
    strokeMiterlimit: !0,
    strokeOpacity: !0,
    strokeWidth: !0
}
  , iB = ["Webkit", "ms", "Moz", "O"];
Object.keys(Dp).forEach(function(n) {
    iB.forEach(function(e) {
        e = e + n.charAt(0).toUpperCase() + n.substring(1),
        Dp[e] = Dp[n]
    })
});
function dT(n, e, t) {
    return e == null || typeof e == "boolean" || e === "" ? "" : t || typeof e != "number" || e === 0 || Dp.hasOwnProperty(n) && Dp[n] ? ("" + e).trim() : e + "px"
}
function hT(n, e) {
    n = n.style;
    for (var t in e)
        if (e.hasOwnProperty(t)) {
            var r = t.indexOf("--") === 0
              , i = dT(t, e[t], r);
            t === "float" && (t = "cssFloat"),
            r ? n.setProperty(t, i) : n[t] = i
        }
}
var sB = Oi({
    menuitem: !0
}, {
    area: !0,
    base: !0,
    br: !0,
    col: !0,
    embed: !0,
    hr: !0,
    img: !0,
    input: !0,
    keygen: !0,
    link: !0,
    meta: !0,
    param: !0,
    source: !0,
    track: !0,
    wbr: !0
});
function Zx(n, e) {
    if (e) {
        if (sB[n] && (e.children != null || e.dangerouslySetInnerHTML != null))
            throw Error(mt(137, n));
        if (e.dangerouslySetInnerHTML != null) {
            if (e.children != null)
                throw Error(mt(60));
            if (typeof e.dangerouslySetInnerHTML != "object" || !("__html"in e.dangerouslySetInnerHTML))
                throw Error(mt(61))
        }
        if (e.style != null && typeof e.style != "object")
            throw Error(mt(62))
    }
}
function $x(n, e) {
    if (n.indexOf("-") === -1)
        return typeof e.is == "string";
    switch (n) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
        return !1;
    default:
        return !0
    }
}
var e1 = null;
function Yw(n) {
    return n = n.target || n.srcElement || window,
    n.correspondingUseElement && (n = n.correspondingUseElement),
    n.nodeType === 3 ? n.parentNode : n
}
var t1 = null
  , $d = null
  , eh = null;
function MA(n) {
    if (n = Bm(n)) {
        if (typeof t1 != "function")
            throw Error(mt(280));
        var e = n.stateNode;
        e && (e = r_(e),
        t1(n.stateNode, n.type, e))
    }
}
function pT(n) {
    $d ? eh ? eh.push(n) : eh = [n] : $d = n
}
function mT() {
    if ($d) {
        var n = $d
          , e = eh;
        if (eh = $d = null,
        MA(n),
        e)
            for (n = 0; n < e.length; n++)
                MA(e[n])
    }
}
function gT(n, e) {
    return n(e)
}
function vT() {}
var hy = !1;
function _T(n, e, t) {
    if (hy)
        return n(e, t);
    hy = !0;
    try {
        return gT(n, e, t)
    } finally {
        hy = !1,
        ($d !== null || eh !== null) && (vT(),
        mT())
    }
}
function Zp(n, e) {
    var t = n.stateNode;
    if (t === null)
        return null;
    var r = r_(t);
    if (r === null)
        return null;
    t = r[e];
    e: switch (e) {
    case "onClick":
    case "onClickCapture":
    case "onDoubleClick":
    case "onDoubleClickCapture":
    case "onMouseDown":
    case "onMouseDownCapture":
    case "onMouseMove":
    case "onMouseMoveCapture":
    case "onMouseUp":
    case "onMouseUpCapture":
    case "onMouseEnter":
        (r = !r.disabled) || (n = n.type,
        r = !(n === "button" || n === "input" || n === "select" || n === "textarea")),
        n = !r;
        break e;
    default:
        n = !1
    }
    if (n)
        return null;
    if (t && typeof t != "function")
        throw Error(mt(231, e, typeof t));
    return t
}
var n1 = !1;
if (Au)
    try {
        var Xh = {};
        Object.defineProperty(Xh, "passive", {
            get: function() {
                n1 = !0
            }
        }),
        window.addEventListener("test", Xh, Xh),
        window.removeEventListener("test", Xh, Xh)
    } catch {
        n1 = !1
    }
function oB(n, e, t, r, i, s, o, a, l) {
    var f = Array.prototype.slice.call(arguments, 3);
    try {
        e.apply(t, f)
    } catch (h) {
        this.onError(h)
    }
}
var Pp = !1
  , yv = null
  , xv = !1
  , r1 = null
  , aB = {
    onError: function(n) {
        Pp = !0,
        yv = n
    }
};
function lB(n, e, t, r, i, s, o, a, l) {
    Pp = !1,
    yv = null,
    oB.apply(aB, arguments)
}
function uB(n, e, t, r, i, s, o, a, l) {
    if (lB.apply(this, arguments),
    Pp) {
        if (Pp) {
            var f = yv;
            Pp = !1,
            yv = null
        } else
            throw Error(mt(198));
        xv || (xv = !0,
        r1 = f)
    }
}
function Qf(n) {
    var e = n
      , t = n;
    if (n.alternate)
        for (; e.return; )
            e = e.return;
    else {
        n = e;
        do
            e = n,
            e.flags & 4098 && (t = e.return),
            n = e.return;
        while (n)
    }
    return e.tag === 3 ? t : null
}
function yT(n) {
    if (n.tag === 13) {
        var e = n.memoizedState;
        if (e === null && (n = n.alternate,
        n !== null && (e = n.memoizedState)),
        e !== null)
            return e.dehydrated
    }
    return null
}
function AA(n) {
    if (Qf(n) !== n)
        throw Error(mt(188))
}
function cB(n) {
    var e = n.alternate;
    if (!e) {
        if (e = Qf(n),
        e === null)
            throw Error(mt(188));
        return e !== n ? null : n
    }
    for (var t = n, r = e; ; ) {
        var i = t.return;
        if (i === null)
            break;
        var s = i.alternate;
        if (s === null) {
            if (r = i.return,
            r !== null) {
                t = r;
                continue
            }
            break
        }
        if (i.child === s.child) {
            for (s = i.child; s; ) {
                if (s === t)
                    return AA(i),
                    n;
                if (s === r)
                    return AA(i),
                    e;
                s = s.sibling
            }
            throw Error(mt(188))
        }
        if (t.return !== r.return)
            t = i,
            r = s;
        else {
            for (var o = !1, a = i.child; a; ) {
                if (a === t) {
                    o = !0,
                    t = i,
                    r = s;
                    break
                }
                if (a === r) {
                    o = !0,
                    r = i,
                    t = s;
                    break
                }
                a = a.sibling
            }
            if (!o) {
                for (a = s.child; a; ) {
                    if (a === t) {
                        o = !0,
                        t = s,
                        r = i;
                        break
                    }
                    if (a === r) {
                        o = !0,
                        r = s,
                        t = i;
                        break
                    }
                    a = a.sibling
                }
                if (!o)
                    throw Error(mt(189))
            }
        }
        if (t.alternate !== r)
            throw Error(mt(190))
    }
    if (t.tag !== 3)
        throw Error(mt(188));
    return t.stateNode.current === t ? n : e
}
function xT(n) {
    return n = cB(n),
    n !== null ? wT(n) : null
}
function wT(n) {
    if (n.tag === 5 || n.tag === 6)
        return n;
    for (n = n.child; n !== null; ) {
        var e = wT(n);
        if (e !== null)
            return e;
        n = n.sibling
    }
    return null
}
var ST = Ma.unstable_scheduleCallback
  , CA = Ma.unstable_cancelCallback
  , fB = Ma.unstable_shouldYield
  , dB = Ma.unstable_requestPaint
  , Zi = Ma.unstable_now
  , hB = Ma.unstable_getCurrentPriorityLevel
  , Kw = Ma.unstable_ImmediatePriority
  , MT = Ma.unstable_UserBlockingPriority
  , wv = Ma.unstable_NormalPriority
  , pB = Ma.unstable_LowPriority
  , AT = Ma.unstable_IdlePriority
  , $v = null
  , Wl = null;
function mB(n) {
    if (Wl && typeof Wl.onCommitFiberRoot == "function")
        try {
            Wl.onCommitFiberRoot($v, n, void 0, (n.current.flags & 128) === 128)
        } catch {}
}
var Ml = Math.clz32 ? Math.clz32 : _B
  , gB = Math.log
  , vB = Math.LN2;
function _B(n) {
    return n >>>= 0,
    n === 0 ? 32 : 31 - (gB(n) / vB | 0) | 0
}
var Mg = 64
  , Ag = 4194304;
function wp(n) {
    switch (n & -n) {
    case 1:
        return 1;
    case 2:
        return 2;
    case 4:
        return 4;
    case 8:
        return 8;
    case 16:
        return 16;
    case 32:
        return 32;
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
        return n & 4194240;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
        return n & 130023424;
    case 134217728:
        return 134217728;
    case 268435456:
        return 268435456;
    case 536870912:
        return 536870912;
    case 1073741824:
        return 1073741824;
    default:
        return n
    }
}
function Sv(n, e) {
    var t = n.pendingLanes;
    if (t === 0)
        return 0;
    var r = 0
      , i = n.suspendedLanes
      , s = n.pingedLanes
      , o = t & 268435455;
    if (o !== 0) {
        var a = o & ~i;
        a !== 0 ? r = wp(a) : (s &= o,
        s !== 0 && (r = wp(s)))
    } else
        o = t & ~i,
        o !== 0 ? r = wp(o) : s !== 0 && (r = wp(s));
    if (r === 0)
        return 0;
    if (e !== 0 && e !== r && !(e & i) && (i = r & -r,
    s = e & -e,
    i >= s || i === 16 && (s & 4194240) !== 0))
        return e;
    if (r & 4 && (r |= t & 16),
    e = n.entangledLanes,
    e !== 0)
        for (n = n.entanglements,
        e &= r; 0 < e; )
            t = 31 - Ml(e),
            i = 1 << t,
            r |= n[t],
            e &= ~i;
    return r
}
function yB(n, e) {
    switch (n) {
    case 1:
    case 2:
    case 4:
        return e + 250;
    case 8:
    case 16:
    case 32:
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
        return e + 5e3;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
        return -1;
    case 134217728:
    case 268435456:
    case 536870912:
    case 1073741824:
        return -1;
    default:
        return -1
    }
}
function xB(n, e) {
    for (var t = n.suspendedLanes, r = n.pingedLanes, i = n.expirationTimes, s = n.pendingLanes; 0 < s; ) {
        var o = 31 - Ml(s)
          , a = 1 << o
          , l = i[o];
        l === -1 ? (!(a & t) || a & r) && (i[o] = yB(a, e)) : l <= e && (n.expiredLanes |= a),
        s &= ~a
    }
}
function i1(n) {
    return n = n.pendingLanes & -1073741825,
    n !== 0 ? n : n & 1073741824 ? 1073741824 : 0
}
function CT() {
    var n = Mg;
    return Mg <<= 1,
    !(Mg & 4194240) && (Mg = 64),
    n
}
function py(n) {
    for (var e = [], t = 0; 31 > t; t++)
        e.push(n);
    return e
}
function Pm(n, e, t) {
    n.pendingLanes |= e,
    e !== 536870912 && (n.suspendedLanes = 0,
    n.pingedLanes = 0),
    n = n.eventTimes,
    e = 31 - Ml(e),
    n[e] = t
}
function wB(n, e) {
    var t = n.pendingLanes & ~e;
    n.pendingLanes = e,
    n.suspendedLanes = 0,
    n.pingedLanes = 0,
    n.expiredLanes &= e,
    n.mutableReadLanes &= e,
    n.entangledLanes &= e,
    e = n.entanglements;
    var r = n.eventTimes;
    for (n = n.expirationTimes; 0 < t; ) {
        var i = 31 - Ml(t)
          , s = 1 << i;
        e[i] = 0,
        r[i] = -1,
        n[i] = -1,
        t &= ~s
    }
}
function qw(n, e) {
    var t = n.entangledLanes |= e;
    for (n = n.entanglements; t; ) {
        var r = 31 - Ml(t)
          , i = 1 << r;
        i & e | n[r] & e && (n[r] |= e),
        t &= ~i
    }
}
var Gr = 0;
function ET(n) {
    return n &= -n,
    1 < n ? 4 < n ? n & 268435455 ? 16 : 536870912 : 4 : 1
}
var bT, Qw, TT, DT, PT, s1 = !1, Cg = [], pc = null, mc = null, gc = null, $p = new Map, em = new Map, ic = [], SB = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
function EA(n, e) {
    switch (n) {
    case "focusin":
    case "focusout":
        pc = null;
        break;
    case "dragenter":
    case "dragleave":
        mc = null;
        break;
    case "mouseover":
    case "mouseout":
        gc = null;
        break;
    case "pointerover":
    case "pointerout":
        $p.delete(e.pointerId);
        break;
    case "gotpointercapture":
    case "lostpointercapture":
        em.delete(e.pointerId)
    }
}
function Jh(n, e, t, r, i, s) {
    return n === null || n.nativeEvent !== s ? (n = {
        blockedOn: e,
        domEventName: t,
        eventSystemFlags: r,
        nativeEvent: s,
        targetContainers: [i]
    },
    e !== null && (e = Bm(e),
    e !== null && Qw(e)),
    n) : (n.eventSystemFlags |= r,
    e = n.targetContainers,
    i !== null && e.indexOf(i) === -1 && e.push(i),
    n)
}
function MB(n, e, t, r, i) {
    switch (e) {
    case "focusin":
        return pc = Jh(pc, n, e, t, r, i),
        !0;
    case "dragenter":
        return mc = Jh(mc, n, e, t, r, i),
        !0;
    case "mouseover":
        return gc = Jh(gc, n, e, t, r, i),
        !0;
    case "pointerover":
        var s = i.pointerId;
        return $p.set(s, Jh($p.get(s) || null, n, e, t, r, i)),
        !0;
    case "gotpointercapture":
        return s = i.pointerId,
        em.set(s, Jh(em.get(s) || null, n, e, t, r, i)),
        !0
    }
    return !1
}
function RT(n) {
    var e = gf(n.target);
    if (e !== null) {
        var t = Qf(e);
        if (t !== null) {
            if (e = t.tag,
            e === 13) {
                if (e = yT(t),
                e !== null) {
                    n.blockedOn = e,
                    PT(n.priority, function() {
                        TT(t)
                    });
                    return
                }
            } else if (e === 3 && t.stateNode.current.memoizedState.isDehydrated) {
                n.blockedOn = t.tag === 3 ? t.stateNode.containerInfo : null;
                return
            }
        }
    }
    n.blockedOn = null
}
function X0(n) {
    if (n.blockedOn !== null)
        return !1;
    for (var e = n.targetContainers; 0 < e.length; ) {
        var t = o1(n.domEventName, n.eventSystemFlags, e[0], n.nativeEvent);
        if (t === null) {
            t = n.nativeEvent;
            var r = new t.constructor(t.type,t);
            e1 = r,
            t.target.dispatchEvent(r),
            e1 = null
        } else
            return e = Bm(t),
            e !== null && Qw(e),
            n.blockedOn = t,
            !1;
        e.shift()
    }
    return !0
}
function bA(n, e, t) {
    X0(n) && t.delete(e)
}
function AB() {
    s1 = !1,
    pc !== null && X0(pc) && (pc = null),
    mc !== null && X0(mc) && (mc = null),
    gc !== null && X0(gc) && (gc = null),
    $p.forEach(bA),
    em.forEach(bA)
}
function jh(n, e) {
    n.blockedOn === e && (n.blockedOn = null,
    s1 || (s1 = !0,
    Ma.unstable_scheduleCallback(Ma.unstable_NormalPriority, AB)))
}
function tm(n) {
    function e(i) {
        return jh(i, n)
    }
    if (0 < Cg.length) {
        jh(Cg[0], n);
        for (var t = 1; t < Cg.length; t++) {
            var r = Cg[t];
            r.blockedOn === n && (r.blockedOn = null)
        }
    }
    for (pc !== null && jh(pc, n),
    mc !== null && jh(mc, n),
    gc !== null && jh(gc, n),
    $p.forEach(e),
    em.forEach(e),
    t = 0; t < ic.length; t++)
        r = ic[t],
        r.blockedOn === n && (r.blockedOn = null);
    for (; 0 < ic.length && (t = ic[0],
    t.blockedOn === null); )
        RT(t),
        t.blockedOn === null && ic.shift()
}
var th = Pu.ReactCurrentBatchConfig
  , Mv = !0;
function CB(n, e, t, r) {
    var i = Gr
      , s = th.transition;
    th.transition = null;
    try {
        Gr = 1,
        Zw(n, e, t, r)
    } finally {
        Gr = i,
        th.transition = s
    }
}
function EB(n, e, t, r) {
    var i = Gr
      , s = th.transition;
    th.transition = null;
    try {
        Gr = 4,
        Zw(n, e, t, r)
    } finally {
        Gr = i,
        th.transition = s
    }
}
function Zw(n, e, t, r) {
    if (Mv) {
        var i = o1(n, e, t, r);
        if (i === null)
            Ay(n, e, r, Av, t),
            EA(n, r);
        else if (MB(i, n, e, t, r))
            r.stopPropagation();
        else if (EA(n, r),
        e & 4 && -1 < SB.indexOf(n)) {
            for (; i !== null; ) {
                var s = Bm(i);
                if (s !== null && bT(s),
                s = o1(n, e, t, r),
                s === null && Ay(n, e, r, Av, t),
                s === i)
                    break;
                i = s
            }
            i !== null && r.stopPropagation()
        } else
            Ay(n, e, r, null, t)
    }
}
var Av = null;
function o1(n, e, t, r) {
    if (Av = null,
    n = Yw(r),
    n = gf(n),
    n !== null)
        if (e = Qf(n),
        e === null)
            n = null;
        else if (t = e.tag,
        t === 13) {
            if (n = yT(e),
            n !== null)
                return n;
            n = null
        } else if (t === 3) {
            if (e.stateNode.current.memoizedState.isDehydrated)
                return e.tag === 3 ? e.stateNode.containerInfo : null;
            n = null
        } else
            e !== n && (n = null);
    return Av = n,
    null
}
function BT(n) {
    switch (n) {
    case "cancel":
    case "click":
    case "close":
    case "contextmenu":
    case "copy":
    case "cut":
    case "auxclick":
    case "dblclick":
    case "dragend":
    case "dragstart":
    case "drop":
    case "focusin":
    case "focusout":
    case "input":
    case "invalid":
    case "keydown":
    case "keypress":
    case "keyup":
    case "mousedown":
    case "mouseup":
    case "paste":
    case "pause":
    case "play":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
    case "ratechange":
    case "reset":
    case "resize":
    case "seeked":
    case "submit":
    case "touchcancel":
    case "touchend":
    case "touchstart":
    case "volumechange":
    case "change":
    case "selectionchange":
    case "textInput":
    case "compositionstart":
    case "compositionend":
    case "compositionupdate":
    case "beforeblur":
    case "afterblur":
    case "beforeinput":
    case "blur":
    case "fullscreenchange":
    case "focus":
    case "hashchange":
    case "popstate":
    case "select":
    case "selectstart":
        return 1;
    case "drag":
    case "dragenter":
    case "dragexit":
    case "dragleave":
    case "dragover":
    case "mousemove":
    case "mouseout":
    case "mouseover":
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "scroll":
    case "toggle":
    case "touchmove":
    case "wheel":
    case "mouseenter":
    case "mouseleave":
    case "pointerenter":
    case "pointerleave":
        return 4;
    case "message":
        switch (hB()) {
        case Kw:
            return 1;
        case MT:
            return 4;
        case wv:
        case pB:
            return 16;
        case AT:
            return 536870912;
        default:
            return 16
        }
    default:
        return 16
    }
}
var oc = null
  , $w = null
  , J0 = null;
function IT() {
    if (J0)
        return J0;
    var n, e = $w, t = e.length, r, i = "value"in oc ? oc.value : oc.textContent, s = i.length;
    for (n = 0; n < t && e[n] === i[n]; n++)
        ;
    var o = t - n;
    for (r = 1; r <= o && e[t - r] === i[s - r]; r++)
        ;
    return J0 = i.slice(n, 1 < r ? 1 - r : void 0)
}
function j0(n) {
    var e = n.keyCode;
    return "charCode"in n ? (n = n.charCode,
    n === 0 && e === 13 && (n = 13)) : n = e,
    n === 10 && (n = 13),
    32 <= n || n === 13 ? n : 0
}
function Eg() {
    return !0
}
function TA() {
    return !1
}
function Ea(n) {
    function e(t, r, i, s, o) {
        this._reactName = t,
        this._targetInst = i,
        this.type = r,
        this.nativeEvent = s,
        this.target = o,
        this.currentTarget = null;
        for (var a in n)
            n.hasOwnProperty(a) && (t = n[a],
            this[a] = t ? t(s) : s[a]);
        return this.isDefaultPrevented = (s.defaultPrevented != null ? s.defaultPrevented : s.returnValue === !1) ? Eg : TA,
        this.isPropagationStopped = TA,
        this
    }
    return Oi(e.prototype, {
        preventDefault: function() {
            this.defaultPrevented = !0;
            var t = this.nativeEvent;
            t && (t.preventDefault ? t.preventDefault() : typeof t.returnValue != "unknown" && (t.returnValue = !1),
            this.isDefaultPrevented = Eg)
        },
        stopPropagation: function() {
            var t = this.nativeEvent;
            t && (t.stopPropagation ? t.stopPropagation() : typeof t.cancelBubble != "unknown" && (t.cancelBubble = !0),
            this.isPropagationStopped = Eg)
        },
        persist: function() {},
        isPersistent: Eg
    }),
    e
}
var bh = {
    eventPhase: 0,
    bubbles: 0,
    cancelable: 0,
    timeStamp: function(n) {
        return n.timeStamp || Date.now()
    },
    defaultPrevented: 0,
    isTrusted: 0
}, eS = Ea(bh), Rm = Oi({}, bh, {
    view: 0,
    detail: 0
}), bB = Ea(Rm), my, gy, Yh, e_ = Oi({}, Rm, {
    screenX: 0,
    screenY: 0,
    clientX: 0,
    clientY: 0,
    pageX: 0,
    pageY: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    getModifierState: tS,
    button: 0,
    buttons: 0,
    relatedTarget: function(n) {
        return n.relatedTarget === void 0 ? n.fromElement === n.srcElement ? n.toElement : n.fromElement : n.relatedTarget
    },
    movementX: function(n) {
        return "movementX"in n ? n.movementX : (n !== Yh && (Yh && n.type === "mousemove" ? (my = n.screenX - Yh.screenX,
        gy = n.screenY - Yh.screenY) : gy = my = 0,
        Yh = n),
        my)
    },
    movementY: function(n) {
        return "movementY"in n ? n.movementY : gy
    }
}), DA = Ea(e_), TB = Oi({}, e_, {
    dataTransfer: 0
}), DB = Ea(TB), PB = Oi({}, Rm, {
    relatedTarget: 0
}), vy = Ea(PB), RB = Oi({}, bh, {
    animationName: 0,
    elapsedTime: 0,
    pseudoElement: 0
}), BB = Ea(RB), IB = Oi({}, bh, {
    clipboardData: function(n) {
        return "clipboardData"in n ? n.clipboardData : window.clipboardData
    }
}), LB = Ea(IB), FB = Oi({}, bh, {
    data: 0
}), PA = Ea(FB), kB = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified"
}, OB = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta"
}, NB = {
    Alt: "altKey",
    Control: "ctrlKey",
    Meta: "metaKey",
    Shift: "shiftKey"
};
function zB(n) {
    var e = this.nativeEvent;
    return e.getModifierState ? e.getModifierState(n) : (n = NB[n]) ? !!e[n] : !1
}
function tS() {
    return zB
}
var GB = Oi({}, Rm, {
    key: function(n) {
        if (n.key) {
            var e = kB[n.key] || n.key;
            if (e !== "Unidentified")
                return e
        }
        return n.type === "keypress" ? (n = j0(n),
        n === 13 ? "Enter" : String.fromCharCode(n)) : n.type === "keydown" || n.type === "keyup" ? OB[n.keyCode] || "Unidentified" : ""
    },
    code: 0,
    location: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    repeat: 0,
    locale: 0,
    getModifierState: tS,
    charCode: function(n) {
        return n.type === "keypress" ? j0(n) : 0
    },
    keyCode: function(n) {
        return n.type === "keydown" || n.type === "keyup" ? n.keyCode : 0
    },
    which: function(n) {
        return n.type === "keypress" ? j0(n) : n.type === "keydown" || n.type === "keyup" ? n.keyCode : 0
    }
})
  , UB = Ea(GB)
  , HB = Oi({}, e_, {
    pointerId: 0,
    width: 0,
    height: 0,
    pressure: 0,
    tangentialPressure: 0,
    tiltX: 0,
    tiltY: 0,
    twist: 0,
    pointerType: 0,
    isPrimary: 0
})
  , RA = Ea(HB)
  , VB = Oi({}, Rm, {
    touches: 0,
    targetTouches: 0,
    changedTouches: 0,
    altKey: 0,
    metaKey: 0,
    ctrlKey: 0,
    shiftKey: 0,
    getModifierState: tS
})
  , WB = Ea(VB)
  , XB = Oi({}, bh, {
    propertyName: 0,
    elapsedTime: 0,
    pseudoElement: 0
})
  , JB = Ea(XB)
  , jB = Oi({}, e_, {
    deltaX: function(n) {
        return "deltaX"in n ? n.deltaX : "wheelDeltaX"in n ? -n.wheelDeltaX : 0
    },
    deltaY: function(n) {
        return "deltaY"in n ? n.deltaY : "wheelDeltaY"in n ? -n.wheelDeltaY : "wheelDelta"in n ? -n.wheelDelta : 0
    },
    deltaZ: 0,
    deltaMode: 0
})
  , YB = Ea(jB)
  , KB = [9, 13, 27, 32]
  , nS = Au && "CompositionEvent"in window
  , Rp = null;
Au && "documentMode"in document && (Rp = document.documentMode);
var qB = Au && "TextEvent"in window && !Rp
  , LT = Au && (!nS || Rp && 8 < Rp && 11 >= Rp)
  , BA = String.fromCharCode(32)
  , IA = !1;
function FT(n, e) {
    switch (n) {
    case "keyup":
        return KB.indexOf(e.keyCode) !== -1;
    case "keydown":
        return e.keyCode !== 229;
    case "keypress":
    case "mousedown":
    case "focusout":
        return !0;
    default:
        return !1
    }
}
function kT(n) {
    return n = n.detail,
    typeof n == "object" && "data"in n ? n.data : null
}
var Ld = !1;
function QB(n, e) {
    switch (n) {
    case "compositionend":
        return kT(e);
    case "keypress":
        return e.which !== 32 ? null : (IA = !0,
        BA);
    case "textInput":
        return n = e.data,
        n === BA && IA ? null : n;
    default:
        return null
    }
}
function ZB(n, e) {
    if (Ld)
        return n === "compositionend" || !nS && FT(n, e) ? (n = IT(),
        J0 = $w = oc = null,
        Ld = !1,
        n) : null;
    switch (n) {
    case "paste":
        return null;
    case "keypress":
        if (!(e.ctrlKey || e.altKey || e.metaKey) || e.ctrlKey && e.altKey) {
            if (e.char && 1 < e.char.length)
                return e.char;
            if (e.which)
                return String.fromCharCode(e.which)
        }
        return null;
    case "compositionend":
        return LT && e.locale !== "ko" ? null : e.data;
    default:
        return null
    }
}
var $B = {
    color: !0,
    date: !0,
    datetime: !0,
    "datetime-local": !0,
    email: !0,
    month: !0,
    number: !0,
    password: !0,
    range: !0,
    search: !0,
    tel: !0,
    text: !0,
    time: !0,
    url: !0,
    week: !0
};
function LA(n) {
    var e = n && n.nodeName && n.nodeName.toLowerCase();
    return e === "input" ? !!$B[n.type] : e === "textarea"
}
function OT(n, e, t, r) {
    pT(r),
    e = Cv(e, "onChange"),
    0 < e.length && (t = new eS("onChange","change",null,t,r),
    n.push({
        event: t,
        listeners: e
    }))
}
var Bp = null
  , nm = null;
function eI(n) {
    YT(n, 0)
}
function t_(n) {
    var e = Od(n);
    if (aT(e))
        return n
}
function tI(n, e) {
    if (n === "change")
        return e
}
var NT = !1;
if (Au) {
    var _y;
    if (Au) {
        var yy = "oninput"in document;
        if (!yy) {
            var FA = document.createElement("div");
            FA.setAttribute("oninput", "return;"),
            yy = typeof FA.oninput == "function"
        }
        _y = yy
    } else
        _y = !1;
    NT = _y && (!document.documentMode || 9 < document.documentMode)
}
function kA() {
    Bp && (Bp.detachEvent("onpropertychange", zT),
    nm = Bp = null)
}
function zT(n) {
    if (n.propertyName === "value" && t_(nm)) {
        var e = [];
        OT(e, nm, n, Yw(n)),
        _T(eI, e)
    }
}
function nI(n, e, t) {
    n === "focusin" ? (kA(),
    Bp = e,
    nm = t,
    Bp.attachEvent("onpropertychange", zT)) : n === "focusout" && kA()
}
function rI(n) {
    if (n === "selectionchange" || n === "keyup" || n === "keydown")
        return t_(nm)
}
function iI(n, e) {
    if (n === "click")
        return t_(e)
}
function sI(n, e) {
    if (n === "input" || n === "change")
        return t_(e)
}
function oI(n, e) {
    return n === e && (n !== 0 || 1 / n === 1 / e) || n !== n && e !== e
}
var Cl = typeof Object.is == "function" ? Object.is : oI;
function rm(n, e) {
    if (Cl(n, e))
        return !0;
    if (typeof n != "object" || n === null || typeof e != "object" || e === null)
        return !1;
    var t = Object.keys(n)
      , r = Object.keys(e);
    if (t.length !== r.length)
        return !1;
    for (r = 0; r < t.length; r++) {
        var i = t[r];
        if (!Hx.call(e, i) || !Cl(n[i], e[i]))
            return !1
    }
    return !0
}
function OA(n) {
    for (; n && n.firstChild; )
        n = n.firstChild;
    return n
}
function NA(n, e) {
    var t = OA(n);
    n = 0;
    for (var r; t; ) {
        if (t.nodeType === 3) {
            if (r = n + t.textContent.length,
            n <= e && r >= e)
                return {
                    node: t,
                    offset: e - n
                };
            n = r
        }
        e: {
            for (; t; ) {
                if (t.nextSibling) {
                    t = t.nextSibling;
                    break e
                }
                t = t.parentNode
            }
            t = void 0
        }
        t = OA(t)
    }
}
function GT(n, e) {
    return n && e ? n === e ? !0 : n && n.nodeType === 3 ? !1 : e && e.nodeType === 3 ? GT(n, e.parentNode) : "contains"in n ? n.contains(e) : n.compareDocumentPosition ? !!(n.compareDocumentPosition(e) & 16) : !1 : !1
}
function UT() {
    for (var n = window, e = _v(); e instanceof n.HTMLIFrameElement; ) {
        try {
            var t = typeof e.contentWindow.location.href == "string"
        } catch {
            t = !1
        }
        if (t)
            n = e.contentWindow;
        else
            break;
        e = _v(n.document)
    }
    return e
}
function rS(n) {
    var e = n && n.nodeName && n.nodeName.toLowerCase();
    return e && (e === "input" && (n.type === "text" || n.type === "search" || n.type === "tel" || n.type === "url" || n.type === "password") || e === "textarea" || n.contentEditable === "true")
}
function aI(n) {
    var e = UT()
      , t = n.focusedElem
      , r = n.selectionRange;
    if (e !== t && t && t.ownerDocument && GT(t.ownerDocument.documentElement, t)) {
        if (r !== null && rS(t)) {
            if (e = r.start,
            n = r.end,
            n === void 0 && (n = e),
            "selectionStart"in t)
                t.selectionStart = e,
                t.selectionEnd = Math.min(n, t.value.length);
            else if (n = (e = t.ownerDocument || document) && e.defaultView || window,
            n.getSelection) {
                n = n.getSelection();
                var i = t.textContent.length
                  , s = Math.min(r.start, i);
                r = r.end === void 0 ? s : Math.min(r.end, i),
                !n.extend && s > r && (i = r,
                r = s,
                s = i),
                i = NA(t, s);
                var o = NA(t, r);
                i && o && (n.rangeCount !== 1 || n.anchorNode !== i.node || n.anchorOffset !== i.offset || n.focusNode !== o.node || n.focusOffset !== o.offset) && (e = e.createRange(),
                e.setStart(i.node, i.offset),
                n.removeAllRanges(),
                s > r ? (n.addRange(e),
                n.extend(o.node, o.offset)) : (e.setEnd(o.node, o.offset),
                n.addRange(e)))
            }
        }
        for (e = [],
        n = t; n = n.parentNode; )
            n.nodeType === 1 && e.push({
                element: n,
                left: n.scrollLeft,
                top: n.scrollTop
            });
        for (typeof t.focus == "function" && t.focus(),
        t = 0; t < e.length; t++)
            n = e[t],
            n.element.scrollLeft = n.left,
            n.element.scrollTop = n.top
    }
}
var lI = Au && "documentMode"in document && 11 >= document.documentMode
  , Fd = null
  , a1 = null
  , Ip = null
  , l1 = !1;
function zA(n, e, t) {
    var r = t.window === t ? t.document : t.nodeType === 9 ? t : t.ownerDocument;
    l1 || Fd == null || Fd !== _v(r) || (r = Fd,
    "selectionStart"in r && rS(r) ? r = {
        start: r.selectionStart,
        end: r.selectionEnd
    } : (r = (r.ownerDocument && r.ownerDocument.defaultView || window).getSelection(),
    r = {
        anchorNode: r.anchorNode,
        anchorOffset: r.anchorOffset,
        focusNode: r.focusNode,
        focusOffset: r.focusOffset
    }),
    Ip && rm(Ip, r) || (Ip = r,
    r = Cv(a1, "onSelect"),
    0 < r.length && (e = new eS("onSelect","select",null,e,t),
    n.push({
        event: e,
        listeners: r
    }),
    e.target = Fd)))
}
function bg(n, e) {
    var t = {};
    return t[n.toLowerCase()] = e.toLowerCase(),
    t["Webkit" + n] = "webkit" + e,
    t["Moz" + n] = "moz" + e,
    t
}
var kd = {
    animationend: bg("Animation", "AnimationEnd"),
    animationiteration: bg("Animation", "AnimationIteration"),
    animationstart: bg("Animation", "AnimationStart"),
    transitionend: bg("Transition", "TransitionEnd")
}
  , xy = {}
  , HT = {};
Au && (HT = document.createElement("div").style,
"AnimationEvent"in window || (delete kd.animationend.animation,
delete kd.animationiteration.animation,
delete kd.animationstart.animation),
"TransitionEvent"in window || delete kd.transitionend.transition);
function n_(n) {
    if (xy[n])
        return xy[n];
    if (!kd[n])
        return n;
    var e = kd[n], t;
    for (t in e)
        if (e.hasOwnProperty(t) && t in HT)
            return xy[n] = e[t];
    return n
}
var VT = n_("animationend")
  , WT = n_("animationiteration")
  , XT = n_("animationstart")
  , JT = n_("transitionend")
  , jT = new Map
  , GA = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
function Ic(n, e) {
    jT.set(n, e),
    qf(e, [n])
}
for (var wy = 0; wy < GA.length; wy++) {
    var Sy = GA[wy]
      , uI = Sy.toLowerCase()
      , cI = Sy[0].toUpperCase() + Sy.slice(1);
    Ic(uI, "on" + cI)
}
Ic(VT, "onAnimationEnd");
Ic(WT, "onAnimationIteration");
Ic(XT, "onAnimationStart");
Ic("dblclick", "onDoubleClick");
Ic("focusin", "onFocus");
Ic("focusout", "onBlur");
Ic(JT, "onTransitionEnd");
lh("onMouseEnter", ["mouseout", "mouseover"]);
lh("onMouseLeave", ["mouseout", "mouseover"]);
lh("onPointerEnter", ["pointerout", "pointerover"]);
lh("onPointerLeave", ["pointerout", "pointerover"]);
qf("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
qf("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
qf("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
qf("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
qf("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
qf("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
var Sp = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" ")
  , fI = new Set("cancel close invalid load scroll toggle".split(" ").concat(Sp));
function UA(n, e, t) {
    var r = n.type || "unknown-event";
    n.currentTarget = t,
    uB(r, e, void 0, n),
    n.currentTarget = null
}
function YT(n, e) {
    e = (e & 4) !== 0;
    for (var t = 0; t < n.length; t++) {
        var r = n[t]
          , i = r.event;
        r = r.listeners;
        e: {
            var s = void 0;
            if (e)
                for (var o = r.length - 1; 0 <= o; o--) {
                    var a = r[o]
                      , l = a.instance
                      , f = a.currentTarget;
                    if (a = a.listener,
                    l !== s && i.isPropagationStopped())
                        break e;
                    UA(i, a, f),
                    s = l
                }
            else
                for (o = 0; o < r.length; o++) {
                    if (a = r[o],
                    l = a.instance,
                    f = a.currentTarget,
                    a = a.listener,
                    l !== s && i.isPropagationStopped())
                        break e;
                    UA(i, a, f),
                    s = l
                }
        }
    }
    if (xv)
        throw n = r1,
        xv = !1,
        r1 = null,
        n
}
function mi(n, e) {
    var t = e[h1];
    t === void 0 && (t = e[h1] = new Set);
    var r = n + "__bubble";
    t.has(r) || (KT(e, n, 2, !1),
    t.add(r))
}
function My(n, e, t) {
    var r = 0;
    e && (r |= 4),
    KT(t, n, r, e)
}
var Tg = "_reactListening" + Math.random().toString(36).slice(2);
function im(n) {
    if (!n[Tg]) {
        n[Tg] = !0,
        nT.forEach(function(t) {
            t !== "selectionchange" && (fI.has(t) || My(t, !1, n),
            My(t, !0, n))
        });
        var e = n.nodeType === 9 ? n : n.ownerDocument;
        e === null || e[Tg] || (e[Tg] = !0,
        My("selectionchange", !1, e))
    }
}
function KT(n, e, t, r) {
    switch (BT(e)) {
    case 1:
        var i = CB;
        break;
    case 4:
        i = EB;
        break;
    default:
        i = Zw
    }
    t = i.bind(null, e, t, n),
    i = void 0,
    !n1 || e !== "touchstart" && e !== "touchmove" && e !== "wheel" || (i = !0),
    r ? i !== void 0 ? n.addEventListener(e, t, {
        capture: !0,
        passive: i
    }) : n.addEventListener(e, t, !0) : i !== void 0 ? n.addEventListener(e, t, {
        passive: i
    }) : n.addEventListener(e, t, !1)
}
function Ay(n, e, t, r, i) {
    var s = r;
    if (!(e & 1) && !(e & 2) && r !== null)
        e: for (; ; ) {
            if (r === null)
                return;
            var o = r.tag;
            if (o === 3 || o === 4) {
                var a = r.stateNode.containerInfo;
                if (a === i || a.nodeType === 8 && a.parentNode === i)
                    break;
                if (o === 4)
                    for (o = r.return; o !== null; ) {
                        var l = o.tag;
                        if ((l === 3 || l === 4) && (l = o.stateNode.containerInfo,
                        l === i || l.nodeType === 8 && l.parentNode === i))
                            return;
                        o = o.return
                    }
                for (; a !== null; ) {
                    if (o = gf(a),
                    o === null)
                        return;
                    if (l = o.tag,
                    l === 5 || l === 6) {
                        r = s = o;
                        continue e
                    }
                    a = a.parentNode
                }
            }
            r = r.return
        }
    _T(function() {
        var f = s
          , h = Yw(t)
          , d = [];
        e: {
            var p = jT.get(n);
            if (p !== void 0) {
                var m = eS
                  , _ = n;
                switch (n) {
                case "keypress":
                    if (j0(t) === 0)
                        break e;
                case "keydown":
                case "keyup":
                    m = UB;
                    break;
                case "focusin":
                    _ = "focus",
                    m = vy;
                    break;
                case "focusout":
                    _ = "blur",
                    m = vy;
                    break;
                case "beforeblur":
                case "afterblur":
                    m = vy;
                    break;
                case "click":
                    if (t.button === 2)
                        break e;
                case "auxclick":
                case "dblclick":
                case "mousedown":
                case "mousemove":
                case "mouseup":
                case "mouseout":
                case "mouseover":
                case "contextmenu":
                    m = DA;
                    break;
                case "drag":
                case "dragend":
                case "dragenter":
                case "dragexit":
                case "dragleave":
                case "dragover":
                case "dragstart":
                case "drop":
                    m = DB;
                    break;
                case "touchcancel":
                case "touchend":
                case "touchmove":
                case "touchstart":
                    m = WB;
                    break;
                case VT:
                case WT:
                case XT:
                    m = BB;
                    break;
                case JT:
                    m = JB;
                    break;
                case "scroll":
                    m = bB;
                    break;
                case "wheel":
                    m = YB;
                    break;
                case "copy":
                case "cut":
                case "paste":
                    m = LB;
                    break;
                case "gotpointercapture":
                case "lostpointercapture":
                case "pointercancel":
                case "pointerdown":
                case "pointermove":
                case "pointerout":
                case "pointerover":
                case "pointerup":
                    m = RA
                }
                var y = (e & 4) !== 0
                  , x = !y && n === "scroll"
                  , S = y ? p !== null ? p + "Capture" : null : p;
                y = [];
                for (var M = f, w; M !== null; ) {
                    w = M;
                    var T = w.stateNode;
                    if (w.tag === 5 && T !== null && (w = T,
                    S !== null && (T = Zp(M, S),
                    T != null && y.push(sm(M, T, w)))),
                    x)
                        break;
                    M = M.return
                }
                0 < y.length && (p = new m(p,_,null,t,h),
                d.push({
                    event: p,
                    listeners: y
                }))
            }
        }
        if (!(e & 7)) {
            e: {
                if (p = n === "mouseover" || n === "pointerover",
                m = n === "mouseout" || n === "pointerout",
                p && t !== e1 && (_ = t.relatedTarget || t.fromElement) && (gf(_) || _[Cu]))
                    break e;
                if ((m || p) && (p = h.window === h ? h : (p = h.ownerDocument) ? p.defaultView || p.parentWindow : window,
                m ? (_ = t.relatedTarget || t.toElement,
                m = f,
                _ = _ ? gf(_) : null,
                _ !== null && (x = Qf(_),
                _ !== x || _.tag !== 5 && _.tag !== 6) && (_ = null)) : (m = null,
                _ = f),
                m !== _)) {
                    if (y = DA,
                    T = "onMouseLeave",
                    S = "onMouseEnter",
                    M = "mouse",
                    (n === "pointerout" || n === "pointerover") && (y = RA,
                    T = "onPointerLeave",
                    S = "onPointerEnter",
                    M = "pointer"),
                    x = m == null ? p : Od(m),
                    w = _ == null ? p : Od(_),
                    p = new y(T,M + "leave",m,t,h),
                    p.target = x,
                    p.relatedTarget = w,
                    T = null,
                    gf(h) === f && (y = new y(S,M + "enter",_,t,h),
                    y.target = w,
                    y.relatedTarget = x,
                    T = y),
                    x = T,
                    m && _)
                        t: {
                            for (y = m,
                            S = _,
                            M = 0,
                            w = y; w; w = ad(w))
                                M++;
                            for (w = 0,
                            T = S; T; T = ad(T))
                                w++;
                            for (; 0 < M - w; )
                                y = ad(y),
                                M--;
                            for (; 0 < w - M; )
                                S = ad(S),
                                w--;
                            for (; M--; ) {
                                if (y === S || S !== null && y === S.alternate)
                                    break t;
                                y = ad(y),
                                S = ad(S)
                            }
                            y = null
                        }
                    else
                        y = null;
                    m !== null && HA(d, p, m, y, !1),
                    _ !== null && x !== null && HA(d, x, _, y, !0)
                }
            }
            e: {
                if (p = f ? Od(f) : window,
                m = p.nodeName && p.nodeName.toLowerCase(),
                m === "select" || m === "input" && p.type === "file")
                    var P = tI;
                else if (LA(p))
                    if (NT)
                        P = sI;
                    else {
                        P = rI;
                        var I = nI
                    }
                else
                    (m = p.nodeName) && m.toLowerCase() === "input" && (p.type === "checkbox" || p.type === "radio") && (P = iI);
                if (P && (P = P(n, f))) {
                    OT(d, P, t, h);
                    break e
                }
                I && I(n, p, f),
                n === "focusout" && (I = p._wrapperState) && I.controlled && p.type === "number" && Kx(p, "number", p.value)
            }
            switch (I = f ? Od(f) : window,
            n) {
            case "focusin":
                (LA(I) || I.contentEditable === "true") && (Fd = I,
                a1 = f,
                Ip = null);
                break;
            case "focusout":
                Ip = a1 = Fd = null;
                break;
            case "mousedown":
                l1 = !0;
                break;
            case "contextmenu":
            case "mouseup":
            case "dragend":
                l1 = !1,
                zA(d, t, h);
                break;
            case "selectionchange":
                if (lI)
                    break;
            case "keydown":
            case "keyup":
                zA(d, t, h)
            }
            var k;
            if (nS)
                e: {
                    switch (n) {
                    case "compositionstart":
                        var R = "onCompositionStart";
                        break e;
                    case "compositionend":
                        R = "onCompositionEnd";
                        break e;
                    case "compositionupdate":
                        R = "onCompositionUpdate";
                        break e
                    }
                    R = void 0
                }
            else
                Ld ? FT(n, t) && (R = "onCompositionEnd") : n === "keydown" && t.keyCode === 229 && (R = "onCompositionStart");
            R && (LT && t.locale !== "ko" && (Ld || R !== "onCompositionStart" ? R === "onCompositionEnd" && Ld && (k = IT()) : (oc = h,
            $w = "value"in oc ? oc.value : oc.textContent,
            Ld = !0)),
            I = Cv(f, R),
            0 < I.length && (R = new PA(R,n,null,t,h),
            d.push({
                event: R,
                listeners: I
            }),
            k ? R.data = k : (k = kT(t),
            k !== null && (R.data = k)))),
            (k = qB ? QB(n, t) : ZB(n, t)) && (f = Cv(f, "onBeforeInput"),
            0 < f.length && (h = new PA("onBeforeInput","beforeinput",null,t,h),
            d.push({
                event: h,
                listeners: f
            }),
            h.data = k))
        }
        YT(d, e)
    })
}
function sm(n, e, t) {
    return {
        instance: n,
        listener: e,
        currentTarget: t
    }
}
function Cv(n, e) {
    for (var t = e + "Capture", r = []; n !== null; ) {
        var i = n
          , s = i.stateNode;
        i.tag === 5 && s !== null && (i = s,
        s = Zp(n, t),
        s != null && r.unshift(sm(n, s, i)),
        s = Zp(n, e),
        s != null && r.push(sm(n, s, i))),
        n = n.return
    }
    return r
}
function ad(n) {
    if (n === null)
        return null;
    do
        n = n.return;
    while (n && n.tag !== 5);
    return n || null
}
function HA(n, e, t, r, i) {
    for (var s = e._reactName, o = []; t !== null && t !== r; ) {
        var a = t
          , l = a.alternate
          , f = a.stateNode;
        if (l !== null && l === r)
            break;
        a.tag === 5 && f !== null && (a = f,
        i ? (l = Zp(t, s),
        l != null && o.unshift(sm(t, l, a))) : i || (l = Zp(t, s),
        l != null && o.push(sm(t, l, a)))),
        t = t.return
    }
    o.length !== 0 && n.push({
        event: e,
        listeners: o
    })
}
var dI = /\r\n?/g
  , hI = /\u0000|\uFFFD/g;
function VA(n) {
    return (typeof n == "string" ? n : "" + n).replace(dI, `
`).replace(hI, "")
}
function Dg(n, e, t) {
    if (e = VA(e),
    VA(n) !== e && t)
        throw Error(mt(425))
}
function Ev() {}
var u1 = null
  , c1 = null;
function f1(n, e) {
    return n === "textarea" || n === "noscript" || typeof e.children == "string" || typeof e.children == "number" || typeof e.dangerouslySetInnerHTML == "object" && e.dangerouslySetInnerHTML !== null && e.dangerouslySetInnerHTML.__html != null
}
var d1 = typeof setTimeout == "function" ? setTimeout : void 0
  , pI = typeof clearTimeout == "function" ? clearTimeout : void 0
  , WA = typeof Promise == "function" ? Promise : void 0
  , mI = typeof queueMicrotask == "function" ? queueMicrotask : typeof WA < "u" ? function(n) {
    return WA.resolve(null).then(n).catch(gI)
}
: d1;
function gI(n) {
    setTimeout(function() {
        throw n
    })
}
function Cy(n, e) {
    var t = e
      , r = 0;
    do {
        var i = t.nextSibling;
        if (n.removeChild(t),
        i && i.nodeType === 8)
            if (t = i.data,
            t === "/$") {
                if (r === 0) {
                    n.removeChild(i),
                    tm(e);
                    return
                }
                r--
            } else
                t !== "$" && t !== "$?" && t !== "$!" || r++;
        t = i
    } while (t);
    tm(e)
}
function vc(n) {
    for (; n != null; n = n.nextSibling) {
        var e = n.nodeType;
        if (e === 1 || e === 3)
            break;
        if (e === 8) {
            if (e = n.data,
            e === "$" || e === "$!" || e === "$?")
                break;
            if (e === "/$")
                return null
        }
    }
    return n
}
function XA(n) {
    n = n.previousSibling;
    for (var e = 0; n; ) {
        if (n.nodeType === 8) {
            var t = n.data;
            if (t === "$" || t === "$!" || t === "$?") {
                if (e === 0)
                    return n;
                e--
            } else
                t === "/$" && e++
        }
        n = n.previousSibling
    }
    return null
}
var Th = Math.random().toString(36).slice(2)
  , Vl = "__reactFiber$" + Th
  , om = "__reactProps$" + Th
  , Cu = "__reactContainer$" + Th
  , h1 = "__reactEvents$" + Th
  , vI = "__reactListeners$" + Th
  , _I = "__reactHandles$" + Th;
function gf(n) {
    var e = n[Vl];
    if (e)
        return e;
    for (var t = n.parentNode; t; ) {
        if (e = t[Cu] || t[Vl]) {
            if (t = e.alternate,
            e.child !== null || t !== null && t.child !== null)
                for (n = XA(n); n !== null; ) {
                    if (t = n[Vl])
                        return t;
                    n = XA(n)
                }
            return e
        }
        n = t,
        t = n.parentNode
    }
    return null
}
function Bm(n) {
    return n = n[Vl] || n[Cu],
    !n || n.tag !== 5 && n.tag !== 6 && n.tag !== 13 && n.tag !== 3 ? null : n
}
function Od(n) {
    if (n.tag === 5 || n.tag === 6)
        return n.stateNode;
    throw Error(mt(33))
}
function r_(n) {
    return n[om] || null
}
var p1 = []
  , Nd = -1;
function Lc(n) {
    return {
        current: n
    }
}
function vi(n) {
    0 > Nd || (n.current = p1[Nd],
    p1[Nd] = null,
    Nd--)
}
function fi(n, e) {
    Nd++,
    p1[Nd] = n.current,
    n.current = e
}
var Cc = {}
  , ao = Lc(Cc)
  , Qo = Lc(!1)
  , kf = Cc;
function uh(n, e) {
    var t = n.type.contextTypes;
    if (!t)
        return Cc;
    var r = n.stateNode;
    if (r && r.__reactInternalMemoizedUnmaskedChildContext === e)
        return r.__reactInternalMemoizedMaskedChildContext;
    var i = {}, s;
    for (s in t)
        i[s] = e[s];
    return r && (n = n.stateNode,
    n.__reactInternalMemoizedUnmaskedChildContext = e,
    n.__reactInternalMemoizedMaskedChildContext = i),
    i
}
function Zo(n) {
    return n = n.childContextTypes,
    n != null
}
function bv() {
    vi(Qo),
    vi(ao)
}
function JA(n, e, t) {
    if (ao.current !== Cc)
        throw Error(mt(168));
    fi(ao, e),
    fi(Qo, t)
}
function qT(n, e, t) {
    var r = n.stateNode;
    if (e = e.childContextTypes,
    typeof r.getChildContext != "function")
        return t;
    r = r.getChildContext();
    for (var i in r)
        if (!(i in e))
            throw Error(mt(108, nB(n) || "Unknown", i));
    return Oi({}, t, r)
}
function Tv(n) {
    return n = (n = n.stateNode) && n.__reactInternalMemoizedMergedChildContext || Cc,
    kf = ao.current,
    fi(ao, n),
    fi(Qo, Qo.current),
    !0
}
function jA(n, e, t) {
    var r = n.stateNode;
    if (!r)
        throw Error(mt(169));
    t ? (n = qT(n, e, kf),
    r.__reactInternalMemoizedMergedChildContext = n,
    vi(Qo),
    vi(ao),
    fi(ao, n)) : vi(Qo),
    fi(Qo, t)
}
var fu = null
  , i_ = !1
  , Ey = !1;
function QT(n) {
    fu === null ? fu = [n] : fu.push(n)
}
function yI(n) {
    i_ = !0,
    QT(n)
}
function Fc() {
    if (!Ey && fu !== null) {
        Ey = !0;
        var n = 0
          , e = Gr;
        try {
            var t = fu;
            for (Gr = 1; n < t.length; n++) {
                var r = t[n];
                do
                    r = r(!0);
                while (r !== null)
            }
            fu = null,
            i_ = !1
        } catch (i) {
            throw fu !== null && (fu = fu.slice(n + 1)),
            ST(Kw, Fc),
            i
        } finally {
            Gr = e,
            Ey = !1
        }
    }
    return null
}
var zd = []
  , Gd = 0
  , Dv = null
  , Pv = 0
  , Ha = []
  , Va = 0
  , Of = null
  , mu = 1
  , gu = "";
function of(n, e) {
    zd[Gd++] = Pv,
    zd[Gd++] = Dv,
    Dv = n,
    Pv = e
}
function ZT(n, e, t) {
    Ha[Va++] = mu,
    Ha[Va++] = gu,
    Ha[Va++] = Of,
    Of = n;
    var r = mu;
    n = gu;
    var i = 32 - Ml(r) - 1;
    r &= ~(1 << i),
    t += 1;
    var s = 32 - Ml(e) + i;
    if (30 < s) {
        var o = i - i % 5;
        s = (r & (1 << o) - 1).toString(32),
        r >>= o,
        i -= o,
        mu = 1 << 32 - Ml(e) + i | t << i | r,
        gu = s + n
    } else
        mu = 1 << s | t << i | r,
        gu = n
}
function iS(n) {
    n.return !== null && (of(n, 1),
    ZT(n, 1, 0))
}
function sS(n) {
    for (; n === Dv; )
        Dv = zd[--Gd],
        zd[Gd] = null,
        Pv = zd[--Gd],
        zd[Gd] = null;
    for (; n === Of; )
        Of = Ha[--Va],
        Ha[Va] = null,
        gu = Ha[--Va],
        Ha[Va] = null,
        mu = Ha[--Va],
        Ha[Va] = null
}
var wa = null
  , _a = null
  , Ai = !1
  , _l = null;
function $T(n, e) {
    var t = Ja(5, null, null, 0);
    t.elementType = "DELETED",
    t.stateNode = e,
    t.return = n,
    e = n.deletions,
    e === null ? (n.deletions = [t],
    n.flags |= 16) : e.push(t)
}
function YA(n, e) {
    switch (n.tag) {
    case 5:
        var t = n.type;
        return e = e.nodeType !== 1 || t.toLowerCase() !== e.nodeName.toLowerCase() ? null : e,
        e !== null ? (n.stateNode = e,
        wa = n,
        _a = vc(e.firstChild),
        !0) : !1;
    case 6:
        return e = n.pendingProps === "" || e.nodeType !== 3 ? null : e,
        e !== null ? (n.stateNode = e,
        wa = n,
        _a = null,
        !0) : !1;
    case 13:
        return e = e.nodeType !== 8 ? null : e,
        e !== null ? (t = Of !== null ? {
            id: mu,
            overflow: gu
        } : null,
        n.memoizedState = {
            dehydrated: e,
            treeContext: t,
            retryLane: 1073741824
        },
        t = Ja(18, null, null, 0),
        t.stateNode = e,
        t.return = n,
        n.child = t,
        wa = n,
        _a = null,
        !0) : !1;
    default:
        return !1
    }
}
function m1(n) {
    return (n.mode & 1) !== 0 && (n.flags & 128) === 0
}
function g1(n) {
    if (Ai) {
        var e = _a;
        if (e) {
            var t = e;
            if (!YA(n, e)) {
                if (m1(n))
                    throw Error(mt(418));
                e = vc(t.nextSibling);
                var r = wa;
                e && YA(n, e) ? $T(r, t) : (n.flags = n.flags & -4097 | 2,
                Ai = !1,
                wa = n)
            }
        } else {
            if (m1(n))
                throw Error(mt(418));
            n.flags = n.flags & -4097 | 2,
            Ai = !1,
            wa = n
        }
    }
}
function KA(n) {
    for (n = n.return; n !== null && n.tag !== 5 && n.tag !== 3 && n.tag !== 13; )
        n = n.return;
    wa = n
}
function Pg(n) {
    if (n !== wa)
        return !1;
    if (!Ai)
        return KA(n),
        Ai = !0,
        !1;
    var e;
    if ((e = n.tag !== 3) && !(e = n.tag !== 5) && (e = n.type,
    e = e !== "head" && e !== "body" && !f1(n.type, n.memoizedProps)),
    e && (e = _a)) {
        if (m1(n))
            throw eD(),
            Error(mt(418));
        for (; e; )
            $T(n, e),
            e = vc(e.nextSibling)
    }
    if (KA(n),
    n.tag === 13) {
        if (n = n.memoizedState,
        n = n !== null ? n.dehydrated : null,
        !n)
            throw Error(mt(317));
        e: {
            for (n = n.nextSibling,
            e = 0; n; ) {
                if (n.nodeType === 8) {
                    var t = n.data;
                    if (t === "/$") {
                        if (e === 0) {
                            _a = vc(n.nextSibling);
                            break e
                        }
                        e--
                    } else
                        t !== "$" && t !== "$!" && t !== "$?" || e++
                }
                n = n.nextSibling
            }
            _a = null
        }
    } else
        _a = wa ? vc(n.stateNode.nextSibling) : null;
    return !0
}
function eD() {
    for (var n = _a; n; )
        n = vc(n.nextSibling)
}
function ch() {
    _a = wa = null,
    Ai = !1
}
function oS(n) {
    _l === null ? _l = [n] : _l.push(n)
}
var xI = Pu.ReactCurrentBatchConfig;
function hl(n, e) {
    if (n && n.defaultProps) {
        e = Oi({}, e),
        n = n.defaultProps;
        for (var t in n)
            e[t] === void 0 && (e[t] = n[t]);
        return e
    }
    return e
}
var Rv = Lc(null)
  , Bv = null
  , Ud = null
  , aS = null;
function lS() {
    aS = Ud = Bv = null
}
function uS(n) {
    var e = Rv.current;
    vi(Rv),
    n._currentValue = e
}
function v1(n, e, t) {
    for (; n !== null; ) {
        var r = n.alternate;
        if ((n.childLanes & e) !== e ? (n.childLanes |= e,
        r !== null && (r.childLanes |= e)) : r !== null && (r.childLanes & e) !== e && (r.childLanes |= e),
        n === t)
            break;
        n = n.return
    }
}
function nh(n, e) {
    Bv = n,
    aS = Ud = null,
    n = n.dependencies,
    n !== null && n.firstContext !== null && (n.lanes & e && (qo = !0),
    n.firstContext = null)
}
function Qa(n) {
    var e = n._currentValue;
    if (aS !== n)
        if (n = {
            context: n,
            memoizedValue: e,
            next: null
        },
        Ud === null) {
            if (Bv === null)
                throw Error(mt(308));
            Ud = n,
            Bv.dependencies = {
                lanes: 0,
                firstContext: n
            }
        } else
            Ud = Ud.next = n;
    return e
}
var vf = null;
function cS(n) {
    vf === null ? vf = [n] : vf.push(n)
}
function tD(n, e, t, r) {
    var i = e.interleaved;
    return i === null ? (t.next = t,
    cS(e)) : (t.next = i.next,
    i.next = t),
    e.interleaved = t,
    Eu(n, r)
}
function Eu(n, e) {
    n.lanes |= e;
    var t = n.alternate;
    for (t !== null && (t.lanes |= e),
    t = n,
    n = n.return; n !== null; )
        n.childLanes |= e,
        t = n.alternate,
        t !== null && (t.childLanes |= e),
        t = n,
        n = n.return;
    return t.tag === 3 ? t.stateNode : null
}
var nc = !1;
function fS(n) {
    n.updateQueue = {
        baseState: n.memoizedState,
        firstBaseUpdate: null,
        lastBaseUpdate: null,
        shared: {
            pending: null,
            interleaved: null,
            lanes: 0
        },
        effects: null
    }
}
function nD(n, e) {
    n = n.updateQueue,
    e.updateQueue === n && (e.updateQueue = {
        baseState: n.baseState,
        firstBaseUpdate: n.firstBaseUpdate,
        lastBaseUpdate: n.lastBaseUpdate,
        shared: n.shared,
        effects: n.effects
    })
}
function wu(n, e) {
    return {
        eventTime: n,
        lane: e,
        tag: 0,
        payload: null,
        callback: null,
        next: null
    }
}
function _c(n, e, t) {
    var r = n.updateQueue;
    if (r === null)
        return null;
    if (r = r.shared,
    xr & 2) {
        var i = r.pending;
        return i === null ? e.next = e : (e.next = i.next,
        i.next = e),
        r.pending = e,
        Eu(n, t)
    }
    return i = r.interleaved,
    i === null ? (e.next = e,
    cS(r)) : (e.next = i.next,
    i.next = e),
    r.interleaved = e,
    Eu(n, t)
}
function Y0(n, e, t) {
    if (e = e.updateQueue,
    e !== null && (e = e.shared,
    (t & 4194240) !== 0)) {
        var r = e.lanes;
        r &= n.pendingLanes,
        t |= r,
        e.lanes = t,
        qw(n, t)
    }
}
function qA(n, e) {
    var t = n.updateQueue
      , r = n.alternate;
    if (r !== null && (r = r.updateQueue,
    t === r)) {
        var i = null
          , s = null;
        if (t = t.firstBaseUpdate,
        t !== null) {
            do {
                var o = {
                    eventTime: t.eventTime,
                    lane: t.lane,
                    tag: t.tag,
                    payload: t.payload,
                    callback: t.callback,
                    next: null
                };
                s === null ? i = s = o : s = s.next = o,
                t = t.next
            } while (t !== null);
            s === null ? i = s = e : s = s.next = e
        } else
            i = s = e;
        t = {
            baseState: r.baseState,
            firstBaseUpdate: i,
            lastBaseUpdate: s,
            shared: r.shared,
            effects: r.effects
        },
        n.updateQueue = t;
        return
    }
    n = t.lastBaseUpdate,
    n === null ? t.firstBaseUpdate = e : n.next = e,
    t.lastBaseUpdate = e
}
function Iv(n, e, t, r) {
    var i = n.updateQueue;
    nc = !1;
    var s = i.firstBaseUpdate
      , o = i.lastBaseUpdate
      , a = i.shared.pending;
    if (a !== null) {
        i.shared.pending = null;
        var l = a
          , f = l.next;
        l.next = null,
        o === null ? s = f : o.next = f,
        o = l;
        var h = n.alternate;
        h !== null && (h = h.updateQueue,
        a = h.lastBaseUpdate,
        a !== o && (a === null ? h.firstBaseUpdate = f : a.next = f,
        h.lastBaseUpdate = l))
    }
    if (s !== null) {
        var d = i.baseState;
        o = 0,
        h = f = l = null,
        a = s;
        do {
            var p = a.lane
              , m = a.eventTime;
            if ((r & p) === p) {
                h !== null && (h = h.next = {
                    eventTime: m,
                    lane: 0,
                    tag: a.tag,
                    payload: a.payload,
                    callback: a.callback,
                    next: null
                });
                e: {
                    var _ = n
                      , y = a;
                    switch (p = e,
                    m = t,
                    y.tag) {
                    case 1:
                        if (_ = y.payload,
                        typeof _ == "function") {
                            d = _.call(m, d, p);
                            break e
                        }
                        d = _;
                        break e;
                    case 3:
                        _.flags = _.flags & -65537 | 128;
                    case 0:
                        if (_ = y.payload,
                        p = typeof _ == "function" ? _.call(m, d, p) : _,
                        p == null)
                            break e;
                        d = Oi({}, d, p);
                        break e;
                    case 2:
                        nc = !0
                    }
                }
                a.callback !== null && a.lane !== 0 && (n.flags |= 64,
                p = i.effects,
                p === null ? i.effects = [a] : p.push(a))
            } else
                m = {
                    eventTime: m,
                    lane: p,
                    tag: a.tag,
                    payload: a.payload,
                    callback: a.callback,
                    next: null
                },
                h === null ? (f = h = m,
                l = d) : h = h.next = m,
                o |= p;
            if (a = a.next,
            a === null) {
                if (a = i.shared.pending,
                a === null)
                    break;
                p = a,
                a = p.next,
                p.next = null,
                i.lastBaseUpdate = p,
                i.shared.pending = null
            }
        } while (1);
        if (h === null && (l = d),
        i.baseState = l,
        i.firstBaseUpdate = f,
        i.lastBaseUpdate = h,
        e = i.shared.interleaved,
        e !== null) {
            i = e;
            do
                o |= i.lane,
                i = i.next;
            while (i !== e)
        } else
            s === null && (i.shared.lanes = 0);
        zf |= o,
        n.lanes = o,
        n.memoizedState = d
    }
}
function QA(n, e, t) {
    if (n = e.effects,
    e.effects = null,
    n !== null)
        for (e = 0; e < n.length; e++) {
            var r = n[e]
              , i = r.callback;
            if (i !== null) {
                if (r.callback = null,
                r = t,
                typeof i != "function")
                    throw Error(mt(191, i));
                i.call(r)
            }
        }
}
var rD = new tT.Component().refs;
function _1(n, e, t, r) {
    e = n.memoizedState,
    t = t(r, e),
    t = t == null ? e : Oi({}, e, t),
    n.memoizedState = t,
    n.lanes === 0 && (n.updateQueue.baseState = t)
}
var s_ = {
    isMounted: function(n) {
        return (n = n._reactInternals) ? Qf(n) === n : !1
    },
    enqueueSetState: function(n, e, t) {
        n = n._reactInternals;
        var r = To()
          , i = xc(n)
          , s = wu(r, i);
        s.payload = e,
        t != null && (s.callback = t),
        e = _c(n, s, i),
        e !== null && (Al(e, n, i, r),
        Y0(e, n, i))
    },
    enqueueReplaceState: function(n, e, t) {
        n = n._reactInternals;
        var r = To()
          , i = xc(n)
          , s = wu(r, i);
        s.tag = 1,
        s.payload = e,
        t != null && (s.callback = t),
        e = _c(n, s, i),
        e !== null && (Al(e, n, i, r),
        Y0(e, n, i))
    },
    enqueueForceUpdate: function(n, e) {
        n = n._reactInternals;
        var t = To()
          , r = xc(n)
          , i = wu(t, r);
        i.tag = 2,
        e != null && (i.callback = e),
        e = _c(n, i, r),
        e !== null && (Al(e, n, r, t),
        Y0(e, n, r))
    }
};
function ZA(n, e, t, r, i, s, o) {
    return n = n.stateNode,
    typeof n.shouldComponentUpdate == "function" ? n.shouldComponentUpdate(r, s, o) : e.prototype && e.prototype.isPureReactComponent ? !rm(t, r) || !rm(i, s) : !0
}
function iD(n, e, t) {
    var r = !1
      , i = Cc
      , s = e.contextType;
    return typeof s == "object" && s !== null ? s = Qa(s) : (i = Zo(e) ? kf : ao.current,
    r = e.contextTypes,
    s = (r = r != null) ? uh(n, i) : Cc),
    e = new e(t,s),
    n.memoizedState = e.state !== null && e.state !== void 0 ? e.state : null,
    e.updater = s_,
    n.stateNode = e,
    e._reactInternals = n,
    r && (n = n.stateNode,
    n.__reactInternalMemoizedUnmaskedChildContext = i,
    n.__reactInternalMemoizedMaskedChildContext = s),
    e
}
function $A(n, e, t, r) {
    n = e.state,
    typeof e.componentWillReceiveProps == "function" && e.componentWillReceiveProps(t, r),
    typeof e.UNSAFE_componentWillReceiveProps == "function" && e.UNSAFE_componentWillReceiveProps(t, r),
    e.state !== n && s_.enqueueReplaceState(e, e.state, null)
}
function y1(n, e, t, r) {
    var i = n.stateNode;
    i.props = t,
    i.state = n.memoizedState,
    i.refs = rD,
    fS(n);
    var s = e.contextType;
    typeof s == "object" && s !== null ? i.context = Qa(s) : (s = Zo(e) ? kf : ao.current,
    i.context = uh(n, s)),
    i.state = n.memoizedState,
    s = e.getDerivedStateFromProps,
    typeof s == "function" && (_1(n, e, s, t),
    i.state = n.memoizedState),
    typeof e.getDerivedStateFromProps == "function" || typeof i.getSnapshotBeforeUpdate == "function" || typeof i.UNSAFE_componentWillMount != "function" && typeof i.componentWillMount != "function" || (e = i.state,
    typeof i.componentWillMount == "function" && i.componentWillMount(),
    typeof i.UNSAFE_componentWillMount == "function" && i.UNSAFE_componentWillMount(),
    e !== i.state && s_.enqueueReplaceState(i, i.state, null),
    Iv(n, t, i, r),
    i.state = n.memoizedState),
    typeof i.componentDidMount == "function" && (n.flags |= 4194308)
}
function Kh(n, e, t) {
    if (n = t.ref,
    n !== null && typeof n != "function" && typeof n != "object") {
        if (t._owner) {
            if (t = t._owner,
            t) {
                if (t.tag !== 1)
                    throw Error(mt(309));
                var r = t.stateNode
            }
            if (!r)
                throw Error(mt(147, n));
            var i = r
              , s = "" + n;
            return e !== null && e.ref !== null && typeof e.ref == "function" && e.ref._stringRef === s ? e.ref : (e = function(o) {
                var a = i.refs;
                a === rD && (a = i.refs = {}),
                o === null ? delete a[s] : a[s] = o
            }
            ,
            e._stringRef = s,
            e)
        }
        if (typeof n != "string")
            throw Error(mt(284));
        if (!t._owner)
            throw Error(mt(290, n))
    }
    return n
}
function Rg(n, e) {
    throw n = Object.prototype.toString.call(e),
    Error(mt(31, n === "[object Object]" ? "object with keys {" + Object.keys(e).join(", ") + "}" : n))
}
function eC(n) {
    var e = n._init;
    return e(n._payload)
}
function sD(n) {
    function e(S, M) {
        if (n) {
            var w = S.deletions;
            w === null ? (S.deletions = [M],
            S.flags |= 16) : w.push(M)
        }
    }
    function t(S, M) {
        if (!n)
            return null;
        for (; M !== null; )
            e(S, M),
            M = M.sibling;
        return null
    }
    function r(S, M) {
        for (S = new Map; M !== null; )
            M.key !== null ? S.set(M.key, M) : S.set(M.index, M),
            M = M.sibling;
        return S
    }
    function i(S, M) {
        return S = wc(S, M),
        S.index = 0,
        S.sibling = null,
        S
    }
    function s(S, M, w) {
        return S.index = w,
        n ? (w = S.alternate,
        w !== null ? (w = w.index,
        w < M ? (S.flags |= 2,
        M) : w) : (S.flags |= 2,
        M)) : (S.flags |= 1048576,
        M)
    }
    function o(S) {
        return n && S.alternate === null && (S.flags |= 2),
        S
    }
    function a(S, M, w, T) {
        return M === null || M.tag !== 6 ? (M = Iy(w, S.mode, T),
        M.return = S,
        M) : (M = i(M, w),
        M.return = S,
        M)
    }
    function l(S, M, w, T) {
        var P = w.type;
        return P === Id ? h(S, M, w.props.children, T, w.key) : M !== null && (M.elementType === P || typeof P == "object" && P !== null && P.$$typeof === tc && eC(P) === M.type) ? (T = i(M, w.props),
        T.ref = Kh(S, M, w),
        T.return = S,
        T) : (T = ev(w.type, w.key, w.props, null, S.mode, T),
        T.ref = Kh(S, M, w),
        T.return = S,
        T)
    }
    function f(S, M, w, T) {
        return M === null || M.tag !== 4 || M.stateNode.containerInfo !== w.containerInfo || M.stateNode.implementation !== w.implementation ? (M = Ly(w, S.mode, T),
        M.return = S,
        M) : (M = i(M, w.children || []),
        M.return = S,
        M)
    }
    function h(S, M, w, T, P) {
        return M === null || M.tag !== 7 ? (M = Ef(w, S.mode, T, P),
        M.return = S,
        M) : (M = i(M, w),
        M.return = S,
        M)
    }
    function d(S, M, w) {
        if (typeof M == "string" && M !== "" || typeof M == "number")
            return M = Iy("" + M, S.mode, w),
            M.return = S,
            M;
        if (typeof M == "object" && M !== null) {
            switch (M.$$typeof) {
            case xg:
                return w = ev(M.type, M.key, M.props, null, S.mode, w),
                w.ref = Kh(S, null, M),
                w.return = S,
                w;
            case Bd:
                return M = Ly(M, S.mode, w),
                M.return = S,
                M;
            case tc:
                var T = M._init;
                return d(S, T(M._payload), w)
            }
            if (xp(M) || Wh(M))
                return M = Ef(M, S.mode, w, null),
                M.return = S,
                M;
            Rg(S, M)
        }
        return null
    }
    function p(S, M, w, T) {
        var P = M !== null ? M.key : null;
        if (typeof w == "string" && w !== "" || typeof w == "number")
            return P !== null ? null : a(S, M, "" + w, T);
        if (typeof w == "object" && w !== null) {
            switch (w.$$typeof) {
            case xg:
                return w.key === P ? l(S, M, w, T) : null;
            case Bd:
                return w.key === P ? f(S, M, w, T) : null;
            case tc:
                return P = w._init,
                p(S, M, P(w._payload), T)
            }
            if (xp(w) || Wh(w))
                return P !== null ? null : h(S, M, w, T, null);
            Rg(S, w)
        }
        return null
    }
    function m(S, M, w, T, P) {
        if (typeof T == "string" && T !== "" || typeof T == "number")
            return S = S.get(w) || null,
            a(M, S, "" + T, P);
        if (typeof T == "object" && T !== null) {
            switch (T.$$typeof) {
            case xg:
                return S = S.get(T.key === null ? w : T.key) || null,
                l(M, S, T, P);
            case Bd:
                return S = S.get(T.key === null ? w : T.key) || null,
                f(M, S, T, P);
            case tc:
                var I = T._init;
                return m(S, M, w, I(T._payload), P)
            }
            if (xp(T) || Wh(T))
                return S = S.get(w) || null,
                h(M, S, T, P, null);
            Rg(M, T)
        }
        return null
    }
    function _(S, M, w, T) {
        for (var P = null, I = null, k = M, R = M = 0, O = null; k !== null && R < w.length; R++) {
            k.index > R ? (O = k,
            k = null) : O = k.sibling;
            var H = p(S, k, w[R], T);
            if (H === null) {
                k === null && (k = O);
                break
            }
            n && k && H.alternate === null && e(S, k),
            M = s(H, M, R),
            I === null ? P = H : I.sibling = H,
            I = H,
            k = O
        }
        if (R === w.length)
            return t(S, k),
            Ai && of(S, R),
            P;
        if (k === null) {
            for (; R < w.length; R++)
                k = d(S, w[R], T),
                k !== null && (M = s(k, M, R),
                I === null ? P = k : I.sibling = k,
                I = k);
            return Ai && of(S, R),
            P
        }
        for (k = r(S, k); R < w.length; R++)
            O = m(k, S, R, w[R], T),
            O !== null && (n && O.alternate !== null && k.delete(O.key === null ? R : O.key),
            M = s(O, M, R),
            I === null ? P = O : I.sibling = O,
            I = O);
        return n && k.forEach(function(W) {
            return e(S, W)
        }),
        Ai && of(S, R),
        P
    }
    function y(S, M, w, T) {
        var P = Wh(w);
        if (typeof P != "function")
            throw Error(mt(150));
        if (w = P.call(w),
        w == null)
            throw Error(mt(151));
        for (var I = P = null, k = M, R = M = 0, O = null, H = w.next(); k !== null && !H.done; R++,
        H = w.next()) {
            k.index > R ? (O = k,
            k = null) : O = k.sibling;
            var W = p(S, k, H.value, T);
            if (W === null) {
                k === null && (k = O);
                break
            }
            n && k && W.alternate === null && e(S, k),
            M = s(W, M, R),
            I === null ? P = W : I.sibling = W,
            I = W,
            k = O
        }
        if (H.done)
            return t(S, k),
            Ai && of(S, R),
            P;
        if (k === null) {
            for (; !H.done; R++,
            H = w.next())
                H = d(S, H.value, T),
                H !== null && (M = s(H, M, R),
                I === null ? P = H : I.sibling = H,
                I = H);
            return Ai && of(S, R),
            P
        }
        for (k = r(S, k); !H.done; R++,
        H = w.next())
            H = m(k, S, R, H.value, T),
            H !== null && (n && H.alternate !== null && k.delete(H.key === null ? R : H.key),
            M = s(H, M, R),
            I === null ? P = H : I.sibling = H,
            I = H);
        return n && k.forEach(function(te) {
            return e(S, te)
        }),
        Ai && of(S, R),
        P
    }
    function x(S, M, w, T) {
        if (typeof w == "object" && w !== null && w.type === Id && w.key === null && (w = w.props.children),
        typeof w == "object" && w !== null) {
            switch (w.$$typeof) {
            case xg:
                e: {
                    for (var P = w.key, I = M; I !== null; ) {
                        if (I.key === P) {
                            if (P = w.type,
                            P === Id) {
                                if (I.tag === 7) {
                                    t(S, I.sibling),
                                    M = i(I, w.props.children),
                                    M.return = S,
                                    S = M;
                                    break e
                                }
                            } else if (I.elementType === P || typeof P == "object" && P !== null && P.$$typeof === tc && eC(P) === I.type) {
                                t(S, I.sibling),
                                M = i(I, w.props),
                                M.ref = Kh(S, I, w),
                                M.return = S,
                                S = M;
                                break e
                            }
                            t(S, I);
                            break
                        } else
                            e(S, I);
                        I = I.sibling
                    }
                    w.type === Id ? (M = Ef(w.props.children, S.mode, T, w.key),
                    M.return = S,
                    S = M) : (T = ev(w.type, w.key, w.props, null, S.mode, T),
                    T.ref = Kh(S, M, w),
                    T.return = S,
                    S = T)
                }
                return o(S);
            case Bd:
                e: {
                    for (I = w.key; M !== null; ) {
                        if (M.key === I)
                            if (M.tag === 4 && M.stateNode.containerInfo === w.containerInfo && M.stateNode.implementation === w.implementation) {
                                t(S, M.sibling),
                                M = i(M, w.children || []),
                                M.return = S,
                                S = M;
                                break e
                            } else {
                                t(S, M);
                                break
                            }
                        else
                            e(S, M);
                        M = M.sibling
                    }
                    M = Ly(w, S.mode, T),
                    M.return = S,
                    S = M
                }
                return o(S);
            case tc:
                return I = w._init,
                x(S, M, I(w._payload), T)
            }
            if (xp(w))
                return _(S, M, w, T);
            if (Wh(w))
                return y(S, M, w, T);
            Rg(S, w)
        }
        return typeof w == "string" && w !== "" || typeof w == "number" ? (w = "" + w,
        M !== null && M.tag === 6 ? (t(S, M.sibling),
        M = i(M, w),
        M.return = S,
        S = M) : (t(S, M),
        M = Iy(w, S.mode, T),
        M.return = S,
        S = M),
        o(S)) : t(S, M)
    }
    return x
}
var fh = sD(!0)
  , oD = sD(!1)
  , Im = {}
  , Xl = Lc(Im)
  , am = Lc(Im)
  , lm = Lc(Im);
function _f(n) {
    if (n === Im)
        throw Error(mt(174));
    return n
}
function dS(n, e) {
    switch (fi(lm, e),
    fi(am, n),
    fi(Xl, Im),
    n = e.nodeType,
    n) {
    case 9:
    case 11:
        e = (e = e.documentElement) ? e.namespaceURI : Qx(null, "");
        break;
    default:
        n = n === 8 ? e.parentNode : e,
        e = n.namespaceURI || null,
        n = n.tagName,
        e = Qx(e, n)
    }
    vi(Xl),
    fi(Xl, e)
}
function dh() {
    vi(Xl),
    vi(am),
    vi(lm)
}
function aD(n) {
    _f(lm.current);
    var e = _f(Xl.current)
      , t = Qx(e, n.type);
    e !== t && (fi(am, n),
    fi(Xl, t))
}
function hS(n) {
    am.current === n && (vi(Xl),
    vi(am))
}
var Li = Lc(0);
function Lv(n) {
    for (var e = n; e !== null; ) {
        if (e.tag === 13) {
            var t = e.memoizedState;
            if (t !== null && (t = t.dehydrated,
            t === null || t.data === "$?" || t.data === "$!"))
                return e
        } else if (e.tag === 19 && e.memoizedProps.revealOrder !== void 0) {
            if (e.flags & 128)
                return e
        } else if (e.child !== null) {
            e.child.return = e,
            e = e.child;
            continue
        }
        if (e === n)
            break;
        for (; e.sibling === null; ) {
            if (e.return === null || e.return === n)
                return null;
            e = e.return
        }
        e.sibling.return = e.return,
        e = e.sibling
    }
    return null
}
var by = [];
function pS() {
    for (var n = 0; n < by.length; n++)
        by[n]._workInProgressVersionPrimary = null;
    by.length = 0
}
var K0 = Pu.ReactCurrentDispatcher
  , Ty = Pu.ReactCurrentBatchConfig
  , Nf = 0
  , ki = null
  , ps = null
  , Ps = null
  , Fv = !1
  , Lp = !1
  , um = 0
  , wI = 0;
function eo() {
    throw Error(mt(321))
}
function mS(n, e) {
    if (e === null)
        return !1;
    for (var t = 0; t < e.length && t < n.length; t++)
        if (!Cl(n[t], e[t]))
            return !1;
    return !0
}
function gS(n, e, t, r, i, s) {
    if (Nf = s,
    ki = e,
    e.memoizedState = null,
    e.updateQueue = null,
    e.lanes = 0,
    K0.current = n === null || n.memoizedState === null ? CI : EI,
    n = t(r, i),
    Lp) {
        s = 0;
        do {
            if (Lp = !1,
            um = 0,
            25 <= s)
                throw Error(mt(301));
            s += 1,
            Ps = ps = null,
            e.updateQueue = null,
            K0.current = bI,
            n = t(r, i)
        } while (Lp)
    }
    if (K0.current = kv,
    e = ps !== null && ps.next !== null,
    Nf = 0,
    Ps = ps = ki = null,
    Fv = !1,
    e)
        throw Error(mt(300));
    return n
}
function vS() {
    var n = um !== 0;
    return um = 0,
    n
}
function Gl() {
    var n = {
        memoizedState: null,
        baseState: null,
        baseQueue: null,
        queue: null,
        next: null
    };
    return Ps === null ? ki.memoizedState = Ps = n : Ps = Ps.next = n,
    Ps
}
function Za() {
    if (ps === null) {
        var n = ki.alternate;
        n = n !== null ? n.memoizedState : null
    } else
        n = ps.next;
    var e = Ps === null ? ki.memoizedState : Ps.next;
    if (e !== null)
        Ps = e,
        ps = n;
    else {
        if (n === null)
            throw Error(mt(310));
        ps = n,
        n = {
            memoizedState: ps.memoizedState,
            baseState: ps.baseState,
            baseQueue: ps.baseQueue,
            queue: ps.queue,
            next: null
        },
        Ps === null ? ki.memoizedState = Ps = n : Ps = Ps.next = n
    }
    return Ps
}
function cm(n, e) {
    return typeof e == "function" ? e(n) : e
}
function Dy(n) {
    var e = Za()
      , t = e.queue;
    if (t === null)
        throw Error(mt(311));
    t.lastRenderedReducer = n;
    var r = ps
      , i = r.baseQueue
      , s = t.pending;
    if (s !== null) {
        if (i !== null) {
            var o = i.next;
            i.next = s.next,
            s.next = o
        }
        r.baseQueue = i = s,
        t.pending = null
    }
    if (i !== null) {
        s = i.next,
        r = r.baseState;
        var a = o = null
          , l = null
          , f = s;
        do {
            var h = f.lane;
            if ((Nf & h) === h)
                l !== null && (l = l.next = {
                    lane: 0,
                    action: f.action,
                    hasEagerState: f.hasEagerState,
                    eagerState: f.eagerState,
                    next: null
                }),
                r = f.hasEagerState ? f.eagerState : n(r, f.action);
            else {
                var d = {
                    lane: h,
                    action: f.action,
                    hasEagerState: f.hasEagerState,
                    eagerState: f.eagerState,
                    next: null
                };
                l === null ? (a = l = d,
                o = r) : l = l.next = d,
                ki.lanes |= h,
                zf |= h
            }
            f = f.next
        } while (f !== null && f !== s);
        l === null ? o = r : l.next = a,
        Cl(r, e.memoizedState) || (qo = !0),
        e.memoizedState = r,
        e.baseState = o,
        e.baseQueue = l,
        t.lastRenderedState = r
    }
    if (n = t.interleaved,
    n !== null) {
        i = n;
        do
            s = i.lane,
            ki.lanes |= s,
            zf |= s,
            i = i.next;
        while (i !== n)
    } else
        i === null && (t.lanes = 0);
    return [e.memoizedState, t.dispatch]
}
function Py(n) {
    var e = Za()
      , t = e.queue;
    if (t === null)
        throw Error(mt(311));
    t.lastRenderedReducer = n;
    var r = t.dispatch
      , i = t.pending
      , s = e.memoizedState;
    if (i !== null) {
        t.pending = null;
        var o = i = i.next;
        do
            s = n(s, o.action),
            o = o.next;
        while (o !== i);
        Cl(s, e.memoizedState) || (qo = !0),
        e.memoizedState = s,
        e.baseQueue === null && (e.baseState = s),
        t.lastRenderedState = s
    }
    return [s, r]
}
function lD() {}
function uD(n, e) {
    var t = ki
      , r = Za()
      , i = e()
      , s = !Cl(r.memoizedState, i);
    if (s && (r.memoizedState = i,
    qo = !0),
    r = r.queue,
    _S(dD.bind(null, t, r, n), [n]),
    r.getSnapshot !== e || s || Ps !== null && Ps.memoizedState.tag & 1) {
        if (t.flags |= 2048,
        fm(9, fD.bind(null, t, r, i, e), void 0, null),
        Rs === null)
            throw Error(mt(349));
        Nf & 30 || cD(t, e, i)
    }
    return i
}
function cD(n, e, t) {
    n.flags |= 16384,
    n = {
        getSnapshot: e,
        value: t
    },
    e = ki.updateQueue,
    e === null ? (e = {
        lastEffect: null,
        stores: null
    },
    ki.updateQueue = e,
    e.stores = [n]) : (t = e.stores,
    t === null ? e.stores = [n] : t.push(n))
}
function fD(n, e, t, r) {
    e.value = t,
    e.getSnapshot = r,
    hD(e) && pD(n)
}
function dD(n, e, t) {
    return t(function() {
        hD(e) && pD(n)
    })
}
function hD(n) {
    var e = n.getSnapshot;
    n = n.value;
    try {
        var t = e();
        return !Cl(n, t)
    } catch {
        return !0
    }
}
function pD(n) {
    var e = Eu(n, 1);
    e !== null && Al(e, n, 1, -1)
}
function tC(n) {
    var e = Gl();
    return typeof n == "function" && (n = n()),
    e.memoizedState = e.baseState = n,
    n = {
        pending: null,
        interleaved: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: cm,
        lastRenderedState: n
    },
    e.queue = n,
    n = n.dispatch = AI.bind(null, ki, n),
    [e.memoizedState, n]
}
function fm(n, e, t, r) {
    return n = {
        tag: n,
        create: e,
        destroy: t,
        deps: r,
        next: null
    },
    e = ki.updateQueue,
    e === null ? (e = {
        lastEffect: null,
        stores: null
    },
    ki.updateQueue = e,
    e.lastEffect = n.next = n) : (t = e.lastEffect,
    t === null ? e.lastEffect = n.next = n : (r = t.next,
    t.next = n,
    n.next = r,
    e.lastEffect = n)),
    n
}
function mD() {
    return Za().memoizedState
}
function q0(n, e, t, r) {
    var i = Gl();
    ki.flags |= n,
    i.memoizedState = fm(1 | e, t, void 0, r === void 0 ? null : r)
}
function o_(n, e, t, r) {
    var i = Za();
    r = r === void 0 ? null : r;
    var s = void 0;
    if (ps !== null) {
        var o = ps.memoizedState;
        if (s = o.destroy,
        r !== null && mS(r, o.deps)) {
            i.memoizedState = fm(e, t, s, r);
            return
        }
    }
    ki.flags |= n,
    i.memoizedState = fm(1 | e, t, s, r)
}
function nC(n, e) {
    return q0(8390656, 8, n, e)
}
function _S(n, e) {
    return o_(2048, 8, n, e)
}
function gD(n, e) {
    return o_(4, 2, n, e)
}
function vD(n, e) {
    return o_(4, 4, n, e)
}
function _D(n, e) {
    if (typeof e == "function")
        return n = n(),
        e(n),
        function() {
            e(null)
        }
        ;
    if (e != null)
        return n = n(),
        e.current = n,
        function() {
            e.current = null
        }
}
function yD(n, e, t) {
    return t = t != null ? t.concat([n]) : null,
    o_(4, 4, _D.bind(null, e, n), t)
}
function yS() {}
function xD(n, e) {
    var t = Za();
    e = e === void 0 ? null : e;
    var r = t.memoizedState;
    return r !== null && e !== null && mS(e, r[1]) ? r[0] : (t.memoizedState = [n, e],
    n)
}
function wD(n, e) {
    var t = Za();
    e = e === void 0 ? null : e;
    var r = t.memoizedState;
    return r !== null && e !== null && mS(e, r[1]) ? r[0] : (n = n(),
    t.memoizedState = [n, e],
    n)
}
function SD(n, e, t) {
    return Nf & 21 ? (Cl(t, e) || (t = CT(),
    ki.lanes |= t,
    zf |= t,
    n.baseState = !0),
    e) : (n.baseState && (n.baseState = !1,
    qo = !0),
    n.memoizedState = t)
}
function SI(n, e) {
    var t = Gr;
    Gr = t !== 0 && 4 > t ? t : 4,
    n(!0);
    var r = Ty.transition;
    Ty.transition = {};
    try {
        n(!1),
        e()
    } finally {
        Gr = t,
        Ty.transition = r
    }
}
function MD() {
    return Za().memoizedState
}
function MI(n, e, t) {
    var r = xc(n);
    if (t = {
        lane: r,
        action: t,
        hasEagerState: !1,
        eagerState: null,
        next: null
    },
    AD(n))
        CD(e, t);
    else if (t = tD(n, e, t, r),
    t !== null) {
        var i = To();
        Al(t, n, r, i),
        ED(t, e, r)
    }
}
function AI(n, e, t) {
    var r = xc(n)
      , i = {
        lane: r,
        action: t,
        hasEagerState: !1,
        eagerState: null,
        next: null
    };
    if (AD(n))
        CD(e, i);
    else {
        var s = n.alternate;
        if (n.lanes === 0 && (s === null || s.lanes === 0) && (s = e.lastRenderedReducer,
        s !== null))
            try {
                var o = e.lastRenderedState
                  , a = s(o, t);
                if (i.hasEagerState = !0,
                i.eagerState = a,
                Cl(a, o)) {
                    var l = e.interleaved;
                    l === null ? (i.next = i,
                    cS(e)) : (i.next = l.next,
                    l.next = i),
                    e.interleaved = i;
                    return
                }
            } catch {} finally {}
        t = tD(n, e, i, r),
        t !== null && (i = To(),
        Al(t, n, r, i),
        ED(t, e, r))
    }
}
function AD(n) {
    var e = n.alternate;
    return n === ki || e !== null && e === ki
}
function CD(n, e) {
    Lp = Fv = !0;
    var t = n.pending;
    t === null ? e.next = e : (e.next = t.next,
    t.next = e),
    n.pending = e
}
function ED(n, e, t) {
    if (t & 4194240) {
        var r = e.lanes;
        r &= n.pendingLanes,
        t |= r,
        e.lanes = t,
        qw(n, t)
    }
}
var kv = {
    readContext: Qa,
    useCallback: eo,
    useContext: eo,
    useEffect: eo,
    useImperativeHandle: eo,
    useInsertionEffect: eo,
    useLayoutEffect: eo,
    useMemo: eo,
    useReducer: eo,
    useRef: eo,
    useState: eo,
    useDebugValue: eo,
    useDeferredValue: eo,
    useTransition: eo,
    useMutableSource: eo,
    useSyncExternalStore: eo,
    useId: eo,
    unstable_isNewReconciler: !1
}
  , CI = {
    readContext: Qa,
    useCallback: function(n, e) {
        return Gl().memoizedState = [n, e === void 0 ? null : e],
        n
    },
    useContext: Qa,
    useEffect: nC,
    useImperativeHandle: function(n, e, t) {
        return t = t != null ? t.concat([n]) : null,
        q0(4194308, 4, _D.bind(null, e, n), t)
    },
    useLayoutEffect: function(n, e) {
        return q0(4194308, 4, n, e)
    },
    useInsertionEffect: function(n, e) {
        return q0(4, 2, n, e)
    },
    useMemo: function(n, e) {
        var t = Gl();
        return e = e === void 0 ? null : e,
        n = n(),
        t.memoizedState = [n, e],
        n
    },
    useReducer: function(n, e, t) {
        var r = Gl();
        return e = t !== void 0 ? t(e) : e,
        r.memoizedState = r.baseState = e,
        n = {
            pending: null,
            interleaved: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: n,
            lastRenderedState: e
        },
        r.queue = n,
        n = n.dispatch = MI.bind(null, ki, n),
        [r.memoizedState, n]
    },
    useRef: function(n) {
        var e = Gl();
        return n = {
            current: n
        },
        e.memoizedState = n
    },
    useState: tC,
    useDebugValue: yS,
    useDeferredValue: function(n) {
        return Gl().memoizedState = n
    },
    useTransition: function() {
        var n = tC(!1)
          , e = n[0];
        return n = SI.bind(null, n[1]),
        Gl().memoizedState = n,
        [e, n]
    },
    useMutableSource: function() {},
    useSyncExternalStore: function(n, e, t) {
        var r = ki
          , i = Gl();
        if (Ai) {
            if (t === void 0)
                throw Error(mt(407));
            t = t()
        } else {
            if (t = e(),
            Rs === null)
                throw Error(mt(349));
            Nf & 30 || cD(r, e, t)
        }
        i.memoizedState = t;
        var s = {
            value: t,
            getSnapshot: e
        };
        return i.queue = s,
        nC(dD.bind(null, r, s, n), [n]),
        r.flags |= 2048,
        fm(9, fD.bind(null, r, s, t, e), void 0, null),
        t
    },
    useId: function() {
        var n = Gl()
          , e = Rs.identifierPrefix;
        if (Ai) {
            var t = gu
              , r = mu;
            t = (r & ~(1 << 32 - Ml(r) - 1)).toString(32) + t,
            e = ":" + e + "R" + t,
            t = um++,
            0 < t && (e += "H" + t.toString(32)),
            e += ":"
        } else
            t = wI++,
            e = ":" + e + "r" + t.toString(32) + ":";
        return n.memoizedState = e
    },
    unstable_isNewReconciler: !1
}
  , EI = {
    readContext: Qa,
    useCallback: xD,
    useContext: Qa,
    useEffect: _S,
    useImperativeHandle: yD,
    useInsertionEffect: gD,
    useLayoutEffect: vD,
    useMemo: wD,
    useReducer: Dy,
    useRef: mD,
    useState: function() {
        return Dy(cm)
    },
    useDebugValue: yS,
    useDeferredValue: function(n) {
        var e = Za();
        return SD(e, ps.memoizedState, n)
    },
    useTransition: function() {
        var n = Dy(cm)[0]
          , e = Za().memoizedState;
        return [n, e]
    },
    useMutableSource: lD,
    useSyncExternalStore: uD,
    useId: MD,
    unstable_isNewReconciler: !1
}
  , bI = {
    readContext: Qa,
    useCallback: xD,
    useContext: Qa,
    useEffect: _S,
    useImperativeHandle: yD,
    useInsertionEffect: gD,
    useLayoutEffect: vD,
    useMemo: wD,
    useReducer: Py,
    useRef: mD,
    useState: function() {
        return Py(cm)
    },
    useDebugValue: yS,
    useDeferredValue: function(n) {
        var e = Za();
        return ps === null ? e.memoizedState = n : SD(e, ps.memoizedState, n)
    },
    useTransition: function() {
        var n = Py(cm)[0]
          , e = Za().memoizedState;
        return [n, e]
    },
    useMutableSource: lD,
    useSyncExternalStore: uD,
    useId: MD,
    unstable_isNewReconciler: !1
};
function hh(n, e) {
    try {
        var t = ""
          , r = e;
        do
            t += tB(r),
            r = r.return;
        while (r);
        var i = t
    } catch (s) {
        i = `
Error generating stack: ` + s.message + `
` + s.stack
    }
    return {
        value: n,
        source: e,
        stack: i,
        digest: null
    }
}
function Ry(n, e, t) {
    return {
        value: n,
        source: null,
        stack: t ?? null,
        digest: e ?? null
    }
}
function x1(n, e) {
    try {
        console.error(e.value)
    } catch (t) {
        setTimeout(function() {
            throw t
        })
    }
}
var TI = typeof WeakMap == "function" ? WeakMap : Map;
function bD(n, e, t) {
    t = wu(-1, t),
    t.tag = 3,
    t.payload = {
        element: null
    };
    var r = e.value;
    return t.callback = function() {
        Nv || (Nv = !0,
        P1 = r),
        x1(n, e)
    }
    ,
    t
}
function TD(n, e, t) {
    t = wu(-1, t),
    t.tag = 3;
    var r = n.type.getDerivedStateFromError;
    if (typeof r == "function") {
        var i = e.value;
        t.payload = function() {
            return r(i)
        }
        ,
        t.callback = function() {
            x1(n, e)
        }
    }
    var s = n.stateNode;
    return s !== null && typeof s.componentDidCatch == "function" && (t.callback = function() {
        x1(n, e),
        typeof r != "function" && (yc === null ? yc = new Set([this]) : yc.add(this));
        var o = e.stack;
        this.componentDidCatch(e.value, {
            componentStack: o !== null ? o : ""
        })
    }
    ),
    t
}
function rC(n, e, t) {
    var r = n.pingCache;
    if (r === null) {
        r = n.pingCache = new TI;
        var i = new Set;
        r.set(e, i)
    } else
        i = r.get(e),
        i === void 0 && (i = new Set,
        r.set(e, i));
    i.has(t) || (i.add(t),
    n = HI.bind(null, n, e, t),
    e.then(n, n))
}
function iC(n) {
    do {
        var e;
        if ((e = n.tag === 13) && (e = n.memoizedState,
        e = e !== null ? e.dehydrated !== null : !0),
        e)
            return n;
        n = n.return
    } while (n !== null);
    return null
}
function sC(n, e, t, r, i) {
    return n.mode & 1 ? (n.flags |= 65536,
    n.lanes = i,
    n) : (n === e ? n.flags |= 65536 : (n.flags |= 128,
    t.flags |= 131072,
    t.flags &= -52805,
    t.tag === 1 && (t.alternate === null ? t.tag = 17 : (e = wu(-1, 1),
    e.tag = 2,
    _c(t, e, 1))),
    t.lanes |= 1),
    n)
}
var DI = Pu.ReactCurrentOwner
  , qo = !1;
function So(n, e, t, r) {
    e.child = n === null ? oD(e, null, t, r) : fh(e, n.child, t, r)
}
function oC(n, e, t, r, i) {
    t = t.render;
    var s = e.ref;
    return nh(e, i),
    r = gS(n, e, t, r, s, i),
    t = vS(),
    n !== null && !qo ? (e.updateQueue = n.updateQueue,
    e.flags &= -2053,
    n.lanes &= ~i,
    bu(n, e, i)) : (Ai && t && iS(e),
    e.flags |= 1,
    So(n, e, r, i),
    e.child)
}
function aC(n, e, t, r, i) {
    if (n === null) {
        var s = t.type;
        return typeof s == "function" && !bS(s) && s.defaultProps === void 0 && t.compare === null && t.defaultProps === void 0 ? (e.tag = 15,
        e.type = s,
        DD(n, e, s, r, i)) : (n = ev(t.type, null, r, e, e.mode, i),
        n.ref = e.ref,
        n.return = e,
        e.child = n)
    }
    if (s = n.child,
    !(n.lanes & i)) {
        var o = s.memoizedProps;
        if (t = t.compare,
        t = t !== null ? t : rm,
        t(o, r) && n.ref === e.ref)
            return bu(n, e, i)
    }
    return e.flags |= 1,
    n = wc(s, r),
    n.ref = e.ref,
    n.return = e,
    e.child = n
}
function DD(n, e, t, r, i) {
    if (n !== null) {
        var s = n.memoizedProps;
        if (rm(s, r) && n.ref === e.ref)
            if (qo = !1,
            e.pendingProps = r = s,
            (n.lanes & i) !== 0)
                n.flags & 131072 && (qo = !0);
            else
                return e.lanes = n.lanes,
                bu(n, e, i)
    }
    return w1(n, e, t, r, i)
}
function PD(n, e, t) {
    var r = e.pendingProps
      , i = r.children
      , s = n !== null ? n.memoizedState : null;
    if (r.mode === "hidden")
        if (!(e.mode & 1))
            e.memoizedState = {
                baseLanes: 0,
                cachePool: null,
                transitions: null
            },
            fi(Vd, ha),
            ha |= t;
        else {
            if (!(t & 1073741824))
                return n = s !== null ? s.baseLanes | t : t,
                e.lanes = e.childLanes = 1073741824,
                e.memoizedState = {
                    baseLanes: n,
                    cachePool: null,
                    transitions: null
                },
                e.updateQueue = null,
                fi(Vd, ha),
                ha |= n,
                null;
            e.memoizedState = {
                baseLanes: 0,
                cachePool: null,
                transitions: null
            },
            r = s !== null ? s.baseLanes : t,
            fi(Vd, ha),
            ha |= r
        }
    else
        s !== null ? (r = s.baseLanes | t,
        e.memoizedState = null) : r = t,
        fi(Vd, ha),
        ha |= r;
    return So(n, e, i, t),
    e.child
}
function RD(n, e) {
    var t = e.ref;
    (n === null && t !== null || n !== null && n.ref !== t) && (e.flags |= 512,
    e.flags |= 2097152)
}
function w1(n, e, t, r, i) {
    var s = Zo(t) ? kf : ao.current;
    return s = uh(e, s),
    nh(e, i),
    t = gS(n, e, t, r, s, i),
    r = vS(),
    n !== null && !qo ? (e.updateQueue = n.updateQueue,
    e.flags &= -2053,
    n.lanes &= ~i,
    bu(n, e, i)) : (Ai && r && iS(e),
    e.flags |= 1,
    So(n, e, t, i),
    e.child)
}
function lC(n, e, t, r, i) {
    if (Zo(t)) {
        var s = !0;
        Tv(e)
    } else
        s = !1;
    if (nh(e, i),
    e.stateNode === null)
        Q0(n, e),
        iD(e, t, r),
        y1(e, t, r, i),
        r = !0;
    else if (n === null) {
        var o = e.stateNode
          , a = e.memoizedProps;
        o.props = a;
        var l = o.context
          , f = t.contextType;
        typeof f == "object" && f !== null ? f = Qa(f) : (f = Zo(t) ? kf : ao.current,
        f = uh(e, f));
        var h = t.getDerivedStateFromProps
          , d = typeof h == "function" || typeof o.getSnapshotBeforeUpdate == "function";
        d || typeof o.UNSAFE_componentWillReceiveProps != "function" && typeof o.componentWillReceiveProps != "function" || (a !== r || l !== f) && $A(e, o, r, f),
        nc = !1;
        var p = e.memoizedState;
        o.state = p,
        Iv(e, r, o, i),
        l = e.memoizedState,
        a !== r || p !== l || Qo.current || nc ? (typeof h == "function" && (_1(e, t, h, r),
        l = e.memoizedState),
        (a = nc || ZA(e, t, a, r, p, l, f)) ? (d || typeof o.UNSAFE_componentWillMount != "function" && typeof o.componentWillMount != "function" || (typeof o.componentWillMount == "function" && o.componentWillMount(),
        typeof o.UNSAFE_componentWillMount == "function" && o.UNSAFE_componentWillMount()),
        typeof o.componentDidMount == "function" && (e.flags |= 4194308)) : (typeof o.componentDidMount == "function" && (e.flags |= 4194308),
        e.memoizedProps = r,
        e.memoizedState = l),
        o.props = r,
        o.state = l,
        o.context = f,
        r = a) : (typeof o.componentDidMount == "function" && (e.flags |= 4194308),
        r = !1)
    } else {
        o = e.stateNode,
        nD(n, e),
        a = e.memoizedProps,
        f = e.type === e.elementType ? a : hl(e.type, a),
        o.props = f,
        d = e.pendingProps,
        p = o.context,
        l = t.contextType,
        typeof l == "object" && l !== null ? l = Qa(l) : (l = Zo(t) ? kf : ao.current,
        l = uh(e, l));
        var m = t.getDerivedStateFromProps;
        (h = typeof m == "function" || typeof o.getSnapshotBeforeUpdate == "function") || typeof o.UNSAFE_componentWillReceiveProps != "function" && typeof o.componentWillReceiveProps != "function" || (a !== d || p !== l) && $A(e, o, r, l),
        nc = !1,
        p = e.memoizedState,
        o.state = p,
        Iv(e, r, o, i);
        var _ = e.memoizedState;
        a !== d || p !== _ || Qo.current || nc ? (typeof m == "function" && (_1(e, t, m, r),
        _ = e.memoizedState),
        (f = nc || ZA(e, t, f, r, p, _, l) || !1) ? (h || typeof o.UNSAFE_componentWillUpdate != "function" && typeof o.componentWillUpdate != "function" || (typeof o.componentWillUpdate == "function" && o.componentWillUpdate(r, _, l),
        typeof o.UNSAFE_componentWillUpdate == "function" && o.UNSAFE_componentWillUpdate(r, _, l)),
        typeof o.componentDidUpdate == "function" && (e.flags |= 4),
        typeof o.getSnapshotBeforeUpdate == "function" && (e.flags |= 1024)) : (typeof o.componentDidUpdate != "function" || a === n.memoizedProps && p === n.memoizedState || (e.flags |= 4),
        typeof o.getSnapshotBeforeUpdate != "function" || a === n.memoizedProps && p === n.memoizedState || (e.flags |= 1024),
        e.memoizedProps = r,
        e.memoizedState = _),
        o.props = r,
        o.state = _,
        o.context = l,
        r = f) : (typeof o.componentDidUpdate != "function" || a === n.memoizedProps && p === n.memoizedState || (e.flags |= 4),
        typeof o.getSnapshotBeforeUpdate != "function" || a === n.memoizedProps && p === n.memoizedState || (e.flags |= 1024),
        r = !1)
    }
    return S1(n, e, t, r, s, i)
}
function S1(n, e, t, r, i, s) {
    RD(n, e);
    var o = (e.flags & 128) !== 0;
    if (!r && !o)
        return i && jA(e, t, !1),
        bu(n, e, s);
    r = e.stateNode,
    DI.current = e;
    var a = o && typeof t.getDerivedStateFromError != "function" ? null : r.render();
    return e.flags |= 1,
    n !== null && o ? (e.child = fh(e, n.child, null, s),
    e.child = fh(e, null, a, s)) : So(n, e, a, s),
    e.memoizedState = r.state,
    i && jA(e, t, !0),
    e.child
}
function BD(n) {
    var e = n.stateNode;
    e.pendingContext ? JA(n, e.pendingContext, e.pendingContext !== e.context) : e.context && JA(n, e.context, !1),
    dS(n, e.containerInfo)
}
function uC(n, e, t, r, i) {
    return ch(),
    oS(i),
    e.flags |= 256,
    So(n, e, t, r),
    e.child
}
var M1 = {
    dehydrated: null,
    treeContext: null,
    retryLane: 0
};
function A1(n) {
    return {
        baseLanes: n,
        cachePool: null,
        transitions: null
    }
}
function ID(n, e, t) {
    var r = e.pendingProps, i = Li.current, s = !1, o = (e.flags & 128) !== 0, a;
    if ((a = o) || (a = n !== null && n.memoizedState === null ? !1 : (i & 2) !== 0),
    a ? (s = !0,
    e.flags &= -129) : (n === null || n.memoizedState !== null) && (i |= 1),
    fi(Li, i & 1),
    n === null)
        return g1(e),
        n = e.memoizedState,
        n !== null && (n = n.dehydrated,
        n !== null) ? (e.mode & 1 ? n.data === "$!" ? e.lanes = 8 : e.lanes = 1073741824 : e.lanes = 1,
        null) : (o = r.children,
        n = r.fallback,
        s ? (r = e.mode,
        s = e.child,
        o = {
            mode: "hidden",
            children: o
        },
        !(r & 1) && s !== null ? (s.childLanes = 0,
        s.pendingProps = o) : s = u_(o, r, 0, null),
        n = Ef(n, r, t, null),
        s.return = e,
        n.return = e,
        s.sibling = n,
        e.child = s,
        e.child.memoizedState = A1(t),
        e.memoizedState = M1,
        n) : xS(e, o));
    if (i = n.memoizedState,
    i !== null && (a = i.dehydrated,
    a !== null))
        return PI(n, e, o, r, a, i, t);
    if (s) {
        s = r.fallback,
        o = e.mode,
        i = n.child,
        a = i.sibling;
        var l = {
            mode: "hidden",
            children: r.children
        };
        return !(o & 1) && e.child !== i ? (r = e.child,
        r.childLanes = 0,
        r.pendingProps = l,
        e.deletions = null) : (r = wc(i, l),
        r.subtreeFlags = i.subtreeFlags & 14680064),
        a !== null ? s = wc(a, s) : (s = Ef(s, o, t, null),
        s.flags |= 2),
        s.return = e,
        r.return = e,
        r.sibling = s,
        e.child = r,
        r = s,
        s = e.child,
        o = n.child.memoizedState,
        o = o === null ? A1(t) : {
            baseLanes: o.baseLanes | t,
            cachePool: null,
            transitions: o.transitions
        },
        s.memoizedState = o,
        s.childLanes = n.childLanes & ~t,
        e.memoizedState = M1,
        r
    }
    return s = n.child,
    n = s.sibling,
    r = wc(s, {
        mode: "visible",
        children: r.children
    }),
    !(e.mode & 1) && (r.lanes = t),
    r.return = e,
    r.sibling = null,
    n !== null && (t = e.deletions,
    t === null ? (e.deletions = [n],
    e.flags |= 16) : t.push(n)),
    e.child = r,
    e.memoizedState = null,
    r
}
function xS(n, e) {
    return e = u_({
        mode: "visible",
        children: e
    }, n.mode, 0, null),
    e.return = n,
    n.child = e
}
function Bg(n, e, t, r) {
    return r !== null && oS(r),
    fh(e, n.child, null, t),
    n = xS(e, e.pendingProps.children),
    n.flags |= 2,
    e.memoizedState = null,
    n
}
function PI(n, e, t, r, i, s, o) {
    if (t)
        return e.flags & 256 ? (e.flags &= -257,
        r = Ry(Error(mt(422))),
        Bg(n, e, o, r)) : e.memoizedState !== null ? (e.child = n.child,
        e.flags |= 128,
        null) : (s = r.fallback,
        i = e.mode,
        r = u_({
            mode: "visible",
            children: r.children
        }, i, 0, null),
        s = Ef(s, i, o, null),
        s.flags |= 2,
        r.return = e,
        s.return = e,
        r.sibling = s,
        e.child = r,
        e.mode & 1 && fh(e, n.child, null, o),
        e.child.memoizedState = A1(o),
        e.memoizedState = M1,
        s);
    if (!(e.mode & 1))
        return Bg(n, e, o, null);
    if (i.data === "$!") {
        if (r = i.nextSibling && i.nextSibling.dataset,
        r)
            var a = r.dgst;
        return r = a,
        s = Error(mt(419)),
        r = Ry(s, r, void 0),
        Bg(n, e, o, r)
    }
    if (a = (o & n.childLanes) !== 0,
    qo || a) {
        if (r = Rs,
        r !== null) {
            switch (o & -o) {
            case 4:
                i = 2;
                break;
            case 16:
                i = 8;
                break;
            case 64:
            case 128:
            case 256:
            case 512:
            case 1024:
            case 2048:
            case 4096:
            case 8192:
            case 16384:
            case 32768:
            case 65536:
            case 131072:
            case 262144:
            case 524288:
            case 1048576:
            case 2097152:
            case 4194304:
            case 8388608:
            case 16777216:
            case 33554432:
            case 67108864:
                i = 32;
                break;
            case 536870912:
                i = 268435456;
                break;
            default:
                i = 0
            }
            i = i & (r.suspendedLanes | o) ? 0 : i,
            i !== 0 && i !== s.retryLane && (s.retryLane = i,
            Eu(n, i),
            Al(r, n, i, -1))
        }
        return ES(),
        r = Ry(Error(mt(421))),
        Bg(n, e, o, r)
    }
    return i.data === "$?" ? (e.flags |= 128,
    e.child = n.child,
    e = VI.bind(null, n),
    i._reactRetry = e,
    null) : (n = s.treeContext,
    _a = vc(i.nextSibling),
    wa = e,
    Ai = !0,
    _l = null,
    n !== null && (Ha[Va++] = mu,
    Ha[Va++] = gu,
    Ha[Va++] = Of,
    mu = n.id,
    gu = n.overflow,
    Of = e),
    e = xS(e, r.children),
    e.flags |= 4096,
    e)
}
function cC(n, e, t) {
    n.lanes |= e;
    var r = n.alternate;
    r !== null && (r.lanes |= e),
    v1(n.return, e, t)
}
function By(n, e, t, r, i) {
    var s = n.memoizedState;
    s === null ? n.memoizedState = {
        isBackwards: e,
        rendering: null,
        renderingStartTime: 0,
        last: r,
        tail: t,
        tailMode: i
    } : (s.isBackwards = e,
    s.rendering = null,
    s.renderingStartTime = 0,
    s.last = r,
    s.tail = t,
    s.tailMode = i)
}
function LD(n, e, t) {
    var r = e.pendingProps
      , i = r.revealOrder
      , s = r.tail;
    if (So(n, e, r.children, t),
    r = Li.current,
    r & 2)
        r = r & 1 | 2,
        e.flags |= 128;
    else {
        if (n !== null && n.flags & 128)
            e: for (n = e.child; n !== null; ) {
                if (n.tag === 13)
                    n.memoizedState !== null && cC(n, t, e);
                else if (n.tag === 19)
                    cC(n, t, e);
                else if (n.child !== null) {
                    n.child.return = n,
                    n = n.child;
                    continue
                }
                if (n === e)
                    break e;
                for (; n.sibling === null; ) {
                    if (n.return === null || n.return === e)
                        break e;
                    n = n.return
                }
                n.sibling.return = n.return,
                n = n.sibling
            }
        r &= 1
    }
    if (fi(Li, r),
    !(e.mode & 1))
        e.memoizedState = null;
    else
        switch (i) {
        case "forwards":
            for (t = e.child,
            i = null; t !== null; )
                n = t.alternate,
                n !== null && Lv(n) === null && (i = t),
                t = t.sibling;
            t = i,
            t === null ? (i = e.child,
            e.child = null) : (i = t.sibling,
            t.sibling = null),
            By(e, !1, i, t, s);
            break;
        case "backwards":
            for (t = null,
            i = e.child,
            e.child = null; i !== null; ) {
                if (n = i.alternate,
                n !== null && Lv(n) === null) {
                    e.child = i;
                    break
                }
                n = i.sibling,
                i.sibling = t,
                t = i,
                i = n
            }
            By(e, !0, t, null, s);
            break;
        case "together":
            By(e, !1, null, null, void 0);
            break;
        default:
            e.memoizedState = null
        }
    return e.child
}
function Q0(n, e) {
    !(e.mode & 1) && n !== null && (n.alternate = null,
    e.alternate = null,
    e.flags |= 2)
}
function bu(n, e, t) {
    if (n !== null && (e.dependencies = n.dependencies),
    zf |= e.lanes,
    !(t & e.childLanes))
        return null;
    if (n !== null && e.child !== n.child)
        throw Error(mt(153));
    if (e.child !== null) {
        for (n = e.child,
        t = wc(n, n.pendingProps),
        e.child = t,
        t.return = e; n.sibling !== null; )
            n = n.sibling,
            t = t.sibling = wc(n, n.pendingProps),
            t.return = e;
        t.sibling = null
    }
    return e.child
}
function RI(n, e, t) {
    switch (e.tag) {
    case 3:
        BD(e),
        ch();
        break;
    case 5:
        aD(e);
        break;
    case 1:
        Zo(e.type) && Tv(e);
        break;
    case 4:
        dS(e, e.stateNode.containerInfo);
        break;
    case 10:
        var r = e.type._context
          , i = e.memoizedProps.value;
        fi(Rv, r._currentValue),
        r._currentValue = i;
        break;
    case 13:
        if (r = e.memoizedState,
        r !== null)
            return r.dehydrated !== null ? (fi(Li, Li.current & 1),
            e.flags |= 128,
            null) : t & e.child.childLanes ? ID(n, e, t) : (fi(Li, Li.current & 1),
            n = bu(n, e, t),
            n !== null ? n.sibling : null);
        fi(Li, Li.current & 1);
        break;
    case 19:
        if (r = (t & e.childLanes) !== 0,
        n.flags & 128) {
            if (r)
                return LD(n, e, t);
            e.flags |= 128
        }
        if (i = e.memoizedState,
        i !== null && (i.rendering = null,
        i.tail = null,
        i.lastEffect = null),
        fi(Li, Li.current),
        r)
            break;
        return null;
    case 22:
    case 23:
        return e.lanes = 0,
        PD(n, e, t)
    }
    return bu(n, e, t)
}
var FD, C1, kD, OD;
FD = function(n, e) {
    for (var t = e.child; t !== null; ) {
        if (t.tag === 5 || t.tag === 6)
            n.appendChild(t.stateNode);
        else if (t.tag !== 4 && t.child !== null) {
            t.child.return = t,
            t = t.child;
            continue
        }
        if (t === e)
            break;
        for (; t.sibling === null; ) {
            if (t.return === null || t.return === e)
                return;
            t = t.return
        }
        t.sibling.return = t.return,
        t = t.sibling
    }
}
;
C1 = function() {}
;
kD = function(n, e, t, r) {
    var i = n.memoizedProps;
    if (i !== r) {
        n = e.stateNode,
        _f(Xl.current);
        var s = null;
        switch (t) {
        case "input":
            i = jx(n, i),
            r = jx(n, r),
            s = [];
            break;
        case "select":
            i = Oi({}, i, {
                value: void 0
            }),
            r = Oi({}, r, {
                value: void 0
            }),
            s = [];
            break;
        case "textarea":
            i = qx(n, i),
            r = qx(n, r),
            s = [];
            break;
        default:
            typeof i.onClick != "function" && typeof r.onClick == "function" && (n.onclick = Ev)
        }
        Zx(t, r);
        var o;
        t = null;
        for (f in i)
            if (!r.hasOwnProperty(f) && i.hasOwnProperty(f) && i[f] != null)
                if (f === "style") {
                    var a = i[f];
                    for (o in a)
                        a.hasOwnProperty(o) && (t || (t = {}),
                        t[o] = "")
                } else
                    f !== "dangerouslySetInnerHTML" && f !== "children" && f !== "suppressContentEditableWarning" && f !== "suppressHydrationWarning" && f !== "autoFocus" && (qp.hasOwnProperty(f) ? s || (s = []) : (s = s || []).push(f, null));
        for (f in r) {
            var l = r[f];
            if (a = i != null ? i[f] : void 0,
            r.hasOwnProperty(f) && l !== a && (l != null || a != null))
                if (f === "style")
                    if (a) {
                        for (o in a)
                            !a.hasOwnProperty(o) || l && l.hasOwnProperty(o) || (t || (t = {}),
                            t[o] = "");
                        for (o in l)
                            l.hasOwnProperty(o) && a[o] !== l[o] && (t || (t = {}),
                            t[o] = l[o])
                    } else
                        t || (s || (s = []),
                        s.push(f, t)),
                        t = l;
                else
                    f === "dangerouslySetInnerHTML" ? (l = l ? l.__html : void 0,
                    a = a ? a.__html : void 0,
                    l != null && a !== l && (s = s || []).push(f, l)) : f === "children" ? typeof l != "string" && typeof l != "number" || (s = s || []).push(f, "" + l) : f !== "suppressContentEditableWarning" && f !== "suppressHydrationWarning" && (qp.hasOwnProperty(f) ? (l != null && f === "onScroll" && mi("scroll", n),
                    s || a === l || (s = [])) : (s = s || []).push(f, l))
        }
        t && (s = s || []).push("style", t);
        var f = s;
        (e.updateQueue = f) && (e.flags |= 4)
    }
}
;
OD = function(n, e, t, r) {
    t !== r && (e.flags |= 4)
}
;
function qh(n, e) {
    if (!Ai)
        switch (n.tailMode) {
        case "hidden":
            e = n.tail;
            for (var t = null; e !== null; )
                e.alternate !== null && (t = e),
                e = e.sibling;
            t === null ? n.tail = null : t.sibling = null;
            break;
        case "collapsed":
            t = n.tail;
            for (var r = null; t !== null; )
                t.alternate !== null && (r = t),
                t = t.sibling;
            r === null ? e || n.tail === null ? n.tail = null : n.tail.sibling = null : r.sibling = null
        }
}
function to(n) {
    var e = n.alternate !== null && n.alternate.child === n.child
      , t = 0
      , r = 0;
    if (e)
        for (var i = n.child; i !== null; )
            t |= i.lanes | i.childLanes,
            r |= i.subtreeFlags & 14680064,
            r |= i.flags & 14680064,
            i.return = n,
            i = i.sibling;
    else
        for (i = n.child; i !== null; )
            t |= i.lanes | i.childLanes,
            r |= i.subtreeFlags,
            r |= i.flags,
            i.return = n,
            i = i.sibling;
    return n.subtreeFlags |= r,
    n.childLanes = t,
    e
}
function BI(n, e, t) {
    var r = e.pendingProps;
    switch (sS(e),
    e.tag) {
    case 2:
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
        return to(e),
        null;
    case 1:
        return Zo(e.type) && bv(),
        to(e),
        null;
    case 3:
        return r = e.stateNode,
        dh(),
        vi(Qo),
        vi(ao),
        pS(),
        r.pendingContext && (r.context = r.pendingContext,
        r.pendingContext = null),
        (n === null || n.child === null) && (Pg(e) ? e.flags |= 4 : n === null || n.memoizedState.isDehydrated && !(e.flags & 256) || (e.flags |= 1024,
        _l !== null && (I1(_l),
        _l = null))),
        C1(n, e),
        to(e),
        null;
    case 5:
        hS(e);
        var i = _f(lm.current);
        if (t = e.type,
        n !== null && e.stateNode != null)
            kD(n, e, t, r, i),
            n.ref !== e.ref && (e.flags |= 512,
            e.flags |= 2097152);
        else {
            if (!r) {
                if (e.stateNode === null)
                    throw Error(mt(166));
                return to(e),
                null
            }
            if (n = _f(Xl.current),
            Pg(e)) {
                r = e.stateNode,
                t = e.type;
                var s = e.memoizedProps;
                switch (r[Vl] = e,
                r[om] = s,
                n = (e.mode & 1) !== 0,
                t) {
                case "dialog":
                    mi("cancel", r),
                    mi("close", r);
                    break;
                case "iframe":
                case "object":
                case "embed":
                    mi("load", r);
                    break;
                case "video":
                case "audio":
                    for (i = 0; i < Sp.length; i++)
                        mi(Sp[i], r);
                    break;
                case "source":
                    mi("error", r);
                    break;
                case "img":
                case "image":
                case "link":
                    mi("error", r),
                    mi("load", r);
                    break;
                case "details":
                    mi("toggle", r);
                    break;
                case "input":
                    yA(r, s),
                    mi("invalid", r);
                    break;
                case "select":
                    r._wrapperState = {
                        wasMultiple: !!s.multiple
                    },
                    mi("invalid", r);
                    break;
                case "textarea":
                    wA(r, s),
                    mi("invalid", r)
                }
                Zx(t, s),
                i = null;
                for (var o in s)
                    if (s.hasOwnProperty(o)) {
                        var a = s[o];
                        o === "children" ? typeof a == "string" ? r.textContent !== a && (s.suppressHydrationWarning !== !0 && Dg(r.textContent, a, n),
                        i = ["children", a]) : typeof a == "number" && r.textContent !== "" + a && (s.suppressHydrationWarning !== !0 && Dg(r.textContent, a, n),
                        i = ["children", "" + a]) : qp.hasOwnProperty(o) && a != null && o === "onScroll" && mi("scroll", r)
                    }
                switch (t) {
                case "input":
                    wg(r),
                    xA(r, s, !0);
                    break;
                case "textarea":
                    wg(r),
                    SA(r);
                    break;
                case "select":
                case "option":
                    break;
                default:
                    typeof s.onClick == "function" && (r.onclick = Ev)
                }
                r = i,
                e.updateQueue = r,
                r !== null && (e.flags |= 4)
            } else {
                o = i.nodeType === 9 ? i : i.ownerDocument,
                n === "http://www.w3.org/1999/xhtml" && (n = cT(t)),
                n === "http://www.w3.org/1999/xhtml" ? t === "script" ? (n = o.createElement("div"),
                n.innerHTML = "<script><\/script>",
                n = n.removeChild(n.firstChild)) : typeof r.is == "string" ? n = o.createElement(t, {
                    is: r.is
                }) : (n = o.createElement(t),
                t === "select" && (o = n,
                r.multiple ? o.multiple = !0 : r.size && (o.size = r.size))) : n = o.createElementNS(n, t),
                n[Vl] = e,
                n[om] = r,
                FD(n, e, !1, !1),
                e.stateNode = n;
                e: {
                    switch (o = $x(t, r),
                    t) {
                    case "dialog":
                        mi("cancel", n),
                        mi("close", n),
                        i = r;
                        break;
                    case "iframe":
                    case "object":
                    case "embed":
                        mi("load", n),
                        i = r;
                        break;
                    case "video":
                    case "audio":
                        for (i = 0; i < Sp.length; i++)
                            mi(Sp[i], n);
                        i = r;
                        break;
                    case "source":
                        mi("error", n),
                        i = r;
                        break;
                    case "img":
                    case "image":
                    case "link":
                        mi("error", n),
                        mi("load", n),
                        i = r;
                        break;
                    case "details":
                        mi("toggle", n),
                        i = r;
                        break;
                    case "input":
                        yA(n, r),
                        i = jx(n, r),
                        mi("invalid", n);
                        break;
                    case "option":
                        i = r;
                        break;
                    case "select":
                        n._wrapperState = {
                            wasMultiple: !!r.multiple
                        },
                        i = Oi({}, r, {
                            value: void 0
                        }),
                        mi("invalid", n);
                        break;
                    case "textarea":
                        wA(n, r),
                        i = qx(n, r),
                        mi("invalid", n);
                        break;
                    default:
                        i = r
                    }
                    Zx(t, i),
                    a = i;
                    for (s in a)
                        if (a.hasOwnProperty(s)) {
                            var l = a[s];
                            s === "style" ? hT(n, l) : s === "dangerouslySetInnerHTML" ? (l = l ? l.__html : void 0,
                            l != null && fT(n, l)) : s === "children" ? typeof l == "string" ? (t !== "textarea" || l !== "") && Qp(n, l) : typeof l == "number" && Qp(n, "" + l) : s !== "suppressContentEditableWarning" && s !== "suppressHydrationWarning" && s !== "autoFocus" && (qp.hasOwnProperty(s) ? l != null && s === "onScroll" && mi("scroll", n) : l != null && Ww(n, s, l, o))
                        }
                    switch (t) {
                    case "input":
                        wg(n),
                        xA(n, r, !1);
                        break;
                    case "textarea":
                        wg(n),
                        SA(n);
                        break;
                    case "option":
                        r.value != null && n.setAttribute("value", "" + Ac(r.value));
                        break;
                    case "select":
                        n.multiple = !!r.multiple,
                        s = r.value,
                        s != null ? Zd(n, !!r.multiple, s, !1) : r.defaultValue != null && Zd(n, !!r.multiple, r.defaultValue, !0);
                        break;
                    default:
                        typeof i.onClick == "function" && (n.onclick = Ev)
                    }
                    switch (t) {
                    case "button":
                    case "input":
                    case "select":
                    case "textarea":
                        r = !!r.autoFocus;
                        break e;
                    case "img":
                        r = !0;
                        break e;
                    default:
                        r = !1
                    }
                }
                r && (e.flags |= 4)
            }
            e.ref !== null && (e.flags |= 512,
            e.flags |= 2097152)
        }
        return to(e),
        null;
    case 6:
        if (n && e.stateNode != null)
            OD(n, e, n.memoizedProps, r);
        else {
            if (typeof r != "string" && e.stateNode === null)
                throw Error(mt(166));
            if (t = _f(lm.current),
            _f(Xl.current),
            Pg(e)) {
                if (r = e.stateNode,
                t = e.memoizedProps,
                r[Vl] = e,
                (s = r.nodeValue !== t) && (n = wa,
                n !== null))
                    switch (n.tag) {
                    case 3:
                        Dg(r.nodeValue, t, (n.mode & 1) !== 0);
                        break;
                    case 5:
                        n.memoizedProps.suppressHydrationWarning !== !0 && Dg(r.nodeValue, t, (n.mode & 1) !== 0)
                    }
                s && (e.flags |= 4)
            } else
                r = (t.nodeType === 9 ? t : t.ownerDocument).createTextNode(r),
                r[Vl] = e,
                e.stateNode = r
        }
        return to(e),
        null;
    case 13:
        if (vi(Li),
        r = e.memoizedState,
        n === null || n.memoizedState !== null && n.memoizedState.dehydrated !== null) {
            if (Ai && _a !== null && e.mode & 1 && !(e.flags & 128))
                eD(),
                ch(),
                e.flags |= 98560,
                s = !1;
            else if (s = Pg(e),
            r !== null && r.dehydrated !== null) {
                if (n === null) {
                    if (!s)
                        throw Error(mt(318));
                    if (s = e.memoizedState,
                    s = s !== null ? s.dehydrated : null,
                    !s)
                        throw Error(mt(317));
                    s[Vl] = e
                } else
                    ch(),
                    !(e.flags & 128) && (e.memoizedState = null),
                    e.flags |= 4;
                to(e),
                s = !1
            } else
                _l !== null && (I1(_l),
                _l = null),
                s = !0;
            if (!s)
                return e.flags & 65536 ? e : null
        }
        return e.flags & 128 ? (e.lanes = t,
        e) : (r = r !== null,
        r !== (n !== null && n.memoizedState !== null) && r && (e.child.flags |= 8192,
        e.mode & 1 && (n === null || Li.current & 1 ? gs === 0 && (gs = 3) : ES())),
        e.updateQueue !== null && (e.flags |= 4),
        to(e),
        null);
    case 4:
        return dh(),
        C1(n, e),
        n === null && im(e.stateNode.containerInfo),
        to(e),
        null;
    case 10:
        return uS(e.type._context),
        to(e),
        null;
    case 17:
        return Zo(e.type) && bv(),
        to(e),
        null;
    case 19:
        if (vi(Li),
        s = e.memoizedState,
        s === null)
            return to(e),
            null;
        if (r = (e.flags & 128) !== 0,
        o = s.rendering,
        o === null)
            if (r)
                qh(s, !1);
            else {
                if (gs !== 0 || n !== null && n.flags & 128)
                    for (n = e.child; n !== null; ) {
                        if (o = Lv(n),
                        o !== null) {
                            for (e.flags |= 128,
                            qh(s, !1),
                            r = o.updateQueue,
                            r !== null && (e.updateQueue = r,
                            e.flags |= 4),
                            e.subtreeFlags = 0,
                            r = t,
                            t = e.child; t !== null; )
                                s = t,
                                n = r,
                                s.flags &= 14680066,
                                o = s.alternate,
                                o === null ? (s.childLanes = 0,
                                s.lanes = n,
                                s.child = null,
                                s.subtreeFlags = 0,
                                s.memoizedProps = null,
                                s.memoizedState = null,
                                s.updateQueue = null,
                                s.dependencies = null,
                                s.stateNode = null) : (s.childLanes = o.childLanes,
                                s.lanes = o.lanes,
                                s.child = o.child,
                                s.subtreeFlags = 0,
                                s.deletions = null,
                                s.memoizedProps = o.memoizedProps,
                                s.memoizedState = o.memoizedState,
                                s.updateQueue = o.updateQueue,
                                s.type = o.type,
                                n = o.dependencies,
                                s.dependencies = n === null ? null : {
                                    lanes: n.lanes,
                                    firstContext: n.firstContext
                                }),
                                t = t.sibling;
                            return fi(Li, Li.current & 1 | 2),
                            e.child
                        }
                        n = n.sibling
                    }
                s.tail !== null && Zi() > ph && (e.flags |= 128,
                r = !0,
                qh(s, !1),
                e.lanes = 4194304)
            }
        else {
            if (!r)
                if (n = Lv(o),
                n !== null) {
                    if (e.flags |= 128,
                    r = !0,
                    t = n.updateQueue,
                    t !== null && (e.updateQueue = t,
                    e.flags |= 4),
                    qh(s, !0),
                    s.tail === null && s.tailMode === "hidden" && !o.alternate && !Ai)
                        return to(e),
                        null
                } else
                    2 * Zi() - s.renderingStartTime > ph && t !== 1073741824 && (e.flags |= 128,
                    r = !0,
                    qh(s, !1),
                    e.lanes = 4194304);
            s.isBackwards ? (o.sibling = e.child,
            e.child = o) : (t = s.last,
            t !== null ? t.sibling = o : e.child = o,
            s.last = o)
        }
        return s.tail !== null ? (e = s.tail,
        s.rendering = e,
        s.tail = e.sibling,
        s.renderingStartTime = Zi(),
        e.sibling = null,
        t = Li.current,
        fi(Li, r ? t & 1 | 2 : t & 1),
        e) : (to(e),
        null);
    case 22:
    case 23:
        return CS(),
        r = e.memoizedState !== null,
        n !== null && n.memoizedState !== null !== r && (e.flags |= 8192),
        r && e.mode & 1 ? ha & 1073741824 && (to(e),
        e.subtreeFlags & 6 && (e.flags |= 8192)) : to(e),
        null;
    case 24:
        return null;
    case 25:
        return null
    }
    throw Error(mt(156, e.tag))
}
function II(n, e) {
    switch (sS(e),
    e.tag) {
    case 1:
        return Zo(e.type) && bv(),
        n = e.flags,
        n & 65536 ? (e.flags = n & -65537 | 128,
        e) : null;
    case 3:
        return dh(),
        vi(Qo),
        vi(ao),
        pS(),
        n = e.flags,
        n & 65536 && !(n & 128) ? (e.flags = n & -65537 | 128,
        e) : null;
    case 5:
        return hS(e),
        null;
    case 13:
        if (vi(Li),
        n = e.memoizedState,
        n !== null && n.dehydrated !== null) {
            if (e.alternate === null)
                throw Error(mt(340));
            ch()
        }
        return n = e.flags,
        n & 65536 ? (e.flags = n & -65537 | 128,
        e) : null;
    case 19:
        return vi(Li),
        null;
    case 4:
        return dh(),
        null;
    case 10:
        return uS(e.type._context),
        null;
    case 22:
    case 23:
        return CS(),
        null;
    case 24:
        return null;
    default:
        return null
    }
}
var Ig = !1
  , oo = !1
  , LI = typeof WeakSet == "function" ? WeakSet : Set
  , Kt = null;
function Hd(n, e) {
    var t = n.ref;
    if (t !== null)
        if (typeof t == "function")
            try {
                t(null)
            } catch (r) {
                Xi(n, e, r)
            }
        else
            t.current = null
}
function E1(n, e, t) {
    try {
        t()
    } catch (r) {
        Xi(n, e, r)
    }
}
var fC = !1;
function FI(n, e) {
    if (u1 = Mv,
    n = UT(),
    rS(n)) {
        if ("selectionStart"in n)
            var t = {
                start: n.selectionStart,
                end: n.selectionEnd
            };
        else
            e: {
                t = (t = n.ownerDocument) && t.defaultView || window;
                var r = t.getSelection && t.getSelection();
                if (r && r.rangeCount !== 0) {
                    t = r.anchorNode;
                    var i = r.anchorOffset
                      , s = r.focusNode;
                    r = r.focusOffset;
                    try {
                        t.nodeType,
                        s.nodeType
                    } catch {
                        t = null;
                        break e
                    }
                    var o = 0
                      , a = -1
                      , l = -1
                      , f = 0
                      , h = 0
                      , d = n
                      , p = null;
                    t: for (; ; ) {
                        for (var m; d !== t || i !== 0 && d.nodeType !== 3 || (a = o + i),
                        d !== s || r !== 0 && d.nodeType !== 3 || (l = o + r),
                        d.nodeType === 3 && (o += d.nodeValue.length),
                        (m = d.firstChild) !== null; )
                            p = d,
                            d = m;
                        for (; ; ) {
                            if (d === n)
                                break t;
                            if (p === t && ++f === i && (a = o),
                            p === s && ++h === r && (l = o),
                            (m = d.nextSibling) !== null)
                                break;
                            d = p,
                            p = d.parentNode
                        }
                        d = m
                    }
                    t = a === -1 || l === -1 ? null : {
                        start: a,
                        end: l
                    }
                } else
                    t = null
            }
        t = t || {
            start: 0,
            end: 0
        }
    } else
        t = null;
    for (c1 = {
        focusedElem: n,
        selectionRange: t
    },
    Mv = !1,
    Kt = e; Kt !== null; )
        if (e = Kt,
        n = e.child,
        (e.subtreeFlags & 1028) !== 0 && n !== null)
            n.return = e,
            Kt = n;
        else
            for (; Kt !== null; ) {
                e = Kt;
                try {
                    var _ = e.alternate;
                    if (e.flags & 1024)
                        switch (e.tag) {
                        case 0:
                        case 11:
                        case 15:
                            break;
                        case 1:
                            if (_ !== null) {
                                var y = _.memoizedProps
                                  , x = _.memoizedState
                                  , S = e.stateNode
                                  , M = S.getSnapshotBeforeUpdate(e.elementType === e.type ? y : hl(e.type, y), x);
                                S.__reactInternalSnapshotBeforeUpdate = M
                            }
                            break;
                        case 3:
                            var w = e.stateNode.containerInfo;
                            w.nodeType === 1 ? w.textContent = "" : w.nodeType === 9 && w.documentElement && w.removeChild(w.documentElement);
                            break;
                        case 5:
                        case 6:
                        case 4:
                        case 17:
                            break;
                        default:
                            throw Error(mt(163))
                        }
                } catch (T) {
                    Xi(e, e.return, T)
                }
                if (n = e.sibling,
                n !== null) {
                    n.return = e.return,
                    Kt = n;
                    break
                }
                Kt = e.return
            }
    return _ = fC,
    fC = !1,
    _
}
function Fp(n, e, t) {
    var r = e.updateQueue;
    if (r = r !== null ? r.lastEffect : null,
    r !== null) {
        var i = r = r.next;
        do {
            if ((i.tag & n) === n) {
                var s = i.destroy;
                i.destroy = void 0,
                s !== void 0 && E1(e, t, s)
            }
            i = i.next
        } while (i !== r)
    }
}
function a_(n, e) {
    if (e = e.updateQueue,
    e = e !== null ? e.lastEffect : null,
    e !== null) {
        var t = e = e.next;
        do {
            if ((t.tag & n) === n) {
                var r = t.create;
                t.destroy = r()
            }
            t = t.next
        } while (t !== e)
    }
}
function b1(n) {
    var e = n.ref;
    if (e !== null) {
        var t = n.stateNode;
        switch (n.tag) {
        case 5:
            n = t;
            break;
        default:
            n = t
        }
        typeof e == "function" ? e(n) : e.current = n
    }
}
function ND(n) {
    var e = n.alternate;
    e !== null && (n.alternate = null,
    ND(e)),
    n.child = null,
    n.deletions = null,
    n.sibling = null,
    n.tag === 5 && (e = n.stateNode,
    e !== null && (delete e[Vl],
    delete e[om],
    delete e[h1],
    delete e[vI],
    delete e[_I])),
    n.stateNode = null,
    n.return = null,
    n.dependencies = null,
    n.memoizedProps = null,
    n.memoizedState = null,
    n.pendingProps = null,
    n.stateNode = null,
    n.updateQueue = null
}
function zD(n) {
    return n.tag === 5 || n.tag === 3 || n.tag === 4
}
function dC(n) {
    e: for (; ; ) {
        for (; n.sibling === null; ) {
            if (n.return === null || zD(n.return))
                return null;
            n = n.return
        }
        for (n.sibling.return = n.return,
        n = n.sibling; n.tag !== 5 && n.tag !== 6 && n.tag !== 18; ) {
            if (n.flags & 2 || n.child === null || n.tag === 4)
                continue e;
            n.child.return = n,
            n = n.child
        }
        if (!(n.flags & 2))
            return n.stateNode
    }
}
function T1(n, e, t) {
    var r = n.tag;
    if (r === 5 || r === 6)
        n = n.stateNode,
        e ? t.nodeType === 8 ? t.parentNode.insertBefore(n, e) : t.insertBefore(n, e) : (t.nodeType === 8 ? (e = t.parentNode,
        e.insertBefore(n, t)) : (e = t,
        e.appendChild(n)),
        t = t._reactRootContainer,
        t != null || e.onclick !== null || (e.onclick = Ev));
    else if (r !== 4 && (n = n.child,
    n !== null))
        for (T1(n, e, t),
        n = n.sibling; n !== null; )
            T1(n, e, t),
            n = n.sibling
}
function D1(n, e, t) {
    var r = n.tag;
    if (r === 5 || r === 6)
        n = n.stateNode,
        e ? t.insertBefore(n, e) : t.appendChild(n);
    else if (r !== 4 && (n = n.child,
    n !== null))
        for (D1(n, e, t),
        n = n.sibling; n !== null; )
            D1(n, e, t),
            n = n.sibling
}
var zs = null
  , ml = !1;
function ju(n, e, t) {
    for (t = t.child; t !== null; )
        GD(n, e, t),
        t = t.sibling
}
function GD(n, e, t) {
    if (Wl && typeof Wl.onCommitFiberUnmount == "function")
        try {
            Wl.onCommitFiberUnmount($v, t)
        } catch {}
    switch (t.tag) {
    case 5:
        oo || Hd(t, e);
    case 6:
        var r = zs
          , i = ml;
        zs = null,
        ju(n, e, t),
        zs = r,
        ml = i,
        zs !== null && (ml ? (n = zs,
        t = t.stateNode,
        n.nodeType === 8 ? n.parentNode.removeChild(t) : n.removeChild(t)) : zs.removeChild(t.stateNode));
        break;
    case 18:
        zs !== null && (ml ? (n = zs,
        t = t.stateNode,
        n.nodeType === 8 ? Cy(n.parentNode, t) : n.nodeType === 1 && Cy(n, t),
        tm(n)) : Cy(zs, t.stateNode));
        break;
    case 4:
        r = zs,
        i = ml,
        zs = t.stateNode.containerInfo,
        ml = !0,
        ju(n, e, t),
        zs = r,
        ml = i;
        break;
    case 0:
    case 11:
    case 14:
    case 15:
        if (!oo && (r = t.updateQueue,
        r !== null && (r = r.lastEffect,
        r !== null))) {
            i = r = r.next;
            do {
                var s = i
                  , o = s.destroy;
                s = s.tag,
                o !== void 0 && (s & 2 || s & 4) && E1(t, e, o),
                i = i.next
            } while (i !== r)
        }
        ju(n, e, t);
        break;
    case 1:
        if (!oo && (Hd(t, e),
        r = t.stateNode,
        typeof r.componentWillUnmount == "function"))
            try {
                r.props = t.memoizedProps,
                r.state = t.memoizedState,
                r.componentWillUnmount()
            } catch (a) {
                Xi(t, e, a)
            }
        ju(n, e, t);
        break;
    case 21:
        ju(n, e, t);
        break;
    case 22:
        t.mode & 1 ? (oo = (r = oo) || t.memoizedState !== null,
        ju(n, e, t),
        oo = r) : ju(n, e, t);
        break;
    default:
        ju(n, e, t)
    }
}
function hC(n) {
    var e = n.updateQueue;
    if (e !== null) {
        n.updateQueue = null;
        var t = n.stateNode;
        t === null && (t = n.stateNode = new LI),
        e.forEach(function(r) {
            var i = WI.bind(null, n, r);
            t.has(r) || (t.add(r),
            r.then(i, i))
        })
    }
}
function ll(n, e) {
    var t = e.deletions;
    if (t !== null)
        for (var r = 0; r < t.length; r++) {
            var i = t[r];
            try {
                var s = n
                  , o = e
                  , a = o;
                e: for (; a !== null; ) {
                    switch (a.tag) {
                    case 5:
                        zs = a.stateNode,
                        ml = !1;
                        break e;
                    case 3:
                        zs = a.stateNode.containerInfo,
                        ml = !0;
                        break e;
                    case 4:
                        zs = a.stateNode.containerInfo,
                        ml = !0;
                        break e
                    }
                    a = a.return
                }
                if (zs === null)
                    throw Error(mt(160));
                GD(s, o, i),
                zs = null,
                ml = !1;
                var l = i.alternate;
                l !== null && (l.return = null),
                i.return = null
            } catch (f) {
                Xi(i, e, f)
            }
        }
    if (e.subtreeFlags & 12854)
        for (e = e.child; e !== null; )
            UD(e, n),
            e = e.sibling
}
function UD(n, e) {
    var t = n.alternate
      , r = n.flags;
    switch (n.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
        if (ll(e, n),
        Ol(n),
        r & 4) {
            try {
                Fp(3, n, n.return),
                a_(3, n)
            } catch (y) {
                Xi(n, n.return, y)
            }
            try {
                Fp(5, n, n.return)
            } catch (y) {
                Xi(n, n.return, y)
            }
        }
        break;
    case 1:
        ll(e, n),
        Ol(n),
        r & 512 && t !== null && Hd(t, t.return);
        break;
    case 5:
        if (ll(e, n),
        Ol(n),
        r & 512 && t !== null && Hd(t, t.return),
        n.flags & 32) {
            var i = n.stateNode;
            try {
                Qp(i, "")
            } catch (y) {
                Xi(n, n.return, y)
            }
        }
        if (r & 4 && (i = n.stateNode,
        i != null)) {
            var s = n.memoizedProps
              , o = t !== null ? t.memoizedProps : s
              , a = n.type
              , l = n.updateQueue;
            if (n.updateQueue = null,
            l !== null)
                try {
                    a === "input" && s.type === "radio" && s.name != null && lT(i, s),
                    $x(a, o);
                    var f = $x(a, s);
                    for (o = 0; o < l.length; o += 2) {
                        var h = l[o]
                          , d = l[o + 1];
                        h === "style" ? hT(i, d) : h === "dangerouslySetInnerHTML" ? fT(i, d) : h === "children" ? Qp(i, d) : Ww(i, h, d, f)
                    }
                    switch (a) {
                    case "input":
                        Yx(i, s);
                        break;
                    case "textarea":
                        uT(i, s);
                        break;
                    case "select":
                        var p = i._wrapperState.wasMultiple;
                        i._wrapperState.wasMultiple = !!s.multiple;
                        var m = s.value;
                        m != null ? Zd(i, !!s.multiple, m, !1) : p !== !!s.multiple && (s.defaultValue != null ? Zd(i, !!s.multiple, s.defaultValue, !0) : Zd(i, !!s.multiple, s.multiple ? [] : "", !1))
                    }
                    i[om] = s
                } catch (y) {
                    Xi(n, n.return, y)
                }
        }
        break;
    case 6:
        if (ll(e, n),
        Ol(n),
        r & 4) {
            if (n.stateNode === null)
                throw Error(mt(162));
            i = n.stateNode,
            s = n.memoizedProps;
            try {
                i.nodeValue = s
            } catch (y) {
                Xi(n, n.return, y)
            }
        }
        break;
    case 3:
        if (ll(e, n),
        Ol(n),
        r & 4 && t !== null && t.memoizedState.isDehydrated)
            try {
                tm(e.containerInfo)
            } catch (y) {
                Xi(n, n.return, y)
            }
        break;
    case 4:
        ll(e, n),
        Ol(n);
        break;
    case 13:
        ll(e, n),
        Ol(n),
        i = n.child,
        i.flags & 8192 && (s = i.memoizedState !== null,
        i.stateNode.isHidden = s,
        !s || i.alternate !== null && i.alternate.memoizedState !== null || (MS = Zi())),
        r & 4 && hC(n);
        break;
    case 22:
        if (h = t !== null && t.memoizedState !== null,
        n.mode & 1 ? (oo = (f = oo) || h,
        ll(e, n),
        oo = f) : ll(e, n),
        Ol(n),
        r & 8192) {
            if (f = n.memoizedState !== null,
            (n.stateNode.isHidden = f) && !h && n.mode & 1)
                for (Kt = n,
                h = n.child; h !== null; ) {
                    for (d = Kt = h; Kt !== null; ) {
                        switch (p = Kt,
                        m = p.child,
                        p.tag) {
                        case 0:
                        case 11:
                        case 14:
                        case 15:
                            Fp(4, p, p.return);
                            break;
                        case 1:
                            Hd(p, p.return);
                            var _ = p.stateNode;
                            if (typeof _.componentWillUnmount == "function") {
                                r = p,
                                t = p.return;
                                try {
                                    e = r,
                                    _.props = e.memoizedProps,
                                    _.state = e.memoizedState,
                                    _.componentWillUnmount()
                                } catch (y) {
                                    Xi(r, t, y)
                                }
                            }
                            break;
                        case 5:
                            Hd(p, p.return);
                            break;
                        case 22:
                            if (p.memoizedState !== null) {
                                mC(d);
                                continue
                            }
                        }
                        m !== null ? (m.return = p,
                        Kt = m) : mC(d)
                    }
                    h = h.sibling
                }
            e: for (h = null,
            d = n; ; ) {
                if (d.tag === 5) {
                    if (h === null) {
                        h = d;
                        try {
                            i = d.stateNode,
                            f ? (s = i.style,
                            typeof s.setProperty == "function" ? s.setProperty("display", "none", "important") : s.display = "none") : (a = d.stateNode,
                            l = d.memoizedProps.style,
                            o = l != null && l.hasOwnProperty("display") ? l.display : null,
                            a.style.display = dT("display", o))
                        } catch (y) {
                            Xi(n, n.return, y)
                        }
                    }
                } else if (d.tag === 6) {
                    if (h === null)
                        try {
                            d.stateNode.nodeValue = f ? "" : d.memoizedProps
                        } catch (y) {
                            Xi(n, n.return, y)
                        }
                } else if ((d.tag !== 22 && d.tag !== 23 || d.memoizedState === null || d === n) && d.child !== null) {
                    d.child.return = d,
                    d = d.child;
                    continue
                }
                if (d === n)
                    break e;
                for (; d.sibling === null; ) {
                    if (d.return === null || d.return === n)
                        break e;
                    h === d && (h = null),
                    d = d.return
                }
                h === d && (h = null),
                d.sibling.return = d.return,
                d = d.sibling
            }
        }
        break;
    case 19:
        ll(e, n),
        Ol(n),
        r & 4 && hC(n);
        break;
    case 21:
        break;
    default:
        ll(e, n),
        Ol(n)
    }
}
function Ol(n) {
    var e = n.flags;
    if (e & 2) {
        try {
            e: {
                for (var t = n.return; t !== null; ) {
                    if (zD(t)) {
                        var r = t;
                        break e
                    }
                    t = t.return
                }
                throw Error(mt(160))
            }
            switch (r.tag) {
            case 5:
                var i = r.stateNode;
                r.flags & 32 && (Qp(i, ""),
                r.flags &= -33);
                var s = dC(n);
                D1(n, s, i);
                break;
            case 3:
            case 4:
                var o = r.stateNode.containerInfo
                  , a = dC(n);
                T1(n, a, o);
                break;
            default:
                throw Error(mt(161))
            }
        } catch (l) {
            Xi(n, n.return, l)
        }
        n.flags &= -3
    }
    e & 4096 && (n.flags &= -4097)
}
function kI(n, e, t) {
    Kt = n,
    HD(n)
}
function HD(n, e, t) {
    for (var r = (n.mode & 1) !== 0; Kt !== null; ) {
        var i = Kt
          , s = i.child;
        if (i.tag === 22 && r) {
            var o = i.memoizedState !== null || Ig;
            if (!o) {
                var a = i.alternate
                  , l = a !== null && a.memoizedState !== null || oo;
                a = Ig;
                var f = oo;
                if (Ig = o,
                (oo = l) && !f)
                    for (Kt = i; Kt !== null; )
                        o = Kt,
                        l = o.child,
                        o.tag === 22 && o.memoizedState !== null ? gC(i) : l !== null ? (l.return = o,
                        Kt = l) : gC(i);
                for (; s !== null; )
                    Kt = s,
                    HD(s),
                    s = s.sibling;
                Kt = i,
                Ig = a,
                oo = f
            }
            pC(n)
        } else
            i.subtreeFlags & 8772 && s !== null ? (s.return = i,
            Kt = s) : pC(n)
    }
}
function pC(n) {
    for (; Kt !== null; ) {
        var e = Kt;
        if (e.flags & 8772) {
            var t = e.alternate;
            try {
                if (e.flags & 8772)
                    switch (e.tag) {
                    case 0:
                    case 11:
                    case 15:
                        oo || a_(5, e);
                        break;
                    case 1:
                        var r = e.stateNode;
                        if (e.flags & 4 && !oo)
                            if (t === null)
                                r.componentDidMount();
                            else {
                                var i = e.elementType === e.type ? t.memoizedProps : hl(e.type, t.memoizedProps);
                                r.componentDidUpdate(i, t.memoizedState, r.__reactInternalSnapshotBeforeUpdate)
                            }
                        var s = e.updateQueue;
                        s !== null && QA(e, s, r);
                        break;
                    case 3:
                        var o = e.updateQueue;
                        if (o !== null) {
                            if (t = null,
                            e.child !== null)
                                switch (e.child.tag) {
                                case 5:
                                    t = e.child.stateNode;
                                    break;
                                case 1:
                                    t = e.child.stateNode
                                }
                            QA(e, o, t)
                        }
                        break;
                    case 5:
                        var a = e.stateNode;
                        if (t === null && e.flags & 4) {
                            t = a;
                            var l = e.memoizedProps;
                            switch (e.type) {
                            case "button":
                            case "input":
                            case "select":
                            case "textarea":
                                l.autoFocus && t.focus();
                                break;
                            case "img":
                                l.src && (t.src = l.src)
                            }
                        }
                        break;
                    case 6:
                        break;
                    case 4:
                        break;
                    case 12:
                        break;
                    case 13:
                        if (e.memoizedState === null) {
                            var f = e.alternate;
                            if (f !== null) {
                                var h = f.memoizedState;
                                if (h !== null) {
                                    var d = h.dehydrated;
                                    d !== null && tm(d)
                                }
                            }
                        }
                        break;
                    case 19:
                    case 17:
                    case 21:
                    case 22:
                    case 23:
                    case 25:
                        break;
                    default:
                        throw Error(mt(163))
                    }
                oo || e.flags & 512 && b1(e)
            } catch (p) {
                Xi(e, e.return, p)
            }
        }
        if (e === n) {
            Kt = null;
            break
        }
        if (t = e.sibling,
        t !== null) {
            t.return = e.return,
            Kt = t;
            break
        }
        Kt = e.return
    }
}
function mC(n) {
    for (; Kt !== null; ) {
        var e = Kt;
        if (e === n) {
            Kt = null;
            break
        }
        var t = e.sibling;
        if (t !== null) {
            t.return = e.return,
            Kt = t;
            break
        }
        Kt = e.return
    }
}
function gC(n) {
    for (; Kt !== null; ) {
        var e = Kt;
        try {
            switch (e.tag) {
            case 0:
            case 11:
            case 15:
                var t = e.return;
                try {
                    a_(4, e)
                } catch (l) {
                    Xi(e, t, l)
                }
                break;
            case 1:
                var r = e.stateNode;
                if (typeof r.componentDidMount == "function") {
                    var i = e.return;
                    try {
                        r.componentDidMount()
                    } catch (l) {
                        Xi(e, i, l)
                    }
                }
                var s = e.return;
                try {
                    b1(e)
                } catch (l) {
                    Xi(e, s, l)
                }
                break;
            case 5:
                var o = e.return;
                try {
                    b1(e)
                } catch (l) {
                    Xi(e, o, l)
                }
            }
        } catch (l) {
            Xi(e, e.return, l)
        }
        if (e === n) {
            Kt = null;
            break
        }
        var a = e.sibling;
        if (a !== null) {
            a.return = e.return,
            Kt = a;
            break
        }
        Kt = e.return
    }
}
var OI = Math.ceil
  , Ov = Pu.ReactCurrentDispatcher
  , wS = Pu.ReactCurrentOwner
  , Ya = Pu.ReactCurrentBatchConfig
  , xr = 0
  , Rs = null
  , os = null
  , Vs = 0
  , ha = 0
  , Vd = Lc(0)
  , gs = 0
  , dm = null
  , zf = 0
  , l_ = 0
  , SS = 0
  , kp = null
  , Ko = null
  , MS = 0
  , ph = 1 / 0
  , cu = null
  , Nv = !1
  , P1 = null
  , yc = null
  , Lg = !1
  , ac = null
  , zv = 0
  , Op = 0
  , R1 = null
  , Z0 = -1
  , $0 = 0;
function To() {
    return xr & 6 ? Zi() : Z0 !== -1 ? Z0 : Z0 = Zi()
}
function xc(n) {
    return n.mode & 1 ? xr & 2 && Vs !== 0 ? Vs & -Vs : xI.transition !== null ? ($0 === 0 && ($0 = CT()),
    $0) : (n = Gr,
    n !== 0 || (n = window.event,
    n = n === void 0 ? 16 : BT(n.type)),
    n) : 1
}
function Al(n, e, t, r) {
    if (50 < Op)
        throw Op = 0,
        R1 = null,
        Error(mt(185));
    Pm(n, t, r),
    (!(xr & 2) || n !== Rs) && (n === Rs && (!(xr & 2) && (l_ |= t),
    gs === 4 && sc(n, Vs)),
    $o(n, r),
    t === 1 && xr === 0 && !(e.mode & 1) && (ph = Zi() + 500,
    i_ && Fc()))
}
function $o(n, e) {
    var t = n.callbackNode;
    xB(n, e);
    var r = Sv(n, n === Rs ? Vs : 0);
    if (r === 0)
        t !== null && CA(t),
        n.callbackNode = null,
        n.callbackPriority = 0;
    else if (e = r & -r,
    n.callbackPriority !== e) {
        if (t != null && CA(t),
        e === 1)
            n.tag === 0 ? yI(vC.bind(null, n)) : QT(vC.bind(null, n)),
            mI(function() {
                !(xr & 6) && Fc()
            }),
            t = null;
        else {
            switch (ET(r)) {
            case 1:
                t = Kw;
                break;
            case 4:
                t = MT;
                break;
            case 16:
                t = wv;
                break;
            case 536870912:
                t = AT;
                break;
            default:
                t = wv
            }
            t = qD(t, VD.bind(null, n))
        }
        n.callbackPriority = e,
        n.callbackNode = t
    }
}
function VD(n, e) {
    if (Z0 = -1,
    $0 = 0,
    xr & 6)
        throw Error(mt(327));
    var t = n.callbackNode;
    if (rh() && n.callbackNode !== t)
        return null;
    var r = Sv(n, n === Rs ? Vs : 0);
    if (r === 0)
        return null;
    if (r & 30 || r & n.expiredLanes || e)
        e = Gv(n, r);
    else {
        e = r;
        var i = xr;
        xr |= 2;
        var s = XD();
        (Rs !== n || Vs !== e) && (cu = null,
        ph = Zi() + 500,
        Cf(n, e));
        do
            try {
                GI();
                break
            } catch (a) {
                WD(n, a)
            }
        while (1);
        lS(),
        Ov.current = s,
        xr = i,
        os !== null ? e = 0 : (Rs = null,
        Vs = 0,
        e = gs)
    }
    if (e !== 0) {
        if (e === 2 && (i = i1(n),
        i !== 0 && (r = i,
        e = B1(n, i))),
        e === 1)
            throw t = dm,
            Cf(n, 0),
            sc(n, r),
            $o(n, Zi()),
            t;
        if (e === 6)
            sc(n, r);
        else {
            if (i = n.current.alternate,
            !(r & 30) && !NI(i) && (e = Gv(n, r),
            e === 2 && (s = i1(n),
            s !== 0 && (r = s,
            e = B1(n, s))),
            e === 1))
                throw t = dm,
                Cf(n, 0),
                sc(n, r),
                $o(n, Zi()),
                t;
            switch (n.finishedWork = i,
            n.finishedLanes = r,
            e) {
            case 0:
            case 1:
                throw Error(mt(345));
            case 2:
                af(n, Ko, cu);
                break;
            case 3:
                if (sc(n, r),
                (r & 130023424) === r && (e = MS + 500 - Zi(),
                10 < e)) {
                    if (Sv(n, 0) !== 0)
                        break;
                    if (i = n.suspendedLanes,
                    (i & r) !== r) {
                        To(),
                        n.pingedLanes |= n.suspendedLanes & i;
                        break
                    }
                    n.timeoutHandle = d1(af.bind(null, n, Ko, cu), e);
                    break
                }
                af(n, Ko, cu);
                break;
            case 4:
                if (sc(n, r),
                (r & 4194240) === r)
                    break;
                for (e = n.eventTimes,
                i = -1; 0 < r; ) {
                    var o = 31 - Ml(r);
                    s = 1 << o,
                    o = e[o],
                    o > i && (i = o),
                    r &= ~s
                }
                if (r = i,
                r = Zi() - r,
                r = (120 > r ? 120 : 480 > r ? 480 : 1080 > r ? 1080 : 1920 > r ? 1920 : 3e3 > r ? 3e3 : 4320 > r ? 4320 : 1960 * OI(r / 1960)) - r,
                10 < r) {
                    n.timeoutHandle = d1(af.bind(null, n, Ko, cu), r);
                    break
                }
                af(n, Ko, cu);
                break;
            case 5:
                af(n, Ko, cu);
                break;
            default:
                throw Error(mt(329))
            }
        }
    }
    return $o(n, Zi()),
    n.callbackNode === t ? VD.bind(null, n) : null
}
function B1(n, e) {
    var t = kp;
    return n.current.memoizedState.isDehydrated && (Cf(n, e).flags |= 256),
    n = Gv(n, e),
    n !== 2 && (e = Ko,
    Ko = t,
    e !== null && I1(e)),
    n
}
function I1(n) {
    Ko === null ? Ko = n : Ko.push.apply(Ko, n)
}
function NI(n) {
    for (var e = n; ; ) {
        if (e.flags & 16384) {
            var t = e.updateQueue;
            if (t !== null && (t = t.stores,
            t !== null))
                for (var r = 0; r < t.length; r++) {
                    var i = t[r]
                      , s = i.getSnapshot;
                    i = i.value;
                    try {
                        if (!Cl(s(), i))
                            return !1
                    } catch {
                        return !1
                    }
                }
        }
        if (t = e.child,
        e.subtreeFlags & 16384 && t !== null)
            t.return = e,
            e = t;
        else {
            if (e === n)
                break;
            for (; e.sibling === null; ) {
                if (e.return === null || e.return === n)
                    return !0;
                e = e.return
            }
            e.sibling.return = e.return,
            e = e.sibling
        }
    }
    return !0
}
function sc(n, e) {
    for (e &= ~SS,
    e &= ~l_,
    n.suspendedLanes |= e,
    n.pingedLanes &= ~e,
    n = n.expirationTimes; 0 < e; ) {
        var t = 31 - Ml(e)
          , r = 1 << t;
        n[t] = -1,
        e &= ~r
    }
}
function vC(n) {
    if (xr & 6)
        throw Error(mt(327));
    rh();
    var e = Sv(n, 0);
    if (!(e & 1))
        return $o(n, Zi()),
        null;
    var t = Gv(n, e);
    if (n.tag !== 0 && t === 2) {
        var r = i1(n);
        r !== 0 && (e = r,
        t = B1(n, r))
    }
    if (t === 1)
        throw t = dm,
        Cf(n, 0),
        sc(n, e),
        $o(n, Zi()),
        t;
    if (t === 6)
        throw Error(mt(345));
    return n.finishedWork = n.current.alternate,
    n.finishedLanes = e,
    af(n, Ko, cu),
    $o(n, Zi()),
    null
}
function AS(n, e) {
    var t = xr;
    xr |= 1;
    try {
        return n(e)
    } finally {
        xr = t,
        xr === 0 && (ph = Zi() + 500,
        i_ && Fc())
    }
}
function Gf(n) {
    ac !== null && ac.tag === 0 && !(xr & 6) && rh();
    var e = xr;
    xr |= 1;
    var t = Ya.transition
      , r = Gr;
    try {
        if (Ya.transition = null,
        Gr = 1,
        n)
            return n()
    } finally {
        Gr = r,
        Ya.transition = t,
        xr = e,
        !(xr & 6) && Fc()
    }
}
function CS() {
    ha = Vd.current,
    vi(Vd)
}
function Cf(n, e) {
    n.finishedWork = null,
    n.finishedLanes = 0;
    var t = n.timeoutHandle;
    if (t !== -1 && (n.timeoutHandle = -1,
    pI(t)),
    os !== null)
        for (t = os.return; t !== null; ) {
            var r = t;
            switch (sS(r),
            r.tag) {
            case 1:
                r = r.type.childContextTypes,
                r != null && bv();
                break;
            case 3:
                dh(),
                vi(Qo),
                vi(ao),
                pS();
                break;
            case 5:
                hS(r);
                break;
            case 4:
                dh();
                break;
            case 13:
                vi(Li);
                break;
            case 19:
                vi(Li);
                break;
            case 10:
                uS(r.type._context);
                break;
            case 22:
            case 23:
                CS()
            }
            t = t.return
        }
    if (Rs = n,
    os = n = wc(n.current, null),
    Vs = ha = e,
    gs = 0,
    dm = null,
    SS = l_ = zf = 0,
    Ko = kp = null,
    vf !== null) {
        for (e = 0; e < vf.length; e++)
            if (t = vf[e],
            r = t.interleaved,
            r !== null) {
                t.interleaved = null;
                var i = r.next
                  , s = t.pending;
                if (s !== null) {
                    var o = s.next;
                    s.next = i,
                    r.next = o
                }
                t.pending = r
            }
        vf = null
    }
    return n
}
function WD(n, e) {
    do {
        var t = os;
        try {
            if (lS(),
            K0.current = kv,
            Fv) {
                for (var r = ki.memoizedState; r !== null; ) {
                    var i = r.queue;
                    i !== null && (i.pending = null),
                    r = r.next
                }
                Fv = !1
            }
            if (Nf = 0,
            Ps = ps = ki = null,
            Lp = !1,
            um = 0,
            wS.current = null,
            t === null || t.return === null) {
                gs = 1,
                dm = e,
                os = null;
                break
            }
            e: {
                var s = n
                  , o = t.return
                  , a = t
                  , l = e;
                if (e = Vs,
                a.flags |= 32768,
                l !== null && typeof l == "object" && typeof l.then == "function") {
                    var f = l
                      , h = a
                      , d = h.tag;
                    if (!(h.mode & 1) && (d === 0 || d === 11 || d === 15)) {
                        var p = h.alternate;
                        p ? (h.updateQueue = p.updateQueue,
                        h.memoizedState = p.memoizedState,
                        h.lanes = p.lanes) : (h.updateQueue = null,
                        h.memoizedState = null)
                    }
                    var m = iC(o);
                    if (m !== null) {
                        m.flags &= -257,
                        sC(m, o, a, s, e),
                        m.mode & 1 && rC(s, f, e),
                        e = m,
                        l = f;
                        var _ = e.updateQueue;
                        if (_ === null) {
                            var y = new Set;
                            y.add(l),
                            e.updateQueue = y
                        } else
                            _.add(l);
                        break e
                    } else {
                        if (!(e & 1)) {
                            rC(s, f, e),
                            ES();
                            break e
                        }
                        l = Error(mt(426))
                    }
                } else if (Ai && a.mode & 1) {
                    var x = iC(o);
                    if (x !== null) {
                        !(x.flags & 65536) && (x.flags |= 256),
                        sC(x, o, a, s, e),
                        oS(hh(l, a));
                        break e
                    }
                }
                s = l = hh(l, a),
                gs !== 4 && (gs = 2),
                kp === null ? kp = [s] : kp.push(s),
                s = o;
                do {
                    switch (s.tag) {
                    case 3:
                        s.flags |= 65536,
                        e &= -e,
                        s.lanes |= e;
                        var S = bD(s, l, e);
                        qA(s, S);
                        break e;
                    case 1:
                        a = l;
                        var M = s.type
                          , w = s.stateNode;
                        if (!(s.flags & 128) && (typeof M.getDerivedStateFromError == "function" || w !== null && typeof w.componentDidCatch == "function" && (yc === null || !yc.has(w)))) {
                            s.flags |= 65536,
                            e &= -e,
                            s.lanes |= e;
                            var T = TD(s, a, e);
                            qA(s, T);
                            break e
                        }
                    }
                    s = s.return
                } while (s !== null)
            }
            jD(t)
        } catch (P) {
            e = P,
            os === t && t !== null && (os = t = t.return);
            continue
        }
        break
    } while (1)
}
function XD() {
    var n = Ov.current;
    return Ov.current = kv,
    n === null ? kv : n
}
function ES() {
    (gs === 0 || gs === 3 || gs === 2) && (gs = 4),
    Rs === null || !(zf & 268435455) && !(l_ & 268435455) || sc(Rs, Vs)
}
function Gv(n, e) {
    var t = xr;
    xr |= 2;
    var r = XD();
    (Rs !== n || Vs !== e) && (cu = null,
    Cf(n, e));
    do
        try {
            zI();
            break
        } catch (i) {
            WD(n, i)
        }
    while (1);
    if (lS(),
    xr = t,
    Ov.current = r,
    os !== null)
        throw Error(mt(261));
    return Rs = null,
    Vs = 0,
    gs
}
function zI() {
    for (; os !== null; )
        JD(os)
}
function GI() {
    for (; os !== null && !fB(); )
        JD(os)
}
function JD(n) {
    var e = KD(n.alternate, n, ha);
    n.memoizedProps = n.pendingProps,
    e === null ? jD(n) : os = e,
    wS.current = null
}
function jD(n) {
    var e = n;
    do {
        var t = e.alternate;
        if (n = e.return,
        e.flags & 32768) {
            if (t = II(t, e),
            t !== null) {
                t.flags &= 32767,
                os = t;
                return
            }
            if (n !== null)
                n.flags |= 32768,
                n.subtreeFlags = 0,
                n.deletions = null;
            else {
                gs = 6,
                os = null;
                return
            }
        } else if (t = BI(t, e, ha),
        t !== null) {
            os = t;
            return
        }
        if (e = e.sibling,
        e !== null) {
            os = e;
            return
        }
        os = e = n
    } while (e !== null);
    gs === 0 && (gs = 5)
}
function af(n, e, t) {
    var r = Gr
      , i = Ya.transition;
    try {
        Ya.transition = null,
        Gr = 1,
        UI(n, e, t, r)
    } finally {
        Ya.transition = i,
        Gr = r
    }
    return null
}
function UI(n, e, t, r) {
    do
        rh();
    while (ac !== null);
    if (xr & 6)
        throw Error(mt(327));
    t = n.finishedWork;
    var i = n.finishedLanes;
    if (t === null)
        return null;
    if (n.finishedWork = null,
    n.finishedLanes = 0,
    t === n.current)
        throw Error(mt(177));
    n.callbackNode = null,
    n.callbackPriority = 0;
    var s = t.lanes | t.childLanes;
    if (wB(n, s),
    n === Rs && (os = Rs = null,
    Vs = 0),
    !(t.subtreeFlags & 2064) && !(t.flags & 2064) || Lg || (Lg = !0,
    qD(wv, function() {
        return rh(),
        null
    })),
    s = (t.flags & 15990) !== 0,
    t.subtreeFlags & 15990 || s) {
        s = Ya.transition,
        Ya.transition = null;
        var o = Gr;
        Gr = 1;
        var a = xr;
        xr |= 4,
        wS.current = null,
        FI(n, t),
        UD(t, n),
        aI(c1),
        Mv = !!u1,
        c1 = u1 = null,
        n.current = t,
        kI(t),
        dB(),
        xr = a,
        Gr = o,
        Ya.transition = s
    } else
        n.current = t;
    if (Lg && (Lg = !1,
    ac = n,
    zv = i),
    s = n.pendingLanes,
    s === 0 && (yc = null),
    mB(t.stateNode),
    $o(n, Zi()),
    e !== null)
        for (r = n.onRecoverableError,
        t = 0; t < e.length; t++)
            i = e[t],
            r(i.value, {
                componentStack: i.stack,
                digest: i.digest
            });
    if (Nv)
        throw Nv = !1,
        n = P1,
        P1 = null,
        n;
    return zv & 1 && n.tag !== 0 && rh(),
    s = n.pendingLanes,
    s & 1 ? n === R1 ? Op++ : (Op = 0,
    R1 = n) : Op = 0,
    Fc(),
    null
}
function rh() {
    if (ac !== null) {
        var n = ET(zv)
          , e = Ya.transition
          , t = Gr;
        try {
            if (Ya.transition = null,
            Gr = 16 > n ? 16 : n,
            ac === null)
                var r = !1;
            else {
                if (n = ac,
                ac = null,
                zv = 0,
                xr & 6)
                    throw Error(mt(331));
                var i = xr;
                for (xr |= 4,
                Kt = n.current; Kt !== null; ) {
                    var s = Kt
                      , o = s.child;
                    if (Kt.flags & 16) {
                        var a = s.deletions;
                        if (a !== null) {
                            for (var l = 0; l < a.length; l++) {
                                var f = a[l];
                                for (Kt = f; Kt !== null; ) {
                                    var h = Kt;
                                    switch (h.tag) {
                                    case 0:
                                    case 11:
                                    case 15:
                                        Fp(8, h, s)
                                    }
                                    var d = h.child;
                                    if (d !== null)
                                        d.return = h,
                                        Kt = d;
                                    else
                                        for (; Kt !== null; ) {
                                            h = Kt;
                                            var p = h.sibling
                                              , m = h.return;
                                            if (ND(h),
                                            h === f) {
                                                Kt = null;
                                                break
                                            }
                                            if (p !== null) {
                                                p.return = m,
                                                Kt = p;
                                                break
                                            }
                                            Kt = m
                                        }
                                }
                            }
                            var _ = s.alternate;
                            if (_ !== null) {
                                var y = _.child;
                                if (y !== null) {
                                    _.child = null;
                                    do {
                                        var x = y.sibling;
                                        y.sibling = null,
                                        y = x
                                    } while (y !== null)
                                }
                            }
                            Kt = s
                        }
                    }
                    if (s.subtreeFlags & 2064 && o !== null)
                        o.return = s,
                        Kt = o;
                    else
                        e: for (; Kt !== null; ) {
                            if (s = Kt,
                            s.flags & 2048)
                                switch (s.tag) {
                                case 0:
                                case 11:
                                case 15:
                                    Fp(9, s, s.return)
                                }
                            var S = s.sibling;
                            if (S !== null) {
                                S.return = s.return,
                                Kt = S;
                                break e
                            }
                            Kt = s.return
                        }
                }
                var M = n.current;
                for (Kt = M; Kt !== null; ) {
                    o = Kt;
                    var w = o.child;
                    if (o.subtreeFlags & 2064 && w !== null)
                        w.return = o,
                        Kt = w;
                    else
                        e: for (o = M; Kt !== null; ) {
                            if (a = Kt,
                            a.flags & 2048)
                                try {
                                    switch (a.tag) {
                                    case 0:
                                    case 11:
                                    case 15:
                                        a_(9, a)
                                    }
                                } catch (P) {
                                    Xi(a, a.return, P)
                                }
                            if (a === o) {
                                Kt = null;
                                break e
                            }
                            var T = a.sibling;
                            if (T !== null) {
                                T.return = a.return,
                                Kt = T;
                                break e
                            }
                            Kt = a.return
                        }
                }
                if (xr = i,
                Fc(),
                Wl && typeof Wl.onPostCommitFiberRoot == "function")
                    try {
                        Wl.onPostCommitFiberRoot($v, n)
                    } catch {}
                r = !0
            }
            return r
        } finally {
            Gr = t,
            Ya.transition = e
        }
    }
    return !1
}
function _C(n, e, t) {
    e = hh(t, e),
    e = bD(n, e, 1),
    n = _c(n, e, 1),
    e = To(),
    n !== null && (Pm(n, 1, e),
    $o(n, e))
}
function Xi(n, e, t) {
    if (n.tag === 3)
        _C(n, n, t);
    else
        for (; e !== null; ) {
            if (e.tag === 3) {
                _C(e, n, t);
                break
            } else if (e.tag === 1) {
                var r = e.stateNode;
                if (typeof e.type.getDerivedStateFromError == "function" || typeof r.componentDidCatch == "function" && (yc === null || !yc.has(r))) {
                    n = hh(t, n),
                    n = TD(e, n, 1),
                    e = _c(e, n, 1),
                    n = To(),
                    e !== null && (Pm(e, 1, n),
                    $o(e, n));
                    break
                }
            }
            e = e.return
        }
}
function HI(n, e, t) {
    var r = n.pingCache;
    r !== null && r.delete(e),
    e = To(),
    n.pingedLanes |= n.suspendedLanes & t,
    Rs === n && (Vs & t) === t && (gs === 4 || gs === 3 && (Vs & 130023424) === Vs && 500 > Zi() - MS ? Cf(n, 0) : SS |= t),
    $o(n, e)
}
function YD(n, e) {
    e === 0 && (n.mode & 1 ? (e = Ag,
    Ag <<= 1,
    !(Ag & 130023424) && (Ag = 4194304)) : e = 1);
    var t = To();
    n = Eu(n, e),
    n !== null && (Pm(n, e, t),
    $o(n, t))
}
function VI(n) {
    var e = n.memoizedState
      , t = 0;
    e !== null && (t = e.retryLane),
    YD(n, t)
}
function WI(n, e) {
    var t = 0;
    switch (n.tag) {
    case 13:
        var r = n.stateNode
          , i = n.memoizedState;
        i !== null && (t = i.retryLane);
        break;
    case 19:
        r = n.stateNode;
        break;
    default:
        throw Error(mt(314))
    }
    r !== null && r.delete(e),
    YD(n, t)
}
var KD;
KD = function(n, e, t) {
    if (n !== null)
        if (n.memoizedProps !== e.pendingProps || Qo.current)
            qo = !0;
        else {
            if (!(n.lanes & t) && !(e.flags & 128))
                return qo = !1,
                RI(n, e, t);
            qo = !!(n.flags & 131072)
        }
    else
        qo = !1,
        Ai && e.flags & 1048576 && ZT(e, Pv, e.index);
    switch (e.lanes = 0,
    e.tag) {
    case 2:
        var r = e.type;
        Q0(n, e),
        n = e.pendingProps;
        var i = uh(e, ao.current);
        nh(e, t),
        i = gS(null, e, r, n, i, t);
        var s = vS();
        return e.flags |= 1,
        typeof i == "object" && i !== null && typeof i.render == "function" && i.$$typeof === void 0 ? (e.tag = 1,
        e.memoizedState = null,
        e.updateQueue = null,
        Zo(r) ? (s = !0,
        Tv(e)) : s = !1,
        e.memoizedState = i.state !== null && i.state !== void 0 ? i.state : null,
        fS(e),
        i.updater = s_,
        e.stateNode = i,
        i._reactInternals = e,
        y1(e, r, n, t),
        e = S1(null, e, r, !0, s, t)) : (e.tag = 0,
        Ai && s && iS(e),
        So(null, e, i, t),
        e = e.child),
        e;
    case 16:
        r = e.elementType;
        e: {
            switch (Q0(n, e),
            n = e.pendingProps,
            i = r._init,
            r = i(r._payload),
            e.type = r,
            i = e.tag = JI(r),
            n = hl(r, n),
            i) {
            case 0:
                e = w1(null, e, r, n, t);
                break e;
            case 1:
                e = lC(null, e, r, n, t);
                break e;
            case 11:
                e = oC(null, e, r, n, t);
                break e;
            case 14:
                e = aC(null, e, r, hl(r.type, n), t);
                break e
            }
            throw Error(mt(306, r, ""))
        }
        return e;
    case 0:
        return r = e.type,
        i = e.pendingProps,
        i = e.elementType === r ? i : hl(r, i),
        w1(n, e, r, i, t);
    case 1:
        return r = e.type,
        i = e.pendingProps,
        i = e.elementType === r ? i : hl(r, i),
        lC(n, e, r, i, t);
    case 3:
        e: {
            if (BD(e),
            n === null)
                throw Error(mt(387));
            r = e.pendingProps,
            s = e.memoizedState,
            i = s.element,
            nD(n, e),
            Iv(e, r, null, t);
            var o = e.memoizedState;
            if (r = o.element,
            s.isDehydrated)
                if (s = {
                    element: r,
                    isDehydrated: !1,
                    cache: o.cache,
                    pendingSuspenseBoundaries: o.pendingSuspenseBoundaries,
                    transitions: o.transitions
                },
                e.updateQueue.baseState = s,
                e.memoizedState = s,
                e.flags & 256) {
                    i = hh(Error(mt(423)), e),
                    e = uC(n, e, r, t, i);
                    break e
                } else if (r !== i) {
                    i = hh(Error(mt(424)), e),
                    e = uC(n, e, r, t, i);
                    break e
                } else
                    for (_a = vc(e.stateNode.containerInfo.firstChild),
                    wa = e,
                    Ai = !0,
                    _l = null,
                    t = oD(e, null, r, t),
                    e.child = t; t; )
                        t.flags = t.flags & -3 | 4096,
                        t = t.sibling;
            else {
                if (ch(),
                r === i) {
                    e = bu(n, e, t);
                    break e
                }
                So(n, e, r, t)
            }
            e = e.child
        }
        return e;
    case 5:
        return aD(e),
        n === null && g1(e),
        r = e.type,
        i = e.pendingProps,
        s = n !== null ? n.memoizedProps : null,
        o = i.children,
        f1(r, i) ? o = null : s !== null && f1(r, s) && (e.flags |= 32),
        RD(n, e),
        So(n, e, o, t),
        e.child;
    case 6:
        return n === null && g1(e),
        null;
    case 13:
        return ID(n, e, t);
    case 4:
        return dS(e, e.stateNode.containerInfo),
        r = e.pendingProps,
        n === null ? e.child = fh(e, null, r, t) : So(n, e, r, t),
        e.child;
    case 11:
        return r = e.type,
        i = e.pendingProps,
        i = e.elementType === r ? i : hl(r, i),
        oC(n, e, r, i, t);
    case 7:
        return So(n, e, e.pendingProps, t),
        e.child;
    case 8:
        return So(n, e, e.pendingProps.children, t),
        e.child;
    case 12:
        return So(n, e, e.pendingProps.children, t),
        e.child;
    case 10:
        e: {
            if (r = e.type._context,
            i = e.pendingProps,
            s = e.memoizedProps,
            o = i.value,
            fi(Rv, r._currentValue),
            r._currentValue = o,
            s !== null)
                if (Cl(s.value, o)) {
                    if (s.children === i.children && !Qo.current) {
                        e = bu(n, e, t);
                        break e
                    }
                } else
                    for (s = e.child,
                    s !== null && (s.return = e); s !== null; ) {
                        var a = s.dependencies;
                        if (a !== null) {
                            o = s.child;
                            for (var l = a.firstContext; l !== null; ) {
                                if (l.context === r) {
                                    if (s.tag === 1) {
                                        l = wu(-1, t & -t),
                                        l.tag = 2;
                                        var f = s.updateQueue;
                                        if (f !== null) {
                                            f = f.shared;
                                            var h = f.pending;
                                            h === null ? l.next = l : (l.next = h.next,
                                            h.next = l),
                                            f.pending = l
                                        }
                                    }
                                    s.lanes |= t,
                                    l = s.alternate,
                                    l !== null && (l.lanes |= t),
                                    v1(s.return, t, e),
                                    a.lanes |= t;
                                    break
                                }
                                l = l.next
                            }
                        } else if (s.tag === 10)
                            o = s.type === e.type ? null : s.child;
                        else if (s.tag === 18) {
                            if (o = s.return,
                            o === null)
                                throw Error(mt(341));
                            o.lanes |= t,
                            a = o.alternate,
                            a !== null && (a.lanes |= t),
                            v1(o, t, e),
                            o = s.sibling
                        } else
                            o = s.child;
                        if (o !== null)
                            o.return = s;
                        else
                            for (o = s; o !== null; ) {
                                if (o === e) {
                                    o = null;
                                    break
                                }
                                if (s = o.sibling,
                                s !== null) {
                                    s.return = o.return,
                                    o = s;
                                    break
                                }
                                o = o.return
                            }
                        s = o
                    }
            So(n, e, i.children, t),
            e = e.child
        }
        return e;
    case 9:
        return i = e.type,
        r = e.pendingProps.children,
        nh(e, t),
        i = Qa(i),
        r = r(i),
        e.flags |= 1,
        So(n, e, r, t),
        e.child;
    case 14:
        return r = e.type,
        i = hl(r, e.pendingProps),
        i = hl(r.type, i),
        aC(n, e, r, i, t);
    case 15:
        return DD(n, e, e.type, e.pendingProps, t);
    case 17:
        return r = e.type,
        i = e.pendingProps,
        i = e.elementType === r ? i : hl(r, i),
        Q0(n, e),
        e.tag = 1,
        Zo(r) ? (n = !0,
        Tv(e)) : n = !1,
        nh(e, t),
        iD(e, r, i),
        y1(e, r, i, t),
        S1(null, e, r, !0, n, t);
    case 19:
        return LD(n, e, t);
    case 22:
        return PD(n, e, t)
    }
    throw Error(mt(156, e.tag))
}
;
function qD(n, e) {
    return ST(n, e)
}
function XI(n, e, t, r) {
    this.tag = n,
    this.key = t,
    this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null,
    this.index = 0,
    this.ref = null,
    this.pendingProps = e,
    this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null,
    this.mode = r,
    this.subtreeFlags = this.flags = 0,
    this.deletions = null,
    this.childLanes = this.lanes = 0,
    this.alternate = null
}
function Ja(n, e, t, r) {
    return new XI(n,e,t,r)
}
function bS(n) {
    return n = n.prototype,
    !(!n || !n.isReactComponent)
}
function JI(n) {
    if (typeof n == "function")
        return bS(n) ? 1 : 0;
    if (n != null) {
        if (n = n.$$typeof,
        n === Jw)
            return 11;
        if (n === jw)
            return 14
    }
    return 2
}
function wc(n, e) {
    var t = n.alternate;
    return t === null ? (t = Ja(n.tag, e, n.key, n.mode),
    t.elementType = n.elementType,
    t.type = n.type,
    t.stateNode = n.stateNode,
    t.alternate = n,
    n.alternate = t) : (t.pendingProps = e,
    t.type = n.type,
    t.flags = 0,
    t.subtreeFlags = 0,
    t.deletions = null),
    t.flags = n.flags & 14680064,
    t.childLanes = n.childLanes,
    t.lanes = n.lanes,
    t.child = n.child,
    t.memoizedProps = n.memoizedProps,
    t.memoizedState = n.memoizedState,
    t.updateQueue = n.updateQueue,
    e = n.dependencies,
    t.dependencies = e === null ? null : {
        lanes: e.lanes,
        firstContext: e.firstContext
    },
    t.sibling = n.sibling,
    t.index = n.index,
    t.ref = n.ref,
    t
}
function ev(n, e, t, r, i, s) {
    var o = 2;
    if (r = n,
    typeof n == "function")
        bS(n) && (o = 1);
    else if (typeof n == "string")
        o = 5;
    else
        e: switch (n) {
        case Id:
            return Ef(t.children, i, s, e);
        case Xw:
            o = 8,
            i |= 8;
            break;
        case Vx:
            return n = Ja(12, t, e, i | 2),
            n.elementType = Vx,
            n.lanes = s,
            n;
        case Wx:
            return n = Ja(13, t, e, i),
            n.elementType = Wx,
            n.lanes = s,
            n;
        case Xx:
            return n = Ja(19, t, e, i),
            n.elementType = Xx,
            n.lanes = s,
            n;
        case sT:
            return u_(t, i, s, e);
        default:
            if (typeof n == "object" && n !== null)
                switch (n.$$typeof) {
                case rT:
                    o = 10;
                    break e;
                case iT:
                    o = 9;
                    break e;
                case Jw:
                    o = 11;
                    break e;
                case jw:
                    o = 14;
                    break e;
                case tc:
                    o = 16,
                    r = null;
                    break e
                }
            throw Error(mt(130, n == null ? n : typeof n, ""))
        }
    return e = Ja(o, t, e, i),
    e.elementType = n,
    e.type = r,
    e.lanes = s,
    e
}
function Ef(n, e, t, r) {
    return n = Ja(7, n, r, e),
    n.lanes = t,
    n
}
function u_(n, e, t, r) {
    return n = Ja(22, n, r, e),
    n.elementType = sT,
    n.lanes = t,
    n.stateNode = {
        isHidden: !1
    },
    n
}
function Iy(n, e, t) {
    return n = Ja(6, n, null, e),
    n.lanes = t,
    n
}
function Ly(n, e, t) {
    return e = Ja(4, n.children !== null ? n.children : [], n.key, e),
    e.lanes = t,
    e.stateNode = {
        containerInfo: n.containerInfo,
        pendingChildren: null,
        implementation: n.implementation
    },
    e
}
function jI(n, e, t, r, i) {
    this.tag = e,
    this.containerInfo = n,
    this.finishedWork = this.pingCache = this.current = this.pendingChildren = null,
    this.timeoutHandle = -1,
    this.callbackNode = this.pendingContext = this.context = null,
    this.callbackPriority = 0,
    this.eventTimes = py(0),
    this.expirationTimes = py(-1),
    this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0,
    this.entanglements = py(0),
    this.identifierPrefix = r,
    this.onRecoverableError = i,
    this.mutableSourceEagerHydrationData = null
}
function TS(n, e, t, r, i, s, o, a, l) {
    return n = new jI(n,e,t,a,l),
    e === 1 ? (e = 1,
    s === !0 && (e |= 8)) : e = 0,
    s = Ja(3, null, null, e),
    n.current = s,
    s.stateNode = n,
    s.memoizedState = {
        element: r,
        isDehydrated: t,
        cache: null,
        transitions: null,
        pendingSuspenseBoundaries: null
    },
    fS(s),
    n
}
function YI(n, e, t) {
    var r = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
    return {
        $$typeof: Bd,
        key: r == null ? null : "" + r,
        children: n,
        containerInfo: e,
        implementation: t
    }
}
function QD(n) {
    if (!n)
        return Cc;
    n = n._reactInternals;
    e: {
        if (Qf(n) !== n || n.tag !== 1)
            throw Error(mt(170));
        var e = n;
        do {
            switch (e.tag) {
            case 3:
                e = e.stateNode.context;
                break e;
            case 1:
                if (Zo(e.type)) {
                    e = e.stateNode.__reactInternalMemoizedMergedChildContext;
                    break e
                }
            }
            e = e.return
        } while (e !== null);
        throw Error(mt(171))
    }
    if (n.tag === 1) {
        var t = n.type;
        if (Zo(t))
            return qT(n, t, e)
    }
    return e
}
function ZD(n, e, t, r, i, s, o, a, l) {
    return n = TS(t, r, !0, n, i, s, o, a, l),
    n.context = QD(null),
    t = n.current,
    r = To(),
    i = xc(t),
    s = wu(r, i),
    s.callback = e ?? null,
    _c(t, s, i),
    n.current.lanes = i,
    Pm(n, i, r),
    $o(n, r),
    n
}
function c_(n, e, t, r) {
    var i = e.current
      , s = To()
      , o = xc(i);
    return t = QD(t),
    e.context === null ? e.context = t : e.pendingContext = t,
    e = wu(s, o),
    e.payload = {
        element: n
    },
    r = r === void 0 ? null : r,
    r !== null && (e.callback = r),
    n = _c(i, e, o),
    n !== null && (Al(n, i, o, s),
    Y0(n, i, o)),
    o
}
function Uv(n) {
    if (n = n.current,
    !n.child)
        return null;
    switch (n.child.tag) {
    case 5:
        return n.child.stateNode;
    default:
        return n.child.stateNode
    }
}
function yC(n, e) {
    if (n = n.memoizedState,
    n !== null && n.dehydrated !== null) {
        var t = n.retryLane;
        n.retryLane = t !== 0 && t < e ? t : e
    }
}
function DS(n, e) {
    yC(n, e),
    (n = n.alternate) && yC(n, e)
}
function KI() {
    return null
}
var $D = typeof reportError == "function" ? reportError : function(n) {
    console.error(n)
}
;
function PS(n) {
    this._internalRoot = n
}
f_.prototype.render = PS.prototype.render = function(n) {
    var e = this._internalRoot;
    if (e === null)
        throw Error(mt(409));
    c_(n, e, null, null)
}
;
f_.prototype.unmount = PS.prototype.unmount = function() {
    var n = this._internalRoot;
    if (n !== null) {
        this._internalRoot = null;
        var e = n.containerInfo;
        Gf(function() {
            c_(null, n, null, null)
        }),
        e[Cu] = null
    }
}
;
function f_(n) {
    this._internalRoot = n
}
f_.prototype.unstable_scheduleHydration = function(n) {
    if (n) {
        var e = DT();
        n = {
            blockedOn: null,
            target: n,
            priority: e
        };
        for (var t = 0; t < ic.length && e !== 0 && e < ic[t].priority; t++)
            ;
        ic.splice(t, 0, n),
        t === 0 && RT(n)
    }
}
;
function RS(n) {
    return !(!n || n.nodeType !== 1 && n.nodeType !== 9 && n.nodeType !== 11)
}
function d_(n) {
    return !(!n || n.nodeType !== 1 && n.nodeType !== 9 && n.nodeType !== 11 && (n.nodeType !== 8 || n.nodeValue !== " react-mount-point-unstable "))
}
function xC() {}
function qI(n, e, t, r, i) {
    if (i) {
        if (typeof r == "function") {
            var s = r;
            r = function() {
                var f = Uv(o);
                s.call(f)
            }
        }
        var o = ZD(e, r, n, 0, null, !1, !1, "", xC);
        return n._reactRootContainer = o,
        n[Cu] = o.current,
        im(n.nodeType === 8 ? n.parentNode : n),
        Gf(),
        o
    }
    for (; i = n.lastChild; )
        n.removeChild(i);
    if (typeof r == "function") {
        var a = r;
        r = function() {
            var f = Uv(l);
            a.call(f)
        }
    }
    var l = TS(n, 0, !1, null, null, !1, !1, "", xC);
    return n._reactRootContainer = l,
    n[Cu] = l.current,
    im(n.nodeType === 8 ? n.parentNode : n),
    Gf(function() {
        c_(e, l, t, r)
    }),
    l
}
function h_(n, e, t, r, i) {
    var s = t._reactRootContainer;
    if (s) {
        var o = s;
        if (typeof i == "function") {
            var a = i;
            i = function() {
                var l = Uv(o);
                a.call(l)
            }
        }
        c_(e, o, n, i)
    } else
        o = qI(t, e, n, i, r);
    return Uv(o)
}
bT = function(n) {
    switch (n.tag) {
    case 3:
        var e = n.stateNode;
        if (e.current.memoizedState.isDehydrated) {
            var t = wp(e.pendingLanes);
            t !== 0 && (qw(e, t | 1),
            $o(e, Zi()),
            !(xr & 6) && (ph = Zi() + 500,
            Fc()))
        }
        break;
    case 13:
        Gf(function() {
            var r = Eu(n, 1);
            if (r !== null) {
                var i = To();
                Al(r, n, 1, i)
            }
        }),
        DS(n, 1)
    }
}
;
Qw = function(n) {
    if (n.tag === 13) {
        var e = Eu(n, 134217728);
        if (e !== null) {
            var t = To();
            Al(e, n, 134217728, t)
        }
        DS(n, 134217728)
    }
}
;
TT = function(n) {
    if (n.tag === 13) {
        var e = xc(n)
          , t = Eu(n, e);
        if (t !== null) {
            var r = To();
            Al(t, n, e, r)
        }
        DS(n, e)
    }
}
;
DT = function() {
    return Gr
}
;
PT = function(n, e) {
    var t = Gr;
    try {
        return Gr = n,
        e()
    } finally {
        Gr = t
    }
}
;
t1 = function(n, e, t) {
    switch (e) {
    case "input":
        if (Yx(n, t),
        e = t.name,
        t.type === "radio" && e != null) {
            for (t = n; t.parentNode; )
                t = t.parentNode;
            for (t = t.querySelectorAll("input[name=" + JSON.stringify("" + e) + '][type="radio"]'),
            e = 0; e < t.length; e++) {
                var r = t[e];
                if (r !== n && r.form === n.form) {
                    var i = r_(r);
                    if (!i)
                        throw Error(mt(90));
                    aT(r),
                    Yx(r, i)
                }
            }
        }
        break;
    case "textarea":
        uT(n, t);
        break;
    case "select":
        e = t.value,
        e != null && Zd(n, !!t.multiple, e, !1)
    }
}
;
gT = AS;
vT = Gf;
var QI = {
    usingClientEntryPoint: !1,
    Events: [Bm, Od, r_, pT, mT, AS]
}
  , Qh = {
    findFiberByHostInstance: gf,
    bundleType: 0,
    version: "18.2.0",
    rendererPackageName: "react-dom"
}
  , ZI = {
    bundleType: Qh.bundleType,
    version: Qh.version,
    rendererPackageName: Qh.rendererPackageName,
    rendererConfig: Qh.rendererConfig,
    overrideHookState: null,
    overrideHookStateDeletePath: null,
    overrideHookStateRenamePath: null,
    overrideProps: null,
    overridePropsDeletePath: null,
    overridePropsRenamePath: null,
    setErrorHandler: null,
    setSuspenseHandler: null,
    scheduleUpdate: null,
    currentDispatcherRef: Pu.ReactCurrentDispatcher,
    findHostInstanceByFiber: function(n) {
        return n = xT(n),
        n === null ? null : n.stateNode
    },
    findFiberByHostInstance: Qh.findFiberByHostInstance || KI,
    findHostInstancesForRefresh: null,
    scheduleRefresh: null,
    scheduleRoot: null,
    setRefreshHandler: null,
    getCurrentFiber: null,
    reconcilerVersion: "18.2.0-next-9e3b772b8-20220608"
};
if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
    var Fg = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!Fg.isDisabled && Fg.supportsFiber)
        try {
            $v = Fg.inject(ZI),
            Wl = Fg
        } catch {}
}
Ca.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = QI;
Ca.createPortal = function(n, e) {
    var t = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
    if (!RS(e))
        throw Error(mt(200));
    return YI(n, e, null, t)
}
;
Ca.createRoot = function(n, e) {
    if (!RS(n))
        throw Error(mt(299));
    var t = !1
      , r = ""
      , i = $D;
    return e != null && (e.unstable_strictMode === !0 && (t = !0),
    e.identifierPrefix !== void 0 && (r = e.identifierPrefix),
    e.onRecoverableError !== void 0 && (i = e.onRecoverableError)),
    e = TS(n, 1, !1, null, null, t, !1, r, i),
    n[Cu] = e.current,
    im(n.nodeType === 8 ? n.parentNode : n),
    new PS(e)
}
;
Ca.findDOMNode = function(n) {
    if (n == null)
        return null;
    if (n.nodeType === 1)
        return n;
    var e = n._reactInternals;
    if (e === void 0)
        throw typeof n.render == "function" ? Error(mt(188)) : (n = Object.keys(n).join(","),
        Error(mt(268, n)));
    return n = xT(e),
    n = n === null ? null : n.stateNode,
    n
}
;
Ca.flushSync = function(n) {
    return Gf(n)
}
;
Ca.hydrate = function(n, e, t) {
    if (!d_(e))
        throw Error(mt(200));
    return h_(null, n, e, !0, t)
}
;
Ca.hydrateRoot = function(n, e, t) {
    if (!RS(n))
        throw Error(mt(405));
    var r = t != null && t.hydratedSources || null
      , i = !1
      , s = ""
      , o = $D;
    if (t != null && (t.unstable_strictMode === !0 && (i = !0),
    t.identifierPrefix !== void 0 && (s = t.identifierPrefix),
    t.onRecoverableError !== void 0 && (o = t.onRecoverableError)),
    e = ZD(e, null, n, 1, t ?? null, i, !1, s, o),
    n[Cu] = e.current,
    im(n),
    r)
        for (n = 0; n < r.length; n++)
            t = r[n],
            i = t._getVersion,
            i = i(t._source),
            e.mutableSourceEagerHydrationData == null ? e.mutableSourceEagerHydrationData = [t, i] : e.mutableSourceEagerHydrationData.push(t, i);
    return new f_(e)
}
;
Ca.render = function(n, e, t) {
    if (!d_(e))
        throw Error(mt(200));
    return h_(null, n, e, !1, t)
}
;
Ca.unmountComponentAtNode = function(n) {
    if (!d_(n))
        throw Error(mt(40));
    return n._reactRootContainer ? (Gf(function() {
        h_(null, null, n, !1, function() {
            n._reactRootContainer = null,
            n[Cu] = null
        })
    }),
    !0) : !1
}
;
Ca.unstable_batchedUpdates = AS;
Ca.unstable_renderSubtreeIntoContainer = function(n, e, t, r) {
    if (!d_(t))
        throw Error(mt(200));
    if (n == null || n._reactInternals === void 0)
        throw Error(mt(38));
    return h_(n, e, t, !1, r)
}
;
Ca.version = "18.2.0-next-9e3b772b8-20220608";
(function(n) {
    function e() {
        if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"))
            try {
                __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e)
            } catch (t) {
                console.error(t)
            }
    }
    e(),
    n.exports = Ca
}
)(KR);
var BS, wC = Gx;
BS = wC.createRoot,
wC.hydrateRoot;
/**
 * @license
 * Copyright 2010-2023 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
const p_ = "149"
  , lf = {
    LEFT: 0,
    MIDDLE: 1,
    RIGHT: 2,
    ROTATE: 0,
    DOLLY: 1,
    PAN: 2
}
  , uf = {
    ROTATE: 0,
    PAN: 1,
    DOLLY_PAN: 2,
    DOLLY_ROTATE: 3
}
  , e2 = 0
  , L1 = 1
  , t2 = 2
  , $I = 3
  , n2 = 0
  , m_ = 1
  , Np = 2
  , yf = 3
  , El = 0
  , Do = 1
  , Sl = 2
  , eL = 2
  , Su = 0
  , bf = 1
  , F1 = 2
  , k1 = 3
  , O1 = 4
  , r2 = 5
  , pf = 100
  , i2 = 101
  , s2 = 102
  , N1 = 103
  , z1 = 104
  , o2 = 200
  , a2 = 201
  , l2 = 202
  , u2 = 203
  , IS = 204
  , LS = 205
  , c2 = 206
  , f2 = 207
  , d2 = 208
  , h2 = 209
  , p2 = 210
  , m2 = 0
  , g2 = 1
  , v2 = 2
  , Hv = 3
  , _2 = 4
  , y2 = 5
  , x2 = 6
  , w2 = 7
  , Lm = 0
  , S2 = 1
  , M2 = 2
  , Ka = 0
  , A2 = 1
  , C2 = 2
  , E2 = 3
  , FS = 4
  , b2 = 5
  , g_ = 300
  , Tu = 301
  , Ec = 302
  , mh = 303
  , hm = 304
  , Dh = 306
  , bc = 1e3
  , Us = 1001
  , gh = 1002
  , Ji = 1003
  , pm = 1004
  , tL = 1004
  , ih = 1005
  , nL = 1005
  , si = 1006
  , v_ = 1007
  , rL = 1007
  , Kl = 1008
  , iL = 1008
  , Tc = 1009
  , T2 = 1010
  , D2 = 1011
  , kS = 1012
  , P2 = 1013
  , lc = 1014
  , ya = 1015
  , ja = 1016
  , R2 = 1017
  , B2 = 1018
  , Tf = 1020
  , I2 = 1021
  , ga = 1023
  , L2 = 1024
  , F2 = 1025
  , Sc = 1026
  , Uf = 1027
  , k2 = 1028
  , O2 = 1029
  , N2 = 1030
  , z2 = 1031
  , G2 = 1033
  , tv = 33776
  , nv = 33777
  , rv = 33778
  , iv = 33779
  , G1 = 35840
  , U1 = 35841
  , H1 = 35842
  , V1 = 35843
  , U2 = 36196
  , W1 = 37492
  , X1 = 37496
  , J1 = 37808
  , j1 = 37809
  , Y1 = 37810
  , K1 = 37811
  , q1 = 37812
  , Q1 = 37813
  , Z1 = 37814
  , $1 = 37815
  , ew = 37816
  , tw = 37817
  , nw = 37818
  , rw = 37819
  , iw = 37820
  , sw = 37821
  , sv = 36492
  , H2 = 36283
  , ow = 36284
  , aw = 36285
  , lw = 36286
  , V2 = 2200
  , W2 = 2201
  , X2 = 2202
  , vh = 2300
  , Hf = 2301
  , ov = 2302
  , xf = 2400
  , wf = 2401
  , mm = 2402
  , __ = 2500
  , OS = 2501
  , sL = 0
  , J2 = 1
  , NS = 2
  , bl = 3e3
  , nr = 3001
  , j2 = 3200
  , Y2 = 3201
  , Ru = 0
  , K2 = 1
  , oL = ""
  , gl = "srgb"
  , _h = "srgb-linear"
  , aL = 0
  , av = 7680
  , lL = 7681
  , uL = 7682
  , cL = 7683
  , fL = 34055
  , dL = 34056
  , hL = 5386
  , pL = 512
  , mL = 513
  , gL = 514
  , vL = 515
  , _L = 516
  , yL = 517
  , xL = 518
  , q2 = 519
  , gm = 35044
  , wL = 35048
  , SL = 35040
  , ML = 35045
  , AL = 35049
  , CL = 35041
  , EL = 35046
  , bL = 35050
  , TL = 35042
  , DL = "100"
  , uw = "300 es"
  , Vv = 1035;
class ql {
    addEventListener(e, t) {
        this._listeners === void 0 && (this._listeners = {});
        const r = this._listeners;
        r[e] === void 0 && (r[e] = []),
        r[e].indexOf(t) === -1 && r[e].push(t)
    }
    hasEventListener(e, t) {
        if (this._listeners === void 0)
            return !1;
        const r = this._listeners;
        return r[e] !== void 0 && r[e].indexOf(t) !== -1
    }
    removeEventListener(e, t) {
        if (this._listeners === void 0)
            return;
        const i = this._listeners[e];
        if (i !== void 0) {
            const s = i.indexOf(t);
            s !== -1 && i.splice(s, 1)
        }
    }
    dispatchEvent(e) {
        if (this._listeners === void 0)
            return;
        const r = this._listeners[e.type];
        if (r !== void 0) {
            e.target = this;
            const i = r.slice(0);
            for (let s = 0, o = i.length; s < o; s++)
                i[s].call(this, e);
            e.target = null
        }
    }
}
const no = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
let SC = 1234567;
const Df = Math.PI / 180
  , vm = 180 / Math.PI;
function Sa() {
    const n = Math.random() * 4294967295 | 0
      , e = Math.random() * 4294967295 | 0
      , t = Math.random() * 4294967295 | 0
      , r = Math.random() * 4294967295 | 0;
    return (no[n & 255] + no[n >> 8 & 255] + no[n >> 16 & 255] + no[n >> 24 & 255] + "-" + no[e & 255] + no[e >> 8 & 255] + "-" + no[e >> 16 & 15 | 64] + no[e >> 24 & 255] + "-" + no[t & 63 | 128] + no[t >> 8 & 255] + "-" + no[t >> 16 & 255] + no[t >> 24 & 255] + no[r & 255] + no[r >> 8 & 255] + no[r >> 16 & 255] + no[r >> 24 & 255]).toLowerCase()
}
function $i(n, e, t) {
    return Math.max(e, Math.min(t, n))
}
function zS(n, e) {
    return (n % e + e) % e
}
function PL(n, e, t, r, i) {
    return r + (n - e) * (i - r) / (t - e)
}
function RL(n, e, t) {
    return n !== e ? (t - n) / (e - n) : 0
}
function zp(n, e, t) {
    return (1 - t) * n + t * e
}
function BL(n, e, t, r) {
    return zp(n, e, 1 - Math.exp(-t * r))
}
function IL(n, e=1) {
    return e - Math.abs(zS(n, e * 2) - e)
}
function LL(n, e, t) {
    return n <= e ? 0 : n >= t ? 1 : (n = (n - e) / (t - e),
    n * n * (3 - 2 * n))
}
function FL(n, e, t) {
    return n <= e ? 0 : n >= t ? 1 : (n = (n - e) / (t - e),
    n * n * n * (n * (n * 6 - 15) + 10))
}
function kL(n, e) {
    return n + Math.floor(Math.random() * (e - n + 1))
}
function OL(n, e) {
    return n + Math.random() * (e - n)
}
function NL(n) {
    return n * (.5 - Math.random())
}
function zL(n) {
    n !== void 0 && (SC = n);
    let e = SC += 1831565813;
    return e = Math.imul(e ^ e >>> 15, e | 1),
    e ^= e + Math.imul(e ^ e >>> 7, e | 61),
    ((e ^ e >>> 14) >>> 0) / 4294967296
}
function GL(n) {
    return n * Df
}
function UL(n) {
    return n * vm
}
function cw(n) {
    return (n & n - 1) === 0 && n !== 0
}
function Q2(n) {
    return Math.pow(2, Math.ceil(Math.log(n) / Math.LN2))
}
function Wv(n) {
    return Math.pow(2, Math.floor(Math.log(n) / Math.LN2))
}
function HL(n, e, t, r, i) {
    const s = Math.cos
      , o = Math.sin
      , a = s(t / 2)
      , l = o(t / 2)
      , f = s((e + r) / 2)
      , h = o((e + r) / 2)
      , d = s((e - r) / 2)
      , p = o((e - r) / 2)
      , m = s((r - e) / 2)
      , _ = o((r - e) / 2);
    switch (i) {
    case "XYX":
        n.set(a * h, l * d, l * p, a * f);
        break;
    case "YZY":
        n.set(l * p, a * h, l * d, a * f);
        break;
    case "ZXZ":
        n.set(l * d, l * p, a * h, a * f);
        break;
    case "XZX":
        n.set(a * h, l * _, l * m, a * f);
        break;
    case "YXY":
        n.set(l * m, a * h, l * _, a * f);
        break;
    case "ZYZ":
        n.set(l * _, l * m, a * h, a * f);
        break;
    default:
        console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + i)
    }
}
function vu(n, e) {
    switch (e.constructor) {
    case Float32Array:
        return n;
    case Uint16Array:
        return n / 65535;
    case Uint8Array:
        return n / 255;
    case Int16Array:
        return Math.max(n / 32767, -1);
    case Int8Array:
        return Math.max(n / 127, -1);
    default:
        throw new Error("Invalid component type.")
    }
}
function ii(n, e) {
    switch (e.constructor) {
    case Float32Array:
        return n;
    case Uint16Array:
        return Math.round(n * 65535);
    case Uint8Array:
        return Math.round(n * 255);
    case Int16Array:
        return Math.round(n * 32767);
    case Int8Array:
        return Math.round(n * 127);
    default:
        throw new Error("Invalid component type.")
    }
}
var y_ = Object.freeze({
    __proto__: null,
    DEG2RAD: Df,
    RAD2DEG: vm,
    ceilPowerOfTwo: Q2,
    clamp: $i,
    damp: BL,
    degToRad: GL,
    denormalize: vu,
    euclideanModulo: zS,
    floorPowerOfTwo: Wv,
    generateUUID: Sa,
    inverseLerp: RL,
    isPowerOfTwo: cw,
    lerp: zp,
    mapLinear: PL,
    normalize: ii,
    pingpong: IL,
    radToDeg: UL,
    randFloat: OL,
    randFloatSpread: NL,
    randInt: kL,
    seededRandom: zL,
    setQuaternionFromProperEuler: HL,
    smootherstep: FL,
    smoothstep: LL
});
class it {
    constructor(e=0, t=0) {
        it.prototype.isVector2 = !0,
        this.x = e,
        this.y = t
    }
    get width() {
        return this.x
    }
    set width(e) {
        this.x = e
    }
    get height() {
        return this.y
    }
    set height(e) {
        this.y = e
    }
    set(e, t) {
        return this.x = e,
        this.y = t,
        this
    }
    setScalar(e) {
        return this.x = e,
        this.y = e,
        this
    }
    setX(e) {
        return this.x = e,
        this
    }
    setY(e) {
        return this.y = e,
        this
    }
    setComponent(e, t) {
        switch (e) {
        case 0:
            this.x = t;
            break;
        case 1:
            this.y = t;
            break;
        default:
            throw new Error("index is out of range: " + e)
        }
        return this
    }
    getComponent(e) {
        switch (e) {
        case 0:
            return this.x;
        case 1:
            return this.y;
        default:
            throw new Error("index is out of range: " + e)
        }
    }
    clone() {
        return new this.constructor(this.x,this.y)
    }
    copy(e) {
        return this.x = e.x,
        this.y = e.y,
        this
    }
    add(e) {
        return this.x += e.x,
        this.y += e.y,
        this
    }
    addScalar(e) {
        return this.x += e,
        this.y += e,
        this
    }
    addVectors(e, t) {
        return this.x = e.x + t.x,
        this.y = e.y + t.y,
        this
    }
    addScaledVector(e, t) {
        return this.x += e.x * t,
        this.y += e.y * t,
        this
    }
    sub(e) {
        return this.x -= e.x,
        this.y -= e.y,
        this
    }
    subScalar(e) {
        return this.x -= e,
        this.y -= e,
        this
    }
    subVectors(e, t) {
        return this.x = e.x - t.x,
        this.y = e.y - t.y,
        this
    }
    multiply(e) {
        return this.x *= e.x,
        this.y *= e.y,
        this
    }
    multiplyScalar(e) {
        return this.x *= e,
        this.y *= e,
        this
    }
    divide(e) {
        return this.x /= e.x,
        this.y /= e.y,
        this
    }
    divideScalar(e) {
        return this.multiplyScalar(1 / e)
    }
    applyMatrix3(e) {
        const t = this.x
          , r = this.y
          , i = e.elements;
        return this.x = i[0] * t + i[3] * r + i[6],
        this.y = i[1] * t + i[4] * r + i[7],
        this
    }
    min(e) {
        return this.x = Math.min(this.x, e.x),
        this.y = Math.min(this.y, e.y),
        this
    }
    max(e) {
        return this.x = Math.max(this.x, e.x),
        this.y = Math.max(this.y, e.y),
        this
    }
    clamp(e, t) {
        return this.x = Math.max(e.x, Math.min(t.x, this.x)),
        this.y = Math.max(e.y, Math.min(t.y, this.y)),
        this
    }
    clampScalar(e, t) {
        return this.x = Math.max(e, Math.min(t, this.x)),
        this.y = Math.max(e, Math.min(t, this.y)),
        this
    }
    clampLength(e, t) {
        const r = this.length();
        return this.divideScalar(r || 1).multiplyScalar(Math.max(e, Math.min(t, r)))
    }
    floor() {
        return this.x = Math.floor(this.x),
        this.y = Math.floor(this.y),
        this
    }
    ceil() {
        return this.x = Math.ceil(this.x),
        this.y = Math.ceil(this.y),
        this
    }
    round() {
        return this.x = Math.round(this.x),
        this.y = Math.round(this.y),
        this
    }
    roundToZero() {
        return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x),
        this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y),
        this
    }
    negate() {
        return this.x = -this.x,
        this.y = -this.y,
        this
    }
    dot(e) {
        return this.x * e.x + this.y * e.y
    }
    cross(e) {
        return this.x * e.y - this.y * e.x
    }
    lengthSq() {
        return this.x * this.x + this.y * this.y
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y)
    }
    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y)
    }
    normalize() {
        return this.divideScalar(this.length() || 1)
    }
    angle() {
        return Math.atan2(-this.y, -this.x) + Math.PI
    }
    distanceTo(e) {
        return Math.sqrt(this.distanceToSquared(e))
    }
    distanceToSquared(e) {
        const t = this.x - e.x
          , r = this.y - e.y;
        return t * t + r * r
    }
    manhattanDistanceTo(e) {
        return Math.abs(this.x - e.x) + Math.abs(this.y - e.y)
    }
    setLength(e) {
        return this.normalize().multiplyScalar(e)
    }
    lerp(e, t) {
        return this.x += (e.x - this.x) * t,
        this.y += (e.y - this.y) * t,
        this
    }
    lerpVectors(e, t, r) {
        return this.x = e.x + (t.x - e.x) * r,
        this.y = e.y + (t.y - e.y) * r,
        this
    }
    equals(e) {
        return e.x === this.x && e.y === this.y
    }
    fromArray(e, t=0) {
        return this.x = e[t],
        this.y = e[t + 1],
        this
    }
    toArray(e=[], t=0) {
        return e[t] = this.x,
        e[t + 1] = this.y,
        e
    }
    fromBufferAttribute(e, t) {
        return this.x = e.getX(t),
        this.y = e.getY(t),
        this
    }
    rotateAround(e, t) {
        const r = Math.cos(t)
          , i = Math.sin(t)
          , s = this.x - e.x
          , o = this.y - e.y;
        return this.x = s * r - o * i + e.x,
        this.y = s * i + o * r + e.y,
        this
    }
    random() {
        return this.x = Math.random(),
        this.y = Math.random(),
        this
    }
    *[Symbol.iterator]() {
        yield this.x,
        yield this.y
    }
}
class bo {
    constructor() {
        bo.prototype.isMatrix3 = !0,
        this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]
    }
    set(e, t, r, i, s, o, a, l, f) {
        const h = this.elements;
        return h[0] = e,
        h[1] = i,
        h[2] = a,
        h[3] = t,
        h[4] = s,
        h[5] = l,
        h[6] = r,
        h[7] = o,
        h[8] = f,
        this
    }
    identity() {
        return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1),
        this
    }
    copy(e) {
        const t = this.elements
          , r = e.elements;
        return t[0] = r[0],
        t[1] = r[1],
        t[2] = r[2],
        t[3] = r[3],
        t[4] = r[4],
        t[5] = r[5],
        t[6] = r[6],
        t[7] = r[7],
        t[8] = r[8],
        this
    }
    extractBasis(e, t, r) {
        return e.setFromMatrix3Column(this, 0),
        t.setFromMatrix3Column(this, 1),
        r.setFromMatrix3Column(this, 2),
        this
    }
    setFromMatrix4(e) {
        const t = e.elements;
        return this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]),
        this
    }
    multiply(e) {
        return this.multiplyMatrices(this, e)
    }
    premultiply(e) {
        return this.multiplyMatrices(e, this)
    }
    multiplyMatrices(e, t) {
        const r = e.elements
          , i = t.elements
          , s = this.elements
          , o = r[0]
          , a = r[3]
          , l = r[6]
          , f = r[1]
          , h = r[4]
          , d = r[7]
          , p = r[2]
          , m = r[5]
          , _ = r[8]
          , y = i[0]
          , x = i[3]
          , S = i[6]
          , M = i[1]
          , w = i[4]
          , T = i[7]
          , P = i[2]
          , I = i[5]
          , k = i[8];
        return s[0] = o * y + a * M + l * P,
        s[3] = o * x + a * w + l * I,
        s[6] = o * S + a * T + l * k,
        s[1] = f * y + h * M + d * P,
        s[4] = f * x + h * w + d * I,
        s[7] = f * S + h * T + d * k,
        s[2] = p * y + m * M + _ * P,
        s[5] = p * x + m * w + _ * I,
        s[8] = p * S + m * T + _ * k,
        this
    }
    multiplyScalar(e) {
        const t = this.elements;
        return t[0] *= e,
        t[3] *= e,
        t[6] *= e,
        t[1] *= e,
        t[4] *= e,
        t[7] *= e,
        t[2] *= e,
        t[5] *= e,
        t[8] *= e,
        this
    }
    determinant() {
        const e = this.elements
          , t = e[0]
          , r = e[1]
          , i = e[2]
          , s = e[3]
          , o = e[4]
          , a = e[5]
          , l = e[6]
          , f = e[7]
          , h = e[8];
        return t * o * h - t * a * f - r * s * h + r * a * l + i * s * f - i * o * l
    }
    invert() {
        const e = this.elements
          , t = e[0]
          , r = e[1]
          , i = e[2]
          , s = e[3]
          , o = e[4]
          , a = e[5]
          , l = e[6]
          , f = e[7]
          , h = e[8]
          , d = h * o - a * f
          , p = a * l - h * s
          , m = f * s - o * l
          , _ = t * d + r * p + i * m;
        if (_ === 0)
            return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
        const y = 1 / _;
        return e[0] = d * y,
        e[1] = (i * f - h * r) * y,
        e[2] = (a * r - i * o) * y,
        e[3] = p * y,
        e[4] = (h * t - i * l) * y,
        e[5] = (i * s - a * t) * y,
        e[6] = m * y,
        e[7] = (r * l - f * t) * y,
        e[8] = (o * t - r * s) * y,
        this
    }
    transpose() {
        let e;
        const t = this.elements;
        return e = t[1],
        t[1] = t[3],
        t[3] = e,
        e = t[2],
        t[2] = t[6],
        t[6] = e,
        e = t[5],
        t[5] = t[7],
        t[7] = e,
        this
    }
    getNormalMatrix(e) {
        return this.setFromMatrix4(e).invert().transpose()
    }
    transposeIntoArray(e) {
        const t = this.elements;
        return e[0] = t[0],
        e[1] = t[3],
        e[2] = t[6],
        e[3] = t[1],
        e[4] = t[4],
        e[5] = t[7],
        e[6] = t[2],
        e[7] = t[5],
        e[8] = t[8],
        this
    }
    setUvTransform(e, t, r, i, s, o, a) {
        const l = Math.cos(s)
          , f = Math.sin(s);
        return this.set(r * l, r * f, -r * (l * o + f * a) + o + e, -i * f, i * l, -i * (-f * o + l * a) + a + t, 0, 0, 1),
        this
    }
    scale(e, t) {
        return this.premultiply(Fy.makeScale(e, t)),
        this
    }
    rotate(e) {
        return this.premultiply(Fy.makeRotation(-e)),
        this
    }
    translate(e, t) {
        return this.premultiply(Fy.makeTranslation(e, t)),
        this
    }
    makeTranslation(e, t) {
        return this.set(1, 0, e, 0, 1, t, 0, 0, 1),
        this
    }
    makeRotation(e) {
        const t = Math.cos(e)
          , r = Math.sin(e);
        return this.set(t, -r, 0, r, t, 0, 0, 0, 1),
        this
    }
    makeScale(e, t) {
        return this.set(e, 0, 0, 0, t, 0, 0, 0, 1),
        this
    }
    equals(e) {
        const t = this.elements
          , r = e.elements;
        for (let i = 0; i < 9; i++)
            if (t[i] !== r[i])
                return !1;
        return !0
    }
    fromArray(e, t=0) {
        for (let r = 0; r < 9; r++)
            this.elements[r] = e[r + t];
        return this
    }
    toArray(e=[], t=0) {
        const r = this.elements;
        return e[t] = r[0],
        e[t + 1] = r[1],
        e[t + 2] = r[2],
        e[t + 3] = r[3],
        e[t + 4] = r[4],
        e[t + 5] = r[5],
        e[t + 6] = r[6],
        e[t + 7] = r[7],
        e[t + 8] = r[8],
        e
    }
    clone() {
        return new this.constructor().fromArray(this.elements)
    }
}
const Fy = new bo;
function Z2(n) {
    for (let e = n.length - 1; e >= 0; --e)
        if (n[e] >= 65535)
            return !0;
    return !1
}
const VL = {
    Int8Array,
    Uint8Array,
    Uint8ClampedArray,
    Int16Array,
    Uint16Array,
    Int32Array,
    Uint32Array,
    Float32Array,
    Float64Array
};
function Wd(n, e) {
    return new VL[n](e)
}
function _m(n) {
    return document.createElementNS("http://www.w3.org/1999/xhtml", n)
}
function Pf(n) {
    return n < .04045 ? n * .0773993808 : Math.pow(n * .9478672986 + .0521327014, 2.4)
}
function lv(n) {
    return n < .0031308 ? n * 12.92 : 1.055 * Math.pow(n, .41666) - .055
}
const ky = {
    [gl]: {
        [_h]: Pf
    },
    [_h]: {
        [gl]: lv
    }
}
  , ro = {
    legacyMode: !0,
    get workingColorSpace() {
        return _h
    },
    set workingColorSpace(n) {
        console.warn("THREE.ColorManagement: .workingColorSpace is readonly.")
    },
    convert: function(n, e, t) {
        if (this.legacyMode || e === t || !e || !t)
            return n;
        if (ky[e] && ky[e][t] !== void 0) {
            const r = ky[e][t];
            return n.r = r(n.r),
            n.g = r(n.g),
            n.b = r(n.b),
            n
        }
        throw new Error("Unsupported color space conversion.")
    },
    fromWorkingColorSpace: function(n, e) {
        return this.convert(n, this.workingColorSpace, e)
    },
    toWorkingColorSpace: function(n, e) {
        return this.convert(n, e, this.workingColorSpace)
    }
}
  , $2 = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074
}
  , hs = {
    r: 0,
    g: 0,
    b: 0
}
  , ul = {
    h: 0,
    s: 0,
    l: 0
}
  , kg = {
    h: 0,
    s: 0,
    l: 0
};
function Oy(n, e, t) {
    return t < 0 && (t += 1),
    t > 1 && (t -= 1),
    t < 1 / 6 ? n + (e - n) * 6 * t : t < 1 / 2 ? e : t < 2 / 3 ? n + (e - n) * 6 * (2 / 3 - t) : n
}
function Og(n, e) {
    return e.r = n.r,
    e.g = n.g,
    e.b = n.b,
    e
}
class It {
    constructor(e, t, r) {
        return this.isColor = !0,
        this.r = 1,
        this.g = 1,
        this.b = 1,
        t === void 0 && r === void 0 ? this.set(e) : this.setRGB(e, t, r)
    }
    set(e) {
        return e && e.isColor ? this.copy(e) : typeof e == "number" ? this.setHex(e) : typeof e == "string" && this.setStyle(e),
        this
    }
    setScalar(e) {
        return this.r = e,
        this.g = e,
        this.b = e,
        this
    }
    setHex(e, t=gl) {
        return e = Math.floor(e),
        this.r = (e >> 16 & 255) / 255,
        this.g = (e >> 8 & 255) / 255,
        this.b = (e & 255) / 255,
        ro.toWorkingColorSpace(this, t),
        this
    }
    setRGB(e, t, r, i=ro.workingColorSpace) {
        return this.r = e,
        this.g = t,
        this.b = r,
        ro.toWorkingColorSpace(this, i),
        this
    }
    setHSL(e, t, r, i=ro.workingColorSpace) {
        if (e = zS(e, 1),
        t = $i(t, 0, 1),
        r = $i(r, 0, 1),
        t === 0)
            this.r = this.g = this.b = r;
        else {
            const s = r <= .5 ? r * (1 + t) : r + t - r * t
              , o = 2 * r - s;
            this.r = Oy(o, s, e + 1 / 3),
            this.g = Oy(o, s, e),
            this.b = Oy(o, s, e - 1 / 3)
        }
        return ro.toWorkingColorSpace(this, i),
        this
    }
    setStyle(e, t=gl) {
        function r(s) {
            s !== void 0 && parseFloat(s) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.")
        }
        let i;
        if (i = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(e)) {
            let s;
            const o = i[1]
              , a = i[2];
            switch (o) {
            case "rgb":
            case "rgba":
                if (s = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))
                    return this.r = Math.min(255, parseInt(s[1], 10)) / 255,
                    this.g = Math.min(255, parseInt(s[2], 10)) / 255,
                    this.b = Math.min(255, parseInt(s[3], 10)) / 255,
                    ro.toWorkingColorSpace(this, t),
                    r(s[4]),
                    this;
                if (s = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))
                    return this.r = Math.min(100, parseInt(s[1], 10)) / 100,
                    this.g = Math.min(100, parseInt(s[2], 10)) / 100,
                    this.b = Math.min(100, parseInt(s[3], 10)) / 100,
                    ro.toWorkingColorSpace(this, t),
                    r(s[4]),
                    this;
                break;
            case "hsl":
            case "hsla":
                if (s = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)) {
                    const l = parseFloat(s[1]) / 360
                      , f = parseFloat(s[2]) / 100
                      , h = parseFloat(s[3]) / 100;
                    return r(s[4]),
                    this.setHSL(l, f, h, t)
                }
                break
            }
        } else if (i = /^\#([A-Fa-f\d]+)$/.exec(e)) {
            const s = i[1]
              , o = s.length;
            if (o === 3)
                return this.r = parseInt(s.charAt(0) + s.charAt(0), 16) / 255,
                this.g = parseInt(s.charAt(1) + s.charAt(1), 16) / 255,
                this.b = parseInt(s.charAt(2) + s.charAt(2), 16) / 255,
                ro.toWorkingColorSpace(this, t),
                this;
            if (o === 6)
                return this.r = parseInt(s.charAt(0) + s.charAt(1), 16) / 255,
                this.g = parseInt(s.charAt(2) + s.charAt(3), 16) / 255,
                this.b = parseInt(s.charAt(4) + s.charAt(5), 16) / 255,
                ro.toWorkingColorSpace(this, t),
                this
        }
        return e && e.length > 0 ? this.setColorName(e, t) : this
    }
    setColorName(e, t=gl) {
        const r = $2[e.toLowerCase()];
        return r !== void 0 ? this.setHex(r, t) : console.warn("THREE.Color: Unknown color " + e),
        this
    }
    clone() {
        return new this.constructor(this.r,this.g,this.b)
    }
    copy(e) {
        return this.r = e.r,
        this.g = e.g,
        this.b = e.b,
        this
    }
    copySRGBToLinear(e) {
        return this.r = Pf(e.r),
        this.g = Pf(e.g),
        this.b = Pf(e.b),
        this
    }
    copyLinearToSRGB(e) {
        return this.r = lv(e.r),
        this.g = lv(e.g),
        this.b = lv(e.b),
        this
    }
    convertSRGBToLinear() {
        return this.copySRGBToLinear(this),
        this
    }
    convertLinearToSRGB() {
        return this.copyLinearToSRGB(this),
        this
    }
    getHex(e=gl) {
        return ro.fromWorkingColorSpace(Og(this, hs), e),
        $i(hs.r * 255, 0, 255) << 16 ^ $i(hs.g * 255, 0, 255) << 8 ^ $i(hs.b * 255, 0, 255) << 0
    }
    getHexString(e=gl) {
        return ("000000" + this.getHex(e).toString(16)).slice(-6)
    }
    getHSL(e, t=ro.workingColorSpace) {
        ro.fromWorkingColorSpace(Og(this, hs), t);
        const r = hs.r
          , i = hs.g
          , s = hs.b
          , o = Math.max(r, i, s)
          , a = Math.min(r, i, s);
        let l, f;
        const h = (a + o) / 2;
        if (a === o)
            l = 0,
            f = 0;
        else {
            const d = o - a;
            switch (f = h <= .5 ? d / (o + a) : d / (2 - o - a),
            o) {
            case r:
                l = (i - s) / d + (i < s ? 6 : 0);
                break;
            case i:
                l = (s - r) / d + 2;
                break;
            case s:
                l = (r - i) / d + 4;
                break
            }
            l /= 6
        }
        return e.h = l,
        e.s = f,
        e.l = h,
        e
    }
    getRGB(e, t=ro.workingColorSpace) {
        return ro.fromWorkingColorSpace(Og(this, hs), t),
        e.r = hs.r,
        e.g = hs.g,
        e.b = hs.b,
        e
    }
    getStyle(e=gl) {
        return ro.fromWorkingColorSpace(Og(this, hs), e),
        e !== gl ? `color(${e} ${hs.r} ${hs.g} ${hs.b})` : `rgb(${hs.r * 255 | 0},${hs.g * 255 | 0},${hs.b * 255 | 0})`
    }
    offsetHSL(e, t, r) {
        return this.getHSL(ul),
        ul.h += e,
        ul.s += t,
        ul.l += r,
        this.setHSL(ul.h, ul.s, ul.l),
        this
    }
    add(e) {
        return this.r += e.r,
        this.g += e.g,
        this.b += e.b,
        this
    }
    addColors(e, t) {
        return this.r = e.r + t.r,
        this.g = e.g + t.g,
        this.b = e.b + t.b,
        this
    }
    addScalar(e) {
        return this.r += e,
        this.g += e,
        this.b += e,
        this
    }
    sub(e) {
        return this.r = Math.max(0, this.r - e.r),
        this.g = Math.max(0, this.g - e.g),
        this.b = Math.max(0, this.b - e.b),
        this
    }
    multiply(e) {
        return this.r *= e.r,
        this.g *= e.g,
        this.b *= e.b,
        this
    }
    multiplyScalar(e) {
        return this.r *= e,
        this.g *= e,
        this.b *= e,
        this
    }
    lerp(e, t) {
        return this.r += (e.r - this.r) * t,
        this.g += (e.g - this.g) * t,
        this.b += (e.b - this.b) * t,
        this
    }
    lerpColors(e, t, r) {
        return this.r = e.r + (t.r - e.r) * r,
        this.g = e.g + (t.g - e.g) * r,
        this.b = e.b + (t.b - e.b) * r,
        this
    }
    lerpHSL(e, t) {
        this.getHSL(ul),
        e.getHSL(kg);
        const r = zp(ul.h, kg.h, t)
          , i = zp(ul.s, kg.s, t)
          , s = zp(ul.l, kg.l, t);
        return this.setHSL(r, i, s),
        this
    }
    equals(e) {
        return e.r === this.r && e.g === this.g && e.b === this.b
    }
    fromArray(e, t=0) {
        return this.r = e[t],
        this.g = e[t + 1],
        this.b = e[t + 2],
        this
    }
    toArray(e=[], t=0) {
        return e[t] = this.r,
        e[t + 1] = this.g,
        e[t + 2] = this.b,
        e
    }
    fromBufferAttribute(e, t) {
        return this.r = e.getX(t),
        this.g = e.getY(t),
        this.b = e.getZ(t),
        this
    }
    toJSON() {
        return this.getHex()
    }
    *[Symbol.iterator]() {
        yield this.r,
        yield this.g,
        yield this.b
    }
}
It.NAMES = $2;
let ld;
class GS {
    static getDataURL(e) {
        if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u")
            return e.src;
        let t;
        if (e instanceof HTMLCanvasElement)
            t = e;
        else {
            ld === void 0 && (ld = _m("canvas")),
            ld.width = e.width,
            ld.height = e.height;
            const r = ld.getContext("2d");
            e instanceof ImageData ? r.putImageData(e, 0, 0) : r.drawImage(e, 0, 0, e.width, e.height),
            t = ld
        }
        return t.width > 2048 || t.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", e),
        t.toDataURL("image/jpeg", .6)) : t.toDataURL("image/png")
    }
    static sRGBToLinear(e) {
        if (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && e instanceof ImageBitmap) {
            const t = _m("canvas");
            t.width = e.width,
            t.height = e.height;
            const r = t.getContext("2d");
            r.drawImage(e, 0, 0, e.width, e.height);
            const i = r.getImageData(0, 0, e.width, e.height)
              , s = i.data;
            for (let o = 0; o < s.length; o++)
                s[o] = Pf(s[o] / 255) * 255;
            return r.putImageData(i, 0, 0),
            t
        } else if (e.data) {
            const t = e.data.slice(0);
            for (let r = 0; r < t.length; r++)
                t instanceof Uint8Array || t instanceof Uint8ClampedArray ? t[r] = Math.floor(Pf(t[r] / 255) * 255) : t[r] = Pf(t[r]);
            return {
                data: t,
                width: e.width,
                height: e.height
            }
        } else
            return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),
            e
    }
}
class Sf {
    constructor(e=null) {
        this.isSource = !0,
        this.uuid = Sa(),
        this.data = e,
        this.version = 0
    }
    set needsUpdate(e) {
        e === !0 && this.version++
    }
    toJSON(e) {
        const t = e === void 0 || typeof e == "string";
        if (!t && e.images[this.uuid] !== void 0)
            return e.images[this.uuid];
        const r = {
            uuid: this.uuid,
            url: ""
        }
          , i = this.data;
        if (i !== null) {
            let s;
            if (Array.isArray(i)) {
                s = [];
                for (let o = 0, a = i.length; o < a; o++)
                    i[o].isDataTexture ? s.push(Ny(i[o].image)) : s.push(Ny(i[o]))
            } else
                s = Ny(i);
            r.url = s
        }
        return t || (e.images[this.uuid] = r),
        r
    }
}
function Ny(n) {
    return typeof HTMLImageElement < "u" && n instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && n instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && n instanceof ImageBitmap ? GS.getDataURL(n) : n.data ? {
        data: Array.from(n.data),
        width: n.width,
        height: n.height,
        type: n.data.constructor.name
    } : (console.warn("THREE.Texture: Unable to serialize Texture."),
    {})
}
let WL = 0;
class Ci extends ql {
    constructor(e=Ci.DEFAULT_IMAGE, t=Ci.DEFAULT_MAPPING, r=Us, i=Us, s=si, o=Kl, a=ga, l=Tc, f=Ci.DEFAULT_ANISOTROPY, h=bl) {
        super(),
        this.isTexture = !0,
        Object.defineProperty(this, "id", {
            value: WL++
        }),
        this.uuid = Sa(),
        this.name = "",
        this.source = new Sf(e),
        this.mipmaps = [],
        this.mapping = t,
        this.wrapS = r,
        this.wrapT = i,
        this.magFilter = s,
        this.minFilter = o,
        this.anisotropy = f,
        this.format = a,
        this.internalFormat = null,
        this.type = l,
        this.offset = new it(0,0),
        this.repeat = new it(1,1),
        this.center = new it(0,0),
        this.rotation = 0,
        this.matrixAutoUpdate = !0,
        this.matrix = new bo,
        this.generateMipmaps = !0,
        this.premultiplyAlpha = !1,
        this.flipY = !0,
        this.unpackAlignment = 4,
        this.encoding = h,
        this.userData = {},
        this.version = 0,
        this.onUpdate = null,
        this.isRenderTargetTexture = !1,
        this.needsPMREMUpdate = !1
    }
    get image() {
        return this.source.data
    }
    set image(e) {
        this.source.data = e
    }
    updateMatrix() {
        this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        return this.name = e.name,
        this.source = e.source,
        this.mipmaps = e.mipmaps.slice(0),
        this.mapping = e.mapping,
        this.wrapS = e.wrapS,
        this.wrapT = e.wrapT,
        this.magFilter = e.magFilter,
        this.minFilter = e.minFilter,
        this.anisotropy = e.anisotropy,
        this.format = e.format,
        this.internalFormat = e.internalFormat,
        this.type = e.type,
        this.offset.copy(e.offset),
        this.repeat.copy(e.repeat),
        this.center.copy(e.center),
        this.rotation = e.rotation,
        this.matrixAutoUpdate = e.matrixAutoUpdate,
        this.matrix.copy(e.matrix),
        this.generateMipmaps = e.generateMipmaps,
        this.premultiplyAlpha = e.premultiplyAlpha,
        this.flipY = e.flipY,
        this.unpackAlignment = e.unpackAlignment,
        this.encoding = e.encoding,
        this.userData = JSON.parse(JSON.stringify(e.userData)),
        this.needsUpdate = !0,
        this
    }
    toJSON(e) {
        const t = e === void 0 || typeof e == "string";
        if (!t && e.textures[this.uuid] !== void 0)
            return e.textures[this.uuid];
        const r = {
            metadata: {
                version: 4.5,
                type: "Texture",
                generator: "Texture.toJSON"
            },
            uuid: this.uuid,
            name: this.name,
            image: this.source.toJSON(e).uuid,
            mapping: this.mapping,
            repeat: [this.repeat.x, this.repeat.y],
            offset: [this.offset.x, this.offset.y],
            center: [this.center.x, this.center.y],
            rotation: this.rotation,
            wrap: [this.wrapS, this.wrapT],
            format: this.format,
            type: this.type,
            encoding: this.encoding,
            minFilter: this.minFilter,
            magFilter: this.magFilter,
            anisotropy: this.anisotropy,
            flipY: this.flipY,
            generateMipmaps: this.generateMipmaps,
            premultiplyAlpha: this.premultiplyAlpha,
            unpackAlignment: this.unpackAlignment
        };
        return Object.keys(this.userData).length > 0 && (r.userData = this.userData),
        t || (e.textures[this.uuid] = r),
        r
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
    transformUv(e) {
        if (this.mapping !== g_)
            return e;
        if (e.applyMatrix3(this.matrix),
        e.x < 0 || e.x > 1)
            switch (this.wrapS) {
            case bc:
                e.x = e.x - Math.floor(e.x);
                break;
            case Us:
                e.x = e.x < 0 ? 0 : 1;
                break;
            case gh:
                Math.abs(Math.floor(e.x) % 2) === 1 ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x);
                break
            }
        if (e.y < 0 || e.y > 1)
            switch (this.wrapT) {
            case bc:
                e.y = e.y - Math.floor(e.y);
                break;
            case Us:
                e.y = e.y < 0 ? 0 : 1;
                break;
            case gh:
                Math.abs(Math.floor(e.y) % 2) === 1 ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y);
                break
            }
        return this.flipY && (e.y = 1 - e.y),
        e
    }
    set needsUpdate(e) {
        e === !0 && (this.version++,
        this.source.needsUpdate = !0)
    }
}
Ci.DEFAULT_IMAGE = null;
Ci.DEFAULT_MAPPING = g_;
Ci.DEFAULT_ANISOTROPY = 1;
class zr {
    constructor(e=0, t=0, r=0, i=1) {
        zr.prototype.isVector4 = !0,
        this.x = e,
        this.y = t,
        this.z = r,
        this.w = i
    }
    get width() {
        return this.z
    }
    set width(e) {
        this.z = e
    }
    get height() {
        return this.w
    }
    set height(e) {
        this.w = e
    }
    set(e, t, r, i) {
        return this.x = e,
        this.y = t,
        this.z = r,
        this.w = i,
        this
    }
    setScalar(e) {
        return this.x = e,
        this.y = e,
        this.z = e,
        this.w = e,
        this
    }
    setX(e) {
        return this.x = e,
        this
    }
    setY(e) {
        return this.y = e,
        this
    }
    setZ(e) {
        return this.z = e,
        this
    }
    setW(e) {
        return this.w = e,
        this
    }
    setComponent(e, t) {
        switch (e) {
        case 0:
            this.x = t;
            break;
        case 1:
            this.y = t;
            break;
        case 2:
            this.z = t;
            break;
        case 3:
            this.w = t;
            break;
        default:
            throw new Error("index is out of range: " + e)
        }
        return this
    }
    getComponent(e) {
        switch (e) {
        case 0:
            return this.x;
        case 1:
            return this.y;
        case 2:
            return this.z;
        case 3:
            return this.w;
        default:
            throw new Error("index is out of range: " + e)
        }
    }
    clone() {
        return new this.constructor(this.x,this.y,this.z,this.w)
    }
    copy(e) {
        return this.x = e.x,
        this.y = e.y,
        this.z = e.z,
        this.w = e.w !== void 0 ? e.w : 1,
        this
    }
    add(e) {
        return this.x += e.x,
        this.y += e.y,
        this.z += e.z,
        this.w += e.w,
        this
    }
    addScalar(e) {
        return this.x += e,
        this.y += e,
        this.z += e,
        this.w += e,
        this
    }
    addVectors(e, t) {
        return this.x = e.x + t.x,
        this.y = e.y + t.y,
        this.z = e.z + t.z,
        this.w = e.w + t.w,
        this
    }
    addScaledVector(e, t) {
        return this.x += e.x * t,
        this.y += e.y * t,
        this.z += e.z * t,
        this.w += e.w * t,
        this
    }
    sub(e) {
        return this.x -= e.x,
        this.y -= e.y,
        this.z -= e.z,
        this.w -= e.w,
        this
    }
    subScalar(e) {
        return this.x -= e,
        this.y -= e,
        this.z -= e,
        this.w -= e,
        this
    }
    subVectors(e, t) {
        return this.x = e.x - t.x,
        this.y = e.y - t.y,
        this.z = e.z - t.z,
        this.w = e.w - t.w,
        this
    }
    multiply(e) {
        return this.x *= e.x,
        this.y *= e.y,
        this.z *= e.z,
        this.w *= e.w,
        this
    }
    multiplyScalar(e) {
        return this.x *= e,
        this.y *= e,
        this.z *= e,
        this.w *= e,
        this
    }
    applyMatrix4(e) {
        const t = this.x
          , r = this.y
          , i = this.z
          , s = this.w
          , o = e.elements;
        return this.x = o[0] * t + o[4] * r + o[8] * i + o[12] * s,
        this.y = o[1] * t + o[5] * r + o[9] * i + o[13] * s,
        this.z = o[2] * t + o[6] * r + o[10] * i + o[14] * s,
        this.w = o[3] * t + o[7] * r + o[11] * i + o[15] * s,
        this
    }
    divideScalar(e) {
        return this.multiplyScalar(1 / e)
    }
    setAxisAngleFromQuaternion(e) {
        this.w = 2 * Math.acos(e.w);
        const t = Math.sqrt(1 - e.w * e.w);
        return t < 1e-4 ? (this.x = 1,
        this.y = 0,
        this.z = 0) : (this.x = e.x / t,
        this.y = e.y / t,
        this.z = e.z / t),
        this
    }
    setAxisAngleFromRotationMatrix(e) {
        let t, r, i, s;
        const l = e.elements
          , f = l[0]
          , h = l[4]
          , d = l[8]
          , p = l[1]
          , m = l[5]
          , _ = l[9]
          , y = l[2]
          , x = l[6]
          , S = l[10];
        if (Math.abs(h - p) < .01 && Math.abs(d - y) < .01 && Math.abs(_ - x) < .01) {
            if (Math.abs(h + p) < .1 && Math.abs(d + y) < .1 && Math.abs(_ + x) < .1 && Math.abs(f + m + S - 3) < .1)
                return this.set(1, 0, 0, 0),
                this;
            t = Math.PI;
            const w = (f + 1) / 2
              , T = (m + 1) / 2
              , P = (S + 1) / 2
              , I = (h + p) / 4
              , k = (d + y) / 4
              , R = (_ + x) / 4;
            return w > T && w > P ? w < .01 ? (r = 0,
            i = .707106781,
            s = .707106781) : (r = Math.sqrt(w),
            i = I / r,
            s = k / r) : T > P ? T < .01 ? (r = .707106781,
            i = 0,
            s = .707106781) : (i = Math.sqrt(T),
            r = I / i,
            s = R / i) : P < .01 ? (r = .707106781,
            i = .707106781,
            s = 0) : (s = Math.sqrt(P),
            r = k / s,
            i = R / s),
            this.set(r, i, s, t),
            this
        }
        let M = Math.sqrt((x - _) * (x - _) + (d - y) * (d - y) + (p - h) * (p - h));
        return Math.abs(M) < .001 && (M = 1),
        this.x = (x - _) / M,
        this.y = (d - y) / M,
        this.z = (p - h) / M,
        this.w = Math.acos((f + m + S - 1) / 2),
        this
    }
    min(e) {
        return this.x = Math.min(this.x, e.x),
        this.y = Math.min(this.y, e.y),
        this.z = Math.min(this.z, e.z),
        this.w = Math.min(this.w, e.w),
        this
    }
    max(e) {
        return this.x = Math.max(this.x, e.x),
        this.y = Math.max(this.y, e.y),
        this.z = Math.max(this.z, e.z),
        this.w = Math.max(this.w, e.w),
        this
    }
    clamp(e, t) {
        return this.x = Math.max(e.x, Math.min(t.x, this.x)),
        this.y = Math.max(e.y, Math.min(t.y, this.y)),
        this.z = Math.max(e.z, Math.min(t.z, this.z)),
        this.w = Math.max(e.w, Math.min(t.w, this.w)),
        this
    }
    clampScalar(e, t) {
        return this.x = Math.max(e, Math.min(t, this.x)),
        this.y = Math.max(e, Math.min(t, this.y)),
        this.z = Math.max(e, Math.min(t, this.z)),
        this.w = Math.max(e, Math.min(t, this.w)),
        this
    }
    clampLength(e, t) {
        const r = this.length();
        return this.divideScalar(r || 1).multiplyScalar(Math.max(e, Math.min(t, r)))
    }
    floor() {
        return this.x = Math.floor(this.x),
        this.y = Math.floor(this.y),
        this.z = Math.floor(this.z),
        this.w = Math.floor(this.w),
        this
    }
    ceil() {
        return this.x = Math.ceil(this.x),
        this.y = Math.ceil(this.y),
        this.z = Math.ceil(this.z),
        this.w = Math.ceil(this.w),
        this
    }
    round() {
        return this.x = Math.round(this.x),
        this.y = Math.round(this.y),
        this.z = Math.round(this.z),
        this.w = Math.round(this.w),
        this
    }
    roundToZero() {
        return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x),
        this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y),
        this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z),
        this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w),
        this
    }
    negate() {
        return this.x = -this.x,
        this.y = -this.y,
        this.z = -this.z,
        this.w = -this.w,
        this
    }
    dot(e) {
        return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w
    }
    lengthSq() {
        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
    }
    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
    }
    normalize() {
        return this.divideScalar(this.length() || 1)
    }
    setLength(e) {
        return this.normalize().multiplyScalar(e)
    }
    lerp(e, t) {
        return this.x += (e.x - this.x) * t,
        this.y += (e.y - this.y) * t,
        this.z += (e.z - this.z) * t,
        this.w += (e.w - this.w) * t,
        this
    }
    lerpVectors(e, t, r) {
        return this.x = e.x + (t.x - e.x) * r,
        this.y = e.y + (t.y - e.y) * r,
        this.z = e.z + (t.z - e.z) * r,
        this.w = e.w + (t.w - e.w) * r,
        this
    }
    equals(e) {
        return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w
    }
    fromArray(e, t=0) {
        return this.x = e[t],
        this.y = e[t + 1],
        this.z = e[t + 2],
        this.w = e[t + 3],
        this
    }
    toArray(e=[], t=0) {
        return e[t] = this.x,
        e[t + 1] = this.y,
        e[t + 2] = this.z,
        e[t + 3] = this.w,
        e
    }
    fromBufferAttribute(e, t) {
        return this.x = e.getX(t),
        this.y = e.getY(t),
        this.z = e.getZ(t),
        this.w = e.getW(t),
        this
    }
    random() {
        return this.x = Math.random(),
        this.y = Math.random(),
        this.z = Math.random(),
        this.w = Math.random(),
        this
    }
    *[Symbol.iterator]() {
        yield this.x,
        yield this.y,
        yield this.z,
        yield this.w
    }
}
class $a extends ql {
    constructor(e=1, t=1, r={}) {
        super(),
        this.isWebGLRenderTarget = !0,
        this.width = e,
        this.height = t,
        this.depth = 1,
        this.scissor = new zr(0,0,e,t),
        this.scissorTest = !1,
        this.viewport = new zr(0,0,e,t);
        const i = {
            width: e,
            height: t,
            depth: 1
        };
        this.texture = new Ci(i,r.mapping,r.wrapS,r.wrapT,r.magFilter,r.minFilter,r.format,r.type,r.anisotropy,r.encoding),
        this.texture.isRenderTargetTexture = !0,
        this.texture.flipY = !1,
        this.texture.generateMipmaps = r.generateMipmaps !== void 0 ? r.generateMipmaps : !1,
        this.texture.internalFormat = r.internalFormat !== void 0 ? r.internalFormat : null,
        this.texture.minFilter = r.minFilter !== void 0 ? r.minFilter : si,
        this.depthBuffer = r.depthBuffer !== void 0 ? r.depthBuffer : !0,
        this.stencilBuffer = r.stencilBuffer !== void 0 ? r.stencilBuffer : !1,
        this.depthTexture = r.depthTexture !== void 0 ? r.depthTexture : null,
        this.samples = r.samples !== void 0 ? r.samples : 0
    }
    setSize(e, t, r=1) {
        (this.width !== e || this.height !== t || this.depth !== r) && (this.width = e,
        this.height = t,
        this.depth = r,
        this.texture.image.width = e,
        this.texture.image.height = t,
        this.texture.image.depth = r,
        this.dispose()),
        this.viewport.set(0, 0, e, t),
        this.scissor.set(0, 0, e, t)
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        this.width = e.width,
        this.height = e.height,
        this.depth = e.depth,
        this.viewport.copy(e.viewport),
        this.texture = e.texture.clone(),
        this.texture.isRenderTargetTexture = !0;
        const t = Object.assign({}, e.texture.image);
        return this.texture.source = new Sf(t),
        this.depthBuffer = e.depthBuffer,
        this.stencilBuffer = e.stencilBuffer,
        e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()),
        this.samples = e.samples,
        this
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
}
class x_ extends Ci {
    constructor(e=null, t=1, r=1, i=1) {
        super(null),
        this.isDataArrayTexture = !0,
        this.image = {
            data: e,
            width: t,
            height: r,
            depth: i
        },
        this.magFilter = Ji,
        this.minFilter = Ji,
        this.wrapR = Us,
        this.generateMipmaps = !1,
        this.flipY = !1,
        this.unpackAlignment = 1
    }
}
class XL extends $a {
    constructor(e=1, t=1, r=1) {
        super(e, t),
        this.isWebGLArrayRenderTarget = !0,
        this.depth = r,
        this.texture = new x_(null,e,t,r),
        this.texture.isRenderTargetTexture = !0
    }
}
class US extends Ci {
    constructor(e=null, t=1, r=1, i=1) {
        super(null),
        this.isData3DTexture = !0,
        this.image = {
            data: e,
            width: t,
            height: r,
            depth: i
        },
        this.magFilter = Ji,
        this.minFilter = Ji,
        this.wrapR = Us,
        this.generateMipmaps = !1,
        this.flipY = !1,
        this.unpackAlignment = 1
    }
}
class JL extends $a {
    constructor(e=1, t=1, r=1) {
        super(e, t),
        this.isWebGL3DRenderTarget = !0,
        this.depth = r,
        this.texture = new US(null,e,t,r),
        this.texture.isRenderTargetTexture = !0
    }
}
class jL extends $a {
    constructor(e=1, t=1, r=1, i={}) {
        super(e, t, i),
        this.isWebGLMultipleRenderTargets = !0;
        const s = this.texture;
        this.texture = [];
        for (let o = 0; o < r; o++)
            this.texture[o] = s.clone(),
            this.texture[o].isRenderTargetTexture = !0
    }
    setSize(e, t, r=1) {
        if (this.width !== e || this.height !== t || this.depth !== r) {
            this.width = e,
            this.height = t,
            this.depth = r;
            for (let i = 0, s = this.texture.length; i < s; i++)
                this.texture[i].image.width = e,
                this.texture[i].image.height = t,
                this.texture[i].image.depth = r;
            this.dispose()
        }
        return this.viewport.set(0, 0, e, t),
        this.scissor.set(0, 0, e, t),
        this
    }
    copy(e) {
        this.dispose(),
        this.width = e.width,
        this.height = e.height,
        this.depth = e.depth,
        this.viewport.set(0, 0, this.width, this.height),
        this.scissor.set(0, 0, this.width, this.height),
        this.depthBuffer = e.depthBuffer,
        this.stencilBuffer = e.stencilBuffer,
        e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()),
        this.texture.length = 0;
        for (let t = 0, r = e.texture.length; t < r; t++)
            this.texture[t] = e.texture[t].clone(),
            this.texture[t].isRenderTargetTexture = !0;
        return this
    }
}
class Ws {
    constructor(e=0, t=0, r=0, i=1) {
        this.isQuaternion = !0,
        this._x = e,
        this._y = t,
        this._z = r,
        this._w = i
    }
    static slerpFlat(e, t, r, i, s, o, a) {
        let l = r[i + 0]
          , f = r[i + 1]
          , h = r[i + 2]
          , d = r[i + 3];
        const p = s[o + 0]
          , m = s[o + 1]
          , _ = s[o + 2]
          , y = s[o + 3];
        if (a === 0) {
            e[t + 0] = l,
            e[t + 1] = f,
            e[t + 2] = h,
            e[t + 3] = d;
            return
        }
        if (a === 1) {
            e[t + 0] = p,
            e[t + 1] = m,
            e[t + 2] = _,
            e[t + 3] = y;
            return
        }
        if (d !== y || l !== p || f !== m || h !== _) {
            let x = 1 - a;
            const S = l * p + f * m + h * _ + d * y
              , M = S >= 0 ? 1 : -1
              , w = 1 - S * S;
            if (w > Number.EPSILON) {
                const P = Math.sqrt(w)
                  , I = Math.atan2(P, S * M);
                x = Math.sin(x * I) / P,
                a = Math.sin(a * I) / P
            }
            const T = a * M;
            if (l = l * x + p * T,
            f = f * x + m * T,
            h = h * x + _ * T,
            d = d * x + y * T,
            x === 1 - a) {
                const P = 1 / Math.sqrt(l * l + f * f + h * h + d * d);
                l *= P,
                f *= P,
                h *= P,
                d *= P
            }
        }
        e[t] = l,
        e[t + 1] = f,
        e[t + 2] = h,
        e[t + 3] = d
    }
    static multiplyQuaternionsFlat(e, t, r, i, s, o) {
        const a = r[i]
          , l = r[i + 1]
          , f = r[i + 2]
          , h = r[i + 3]
          , d = s[o]
          , p = s[o + 1]
          , m = s[o + 2]
          , _ = s[o + 3];
        return e[t] = a * _ + h * d + l * m - f * p,
        e[t + 1] = l * _ + h * p + f * d - a * m,
        e[t + 2] = f * _ + h * m + a * p - l * d,
        e[t + 3] = h * _ - a * d - l * p - f * m,
        e
    }
    get x() {
        return this._x
    }
    set x(e) {
        this._x = e,
        this._onChangeCallback()
    }
    get y() {
        return this._y
    }
    set y(e) {
        this._y = e,
        this._onChangeCallback()
    }
    get z() {
        return this._z
    }
    set z(e) {
        this._z = e,
        this._onChangeCallback()
    }
    get w() {
        return this._w
    }
    set w(e) {
        this._w = e,
        this._onChangeCallback()
    }
    set(e, t, r, i) {
        return this._x = e,
        this._y = t,
        this._z = r,
        this._w = i,
        this._onChangeCallback(),
        this
    }
    clone() {
        return new this.constructor(this._x,this._y,this._z,this._w)
    }
    copy(e) {
        return this._x = e.x,
        this._y = e.y,
        this._z = e.z,
        this._w = e.w,
        this._onChangeCallback(),
        this
    }
    setFromEuler(e, t) {
        const r = e._x
          , i = e._y
          , s = e._z
          , o = e._order
          , a = Math.cos
          , l = Math.sin
          , f = a(r / 2)
          , h = a(i / 2)
          , d = a(s / 2)
          , p = l(r / 2)
          , m = l(i / 2)
          , _ = l(s / 2);
        switch (o) {
        case "XYZ":
            this._x = p * h * d + f * m * _,
            this._y = f * m * d - p * h * _,
            this._z = f * h * _ + p * m * d,
            this._w = f * h * d - p * m * _;
            break;
        case "YXZ":
            this._x = p * h * d + f * m * _,
            this._y = f * m * d - p * h * _,
            this._z = f * h * _ - p * m * d,
            this._w = f * h * d + p * m * _;
            break;
        case "ZXY":
            this._x = p * h * d - f * m * _,
            this._y = f * m * d + p * h * _,
            this._z = f * h * _ + p * m * d,
            this._w = f * h * d - p * m * _;
            break;
        case "ZYX":
            this._x = p * h * d - f * m * _,
            this._y = f * m * d + p * h * _,
            this._z = f * h * _ - p * m * d,
            this._w = f * h * d + p * m * _;
            break;
        case "YZX":
            this._x = p * h * d + f * m * _,
            this._y = f * m * d + p * h * _,
            this._z = f * h * _ - p * m * d,
            this._w = f * h * d - p * m * _;
            break;
        case "XZY":
            this._x = p * h * d - f * m * _,
            this._y = f * m * d - p * h * _,
            this._z = f * h * _ + p * m * d,
            this._w = f * h * d + p * m * _;
            break;
        default:
            console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + o)
        }
        return t !== !1 && this._onChangeCallback(),
        this
    }
    setFromAxisAngle(e, t) {
        const r = t / 2
          , i = Math.sin(r);
        return this._x = e.x * i,
        this._y = e.y * i,
        this._z = e.z * i,
        this._w = Math.cos(r),
        this._onChangeCallback(),
        this
    }
    setFromRotationMatrix(e) {
        const t = e.elements
          , r = t[0]
          , i = t[4]
          , s = t[8]
          , o = t[1]
          , a = t[5]
          , l = t[9]
          , f = t[2]
          , h = t[6]
          , d = t[10]
          , p = r + a + d;
        if (p > 0) {
            const m = .5 / Math.sqrt(p + 1);
            this._w = .25 / m,
            this._x = (h - l) * m,
            this._y = (s - f) * m,
            this._z = (o - i) * m
        } else if (r > a && r > d) {
            const m = 2 * Math.sqrt(1 + r - a - d);
            this._w = (h - l) / m,
            this._x = .25 * m,
            this._y = (i + o) / m,
            this._z = (s + f) / m
        } else if (a > d) {
            const m = 2 * Math.sqrt(1 + a - r - d);
            this._w = (s - f) / m,
            this._x = (i + o) / m,
            this._y = .25 * m,
            this._z = (l + h) / m
        } else {
            const m = 2 * Math.sqrt(1 + d - r - a);
            this._w = (o - i) / m,
            this._x = (s + f) / m,
            this._y = (l + h) / m,
            this._z = .25 * m
        }
        return this._onChangeCallback(),
        this
    }
    setFromUnitVectors(e, t) {
        let r = e.dot(t) + 1;
        return r < Number.EPSILON ? (r = 0,
        Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y,
        this._y = e.x,
        this._z = 0,
        this._w = r) : (this._x = 0,
        this._y = -e.z,
        this._z = e.y,
        this._w = r)) : (this._x = e.y * t.z - e.z * t.y,
        this._y = e.z * t.x - e.x * t.z,
        this._z = e.x * t.y - e.y * t.x,
        this._w = r),
        this.normalize()
    }
    angleTo(e) {
        return 2 * Math.acos(Math.abs($i(this.dot(e), -1, 1)))
    }
    rotateTowards(e, t) {
        const r = this.angleTo(e);
        if (r === 0)
            return this;
        const i = Math.min(1, t / r);
        return this.slerp(e, i),
        this
    }
    identity() {
        return this.set(0, 0, 0, 1)
    }
    invert() {
        return this.conjugate()
    }
    conjugate() {
        return this._x *= -1,
        this._y *= -1,
        this._z *= -1,
        this._onChangeCallback(),
        this
    }
    dot(e) {
        return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w
    }
    lengthSq() {
        return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
    }
    length() {
        return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
    }
    normalize() {
        let e = this.length();
        return e === 0 ? (this._x = 0,
        this._y = 0,
        this._z = 0,
        this._w = 1) : (e = 1 / e,
        this._x = this._x * e,
        this._y = this._y * e,
        this._z = this._z * e,
        this._w = this._w * e),
        this._onChangeCallback(),
        this
    }
    multiply(e) {
        return this.multiplyQuaternions(this, e)
    }
    premultiply(e) {
        return this.multiplyQuaternions(e, this)
    }
    multiplyQuaternions(e, t) {
        const r = e._x
          , i = e._y
          , s = e._z
          , o = e._w
          , a = t._x
          , l = t._y
          , f = t._z
          , h = t._w;
        return this._x = r * h + o * a + i * f - s * l,
        this._y = i * h + o * l + s * a - r * f,
        this._z = s * h + o * f + r * l - i * a,
        this._w = o * h - r * a - i * l - s * f,
        this._onChangeCallback(),
        this
    }
    slerp(e, t) {
        if (t === 0)
            return this;
        if (t === 1)
            return this.copy(e);
        const r = this._x
          , i = this._y
          , s = this._z
          , o = this._w;
        let a = o * e._w + r * e._x + i * e._y + s * e._z;
        if (a < 0 ? (this._w = -e._w,
        this._x = -e._x,
        this._y = -e._y,
        this._z = -e._z,
        a = -a) : this.copy(e),
        a >= 1)
            return this._w = o,
            this._x = r,
            this._y = i,
            this._z = s,
            this;
        const l = 1 - a * a;
        if (l <= Number.EPSILON) {
            const m = 1 - t;
            return this._w = m * o + t * this._w,
            this._x = m * r + t * this._x,
            this._y = m * i + t * this._y,
            this._z = m * s + t * this._z,
            this.normalize(),
            this._onChangeCallback(),
            this
        }
        const f = Math.sqrt(l)
          , h = Math.atan2(f, a)
          , d = Math.sin((1 - t) * h) / f
          , p = Math.sin(t * h) / f;
        return this._w = o * d + this._w * p,
        this._x = r * d + this._x * p,
        this._y = i * d + this._y * p,
        this._z = s * d + this._z * p,
        this._onChangeCallback(),
        this
    }
    slerpQuaternions(e, t, r) {
        return this.copy(e).slerp(t, r)
    }
    random() {
        const e = Math.random()
          , t = Math.sqrt(1 - e)
          , r = Math.sqrt(e)
          , i = 2 * Math.PI * Math.random()
          , s = 2 * Math.PI * Math.random();
        return this.set(t * Math.cos(i), r * Math.sin(s), r * Math.cos(s), t * Math.sin(i))
    }
    equals(e) {
        return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w
    }
    fromArray(e, t=0) {
        return this._x = e[t],
        this._y = e[t + 1],
        this._z = e[t + 2],
        this._w = e[t + 3],
        this._onChangeCallback(),
        this
    }
    toArray(e=[], t=0) {
        return e[t] = this._x,
        e[t + 1] = this._y,
        e[t + 2] = this._z,
        e[t + 3] = this._w,
        e
    }
    fromBufferAttribute(e, t) {
        return this._x = e.getX(t),
        this._y = e.getY(t),
        this._z = e.getZ(t),
        this._w = e.getW(t),
        this
    }
    _onChange(e) {
        return this._onChangeCallback = e,
        this
    }
    _onChangeCallback() {}
    *[Symbol.iterator]() {
        yield this._x,
        yield this._y,
        yield this._z,
        yield this._w
    }
}
class $ {
    constructor(e=0, t=0, r=0) {
        $.prototype.isVector3 = !0,
        this.x = e,
        this.y = t,
        this.z = r
    }
    set(e, t, r) {
        return r === void 0 && (r = this.z),
        this.x = e,
        this.y = t,
        this.z = r,
        this
    }
    setScalar(e) {
        return this.x = e,
        this.y = e,
        this.z = e,
        this
    }
    setX(e) {
        return this.x = e,
        this
    }
    setY(e) {
        return this.y = e,
        this
    }
    setZ(e) {
        return this.z = e,
        this
    }
    setComponent(e, t) {
        switch (e) {
        case 0:
            this.x = t;
            break;
        case 1:
            this.y = t;
            break;
        case 2:
            this.z = t;
            break;
        default:
            throw new Error("index is out of range: " + e)
        }
        return this
    }
    getComponent(e) {
        switch (e) {
        case 0:
            return this.x;
        case 1:
            return this.y;
        case 2:
            return this.z;
        default:
            throw new Error("index is out of range: " + e)
        }
    }
    clone() {
        return new this.constructor(this.x,this.y,this.z)
    }
    copy(e) {
        return this.x = e.x,
        this.y = e.y,
        this.z = e.z,
        this
    }
    add(e) {
        return this.x += e.x,
        this.y += e.y,
        this.z += e.z,
        this
    }
    addScalar(e) {
        return this.x += e,
        this.y += e,
        this.z += e,
        this
    }
    addVectors(e, t) {
        return this.x = e.x + t.x,
        this.y = e.y + t.y,
        this.z = e.z + t.z,
        this
    }
    addScaledVector(e, t) {
        return this.x += e.x * t,
        this.y += e.y * t,
        this.z += e.z * t,
        this
    }
    sub(e) {
        return this.x -= e.x,
        this.y -= e.y,
        this.z -= e.z,
        this
    }
    subScalar(e) {
        return this.x -= e,
        this.y -= e,
        this.z -= e,
        this
    }
    subVectors(e, t) {
        return this.x = e.x - t.x,
        this.y = e.y - t.y,
        this.z = e.z - t.z,
        this
    }
    multiply(e) {
        return this.x *= e.x,
        this.y *= e.y,
        this.z *= e.z,
        this
    }
    multiplyScalar(e) {
        return this.x *= e,
        this.y *= e,
        this.z *= e,
        this
    }
    multiplyVectors(e, t) {
        return this.x = e.x * t.x,
        this.y = e.y * t.y,
        this.z = e.z * t.z,
        this
    }
    applyEuler(e) {
        return this.applyQuaternion(MC.setFromEuler(e))
    }
    applyAxisAngle(e, t) {
        return this.applyQuaternion(MC.setFromAxisAngle(e, t))
    }
    applyMatrix3(e) {
        const t = this.x
          , r = this.y
          , i = this.z
          , s = e.elements;
        return this.x = s[0] * t + s[3] * r + s[6] * i,
        this.y = s[1] * t + s[4] * r + s[7] * i,
        this.z = s[2] * t + s[5] * r + s[8] * i,
        this
    }
    applyNormalMatrix(e) {
        return this.applyMatrix3(e).normalize()
    }
    applyMatrix4(e) {
        const t = this.x
          , r = this.y
          , i = this.z
          , s = e.elements
          , o = 1 / (s[3] * t + s[7] * r + s[11] * i + s[15]);
        return this.x = (s[0] * t + s[4] * r + s[8] * i + s[12]) * o,
        this.y = (s[1] * t + s[5] * r + s[9] * i + s[13]) * o,
        this.z = (s[2] * t + s[6] * r + s[10] * i + s[14]) * o,
        this
    }
    applyQuaternion(e) {
        const t = this.x
          , r = this.y
          , i = this.z
          , s = e.x
          , o = e.y
          , a = e.z
          , l = e.w
          , f = l * t + o * i - a * r
          , h = l * r + a * t - s * i
          , d = l * i + s * r - o * t
          , p = -s * t - o * r - a * i;
        return this.x = f * l + p * -s + h * -a - d * -o,
        this.y = h * l + p * -o + d * -s - f * -a,
        this.z = d * l + p * -a + f * -o - h * -s,
        this
    }
    project(e) {
        return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)
    }
    unproject(e) {
        return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)
    }
    transformDirection(e) {
        const t = this.x
          , r = this.y
          , i = this.z
          , s = e.elements;
        return this.x = s[0] * t + s[4] * r + s[8] * i,
        this.y = s[1] * t + s[5] * r + s[9] * i,
        this.z = s[2] * t + s[6] * r + s[10] * i,
        this.normalize()
    }
    divide(e) {
        return this.x /= e.x,
        this.y /= e.y,
        this.z /= e.z,
        this
    }
    divideScalar(e) {
        return this.multiplyScalar(1 / e)
    }
    min(e) {
        return this.x = Math.min(this.x, e.x),
        this.y = Math.min(this.y, e.y),
        this.z = Math.min(this.z, e.z),
        this
    }
    max(e) {
        return this.x = Math.max(this.x, e.x),
        this.y = Math.max(this.y, e.y),
        this.z = Math.max(this.z, e.z),
        this
    }
    clamp(e, t) {
        return this.x = Math.max(e.x, Math.min(t.x, this.x)),
        this.y = Math.max(e.y, Math.min(t.y, this.y)),
        this.z = Math.max(e.z, Math.min(t.z, this.z)),
        this
    }
    clampScalar(e, t) {
        return this.x = Math.max(e, Math.min(t, this.x)),
        this.y = Math.max(e, Math.min(t, this.y)),
        this.z = Math.max(e, Math.min(t, this.z)),
        this
    }
    clampLength(e, t) {
        const r = this.length();
        return this.divideScalar(r || 1).multiplyScalar(Math.max(e, Math.min(t, r)))
    }
    floor() {
        return this.x = Math.floor(this.x),
        this.y = Math.floor(this.y),
        this.z = Math.floor(this.z),
        this
    }
    ceil() {
        return this.x = Math.ceil(this.x),
        this.y = Math.ceil(this.y),
        this.z = Math.ceil(this.z),
        this
    }
    round() {
        return this.x = Math.round(this.x),
        this.y = Math.round(this.y),
        this.z = Math.round(this.z),
        this
    }
    roundToZero() {
        return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x),
        this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y),
        this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z),
        this
    }
    negate() {
        return this.x = -this.x,
        this.y = -this.y,
        this.z = -this.z,
        this
    }
    dot(e) {
        return this.x * e.x + this.y * e.y + this.z * e.z
    }
    lengthSq() {
        return this.x * this.x + this.y * this.y + this.z * this.z
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
    }
    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
    }
    normalize() {
        return this.divideScalar(this.length() || 1)
    }
    setLength(e) {
        return this.normalize().multiplyScalar(e)
    }
    lerp(e, t) {
        return this.x += (e.x - this.x) * t,
        this.y += (e.y - this.y) * t,
        this.z += (e.z - this.z) * t,
        this
    }
    lerpVectors(e, t, r) {
        return this.x = e.x + (t.x - e.x) * r,
        this.y = e.y + (t.y - e.y) * r,
        this.z = e.z + (t.z - e.z) * r,
        this
    }
    cross(e) {
        return this.crossVectors(this, e)
    }
    crossVectors(e, t) {
        const r = e.x
          , i = e.y
          , s = e.z
          , o = t.x
          , a = t.y
          , l = t.z;
        return this.x = i * l - s * a,
        this.y = s * o - r * l,
        this.z = r * a - i * o,
        this
    }
    projectOnVector(e) {
        const t = e.lengthSq();
        if (t === 0)
            return this.set(0, 0, 0);
        const r = e.dot(this) / t;
        return this.copy(e).multiplyScalar(r)
    }
    projectOnPlane(e) {
        return zy.copy(this).projectOnVector(e),
        this.sub(zy)
    }
    reflect(e) {
        return this.sub(zy.copy(e).multiplyScalar(2 * this.dot(e)))
    }
    angleTo(e) {
        const t = Math.sqrt(this.lengthSq() * e.lengthSq());
        if (t === 0)
            return Math.PI / 2;
        const r = this.dot(e) / t;
        return Math.acos($i(r, -1, 1))
    }
    distanceTo(e) {
        return Math.sqrt(this.distanceToSquared(e))
    }
    distanceToSquared(e) {
        const t = this.x - e.x
          , r = this.y - e.y
          , i = this.z - e.z;
        return t * t + r * r + i * i
    }
    manhattanDistanceTo(e) {
        return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
    }
    setFromSpherical(e) {
        return this.setFromSphericalCoords(e.radius, e.phi, e.theta)
    }
    setFromSphericalCoords(e, t, r) {
        const i = Math.sin(t) * e;
        return this.x = i * Math.sin(r),
        this.y = Math.cos(t) * e,
        this.z = i * Math.cos(r),
        this
    }
    setFromCylindrical(e) {
        return this.setFromCylindricalCoords(e.radius, e.theta, e.y)
    }
    setFromCylindricalCoords(e, t, r) {
        return this.x = e * Math.sin(t),
        this.y = r,
        this.z = e * Math.cos(t),
        this
    }
    setFromMatrixPosition(e) {
        const t = e.elements;
        return this.x = t[12],
        this.y = t[13],
        this.z = t[14],
        this
    }
    setFromMatrixScale(e) {
        const t = this.setFromMatrixColumn(e, 0).length()
          , r = this.setFromMatrixColumn(e, 1).length()
          , i = this.setFromMatrixColumn(e, 2).length();
        return this.x = t,
        this.y = r,
        this.z = i,
        this
    }
    setFromMatrixColumn(e, t) {
        return this.fromArray(e.elements, t * 4)
    }
    setFromMatrix3Column(e, t) {
        return this.fromArray(e.elements, t * 3)
    }
    setFromEuler(e) {
        return this.x = e._x,
        this.y = e._y,
        this.z = e._z,
        this
    }
    equals(e) {
        return e.x === this.x && e.y === this.y && e.z === this.z
    }
    fromArray(e, t=0) {
        return this.x = e[t],
        this.y = e[t + 1],
        this.z = e[t + 2],
        this
    }
    toArray(e=[], t=0) {
        return e[t] = this.x,
        e[t + 1] = this.y,
        e[t + 2] = this.z,
        e
    }
    fromBufferAttribute(e, t) {
        return this.x = e.getX(t),
        this.y = e.getY(t),
        this.z = e.getZ(t),
        this
    }
    random() {
        return this.x = Math.random(),
        this.y = Math.random(),
        this.z = Math.random(),
        this
    }
    randomDirection() {
        const e = (Math.random() - .5) * 2
          , t = Math.random() * Math.PI * 2
          , r = Math.sqrt(1 - e ** 2);
        return this.x = r * Math.cos(t),
        this.y = r * Math.sin(t),
        this.z = e,
        this
    }
    *[Symbol.iterator]() {
        yield this.x,
        yield this.y,
        yield this.z
    }
}
const zy = new $
  , MC = new Ws;
class kc {
    constructor(e=new $(1 / 0,1 / 0,1 / 0), t=new $(-1 / 0,-1 / 0,-1 / 0)) {
        this.isBox3 = !0,
        this.min = e,
        this.max = t
    }
    set(e, t) {
        return this.min.copy(e),
        this.max.copy(t),
        this
    }
    setFromArray(e) {
        let t = 1 / 0
          , r = 1 / 0
          , i = 1 / 0
          , s = -1 / 0
          , o = -1 / 0
          , a = -1 / 0;
        for (let l = 0, f = e.length; l < f; l += 3) {
            const h = e[l]
              , d = e[l + 1]
              , p = e[l + 2];
            h < t && (t = h),
            d < r && (r = d),
            p < i && (i = p),
            h > s && (s = h),
            d > o && (o = d),
            p > a && (a = p)
        }
        return this.min.set(t, r, i),
        this.max.set(s, o, a),
        this
    }
    setFromBufferAttribute(e) {
        let t = 1 / 0
          , r = 1 / 0
          , i = 1 / 0
          , s = -1 / 0
          , o = -1 / 0
          , a = -1 / 0;
        for (let l = 0, f = e.count; l < f; l++) {
            const h = e.getX(l)
              , d = e.getY(l)
              , p = e.getZ(l);
            h < t && (t = h),
            d < r && (r = d),
            p < i && (i = p),
            h > s && (s = h),
            d > o && (o = d),
            p > a && (a = p)
        }
        return this.min.set(t, r, i),
        this.max.set(s, o, a),
        this
    }
    setFromPoints(e) {
        this.makeEmpty();
        for (let t = 0, r = e.length; t < r; t++)
            this.expandByPoint(e[t]);
        return this
    }
    setFromCenterAndSize(e, t) {
        const r = Qc.copy(t).multiplyScalar(.5);
        return this.min.copy(e).sub(r),
        this.max.copy(e).add(r),
        this
    }
    setFromObject(e, t=!1) {
        return this.makeEmpty(),
        this.expandByObject(e, t)
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        return this.min.copy(e.min),
        this.max.copy(e.max),
        this
    }
    makeEmpty() {
        return this.min.x = this.min.y = this.min.z = 1 / 0,
        this.max.x = this.max.y = this.max.z = -1 / 0,
        this
    }
    isEmpty() {
        return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
    }
    getCenter(e) {
        return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
    }
    getSize(e) {
        return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min)
    }
    expandByPoint(e) {
        return this.min.min(e),
        this.max.max(e),
        this
    }
    expandByVector(e) {
        return this.min.sub(e),
        this.max.add(e),
        this
    }
    expandByScalar(e) {
        return this.min.addScalar(-e),
        this.max.addScalar(e),
        this
    }
    expandByObject(e, t=!1) {
        e.updateWorldMatrix(!1, !1);
        const r = e.geometry;
        if (r !== void 0)
            if (t && r.attributes != null && r.attributes.position !== void 0) {
                const s = r.attributes.position;
                for (let o = 0, a = s.count; o < a; o++)
                    Qc.fromBufferAttribute(s, o).applyMatrix4(e.matrixWorld),
                    this.expandByPoint(Qc)
            } else
                r.boundingBox === null && r.computeBoundingBox(),
                Gy.copy(r.boundingBox),
                Gy.applyMatrix4(e.matrixWorld),
                this.union(Gy);
        const i = e.children;
        for (let s = 0, o = i.length; s < o; s++)
            this.expandByObject(i[s], t);
        return this
    }
    containsPoint(e) {
        return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z)
    }
    containsBox(e) {
        return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z
    }
    getParameter(e, t) {
        return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z))
    }
    intersectsBox(e) {
        return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z)
    }
    intersectsSphere(e) {
        return this.clampPoint(e.center, Qc),
        Qc.distanceToSquared(e.center) <= e.radius * e.radius
    }
    intersectsPlane(e) {
        let t, r;
        return e.normal.x > 0 ? (t = e.normal.x * this.min.x,
        r = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x,
        r = e.normal.x * this.min.x),
        e.normal.y > 0 ? (t += e.normal.y * this.min.y,
        r += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y,
        r += e.normal.y * this.min.y),
        e.normal.z > 0 ? (t += e.normal.z * this.min.z,
        r += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z,
        r += e.normal.z * this.min.z),
        t <= -e.constant && r >= -e.constant
    }
    intersectsTriangle(e) {
        if (this.isEmpty())
            return !1;
        this.getCenter(Zh),
        Ng.subVectors(this.max, Zh),
        ud.subVectors(e.a, Zh),
        cd.subVectors(e.b, Zh),
        fd.subVectors(e.c, Zh),
        Yu.subVectors(cd, ud),
        Ku.subVectors(fd, cd),
        Zc.subVectors(ud, fd);
        let t = [0, -Yu.z, Yu.y, 0, -Ku.z, Ku.y, 0, -Zc.z, Zc.y, Yu.z, 0, -Yu.x, Ku.z, 0, -Ku.x, Zc.z, 0, -Zc.x, -Yu.y, Yu.x, 0, -Ku.y, Ku.x, 0, -Zc.y, Zc.x, 0];
        return !Uy(t, ud, cd, fd, Ng) || (t = [1, 0, 0, 0, 1, 0, 0, 0, 1],
        !Uy(t, ud, cd, fd, Ng)) ? !1 : (zg.crossVectors(Yu, Ku),
        t = [zg.x, zg.y, zg.z],
        Uy(t, ud, cd, fd, Ng))
    }
    clampPoint(e, t) {
        return t.copy(e).clamp(this.min, this.max)
    }
    distanceToPoint(e) {
        return Qc.copy(e).clamp(this.min, this.max).sub(e).length()
    }
    getBoundingSphere(e) {
        return this.getCenter(e.center),
        e.radius = this.getSize(Qc).length() * .5,
        e
    }
    intersect(e) {
        return this.min.max(e.min),
        this.max.min(e.max),
        this.isEmpty() && this.makeEmpty(),
        this
    }
    union(e) {
        return this.min.min(e.min),
        this.max.max(e.max),
        this
    }
    applyMatrix4(e) {
        return this.isEmpty() ? this : (ru[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e),
        ru[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e),
        ru[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e),
        ru[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e),
        ru[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e),
        ru[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e),
        ru[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e),
        ru[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e),
        this.setFromPoints(ru),
        this)
    }
    translate(e) {
        return this.min.add(e),
        this.max.add(e),
        this
    }
    equals(e) {
        return e.min.equals(this.min) && e.max.equals(this.max)
    }
}
const ru = [new $, new $, new $, new $, new $, new $, new $, new $]
  , Qc = new $
  , Gy = new kc
  , ud = new $
  , cd = new $
  , fd = new $
  , Yu = new $
  , Ku = new $
  , Zc = new $
  , Zh = new $
  , Ng = new $
  , zg = new $
  , $c = new $;
function Uy(n, e, t, r, i) {
    for (let s = 0, o = n.length - 3; s <= o; s += 3) {
        $c.fromArray(n, s);
        const a = i.x * Math.abs($c.x) + i.y * Math.abs($c.y) + i.z * Math.abs($c.z)
          , l = e.dot($c)
          , f = t.dot($c)
          , h = r.dot($c);
        if (Math.max(-Math.max(l, f, h), Math.min(l, f, h)) > a)
            return !1
    }
    return !0
}
const YL = new kc
  , $h = new $
  , Hy = new $;
class Oc {
    constructor(e=new $, t=-1) {
        this.center = e,
        this.radius = t
    }
    set(e, t) {
        return this.center.copy(e),
        this.radius = t,
        this
    }
    setFromPoints(e, t) {
        const r = this.center;
        t !== void 0 ? r.copy(t) : YL.setFromPoints(e).getCenter(r);
        let i = 0;
        for (let s = 0, o = e.length; s < o; s++)
            i = Math.max(i, r.distanceToSquared(e[s]));
        return this.radius = Math.sqrt(i),
        this
    }
    copy(e) {
        return this.center.copy(e.center),
        this.radius = e.radius,
        this
    }
    isEmpty() {
        return this.radius < 0
    }
    makeEmpty() {
        return this.center.set(0, 0, 0),
        this.radius = -1,
        this
    }
    containsPoint(e) {
        return e.distanceToSquared(this.center) <= this.radius * this.radius
    }
    distanceToPoint(e) {
        return e.distanceTo(this.center) - this.radius
    }
    intersectsSphere(e) {
        const t = this.radius + e.radius;
        return e.center.distanceToSquared(this.center) <= t * t
    }
    intersectsBox(e) {
        return e.intersectsSphere(this)
    }
    intersectsPlane(e) {
        return Math.abs(e.distanceToPoint(this.center)) <= this.radius
    }
    clampPoint(e, t) {
        const r = this.center.distanceToSquared(e);
        return t.copy(e),
        r > this.radius * this.radius && (t.sub(this.center).normalize(),
        t.multiplyScalar(this.radius).add(this.center)),
        t
    }
    getBoundingBox(e) {
        return this.isEmpty() ? (e.makeEmpty(),
        e) : (e.set(this.center, this.center),
        e.expandByScalar(this.radius),
        e)
    }
    applyMatrix4(e) {
        return this.center.applyMatrix4(e),
        this.radius = this.radius * e.getMaxScaleOnAxis(),
        this
    }
    translate(e) {
        return this.center.add(e),
        this
    }
    expandByPoint(e) {
        if (this.isEmpty())
            return this.center.copy(e),
            this.radius = 0,
            this;
        $h.subVectors(e, this.center);
        const t = $h.lengthSq();
        if (t > this.radius * this.radius) {
            const r = Math.sqrt(t)
              , i = (r - this.radius) * .5;
            this.center.addScaledVector($h, i / r),
            this.radius += i
        }
        return this
    }
    union(e) {
        return e.isEmpty() ? this : this.isEmpty() ? (this.copy(e),
        this) : (this.center.equals(e.center) === !0 ? this.radius = Math.max(this.radius, e.radius) : (Hy.subVectors(e.center, this.center).setLength(e.radius),
        this.expandByPoint($h.copy(e.center).add(Hy)),
        this.expandByPoint($h.copy(e.center).sub(Hy))),
        this)
    }
    equals(e) {
        return e.center.equals(this.center) && e.radius === this.radius
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
const iu = new $
  , Vy = new $
  , Gg = new $
  , qu = new $
  , Wy = new $
  , Ug = new $
  , Xy = new $;
class Fm {
    constructor(e=new $, t=new $(0,0,-1)) {
        this.origin = e,
        this.direction = t
    }
    set(e, t) {
        return this.origin.copy(e),
        this.direction.copy(t),
        this
    }
    copy(e) {
        return this.origin.copy(e.origin),
        this.direction.copy(e.direction),
        this
    }
    at(e, t) {
        return t.copy(this.direction).multiplyScalar(e).add(this.origin)
    }
    lookAt(e) {
        return this.direction.copy(e).sub(this.origin).normalize(),
        this
    }
    recast(e) {
        return this.origin.copy(this.at(e, iu)),
        this
    }
    closestPointToPoint(e, t) {
        t.subVectors(e, this.origin);
        const r = t.dot(this.direction);
        return r < 0 ? t.copy(this.origin) : t.copy(this.direction).multiplyScalar(r).add(this.origin)
    }
    distanceToPoint(e) {
        return Math.sqrt(this.distanceSqToPoint(e))
    }
    distanceSqToPoint(e) {
        const t = iu.subVectors(e, this.origin).dot(this.direction);
        return t < 0 ? this.origin.distanceToSquared(e) : (iu.copy(this.direction).multiplyScalar(t).add(this.origin),
        iu.distanceToSquared(e))
    }
    distanceSqToSegment(e, t, r, i) {
        Vy.copy(e).add(t).multiplyScalar(.5),
        Gg.copy(t).sub(e).normalize(),
        qu.copy(this.origin).sub(Vy);
        const s = e.distanceTo(t) * .5
          , o = -this.direction.dot(Gg)
          , a = qu.dot(this.direction)
          , l = -qu.dot(Gg)
          , f = qu.lengthSq()
          , h = Math.abs(1 - o * o);
        let d, p, m, _;
        if (h > 0)
            if (d = o * l - a,
            p = o * a - l,
            _ = s * h,
            d >= 0)
                if (p >= -_)
                    if (p <= _) {
                        const y = 1 / h;
                        d *= y,
                        p *= y,
                        m = d * (d + o * p + 2 * a) + p * (o * d + p + 2 * l) + f
                    } else
                        p = s,
                        d = Math.max(0, -(o * p + a)),
                        m = -d * d + p * (p + 2 * l) + f;
                else
                    p = -s,
                    d = Math.max(0, -(o * p + a)),
                    m = -d * d + p * (p + 2 * l) + f;
            else
                p <= -_ ? (d = Math.max(0, -(-o * s + a)),
                p = d > 0 ? -s : Math.min(Math.max(-s, -l), s),
                m = -d * d + p * (p + 2 * l) + f) : p <= _ ? (d = 0,
                p = Math.min(Math.max(-s, -l), s),
                m = p * (p + 2 * l) + f) : (d = Math.max(0, -(o * s + a)),
                p = d > 0 ? s : Math.min(Math.max(-s, -l), s),
                m = -d * d + p * (p + 2 * l) + f);
        else
            p = o > 0 ? -s : s,
            d = Math.max(0, -(o * p + a)),
            m = -d * d + p * (p + 2 * l) + f;
        return r && r.copy(this.direction).multiplyScalar(d).add(this.origin),
        i && i.copy(Gg).multiplyScalar(p).add(Vy),
        m
    }
    intersectSphere(e, t) {
        iu.subVectors(e.center, this.origin);
        const r = iu.dot(this.direction)
          , i = iu.dot(iu) - r * r
          , s = e.radius * e.radius;
        if (i > s)
            return null;
        const o = Math.sqrt(s - i)
          , a = r - o
          , l = r + o;
        return a < 0 && l < 0 ? null : a < 0 ? this.at(l, t) : this.at(a, t)
    }
    intersectsSphere(e) {
        return this.distanceSqToPoint(e.center) <= e.radius * e.radius
    }
    distanceToPlane(e) {
        const t = e.normal.dot(this.direction);
        if (t === 0)
            return e.distanceToPoint(this.origin) === 0 ? 0 : null;
        const r = -(this.origin.dot(e.normal) + e.constant) / t;
        return r >= 0 ? r : null
    }
    intersectPlane(e, t) {
        const r = this.distanceToPlane(e);
        return r === null ? null : this.at(r, t)
    }
    intersectsPlane(e) {
        const t = e.distanceToPoint(this.origin);
        return t === 0 || e.normal.dot(this.direction) * t < 0
    }
    intersectBox(e, t) {
        let r, i, s, o, a, l;
        const f = 1 / this.direction.x
          , h = 1 / this.direction.y
          , d = 1 / this.direction.z
          , p = this.origin;
        return f >= 0 ? (r = (e.min.x - p.x) * f,
        i = (e.max.x - p.x) * f) : (r = (e.max.x - p.x) * f,
        i = (e.min.x - p.x) * f),
        h >= 0 ? (s = (e.min.y - p.y) * h,
        o = (e.max.y - p.y) * h) : (s = (e.max.y - p.y) * h,
        o = (e.min.y - p.y) * h),
        r > o || s > i || ((s > r || isNaN(r)) && (r = s),
        (o < i || isNaN(i)) && (i = o),
        d >= 0 ? (a = (e.min.z - p.z) * d,
        l = (e.max.z - p.z) * d) : (a = (e.max.z - p.z) * d,
        l = (e.min.z - p.z) * d),
        r > l || a > i) || ((a > r || r !== r) && (r = a),
        (l < i || i !== i) && (i = l),
        i < 0) ? null : this.at(r >= 0 ? r : i, t)
    }
    intersectsBox(e) {
        return this.intersectBox(e, iu) !== null
    }
    intersectTriangle(e, t, r, i, s) {
        Wy.subVectors(t, e),
        Ug.subVectors(r, e),
        Xy.crossVectors(Wy, Ug);
        let o = this.direction.dot(Xy), a;
        if (o > 0) {
            if (i)
                return null;
            a = 1
        } else if (o < 0)
            a = -1,
            o = -o;
        else
            return null;
        qu.subVectors(this.origin, e);
        const l = a * this.direction.dot(Ug.crossVectors(qu, Ug));
        if (l < 0)
            return null;
        const f = a * this.direction.dot(Wy.cross(qu));
        if (f < 0 || l + f > o)
            return null;
        const h = -a * qu.dot(Xy);
        return h < 0 ? null : this.at(h / o, s)
    }
    applyMatrix4(e) {
        return this.origin.applyMatrix4(e),
        this.direction.transformDirection(e),
        this
    }
    equals(e) {
        return e.origin.equals(this.origin) && e.direction.equals(this.direction)
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
class Dn {
    constructor() {
        Dn.prototype.isMatrix4 = !0,
        this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]
    }
    set(e, t, r, i, s, o, a, l, f, h, d, p, m, _, y, x) {
        const S = this.elements;
        return S[0] = e,
        S[4] = t,
        S[8] = r,
        S[12] = i,
        S[1] = s,
        S[5] = o,
        S[9] = a,
        S[13] = l,
        S[2] = f,
        S[6] = h,
        S[10] = d,
        S[14] = p,
        S[3] = m,
        S[7] = _,
        S[11] = y,
        S[15] = x,
        this
    }
    identity() {
        return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
        this
    }
    clone() {
        return new Dn().fromArray(this.elements)
    }
    copy(e) {
        const t = this.elements
          , r = e.elements;
        return t[0] = r[0],
        t[1] = r[1],
        t[2] = r[2],
        t[3] = r[3],
        t[4] = r[4],
        t[5] = r[5],
        t[6] = r[6],
        t[7] = r[7],
        t[8] = r[8],
        t[9] = r[9],
        t[10] = r[10],
        t[11] = r[11],
        t[12] = r[12],
        t[13] = r[13],
        t[14] = r[14],
        t[15] = r[15],
        this
    }
    copyPosition(e) {
        const t = this.elements
          , r = e.elements;
        return t[12] = r[12],
        t[13] = r[13],
        t[14] = r[14],
        this
    }
    setFromMatrix3(e) {
        const t = e.elements;
        return this.set(t[0], t[3], t[6], 0, t[1], t[4], t[7], 0, t[2], t[5], t[8], 0, 0, 0, 0, 1),
        this
    }
    extractBasis(e, t, r) {
        return e.setFromMatrixColumn(this, 0),
        t.setFromMatrixColumn(this, 1),
        r.setFromMatrixColumn(this, 2),
        this
    }
    makeBasis(e, t, r) {
        return this.set(e.x, t.x, r.x, 0, e.y, t.y, r.y, 0, e.z, t.z, r.z, 0, 0, 0, 0, 1),
        this
    }
    extractRotation(e) {
        const t = this.elements
          , r = e.elements
          , i = 1 / dd.setFromMatrixColumn(e, 0).length()
          , s = 1 / dd.setFromMatrixColumn(e, 1).length()
          , o = 1 / dd.setFromMatrixColumn(e, 2).length();
        return t[0] = r[0] * i,
        t[1] = r[1] * i,
        t[2] = r[2] * i,
        t[3] = 0,
        t[4] = r[4] * s,
        t[5] = r[5] * s,
        t[6] = r[6] * s,
        t[7] = 0,
        t[8] = r[8] * o,
        t[9] = r[9] * o,
        t[10] = r[10] * o,
        t[11] = 0,
        t[12] = 0,
        t[13] = 0,
        t[14] = 0,
        t[15] = 1,
        this
    }
    makeRotationFromEuler(e) {
        const t = this.elements
          , r = e.x
          , i = e.y
          , s = e.z
          , o = Math.cos(r)
          , a = Math.sin(r)
          , l = Math.cos(i)
          , f = Math.sin(i)
          , h = Math.cos(s)
          , d = Math.sin(s);
        if (e.order === "XYZ") {
            const p = o * h
              , m = o * d
              , _ = a * h
              , y = a * d;
            t[0] = l * h,
            t[4] = -l * d,
            t[8] = f,
            t[1] = m + _ * f,
            t[5] = p - y * f,
            t[9] = -a * l,
            t[2] = y - p * f,
            t[6] = _ + m * f,
            t[10] = o * l
        } else if (e.order === "YXZ") {
            const p = l * h
              , m = l * d
              , _ = f * h
              , y = f * d;
            t[0] = p + y * a,
            t[4] = _ * a - m,
            t[8] = o * f,
            t[1] = o * d,
            t[5] = o * h,
            t[9] = -a,
            t[2] = m * a - _,
            t[6] = y + p * a,
            t[10] = o * l
        } else if (e.order === "ZXY") {
            const p = l * h
              , m = l * d
              , _ = f * h
              , y = f * d;
            t[0] = p - y * a,
            t[4] = -o * d,
            t[8] = _ + m * a,
            t[1] = m + _ * a,
            t[5] = o * h,
            t[9] = y - p * a,
            t[2] = -o * f,
            t[6] = a,
            t[10] = o * l
        } else if (e.order === "ZYX") {
            const p = o * h
              , m = o * d
              , _ = a * h
              , y = a * d;
            t[0] = l * h,
            t[4] = _ * f - m,
            t[8] = p * f + y,
            t[1] = l * d,
            t[5] = y * f + p,
            t[9] = m * f - _,
            t[2] = -f,
            t[6] = a * l,
            t[10] = o * l
        } else if (e.order === "YZX") {
            const p = o * l
              , m = o * f
              , _ = a * l
              , y = a * f;
            t[0] = l * h,
            t[4] = y - p * d,
            t[8] = _ * d + m,
            t[1] = d,
            t[5] = o * h,
            t[9] = -a * h,
            t[2] = -f * h,
            t[6] = m * d + _,
            t[10] = p - y * d
        } else if (e.order === "XZY") {
            const p = o * l
              , m = o * f
              , _ = a * l
              , y = a * f;
            t[0] = l * h,
            t[4] = -d,
            t[8] = f * h,
            t[1] = p * d + y,
            t[5] = o * h,
            t[9] = m * d - _,
            t[2] = _ * d - m,
            t[6] = a * h,
            t[10] = y * d + p
        }
        return t[3] = 0,
        t[7] = 0,
        t[11] = 0,
        t[12] = 0,
        t[13] = 0,
        t[14] = 0,
        t[15] = 1,
        this
    }
    makeRotationFromQuaternion(e) {
        return this.compose(KL, e, qL)
    }
    lookAt(e, t, r) {
        const i = this.elements;
        return ua.subVectors(e, t),
        ua.lengthSq() === 0 && (ua.z = 1),
        ua.normalize(),
        Qu.crossVectors(r, ua),
        Qu.lengthSq() === 0 && (Math.abs(r.z) === 1 ? ua.x += 1e-4 : ua.z += 1e-4,
        ua.normalize(),
        Qu.crossVectors(r, ua)),
        Qu.normalize(),
        Hg.crossVectors(ua, Qu),
        i[0] = Qu.x,
        i[4] = Hg.x,
        i[8] = ua.x,
        i[1] = Qu.y,
        i[5] = Hg.y,
        i[9] = ua.y,
        i[2] = Qu.z,
        i[6] = Hg.z,
        i[10] = ua.z,
        this
    }
    multiply(e) {
        return this.multiplyMatrices(this, e)
    }
    premultiply(e) {
        return this.multiplyMatrices(e, this)
    }
    multiplyMatrices(e, t) {
        const r = e.elements
          , i = t.elements
          , s = this.elements
          , o = r[0]
          , a = r[4]
          , l = r[8]
          , f = r[12]
          , h = r[1]
          , d = r[5]
          , p = r[9]
          , m = r[13]
          , _ = r[2]
          , y = r[6]
          , x = r[10]
          , S = r[14]
          , M = r[3]
          , w = r[7]
          , T = r[11]
          , P = r[15]
          , I = i[0]
          , k = i[4]
          , R = i[8]
          , O = i[12]
          , H = i[1]
          , W = i[5]
          , te = i[9]
          , ne = i[13]
          , re = i[2]
          , pe = i[6]
          , ce = i[10]
          , xe = i[14]
          , G = i[3]
          , z = i[7]
          , U = i[11]
          , fe = i[15];
        return s[0] = o * I + a * H + l * re + f * G,
        s[4] = o * k + a * W + l * pe + f * z,
        s[8] = o * R + a * te + l * ce + f * U,
        s[12] = o * O + a * ne + l * xe + f * fe,
        s[1] = h * I + d * H + p * re + m * G,
        s[5] = h * k + d * W + p * pe + m * z,
        s[9] = h * R + d * te + p * ce + m * U,
        s[13] = h * O + d * ne + p * xe + m * fe,
        s[2] = _ * I + y * H + x * re + S * G,
        s[6] = _ * k + y * W + x * pe + S * z,
        s[10] = _ * R + y * te + x * ce + S * U,
        s[14] = _ * O + y * ne + x * xe + S * fe,
        s[3] = M * I + w * H + T * re + P * G,
        s[7] = M * k + w * W + T * pe + P * z,
        s[11] = M * R + w * te + T * ce + P * U,
        s[15] = M * O + w * ne + T * xe + P * fe,
        this
    }
    multiplyScalar(e) {
        const t = this.elements;
        return t[0] *= e,
        t[4] *= e,
        t[8] *= e,
        t[12] *= e,
        t[1] *= e,
        t[5] *= e,
        t[9] *= e,
        t[13] *= e,
        t[2] *= e,
        t[6] *= e,
        t[10] *= e,
        t[14] *= e,
        t[3] *= e,
        t[7] *= e,
        t[11] *= e,
        t[15] *= e,
        this
    }
    determinant() {
        const e = this.elements
          , t = e[0]
          , r = e[4]
          , i = e[8]
          , s = e[12]
          , o = e[1]
          , a = e[5]
          , l = e[9]
          , f = e[13]
          , h = e[2]
          , d = e[6]
          , p = e[10]
          , m = e[14]
          , _ = e[3]
          , y = e[7]
          , x = e[11]
          , S = e[15];
        return _ * (+s * l * d - i * f * d - s * a * p + r * f * p + i * a * m - r * l * m) + y * (+t * l * m - t * f * p + s * o * p - i * o * m + i * f * h - s * l * h) + x * (+t * f * d - t * a * m - s * o * d + r * o * m + s * a * h - r * f * h) + S * (-i * a * h - t * l * d + t * a * p + i * o * d - r * o * p + r * l * h)
    }
    transpose() {
        const e = this.elements;
        let t;
        return t = e[1],
        e[1] = e[4],
        e[4] = t,
        t = e[2],
        e[2] = e[8],
        e[8] = t,
        t = e[6],
        e[6] = e[9],
        e[9] = t,
        t = e[3],
        e[3] = e[12],
        e[12] = t,
        t = e[7],
        e[7] = e[13],
        e[13] = t,
        t = e[11],
        e[11] = e[14],
        e[14] = t,
        this
    }
    setPosition(e, t, r) {
        const i = this.elements;
        return e.isVector3 ? (i[12] = e.x,
        i[13] = e.y,
        i[14] = e.z) : (i[12] = e,
        i[13] = t,
        i[14] = r),
        this
    }
    invert() {
        const e = this.elements
          , t = e[0]
          , r = e[1]
          , i = e[2]
          , s = e[3]
          , o = e[4]
          , a = e[5]
          , l = e[6]
          , f = e[7]
          , h = e[8]
          , d = e[9]
          , p = e[10]
          , m = e[11]
          , _ = e[12]
          , y = e[13]
          , x = e[14]
          , S = e[15]
          , M = d * x * f - y * p * f + y * l * m - a * x * m - d * l * S + a * p * S
          , w = _ * p * f - h * x * f - _ * l * m + o * x * m + h * l * S - o * p * S
          , T = h * y * f - _ * d * f + _ * a * m - o * y * m - h * a * S + o * d * S
          , P = _ * d * l - h * y * l - _ * a * p + o * y * p + h * a * x - o * d * x
          , I = t * M + r * w + i * T + s * P;
        if (I === 0)
            return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        const k = 1 / I;
        return e[0] = M * k,
        e[1] = (y * p * s - d * x * s - y * i * m + r * x * m + d * i * S - r * p * S) * k,
        e[2] = (a * x * s - y * l * s + y * i * f - r * x * f - a * i * S + r * l * S) * k,
        e[3] = (d * l * s - a * p * s - d * i * f + r * p * f + a * i * m - r * l * m) * k,
        e[4] = w * k,
        e[5] = (h * x * s - _ * p * s + _ * i * m - t * x * m - h * i * S + t * p * S) * k,
        e[6] = (_ * l * s - o * x * s - _ * i * f + t * x * f + o * i * S - t * l * S) * k,
        e[7] = (o * p * s - h * l * s + h * i * f - t * p * f - o * i * m + t * l * m) * k,
        e[8] = T * k,
        e[9] = (_ * d * s - h * y * s - _ * r * m + t * y * m + h * r * S - t * d * S) * k,
        e[10] = (o * y * s - _ * a * s + _ * r * f - t * y * f - o * r * S + t * a * S) * k,
        e[11] = (h * a * s - o * d * s - h * r * f + t * d * f + o * r * m - t * a * m) * k,
        e[12] = P * k,
        e[13] = (h * y * i - _ * d * i + _ * r * p - t * y * p - h * r * x + t * d * x) * k,
        e[14] = (_ * a * i - o * y * i - _ * r * l + t * y * l + o * r * x - t * a * x) * k,
        e[15] = (o * d * i - h * a * i + h * r * l - t * d * l - o * r * p + t * a * p) * k,
        this
    }
    scale(e) {
        const t = this.elements
          , r = e.x
          , i = e.y
          , s = e.z;
        return t[0] *= r,
        t[4] *= i,
        t[8] *= s,
        t[1] *= r,
        t[5] *= i,
        t[9] *= s,
        t[2] *= r,
        t[6] *= i,
        t[10] *= s,
        t[3] *= r,
        t[7] *= i,
        t[11] *= s,
        this
    }
    getMaxScaleOnAxis() {
        const e = this.elements
          , t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2]
          , r = e[4] * e[4] + e[5] * e[5] + e[6] * e[6]
          , i = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
        return Math.sqrt(Math.max(t, r, i))
    }
    makeTranslation(e, t, r) {
        return this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, r, 0, 0, 0, 1),
        this
    }
    makeRotationX(e) {
        const t = Math.cos(e)
          , r = Math.sin(e);
        return this.set(1, 0, 0, 0, 0, t, -r, 0, 0, r, t, 0, 0, 0, 0, 1),
        this
    }
    makeRotationY(e) {
        const t = Math.cos(e)
          , r = Math.sin(e);
        return this.set(t, 0, r, 0, 0, 1, 0, 0, -r, 0, t, 0, 0, 0, 0, 1),
        this
    }
    makeRotationZ(e) {
        const t = Math.cos(e)
          , r = Math.sin(e);
        return this.set(t, -r, 0, 0, r, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
        this
    }
    makeRotationAxis(e, t) {
        const r = Math.cos(t)
          , i = Math.sin(t)
          , s = 1 - r
          , o = e.x
          , a = e.y
          , l = e.z
          , f = s * o
          , h = s * a;
        return this.set(f * o + r, f * a - i * l, f * l + i * a, 0, f * a + i * l, h * a + r, h * l - i * o, 0, f * l - i * a, h * l + i * o, s * l * l + r, 0, 0, 0, 0, 1),
        this
    }
    makeScale(e, t, r) {
        return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, r, 0, 0, 0, 0, 1),
        this
    }
    makeShear(e, t, r, i, s, o) {
        return this.set(1, r, s, 0, e, 1, o, 0, t, i, 1, 0, 0, 0, 0, 1),
        this
    }
    compose(e, t, r) {
        const i = this.elements
          , s = t._x
          , o = t._y
          , a = t._z
          , l = t._w
          , f = s + s
          , h = o + o
          , d = a + a
          , p = s * f
          , m = s * h
          , _ = s * d
          , y = o * h
          , x = o * d
          , S = a * d
          , M = l * f
          , w = l * h
          , T = l * d
          , P = r.x
          , I = r.y
          , k = r.z;
        return i[0] = (1 - (y + S)) * P,
        i[1] = (m + T) * P,
        i[2] = (_ - w) * P,
        i[3] = 0,
        i[4] = (m - T) * I,
        i[5] = (1 - (p + S)) * I,
        i[6] = (x + M) * I,
        i[7] = 0,
        i[8] = (_ + w) * k,
        i[9] = (x - M) * k,
        i[10] = (1 - (p + y)) * k,
        i[11] = 0,
        i[12] = e.x,
        i[13] = e.y,
        i[14] = e.z,
        i[15] = 1,
        this
    }
    decompose(e, t, r) {
        const i = this.elements;
        let s = dd.set(i[0], i[1], i[2]).length();
        const o = dd.set(i[4], i[5], i[6]).length()
          , a = dd.set(i[8], i[9], i[10]).length();
        this.determinant() < 0 && (s = -s),
        e.x = i[12],
        e.y = i[13],
        e.z = i[14],
        cl.copy(this);
        const f = 1 / s
          , h = 1 / o
          , d = 1 / a;
        return cl.elements[0] *= f,
        cl.elements[1] *= f,
        cl.elements[2] *= f,
        cl.elements[4] *= h,
        cl.elements[5] *= h,
        cl.elements[6] *= h,
        cl.elements[8] *= d,
        cl.elements[9] *= d,
        cl.elements[10] *= d,
        t.setFromRotationMatrix(cl),
        r.x = s,
        r.y = o,
        r.z = a,
        this
    }
    makePerspective(e, t, r, i, s, o) {
        const a = this.elements
          , l = 2 * s / (t - e)
          , f = 2 * s / (r - i)
          , h = (t + e) / (t - e)
          , d = (r + i) / (r - i)
          , p = -(o + s) / (o - s)
          , m = -2 * o * s / (o - s);
        return a[0] = l,
        a[4] = 0,
        a[8] = h,
        a[12] = 0,
        a[1] = 0,
        a[5] = f,
        a[9] = d,
        a[13] = 0,
        a[2] = 0,
        a[6] = 0,
        a[10] = p,
        a[14] = m,
        a[3] = 0,
        a[7] = 0,
        a[11] = -1,
        a[15] = 0,
        this
    }
    makeOrthographic(e, t, r, i, s, o) {
        const a = this.elements
          , l = 1 / (t - e)
          , f = 1 / (r - i)
          , h = 1 / (o - s)
          , d = (t + e) * l
          , p = (r + i) * f
          , m = (o + s) * h;
        return a[0] = 2 * l,
        a[4] = 0,
        a[8] = 0,
        a[12] = -d,
        a[1] = 0,
        a[5] = 2 * f,
        a[9] = 0,
        a[13] = -p,
        a[2] = 0,
        a[6] = 0,
        a[10] = -2 * h,
        a[14] = -m,
        a[3] = 0,
        a[7] = 0,
        a[11] = 0,
        a[15] = 1,
        this
    }
    equals(e) {
        const t = this.elements
          , r = e.elements;
        for (let i = 0; i < 16; i++)
            if (t[i] !== r[i])
                return !1;
        return !0
    }
    fromArray(e, t=0) {
        for (let r = 0; r < 16; r++)
            this.elements[r] = e[r + t];
        return this
    }
    toArray(e=[], t=0) {
        const r = this.elements;
        return e[t] = r[0],
        e[t + 1] = r[1],
        e[t + 2] = r[2],
        e[t + 3] = r[3],
        e[t + 4] = r[4],
        e[t + 5] = r[5],
        e[t + 6] = r[6],
        e[t + 7] = r[7],
        e[t + 8] = r[8],
        e[t + 9] = r[9],
        e[t + 10] = r[10],
        e[t + 11] = r[11],
        e[t + 12] = r[12],
        e[t + 13] = r[13],
        e[t + 14] = r[14],
        e[t + 15] = r[15],
        e
    }
}
const dd = new $
  , cl = new Dn
  , KL = new $(0,0,0)
  , qL = new $(1,1,1)
  , Qu = new $
  , Hg = new $
  , ua = new $
  , AC = new Dn
  , CC = new Ws;
class km {
    constructor(e=0, t=0, r=0, i=km.DEFAULT_ORDER) {
        this.isEuler = !0,
        this._x = e,
        this._y = t,
        this._z = r,
        this._order = i
    }
    get x() {
        return this._x
    }
    set x(e) {
        this._x = e,
        this._onChangeCallback()
    }
    get y() {
        return this._y
    }
    set y(e) {
        this._y = e,
        this._onChangeCallback()
    }
    get z() {
        return this._z
    }
    set z(e) {
        this._z = e,
        this._onChangeCallback()
    }
    get order() {
        return this._order
    }
    set order(e) {
        this._order = e,
        this._onChangeCallback()
    }
    set(e, t, r, i=this._order) {
        return this._x = e,
        this._y = t,
        this._z = r,
        this._order = i,
        this._onChangeCallback(),
        this
    }
    clone() {
        return new this.constructor(this._x,this._y,this._z,this._order)
    }
    copy(e) {
        return this._x = e._x,
        this._y = e._y,
        this._z = e._z,
        this._order = e._order,
        this._onChangeCallback(),
        this
    }
    setFromRotationMatrix(e, t=this._order, r=!0) {
        const i = e.elements
          , s = i[0]
          , o = i[4]
          , a = i[8]
          , l = i[1]
          , f = i[5]
          , h = i[9]
          , d = i[2]
          , p = i[6]
          , m = i[10];
        switch (t) {
        case "XYZ":
            this._y = Math.asin($i(a, -1, 1)),
            Math.abs(a) < .9999999 ? (this._x = Math.atan2(-h, m),
            this._z = Math.atan2(-o, s)) : (this._x = Math.atan2(p, f),
            this._z = 0);
            break;
        case "YXZ":
            this._x = Math.asin(-$i(h, -1, 1)),
            Math.abs(h) < .9999999 ? (this._y = Math.atan2(a, m),
            this._z = Math.atan2(l, f)) : (this._y = Math.atan2(-d, s),
            this._z = 0);
            break;
        case "ZXY":
            this._x = Math.asin($i(p, -1, 1)),
            Math.abs(p) < .9999999 ? (this._y = Math.atan2(-d, m),
            this._z = Math.atan2(-o, f)) : (this._y = 0,
            this._z = Math.atan2(l, s));
            break;
        case "ZYX":
            this._y = Math.asin(-$i(d, -1, 1)),
            Math.abs(d) < .9999999 ? (this._x = Math.atan2(p, m),
            this._z = Math.atan2(l, s)) : (this._x = 0,
            this._z = Math.atan2(-o, f));
            break;
        case "YZX":
            this._z = Math.asin($i(l, -1, 1)),
            Math.abs(l) < .9999999 ? (this._x = Math.atan2(-h, f),
            this._y = Math.atan2(-d, s)) : (this._x = 0,
            this._y = Math.atan2(a, m));
            break;
        case "XZY":
            this._z = Math.asin(-$i(o, -1, 1)),
            Math.abs(o) < .9999999 ? (this._x = Math.atan2(p, f),
            this._y = Math.atan2(a, s)) : (this._x = Math.atan2(-h, m),
            this._y = 0);
            break;
        default:
            console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + t)
        }
        return this._order = t,
        r === !0 && this._onChangeCallback(),
        this
    }
    setFromQuaternion(e, t, r) {
        return AC.makeRotationFromQuaternion(e),
        this.setFromRotationMatrix(AC, t, r)
    }
    setFromVector3(e, t=this._order) {
        return this.set(e.x, e.y, e.z, t)
    }
    reorder(e) {
        return CC.setFromEuler(this),
        this.setFromQuaternion(CC, e)
    }
    equals(e) {
        return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order
    }
    fromArray(e) {
        return this._x = e[0],
        this._y = e[1],
        this._z = e[2],
        e[3] !== void 0 && (this._order = e[3]),
        this._onChangeCallback(),
        this
    }
    toArray(e=[], t=0) {
        return e[t] = this._x,
        e[t + 1] = this._y,
        e[t + 2] = this._z,
        e[t + 3] = this._order,
        e
    }
    _onChange(e) {
        return this._onChangeCallback = e,
        this
    }
    _onChangeCallback() {}
    *[Symbol.iterator]() {
        yield this._x,
        yield this._y,
        yield this._z,
        yield this._order
    }
}
km.DEFAULT_ORDER = "XYZ";
class Rf {
    constructor() {
        this.mask = 1
    }
    set(e) {
        this.mask = (1 << e | 0) >>> 0
    }
    enable(e) {
        this.mask |= 1 << e | 0
    }
    enableAll() {
        this.mask = -1
    }
    toggle(e) {
        this.mask ^= 1 << e | 0
    }
    disable(e) {
        this.mask &= ~(1 << e | 0)
    }
    disableAll() {
        this.mask = 0
    }
    test(e) {
        return (this.mask & e.mask) !== 0
    }
    isEnabled(e) {
        return (this.mask & (1 << e | 0)) !== 0
    }
}
let QL = 0;
const EC = new $
  , hd = new Ws
  , su = new Dn
  , Vg = new $
  , ep = new $
  , ZL = new $
  , $L = new Ws
  , bC = new $(1,0,0)
  , TC = new $(0,1,0)
  , DC = new $(0,0,1)
  , eF = {
    type: "added"
}
  , PC = {
    type: "removed"
};
class wr extends ql {
    constructor() {
        super(),
        this.isObject3D = !0,
        Object.defineProperty(this, "id", {
            value: QL++
        }),
        this.uuid = Sa(),
        this.name = "",
        this.type = "Object3D",
        this.parent = null,
        this.children = [],
        this.up = wr.DEFAULT_UP.clone();
        const e = new $
          , t = new km
          , r = new Ws
          , i = new $(1,1,1);
        function s() {
            r.setFromEuler(t, !1)
        }
        function o() {
            t.setFromQuaternion(r, void 0, !1)
        }
        t._onChange(s),
        r._onChange(o),
        Object.defineProperties(this, {
            position: {
                configurable: !0,
                enumerable: !0,
                value: e
            },
            rotation: {
                configurable: !0,
                enumerable: !0,
                value: t
            },
            quaternion: {
                configurable: !0,
                enumerable: !0,
                value: r
            },
            scale: {
                configurable: !0,
                enumerable: !0,
                value: i
            },
            modelViewMatrix: {
                value: new Dn
            },
            normalMatrix: {
                value: new bo
            }
        }),
        this.matrix = new Dn,
        this.matrixWorld = new Dn,
        this.matrixAutoUpdate = wr.DEFAULT_MATRIX_AUTO_UPDATE,
        this.matrixWorldNeedsUpdate = !1,
        this.matrixWorldAutoUpdate = wr.DEFAULT_MATRIX_WORLD_AUTO_UPDATE,
        this.layers = new Rf,
        this.visible = !0,
        this.castShadow = !1,
        this.receiveShadow = !1,
        this.frustumCulled = !0,
        this.renderOrder = 0,
        this.animations = [],
        this.userData = {}
    }
    onBeforeRender() {}
    onAfterRender() {}
    applyMatrix4(e) {
        this.matrixAutoUpdate && this.updateMatrix(),
        this.matrix.premultiply(e),
        this.matrix.decompose(this.position, this.quaternion, this.scale)
    }
    applyQuaternion(e) {
        return this.quaternion.premultiply(e),
        this
    }
    setRotationFromAxisAngle(e, t) {
        this.quaternion.setFromAxisAngle(e, t)
    }
    setRotationFromEuler(e) {
        this.quaternion.setFromEuler(e, !0)
    }
    setRotationFromMatrix(e) {
        this.quaternion.setFromRotationMatrix(e)
    }
    setRotationFromQuaternion(e) {
        this.quaternion.copy(e)
    }
    rotateOnAxis(e, t) {
        return hd.setFromAxisAngle(e, t),
        this.quaternion.multiply(hd),
        this
    }
    rotateOnWorldAxis(e, t) {
        return hd.setFromAxisAngle(e, t),
        this.quaternion.premultiply(hd),
        this
    }
    rotateX(e) {
        return this.rotateOnAxis(bC, e)
    }
    rotateY(e) {
        return this.rotateOnAxis(TC, e)
    }
    rotateZ(e) {
        return this.rotateOnAxis(DC, e)
    }
    translateOnAxis(e, t) {
        return EC.copy(e).applyQuaternion(this.quaternion),
        this.position.add(EC.multiplyScalar(t)),
        this
    }
    translateX(e) {
        return this.translateOnAxis(bC, e)
    }
    translateY(e) {
        return this.translateOnAxis(TC, e)
    }
    translateZ(e) {
        return this.translateOnAxis(DC, e)
    }
    localToWorld(e) {
        return this.updateWorldMatrix(!0, !1),
        e.applyMatrix4(this.matrixWorld)
    }
    worldToLocal(e) {
        return this.updateWorldMatrix(!0, !1),
        e.applyMatrix4(su.copy(this.matrixWorld).invert())
    }
    lookAt(e, t, r) {
        e.isVector3 ? Vg.copy(e) : Vg.set(e, t, r);
        const i = this.parent;
        this.updateWorldMatrix(!0, !1),
        ep.setFromMatrixPosition(this.matrixWorld),
        this.isCamera || this.isLight ? su.lookAt(ep, Vg, this.up) : su.lookAt(Vg, ep, this.up),
        this.quaternion.setFromRotationMatrix(su),
        i && (su.extractRotation(i.matrixWorld),
        hd.setFromRotationMatrix(su),
        this.quaternion.premultiply(hd.invert()))
    }
    add(e) {
        if (arguments.length > 1) {
            for (let t = 0; t < arguments.length; t++)
                this.add(arguments[t]);
            return this
        }
        return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e),
        this) : (e && e.isObject3D ? (e.parent !== null && e.parent.remove(e),
        e.parent = this,
        this.children.push(e),
        e.dispatchEvent(eF)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e),
        this)
    }
    remove(e) {
        if (arguments.length > 1) {
            for (let r = 0; r < arguments.length; r++)
                this.remove(arguments[r]);
            return this
        }
        const t = this.children.indexOf(e);
        return t !== -1 && (e.parent = null,
        this.children.splice(t, 1),
        e.dispatchEvent(PC)),
        this
    }
    removeFromParent() {
        const e = this.parent;
        return e !== null && e.remove(this),
        this
    }
    clear() {
        for (let e = 0; e < this.children.length; e++) {
            const t = this.children[e];
            t.parent = null,
            t.dispatchEvent(PC)
        }
        return this.children.length = 0,
        this
    }
    attach(e) {
        return this.updateWorldMatrix(!0, !1),
        su.copy(this.matrixWorld).invert(),
        e.parent !== null && (e.parent.updateWorldMatrix(!0, !1),
        su.multiply(e.parent.matrixWorld)),
        e.applyMatrix4(su),
        this.add(e),
        e.updateWorldMatrix(!1, !0),
        this
    }
    getObjectById(e) {
        return this.getObjectByProperty("id", e)
    }
    getObjectByName(e) {
        return this.getObjectByProperty("name", e)
    }
    getObjectByProperty(e, t) {
        if (this[e] === t)
            return this;
        for (let r = 0, i = this.children.length; r < i; r++) {
            const o = this.children[r].getObjectByProperty(e, t);
            if (o !== void 0)
                return o
        }
    }
    getObjectsByProperty(e, t) {
        let r = [];
        this[e] === t && r.push(this);
        for (let i = 0, s = this.children.length; i < s; i++) {
            const o = this.children[i].getObjectsByProperty(e, t);
            o.length > 0 && (r = r.concat(o))
        }
        return r
    }
    getWorldPosition(e) {
        return this.updateWorldMatrix(!0, !1),
        e.setFromMatrixPosition(this.matrixWorld)
    }
    getWorldQuaternion(e) {
        return this.updateWorldMatrix(!0, !1),
        this.matrixWorld.decompose(ep, e, ZL),
        e
    }
    getWorldScale(e) {
        return this.updateWorldMatrix(!0, !1),
        this.matrixWorld.decompose(ep, $L, e),
        e
    }
    getWorldDirection(e) {
        this.updateWorldMatrix(!0, !1);
        const t = this.matrixWorld.elements;
        return e.set(t[8], t[9], t[10]).normalize()
    }
    raycast() {}
    traverse(e) {
        e(this);
        const t = this.children;
        for (let r = 0, i = t.length; r < i; r++)
            t[r].traverse(e)
    }
    traverseVisible(e) {
        if (this.visible === !1)
            return;
        e(this);
        const t = this.children;
        for (let r = 0, i = t.length; r < i; r++)
            t[r].traverseVisible(e)
    }
    traverseAncestors(e) {
        const t = this.parent;
        t !== null && (e(t),
        t.traverseAncestors(e))
    }
    updateMatrix() {
        this.matrix.compose(this.position, this.quaternion, this.scale),
        this.matrixWorldNeedsUpdate = !0
    }
    updateMatrixWorld(e) {
        this.matrixAutoUpdate && this.updateMatrix(),
        (this.matrixWorldNeedsUpdate || e) && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix),
        this.matrixWorldNeedsUpdate = !1,
        e = !0);
        const t = this.children;
        for (let r = 0, i = t.length; r < i; r++) {
            const s = t[r];
            (s.matrixWorldAutoUpdate === !0 || e === !0) && s.updateMatrixWorld(e)
        }
    }
    updateWorldMatrix(e, t) {
        const r = this.parent;
        if (e === !0 && r !== null && r.matrixWorldAutoUpdate === !0 && r.updateWorldMatrix(!0, !1),
        this.matrixAutoUpdate && this.updateMatrix(),
        this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix),
        t === !0) {
            const i = this.children;
            for (let s = 0, o = i.length; s < o; s++) {
                const a = i[s];
                a.matrixWorldAutoUpdate === !0 && a.updateWorldMatrix(!1, !0)
            }
        }
    }
    toJSON(e) {
        const t = e === void 0 || typeof e == "string"
          , r = {};
        t && (e = {
            geometries: {},
            materials: {},
            textures: {},
            images: {},
            shapes: {},
            skeletons: {},
            animations: {},
            nodes: {}
        },
        r.metadata = {
            version: 4.5,
            type: "Object",
            generator: "Object3D.toJSON"
        });
        const i = {};
        i.uuid = this.uuid,
        i.type = this.type,
        this.name !== "" && (i.name = this.name),
        this.castShadow === !0 && (i.castShadow = !0),
        this.receiveShadow === !0 && (i.receiveShadow = !0),
        this.visible === !1 && (i.visible = !1),
        this.frustumCulled === !1 && (i.frustumCulled = !1),
        this.renderOrder !== 0 && (i.renderOrder = this.renderOrder),
        Object.keys(this.userData).length > 0 && (i.userData = this.userData),
        i.layers = this.layers.mask,
        i.matrix = this.matrix.toArray(),
        this.matrixAutoUpdate === !1 && (i.matrixAutoUpdate = !1),
        this.isInstancedMesh && (i.type = "InstancedMesh",
        i.count = this.count,
        i.instanceMatrix = this.instanceMatrix.toJSON(),
        this.instanceColor !== null && (i.instanceColor = this.instanceColor.toJSON()));
        function s(a, l) {
            return a[l.uuid] === void 0 && (a[l.uuid] = l.toJSON(e)),
            l.uuid
        }
        if (this.isScene)
            this.background && (this.background.isColor ? i.background = this.background.toJSON() : this.background.isTexture && (i.background = this.background.toJSON(e).uuid)),
            this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== !0 && (i.environment = this.environment.toJSON(e).uuid);
        else if (this.isMesh || this.isLine || this.isPoints) {
            i.geometry = s(e.geometries, this.geometry);
            const a = this.geometry.parameters;
            if (a !== void 0 && a.shapes !== void 0) {
                const l = a.shapes;
                if (Array.isArray(l))
                    for (let f = 0, h = l.length; f < h; f++) {
                        const d = l[f];
                        s(e.shapes, d)
                    }
                else
                    s(e.shapes, l)
            }
        }
        if (this.isSkinnedMesh && (i.bindMode = this.bindMode,
        i.bindMatrix = this.bindMatrix.toArray(),
        this.skeleton !== void 0 && (s(e.skeletons, this.skeleton),
        i.skeleton = this.skeleton.uuid)),
        this.material !== void 0)
            if (Array.isArray(this.material)) {
                const a = [];
                for (let l = 0, f = this.material.length; l < f; l++)
                    a.push(s(e.materials, this.material[l]));
                i.material = a
            } else
                i.material = s(e.materials, this.material);
        if (this.children.length > 0) {
            i.children = [];
            for (let a = 0; a < this.children.length; a++)
                i.children.push(this.children[a].toJSON(e).object)
        }
        if (this.animations.length > 0) {
            i.animations = [];
            for (let a = 0; a < this.animations.length; a++) {
                const l = this.animations[a];
                i.animations.push(s(e.animations, l))
            }
        }
        if (t) {
            const a = o(e.geometries)
              , l = o(e.materials)
              , f = o(e.textures)
              , h = o(e.images)
              , d = o(e.shapes)
              , p = o(e.skeletons)
              , m = o(e.animations)
              , _ = o(e.nodes);
            a.length > 0 && (r.geometries = a),
            l.length > 0 && (r.materials = l),
            f.length > 0 && (r.textures = f),
            h.length > 0 && (r.images = h),
            d.length > 0 && (r.shapes = d),
            p.length > 0 && (r.skeletons = p),
            m.length > 0 && (r.animations = m),
            _.length > 0 && (r.nodes = _)
        }
        return r.object = i,
        r;
        function o(a) {
            const l = [];
            for (const f in a) {
                const h = a[f];
                delete h.metadata,
                l.push(h)
            }
            return l
        }
    }
    clone(e) {
        return new this.constructor().copy(this, e)
    }
    copy(e, t=!0) {
        if (this.name = e.name,
        this.up.copy(e.up),
        this.position.copy(e.position),
        this.rotation.order = e.rotation.order,
        this.quaternion.copy(e.quaternion),
        this.scale.copy(e.scale),
        this.matrix.copy(e.matrix),
        this.matrixWorld.copy(e.matrixWorld),
        this.matrixAutoUpdate = e.matrixAutoUpdate,
        this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate,
        this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate,
        this.layers.mask = e.layers.mask,
        this.visible = e.visible,
        this.castShadow = e.castShadow,
        this.receiveShadow = e.receiveShadow,
        this.frustumCulled = e.frustumCulled,
        this.renderOrder = e.renderOrder,
        this.userData = JSON.parse(JSON.stringify(e.userData)),
        t === !0)
            for (let r = 0; r < e.children.length; r++) {
                const i = e.children[r];
                this.add(i.clone())
            }
        return this
    }
}
wr.DEFAULT_UP = new $(0,1,0);
wr.DEFAULT_MATRIX_AUTO_UPDATE = !0;
wr.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
const fl = new $
  , ou = new $
  , Jy = new $
  , au = new $
  , pd = new $
  , md = new $
  , RC = new $
  , jy = new $
  , Yy = new $
  , Ky = new $;
class Xa {
    constructor(e=new $, t=new $, r=new $) {
        this.a = e,
        this.b = t,
        this.c = r
    }
    static getNormal(e, t, r, i) {
        i.subVectors(r, t),
        fl.subVectors(e, t),
        i.cross(fl);
        const s = i.lengthSq();
        return s > 0 ? i.multiplyScalar(1 / Math.sqrt(s)) : i.set(0, 0, 0)
    }
    static getBarycoord(e, t, r, i, s) {
        fl.subVectors(i, t),
        ou.subVectors(r, t),
        Jy.subVectors(e, t);
        const o = fl.dot(fl)
          , a = fl.dot(ou)
          , l = fl.dot(Jy)
          , f = ou.dot(ou)
          , h = ou.dot(Jy)
          , d = o * f - a * a;
        if (d === 0)
            return s.set(-2, -1, -1);
        const p = 1 / d
          , m = (f * l - a * h) * p
          , _ = (o * h - a * l) * p;
        return s.set(1 - m - _, _, m)
    }
    static containsPoint(e, t, r, i) {
        return this.getBarycoord(e, t, r, i, au),
        au.x >= 0 && au.y >= 0 && au.x + au.y <= 1
    }
    static getUV(e, t, r, i, s, o, a, l) {
        return this.getBarycoord(e, t, r, i, au),
        l.set(0, 0),
        l.addScaledVector(s, au.x),
        l.addScaledVector(o, au.y),
        l.addScaledVector(a, au.z),
        l
    }
    static isFrontFacing(e, t, r, i) {
        return fl.subVectors(r, t),
        ou.subVectors(e, t),
        fl.cross(ou).dot(i) < 0
    }
    set(e, t, r) {
        return this.a.copy(e),
        this.b.copy(t),
        this.c.copy(r),
        this
    }
    setFromPointsAndIndices(e, t, r, i) {
        return this.a.copy(e[t]),
        this.b.copy(e[r]),
        this.c.copy(e[i]),
        this
    }
    setFromAttributeAndIndices(e, t, r, i) {
        return this.a.fromBufferAttribute(e, t),
        this.b.fromBufferAttribute(e, r),
        this.c.fromBufferAttribute(e, i),
        this
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        return this.a.copy(e.a),
        this.b.copy(e.b),
        this.c.copy(e.c),
        this
    }
    getArea() {
        return fl.subVectors(this.c, this.b),
        ou.subVectors(this.a, this.b),
        fl.cross(ou).length() * .5
    }
    getMidpoint(e) {
        return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
    }
    getNormal(e) {
        return Xa.getNormal(this.a, this.b, this.c, e)
    }
    getPlane(e) {
        return e.setFromCoplanarPoints(this.a, this.b, this.c)
    }
    getBarycoord(e, t) {
        return Xa.getBarycoord(e, this.a, this.b, this.c, t)
    }
    getUV(e, t, r, i, s) {
        return Xa.getUV(e, this.a, this.b, this.c, t, r, i, s)
    }
    containsPoint(e) {
        return Xa.containsPoint(e, this.a, this.b, this.c)
    }
    isFrontFacing(e) {
        return Xa.isFrontFacing(this.a, this.b, this.c, e)
    }
    intersectsBox(e) {
        return e.intersectsTriangle(this)
    }
    closestPointToPoint(e, t) {
        const r = this.a
          , i = this.b
          , s = this.c;
        let o, a;
        pd.subVectors(i, r),
        md.subVectors(s, r),
        jy.subVectors(e, r);
        const l = pd.dot(jy)
          , f = md.dot(jy);
        if (l <= 0 && f <= 0)
            return t.copy(r);
        Yy.subVectors(e, i);
        const h = pd.dot(Yy)
          , d = md.dot(Yy);
        if (h >= 0 && d <= h)
            return t.copy(i);
        const p = l * d - h * f;
        if (p <= 0 && l >= 0 && h <= 0)
            return o = l / (l - h),
            t.copy(r).addScaledVector(pd, o);
        Ky.subVectors(e, s);
        const m = pd.dot(Ky)
          , _ = md.dot(Ky);
        if (_ >= 0 && m <= _)
            return t.copy(s);
        const y = m * f - l * _;
        if (y <= 0 && f >= 0 && _ <= 0)
            return a = f / (f - _),
            t.copy(r).addScaledVector(md, a);
        const x = h * _ - m * d;
        if (x <= 0 && d - h >= 0 && m - _ >= 0)
            return RC.subVectors(s, i),
            a = (d - h) / (d - h + (m - _)),
            t.copy(i).addScaledVector(RC, a);
        const S = 1 / (x + y + p);
        return o = y * S,
        a = p * S,
        t.copy(r).addScaledVector(pd, o).addScaledVector(md, a)
    }
    equals(e) {
        return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c)
    }
}
let tF = 0;
class as extends ql {
    constructor() {
        super(),
        this.isMaterial = !0,
        Object.defineProperty(this, "id", {
            value: tF++
        }),
        this.uuid = Sa(),
        this.name = "",
        this.type = "Material",
        this.blending = bf,
        this.side = El,
        this.vertexColors = !1,
        this.opacity = 1,
        this.transparent = !1,
        this.blendSrc = IS,
        this.blendDst = LS,
        this.blendEquation = pf,
        this.blendSrcAlpha = null,
        this.blendDstAlpha = null,
        this.blendEquationAlpha = null,
        this.depthFunc = Hv,
        this.depthTest = !0,
        this.depthWrite = !0,
        this.stencilWriteMask = 255,
        this.stencilFunc = q2,
        this.stencilRef = 0,
        this.stencilFuncMask = 255,
        this.stencilFail = av,
        this.stencilZFail = av,
        this.stencilZPass = av,
        this.stencilWrite = !1,
        this.clippingPlanes = null,
        this.clipIntersection = !1,
        this.clipShadows = !1,
        this.shadowSide = null,
        this.colorWrite = !0,
        this.precision = null,
        this.polygonOffset = !1,
        this.polygonOffsetFactor = 0,
        this.polygonOffsetUnits = 0,
        this.dithering = !1,
        this.alphaToCoverage = !1,
        this.premultipliedAlpha = !1,
        this.forceSinglePass = !1,
        this.visible = !0,
        this.toneMapped = !0,
        this.userData = {},
        this.version = 0,
        this._alphaTest = 0
    }
    get alphaTest() {
        return this._alphaTest
    }
    set alphaTest(e) {
        this._alphaTest > 0 != e > 0 && this.version++,
        this._alphaTest = e
    }
    onBuild() {}
    onBeforeRender() {}
    onBeforeCompile() {}
    customProgramCacheKey() {
        return this.onBeforeCompile.toString()
    }
    setValues(e) {
        if (e !== void 0)
            for (const t in e) {
                const r = e[t];
                if (r === void 0) {
                    console.warn("THREE.Material: '" + t + "' parameter is undefined.");
                    continue
                }
                const i = this[t];
                if (i === void 0) {
                    console.warn("THREE." + this.type + ": '" + t + "' is not a property of this material.");
                    continue
                }
                i && i.isColor ? i.set(r) : i && i.isVector3 && r && r.isVector3 ? i.copy(r) : this[t] = r
            }
    }
    toJSON(e) {
        const t = e === void 0 || typeof e == "string";
        t && (e = {
            textures: {},
            images: {}
        });
        const r = {
            metadata: {
                version: 4.5,
                type: "Material",
                generator: "Material.toJSON"
            }
        };
        r.uuid = this.uuid,
        r.type = this.type,
        this.name !== "" && (r.name = this.name),
        this.color && this.color.isColor && (r.color = this.color.getHex()),
        this.roughness !== void 0 && (r.roughness = this.roughness),
        this.metalness !== void 0 && (r.metalness = this.metalness),
        this.sheen !== void 0 && (r.sheen = this.sheen),
        this.sheenColor && this.sheenColor.isColor && (r.sheenColor = this.sheenColor.getHex()),
        this.sheenRoughness !== void 0 && (r.sheenRoughness = this.sheenRoughness),
        this.emissive && this.emissive.isColor && (r.emissive = this.emissive.getHex()),
        this.emissiveIntensity && this.emissiveIntensity !== 1 && (r.emissiveIntensity = this.emissiveIntensity),
        this.specular && this.specular.isColor && (r.specular = this.specular.getHex()),
        this.specularIntensity !== void 0 && (r.specularIntensity = this.specularIntensity),
        this.specularColor && this.specularColor.isColor && (r.specularColor = this.specularColor.getHex()),
        this.shininess !== void 0 && (r.shininess = this.shininess),
        this.clearcoat !== void 0 && (r.clearcoat = this.clearcoat),
        this.clearcoatRoughness !== void 0 && (r.clearcoatRoughness = this.clearcoatRoughness),
        this.clearcoatMap && this.clearcoatMap.isTexture && (r.clearcoatMap = this.clearcoatMap.toJSON(e).uuid),
        this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (r.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid),
        this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (r.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid,
        r.clearcoatNormalScale = this.clearcoatNormalScale.toArray()),
        this.iridescence !== void 0 && (r.iridescence = this.iridescence),
        this.iridescenceIOR !== void 0 && (r.iridescenceIOR = this.iridescenceIOR),
        this.iridescenceThicknessRange !== void 0 && (r.iridescenceThicknessRange = this.iridescenceThicknessRange),
        this.iridescenceMap && this.iridescenceMap.isTexture && (r.iridescenceMap = this.iridescenceMap.toJSON(e).uuid),
        this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (r.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(e).uuid),
        this.map && this.map.isTexture && (r.map = this.map.toJSON(e).uuid),
        this.matcap && this.matcap.isTexture && (r.matcap = this.matcap.toJSON(e).uuid),
        this.alphaMap && this.alphaMap.isTexture && (r.alphaMap = this.alphaMap.toJSON(e).uuid),
        this.lightMap && this.lightMap.isTexture && (r.lightMap = this.lightMap.toJSON(e).uuid,
        r.lightMapIntensity = this.lightMapIntensity),
        this.aoMap && this.aoMap.isTexture && (r.aoMap = this.aoMap.toJSON(e).uuid,
        r.aoMapIntensity = this.aoMapIntensity),
        this.bumpMap && this.bumpMap.isTexture && (r.bumpMap = this.bumpMap.toJSON(e).uuid,
        r.bumpScale = this.bumpScale),
        this.normalMap && this.normalMap.isTexture && (r.normalMap = this.normalMap.toJSON(e).uuid,
        r.normalMapType = this.normalMapType,
        r.normalScale = this.normalScale.toArray()),
        this.displacementMap && this.displacementMap.isTexture && (r.displacementMap = this.displacementMap.toJSON(e).uuid,
        r.displacementScale = this.displacementScale,
        r.displacementBias = this.displacementBias),
        this.roughnessMap && this.roughnessMap.isTexture && (r.roughnessMap = this.roughnessMap.toJSON(e).uuid),
        this.metalnessMap && this.metalnessMap.isTexture && (r.metalnessMap = this.metalnessMap.toJSON(e).uuid),
        this.emissiveMap && this.emissiveMap.isTexture && (r.emissiveMap = this.emissiveMap.toJSON(e).uuid),
        this.specularMap && this.specularMap.isTexture && (r.specularMap = this.specularMap.toJSON(e).uuid),
        this.specularIntensityMap && this.specularIntensityMap.isTexture && (r.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid),
        this.specularColorMap && this.specularColorMap.isTexture && (r.specularColorMap = this.specularColorMap.toJSON(e).uuid),
        this.envMap && this.envMap.isTexture && (r.envMap = this.envMap.toJSON(e).uuid,
        this.combine !== void 0 && (r.combine = this.combine)),
        this.envMapIntensity !== void 0 && (r.envMapIntensity = this.envMapIntensity),
        this.reflectivity !== void 0 && (r.reflectivity = this.reflectivity),
        this.refractionRatio !== void 0 && (r.refractionRatio = this.refractionRatio),
        this.gradientMap && this.gradientMap.isTexture && (r.gradientMap = this.gradientMap.toJSON(e).uuid),
        this.transmission !== void 0 && (r.transmission = this.transmission),
        this.transmissionMap && this.transmissionMap.isTexture && (r.transmissionMap = this.transmissionMap.toJSON(e).uuid),
        this.thickness !== void 0 && (r.thickness = this.thickness),
        this.thicknessMap && this.thicknessMap.isTexture && (r.thicknessMap = this.thicknessMap.toJSON(e).uuid),
        this.attenuationDistance !== void 0 && this.attenuationDistance !== 1 / 0 && (r.attenuationDistance = this.attenuationDistance),
        this.attenuationColor !== void 0 && (r.attenuationColor = this.attenuationColor.getHex()),
        this.size !== void 0 && (r.size = this.size),
        this.shadowSide !== null && (r.shadowSide = this.shadowSide),
        this.sizeAttenuation !== void 0 && (r.sizeAttenuation = this.sizeAttenuation),
        this.blending !== bf && (r.blending = this.blending),
        this.side !== El && (r.side = this.side),
        this.vertexColors && (r.vertexColors = !0),
        this.opacity < 1 && (r.opacity = this.opacity),
        this.transparent === !0 && (r.transparent = this.transparent),
        r.depthFunc = this.depthFunc,
        r.depthTest = this.depthTest,
        r.depthWrite = this.depthWrite,
        r.colorWrite = this.colorWrite,
        r.stencilWrite = this.stencilWrite,
        r.stencilWriteMask = this.stencilWriteMask,
        r.stencilFunc = this.stencilFunc,
        r.stencilRef = this.stencilRef,
        r.stencilFuncMask = this.stencilFuncMask,
        r.stencilFail = this.stencilFail,
        r.stencilZFail = this.stencilZFail,
        r.stencilZPass = this.stencilZPass,
        this.rotation !== void 0 && this.rotation !== 0 && (r.rotation = this.rotation),
        this.polygonOffset === !0 && (r.polygonOffset = !0),
        this.polygonOffsetFactor !== 0 && (r.polygonOffsetFactor = this.polygonOffsetFactor),
        this.polygonOffsetUnits !== 0 && (r.polygonOffsetUnits = this.polygonOffsetUnits),
        this.linewidth !== void 0 && this.linewidth !== 1 && (r.linewidth = this.linewidth),
        this.dashSize !== void 0 && (r.dashSize = this.dashSize),
        this.gapSize !== void 0 && (r.gapSize = this.gapSize),
        this.scale !== void 0 && (r.scale = this.scale),
        this.dithering === !0 && (r.dithering = !0),
        this.alphaTest > 0 && (r.alphaTest = this.alphaTest),
        this.alphaToCoverage === !0 && (r.alphaToCoverage = this.alphaToCoverage),
        this.premultipliedAlpha === !0 && (r.premultipliedAlpha = this.premultipliedAlpha),
        this.forceSinglePass === !0 && (r.forceSinglePass = this.forceSinglePass),
        this.wireframe === !0 && (r.wireframe = this.wireframe),
        this.wireframeLinewidth > 1 && (r.wireframeLinewidth = this.wireframeLinewidth),
        this.wireframeLinecap !== "round" && (r.wireframeLinecap = this.wireframeLinecap),
        this.wireframeLinejoin !== "round" && (r.wireframeLinejoin = this.wireframeLinejoin),
        this.flatShading === !0 && (r.flatShading = this.flatShading),
        this.visible === !1 && (r.visible = !1),
        this.toneMapped === !1 && (r.toneMapped = !1),
        this.fog === !1 && (r.fog = !1),
        Object.keys(this.userData).length > 0 && (r.userData = this.userData);
        function i(s) {
            const o = [];
            for (const a in s) {
                const l = s[a];
                delete l.metadata,
                o.push(l)
            }
            return o
        }
        if (t) {
            const s = i(e.textures)
              , o = i(e.images);
            s.length > 0 && (r.textures = s),
            o.length > 0 && (r.images = o)
        }
        return r
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        this.name = e.name,
        this.blending = e.blending,
        this.side = e.side,
        this.vertexColors = e.vertexColors,
        this.opacity = e.opacity,
        this.transparent = e.transparent,
        this.blendSrc = e.blendSrc,
        this.blendDst = e.blendDst,
        this.blendEquation = e.blendEquation,
        this.blendSrcAlpha = e.blendSrcAlpha,
        this.blendDstAlpha = e.blendDstAlpha,
        this.blendEquationAlpha = e.blendEquationAlpha,
        this.depthFunc = e.depthFunc,
        this.depthTest = e.depthTest,
        this.depthWrite = e.depthWrite,
        this.stencilWriteMask = e.stencilWriteMask,
        this.stencilFunc = e.stencilFunc,
        this.stencilRef = e.stencilRef,
        this.stencilFuncMask = e.stencilFuncMask,
        this.stencilFail = e.stencilFail,
        this.stencilZFail = e.stencilZFail,
        this.stencilZPass = e.stencilZPass,
        this.stencilWrite = e.stencilWrite;
        const t = e.clippingPlanes;
        let r = null;
        if (t !== null) {
            const i = t.length;
            r = new Array(i);
            for (let s = 0; s !== i; ++s)
                r[s] = t[s].clone()
        }
        return this.clippingPlanes = r,
        this.clipIntersection = e.clipIntersection,
        this.clipShadows = e.clipShadows,
        this.shadowSide = e.shadowSide,
        this.colorWrite = e.colorWrite,
        this.precision = e.precision,
        this.polygonOffset = e.polygonOffset,
        this.polygonOffsetFactor = e.polygonOffsetFactor,
        this.polygonOffsetUnits = e.polygonOffsetUnits,
        this.dithering = e.dithering,
        this.alphaTest = e.alphaTest,
        this.alphaToCoverage = e.alphaToCoverage,
        this.premultipliedAlpha = e.premultipliedAlpha,
        this.forceSinglePass = e.forceSinglePass,
        this.visible = e.visible,
        this.toneMapped = e.toneMapped,
        this.userData = JSON.parse(JSON.stringify(e.userData)),
        this
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
    set needsUpdate(e) {
        e === !0 && this.version++
    }
}
class xa extends as {
    constructor(e) {
        super(),
        this.isMeshBasicMaterial = !0,
        this.type = "MeshBasicMaterial",
        this.color = new It(16777215),
        this.map = null,
        this.lightMap = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.specularMap = null,
        this.alphaMap = null,
        this.envMap = null,
        this.combine = Lm,
        this.reflectivity = 1,
        this.refractionRatio = .98,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinecap = "round",
        this.wireframeLinejoin = "round",
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.color.copy(e.color),
        this.map = e.map,
        this.lightMap = e.lightMap,
        this.lightMapIntensity = e.lightMapIntensity,
        this.aoMap = e.aoMap,
        this.aoMapIntensity = e.aoMapIntensity,
        this.specularMap = e.specularMap,
        this.alphaMap = e.alphaMap,
        this.envMap = e.envMap,
        this.combine = e.combine,
        this.reflectivity = e.reflectivity,
        this.refractionRatio = e.refractionRatio,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.wireframeLinecap = e.wireframeLinecap,
        this.wireframeLinejoin = e.wireframeLinejoin,
        this.fog = e.fog,
        this
    }
}
const ss = new $
  , Wg = new it;
class Dr {
    constructor(e, t, r=!1) {
        if (Array.isArray(e))
            throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
        this.isBufferAttribute = !0,
        this.name = "",
        this.array = e,
        this.itemSize = t,
        this.count = e !== void 0 ? e.length / t : 0,
        this.normalized = r,
        this.usage = gm,
        this.updateRange = {
            offset: 0,
            count: -1
        },
        this.version = 0
    }
    onUploadCallback() {}
    set needsUpdate(e) {
        e === !0 && this.version++
    }
    setUsage(e) {
        return this.usage = e,
        this
    }
    copy(e) {
        return this.name = e.name,
        this.array = new e.array.constructor(e.array),
        this.itemSize = e.itemSize,
        this.count = e.count,
        this.normalized = e.normalized,
        this.usage = e.usage,
        this
    }
    copyAt(e, t, r) {
        e *= this.itemSize,
        r *= t.itemSize;
        for (let i = 0, s = this.itemSize; i < s; i++)
            this.array[e + i] = t.array[r + i];
        return this
    }
    copyArray(e) {
        return this.array.set(e),
        this
    }
    applyMatrix3(e) {
        if (this.itemSize === 2)
            for (let t = 0, r = this.count; t < r; t++)
                Wg.fromBufferAttribute(this, t),
                Wg.applyMatrix3(e),
                this.setXY(t, Wg.x, Wg.y);
        else if (this.itemSize === 3)
            for (let t = 0, r = this.count; t < r; t++)
                ss.fromBufferAttribute(this, t),
                ss.applyMatrix3(e),
                this.setXYZ(t, ss.x, ss.y, ss.z);
        return this
    }
    applyMatrix4(e) {
        for (let t = 0, r = this.count; t < r; t++)
            ss.fromBufferAttribute(this, t),
            ss.applyMatrix4(e),
            this.setXYZ(t, ss.x, ss.y, ss.z);
        return this
    }
    applyNormalMatrix(e) {
        for (let t = 0, r = this.count; t < r; t++)
            ss.fromBufferAttribute(this, t),
            ss.applyNormalMatrix(e),
            this.setXYZ(t, ss.x, ss.y, ss.z);
        return this
    }
    transformDirection(e) {
        for (let t = 0, r = this.count; t < r; t++)
            ss.fromBufferAttribute(this, t),
            ss.transformDirection(e),
            this.setXYZ(t, ss.x, ss.y, ss.z);
        return this
    }
    set(e, t=0) {
        return this.array.set(e, t),
        this
    }
    getX(e) {
        let t = this.array[e * this.itemSize];
        return this.normalized && (t = vu(t, this.array)),
        t
    }
    setX(e, t) {
        return this.normalized && (t = ii(t, this.array)),
        this.array[e * this.itemSize] = t,
        this
    }
    getY(e) {
        let t = this.array[e * this.itemSize + 1];
        return this.normalized && (t = vu(t, this.array)),
        t
    }
    setY(e, t) {
        return this.normalized && (t = ii(t, this.array)),
        this.array[e * this.itemSize + 1] = t,
        this
    }
    getZ(e) {
        let t = this.array[e * this.itemSize + 2];
        return this.normalized && (t = vu(t, this.array)),
        t
    }
    setZ(e, t) {
        return this.normalized && (t = ii(t, this.array)),
        this.array[e * this.itemSize + 2] = t,
        this
    }
    getW(e) {
        let t = this.array[e * this.itemSize + 3];
        return this.normalized && (t = vu(t, this.array)),
        t
    }
    setW(e, t) {
        return this.normalized && (t = ii(t, this.array)),
        this.array[e * this.itemSize + 3] = t,
        this
    }
    setXY(e, t, r) {
        return e *= this.itemSize,
        this.normalized && (t = ii(t, this.array),
        r = ii(r, this.array)),
        this.array[e + 0] = t,
        this.array[e + 1] = r,
        this
    }
    setXYZ(e, t, r, i) {
        return e *= this.itemSize,
        this.normalized && (t = ii(t, this.array),
        r = ii(r, this.array),
        i = ii(i, this.array)),
        this.array[e + 0] = t,
        this.array[e + 1] = r,
        this.array[e + 2] = i,
        this
    }
    setXYZW(e, t, r, i, s) {
        return e *= this.itemSize,
        this.normalized && (t = ii(t, this.array),
        r = ii(r, this.array),
        i = ii(i, this.array),
        s = ii(s, this.array)),
        this.array[e + 0] = t,
        this.array[e + 1] = r,
        this.array[e + 2] = i,
        this.array[e + 3] = s,
        this
    }
    onUpload(e) {
        return this.onUploadCallback = e,
        this
    }
    clone() {
        return new this.constructor(this.array,this.itemSize).copy(this)
    }
    toJSON() {
        const e = {
            itemSize: this.itemSize,
            type: this.array.constructor.name,
            array: Array.from(this.array),
            normalized: this.normalized
        };
        return this.name !== "" && (e.name = this.name),
        this.usage !== gm && (e.usage = this.usage),
        (this.updateRange.offset !== 0 || this.updateRange.count !== -1) && (e.updateRange = this.updateRange),
        e
    }
    copyColorsArray() {
        console.error("THREE.BufferAttribute: copyColorsArray() was removed in r144.")
    }
    copyVector2sArray() {
        console.error("THREE.BufferAttribute: copyVector2sArray() was removed in r144.")
    }
    copyVector3sArray() {
        console.error("THREE.BufferAttribute: copyVector3sArray() was removed in r144.")
    }
    copyVector4sArray() {
        console.error("THREE.BufferAttribute: copyVector4sArray() was removed in r144.")
    }
}
class nF extends Dr {
    constructor(e, t, r) {
        super(new Int8Array(e), t, r)
    }
}
class rF extends Dr {
    constructor(e, t, r) {
        super(new Uint8Array(e), t, r)
    }
}
class iF extends Dr {
    constructor(e, t, r) {
        super(new Uint8ClampedArray(e), t, r)
    }
}
class sF extends Dr {
    constructor(e, t, r) {
        super(new Int16Array(e), t, r)
    }
}
class HS extends Dr {
    constructor(e, t, r) {
        super(new Uint16Array(e), t, r)
    }
}
class oF extends Dr {
    constructor(e, t, r) {
        super(new Int32Array(e), t, r)
    }
}
class VS extends Dr {
    constructor(e, t, r) {
        super(new Uint32Array(e), t, r)
    }
}
class aF extends Dr {
    constructor(e, t, r) {
        super(new Uint16Array(e), t, r),
        this.isFloat16BufferAttribute = !0
    }
}
class nn extends Dr {
    constructor(e, t, r) {
        super(new Float32Array(e), t, r)
    }
}
class lF extends Dr {
    constructor(e, t, r) {
        super(new Float64Array(e), t, r)
    }
}
let uF = 0;
const za = new Dn
  , qy = new wr
  , gd = new $
  , ca = new kc
  , tp = new kc
  , Ts = new $;
class On extends ql {
    constructor() {
        super(),
        this.isBufferGeometry = !0,
        Object.defineProperty(this, "id", {
            value: uF++
        }),
        this.uuid = Sa(),
        this.name = "",
        this.type = "BufferGeometry",
        this.index = null,
        this.attributes = {},
        this.morphAttributes = {},
        this.morphTargetsRelative = !1,
        this.groups = [],
        this.boundingBox = null,
        this.boundingSphere = null,
        this.drawRange = {
            start: 0,
            count: 1 / 0
        },
        this.userData = {}
    }
    getIndex() {
        return this.index
    }
    setIndex(e) {
        return Array.isArray(e) ? this.index = new (Z2(e) ? VS : HS)(e,1) : this.index = e,
        this
    }
    getAttribute(e) {
        return this.attributes[e]
    }
    setAttribute(e, t) {
        return this.attributes[e] = t,
        this
    }
    deleteAttribute(e) {
        return delete this.attributes[e],
        this
    }
    hasAttribute(e) {
        return this.attributes[e] !== void 0
    }
    addGroup(e, t, r=0) {
        this.groups.push({
            start: e,
            count: t,
            materialIndex: r
        })
    }
    clearGroups() {
        this.groups = []
    }
    setDrawRange(e, t) {
        this.drawRange.start = e,
        this.drawRange.count = t
    }
    applyMatrix4(e) {
        const t = this.attributes.position;
        t !== void 0 && (t.applyMatrix4(e),
        t.needsUpdate = !0);
        const r = this.attributes.normal;
        if (r !== void 0) {
            const s = new bo().getNormalMatrix(e);
            r.applyNormalMatrix(s),
            r.needsUpdate = !0
        }
        const i = this.attributes.tangent;
        return i !== void 0 && (i.transformDirection(e),
        i.needsUpdate = !0),
        this.boundingBox !== null && this.computeBoundingBox(),
        this.boundingSphere !== null && this.computeBoundingSphere(),
        this
    }
    applyQuaternion(e) {
        return za.makeRotationFromQuaternion(e),
        this.applyMatrix4(za),
        this
    }
    rotateX(e) {
        return za.makeRotationX(e),
        this.applyMatrix4(za),
        this
    }
    rotateY(e) {
        return za.makeRotationY(e),
        this.applyMatrix4(za),
        this
    }
    rotateZ(e) {
        return za.makeRotationZ(e),
        this.applyMatrix4(za),
        this
    }
    translate(e, t, r) {
        return za.makeTranslation(e, t, r),
        this.applyMatrix4(za),
        this
    }
    scale(e, t, r) {
        return za.makeScale(e, t, r),
        this.applyMatrix4(za),
        this
    }
    lookAt(e) {
        return qy.lookAt(e),
        qy.updateMatrix(),
        this.applyMatrix4(qy.matrix),
        this
    }
    center() {
        return this.computeBoundingBox(),
        this.boundingBox.getCenter(gd).negate(),
        this.translate(gd.x, gd.y, gd.z),
        this
    }
    setFromPoints(e) {
        const t = [];
        for (let r = 0, i = e.length; r < i; r++) {
            const s = e[r];
            t.push(s.x, s.y, s.z || 0)
        }
        return this.setAttribute("position", new nn(t,3)),
        this
    }
    computeBoundingBox() {
        this.boundingBox === null && (this.boundingBox = new kc);
        const e = this.attributes.position
          , t = this.morphAttributes.position;
        if (e && e.isGLBufferAttribute) {
            console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this),
            this.boundingBox.set(new $(-1 / 0,-1 / 0,-1 / 0), new $(1 / 0,1 / 0,1 / 0));
            return
        }
        if (e !== void 0) {
            if (this.boundingBox.setFromBufferAttribute(e),
            t)
                for (let r = 0, i = t.length; r < i; r++) {
                    const s = t[r];
                    ca.setFromBufferAttribute(s),
                    this.morphTargetsRelative ? (Ts.addVectors(this.boundingBox.min, ca.min),
                    this.boundingBox.expandByPoint(Ts),
                    Ts.addVectors(this.boundingBox.max, ca.max),
                    this.boundingBox.expandByPoint(Ts)) : (this.boundingBox.expandByPoint(ca.min),
                    this.boundingBox.expandByPoint(ca.max))
                }
        } else
            this.boundingBox.makeEmpty();
        (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
    }
    computeBoundingSphere() {
        this.boundingSphere === null && (this.boundingSphere = new Oc);
        const e = this.attributes.position
          , t = this.morphAttributes.position;
        if (e && e.isGLBufferAttribute) {
            console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this),
            this.boundingSphere.set(new $, 1 / 0);
            return
        }
        if (e) {
            const r = this.boundingSphere.center;
            if (ca.setFromBufferAttribute(e),
            t)
                for (let s = 0, o = t.length; s < o; s++) {
                    const a = t[s];
                    tp.setFromBufferAttribute(a),
                    this.morphTargetsRelative ? (Ts.addVectors(ca.min, tp.min),
                    ca.expandByPoint(Ts),
                    Ts.addVectors(ca.max, tp.max),
                    ca.expandByPoint(Ts)) : (ca.expandByPoint(tp.min),
                    ca.expandByPoint(tp.max))
                }
            ca.getCenter(r);
            let i = 0;
            for (let s = 0, o = e.count; s < o; s++)
                Ts.fromBufferAttribute(e, s),
                i = Math.max(i, r.distanceToSquared(Ts));
            if (t)
                for (let s = 0, o = t.length; s < o; s++) {
                    const a = t[s]
                      , l = this.morphTargetsRelative;
                    for (let f = 0, h = a.count; f < h; f++)
                        Ts.fromBufferAttribute(a, f),
                        l && (gd.fromBufferAttribute(e, f),
                        Ts.add(gd)),
                        i = Math.max(i, r.distanceToSquared(Ts))
                }
            this.boundingSphere.radius = Math.sqrt(i),
            isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
        }
    }
    computeTangents() {
        const e = this.index
          , t = this.attributes;
        if (e === null || t.position === void 0 || t.normal === void 0 || t.uv === void 0) {
            console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
            return
        }
        const r = e.array
          , i = t.position.array
          , s = t.normal.array
          , o = t.uv.array
          , a = i.length / 3;
        this.hasAttribute("tangent") === !1 && this.setAttribute("tangent", new Dr(new Float32Array(4 * a),4));
        const l = this.getAttribute("tangent").array
          , f = []
          , h = [];
        for (let H = 0; H < a; H++)
            f[H] = new $,
            h[H] = new $;
        const d = new $
          , p = new $
          , m = new $
          , _ = new it
          , y = new it
          , x = new it
          , S = new $
          , M = new $;
        function w(H, W, te) {
            d.fromArray(i, H * 3),
            p.fromArray(i, W * 3),
            m.fromArray(i, te * 3),
            _.fromArray(o, H * 2),
            y.fromArray(o, W * 2),
            x.fromArray(o, te * 2),
            p.sub(d),
            m.sub(d),
            y.sub(_),
            x.sub(_);
            const ne = 1 / (y.x * x.y - x.x * y.y);
            isFinite(ne) && (S.copy(p).multiplyScalar(x.y).addScaledVector(m, -y.y).multiplyScalar(ne),
            M.copy(m).multiplyScalar(y.x).addScaledVector(p, -x.x).multiplyScalar(ne),
            f[H].add(S),
            f[W].add(S),
            f[te].add(S),
            h[H].add(M),
            h[W].add(M),
            h[te].add(M))
        }
        let T = this.groups;
        T.length === 0 && (T = [{
            start: 0,
            count: r.length
        }]);
        for (let H = 0, W = T.length; H < W; ++H) {
            const te = T[H]
              , ne = te.start
              , re = te.count;
            for (let pe = ne, ce = ne + re; pe < ce; pe += 3)
                w(r[pe + 0], r[pe + 1], r[pe + 2])
        }
        const P = new $
          , I = new $
          , k = new $
          , R = new $;
        function O(H) {
            k.fromArray(s, H * 3),
            R.copy(k);
            const W = f[H];
            P.copy(W),
            P.sub(k.multiplyScalar(k.dot(W))).normalize(),
            I.crossVectors(R, W);
            const ne = I.dot(h[H]) < 0 ? -1 : 1;
            l[H * 4] = P.x,
            l[H * 4 + 1] = P.y,
            l[H * 4 + 2] = P.z,
            l[H * 4 + 3] = ne
        }
        for (let H = 0, W = T.length; H < W; ++H) {
            const te = T[H]
              , ne = te.start
              , re = te.count;
            for (let pe = ne, ce = ne + re; pe < ce; pe += 3)
                O(r[pe + 0]),
                O(r[pe + 1]),
                O(r[pe + 2])
        }
    }
    computeVertexNormals() {
        const e = this.index
          , t = this.getAttribute("position");
        if (t !== void 0) {
            let r = this.getAttribute("normal");
            if (r === void 0)
                r = new Dr(new Float32Array(t.count * 3),3),
                this.setAttribute("normal", r);
            else
                for (let p = 0, m = r.count; p < m; p++)
                    r.setXYZ(p, 0, 0, 0);
            const i = new $
              , s = new $
              , o = new $
              , a = new $
              , l = new $
              , f = new $
              , h = new $
              , d = new $;
            if (e)
                for (let p = 0, m = e.count; p < m; p += 3) {
                    const _ = e.getX(p + 0)
                      , y = e.getX(p + 1)
                      , x = e.getX(p + 2);
                    i.fromBufferAttribute(t, _),
                    s.fromBufferAttribute(t, y),
                    o.fromBufferAttribute(t, x),
                    h.subVectors(o, s),
                    d.subVectors(i, s),
                    h.cross(d),
                    a.fromBufferAttribute(r, _),
                    l.fromBufferAttribute(r, y),
                    f.fromBufferAttribute(r, x),
                    a.add(h),
                    l.add(h),
                    f.add(h),
                    r.setXYZ(_, a.x, a.y, a.z),
                    r.setXYZ(y, l.x, l.y, l.z),
                    r.setXYZ(x, f.x, f.y, f.z)
                }
            else
                for (let p = 0, m = t.count; p < m; p += 3)
                    i.fromBufferAttribute(t, p + 0),
                    s.fromBufferAttribute(t, p + 1),
                    o.fromBufferAttribute(t, p + 2),
                    h.subVectors(o, s),
                    d.subVectors(i, s),
                    h.cross(d),
                    r.setXYZ(p + 0, h.x, h.y, h.z),
                    r.setXYZ(p + 1, h.x, h.y, h.z),
                    r.setXYZ(p + 2, h.x, h.y, h.z);
            this.normalizeNormals(),
            r.needsUpdate = !0
        }
    }
    merge() {
        return console.error("THREE.BufferGeometry.merge() has been removed. Use THREE.BufferGeometryUtils.mergeBufferGeometries() instead."),
        this
    }
    normalizeNormals() {
        const e = this.attributes.normal;
        for (let t = 0, r = e.count; t < r; t++)
            Ts.fromBufferAttribute(e, t),
            Ts.normalize(),
            e.setXYZ(t, Ts.x, Ts.y, Ts.z)
    }
    toNonIndexed() {
        function e(a, l) {
            const f = a.array
              , h = a.itemSize
              , d = a.normalized
              , p = new f.constructor(l.length * h);
            let m = 0
              , _ = 0;
            for (let y = 0, x = l.length; y < x; y++) {
                a.isInterleavedBufferAttribute ? m = l[y] * a.data.stride + a.offset : m = l[y] * h;
                for (let S = 0; S < h; S++)
                    p[_++] = f[m++]
            }
            return new Dr(p,h,d)
        }
        if (this.index === null)
            return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),
            this;
        const t = new On
          , r = this.index.array
          , i = this.attributes;
        for (const a in i) {
            const l = i[a]
              , f = e(l, r);
            t.setAttribute(a, f)
        }
        const s = this.morphAttributes;
        for (const a in s) {
            const l = []
              , f = s[a];
            for (let h = 0, d = f.length; h < d; h++) {
                const p = f[h]
                  , m = e(p, r);
                l.push(m)
            }
            t.morphAttributes[a] = l
        }
        t.morphTargetsRelative = this.morphTargetsRelative;
        const o = this.groups;
        for (let a = 0, l = o.length; a < l; a++) {
            const f = o[a];
            t.addGroup(f.start, f.count, f.materialIndex)
        }
        return t
    }
    toJSON() {
        const e = {
            metadata: {
                version: 4.5,
                type: "BufferGeometry",
                generator: "BufferGeometry.toJSON"
            }
        };
        if (e.uuid = this.uuid,
        e.type = this.type,
        this.name !== "" && (e.name = this.name),
        Object.keys(this.userData).length > 0 && (e.userData = this.userData),
        this.parameters !== void 0) {
            const l = this.parameters;
            for (const f in l)
                l[f] !== void 0 && (e[f] = l[f]);
            return e
        }
        e.data = {
            attributes: {}
        };
        const t = this.index;
        t !== null && (e.data.index = {
            type: t.array.constructor.name,
            array: Array.prototype.slice.call(t.array)
        });
        const r = this.attributes;
        for (const l in r) {
            const f = r[l];
            e.data.attributes[l] = f.toJSON(e.data)
        }
        const i = {};
        let s = !1;
        for (const l in this.morphAttributes) {
            const f = this.morphAttributes[l]
              , h = [];
            for (let d = 0, p = f.length; d < p; d++) {
                const m = f[d];
                h.push(m.toJSON(e.data))
            }
            h.length > 0 && (i[l] = h,
            s = !0)
        }
        s && (e.data.morphAttributes = i,
        e.data.morphTargetsRelative = this.morphTargetsRelative);
        const o = this.groups;
        o.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(o)));
        const a = this.boundingSphere;
        return a !== null && (e.data.boundingSphere = {
            center: a.center.toArray(),
            radius: a.radius
        }),
        e
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        this.index = null,
        this.attributes = {},
        this.morphAttributes = {},
        this.groups = [],
        this.boundingBox = null,
        this.boundingSphere = null;
        const t = {};
        this.name = e.name;
        const r = e.index;
        r !== null && this.setIndex(r.clone(t));
        const i = e.attributes;
        for (const f in i) {
            const h = i[f];
            this.setAttribute(f, h.clone(t))
        }
        const s = e.morphAttributes;
        for (const f in s) {
            const h = []
              , d = s[f];
            for (let p = 0, m = d.length; p < m; p++)
                h.push(d[p].clone(t));
            this.morphAttributes[f] = h
        }
        this.morphTargetsRelative = e.morphTargetsRelative;
        const o = e.groups;
        for (let f = 0, h = o.length; f < h; f++) {
            const d = o[f];
            this.addGroup(d.start, d.count, d.materialIndex)
        }
        const a = e.boundingBox;
        a !== null && (this.boundingBox = a.clone());
        const l = e.boundingSphere;
        return l !== null && (this.boundingSphere = l.clone()),
        this.drawRange.start = e.drawRange.start,
        this.drawRange.count = e.drawRange.count,
        this.userData = e.userData,
        e.parameters !== void 0 && (this.parameters = Object.assign({}, e.parameters)),
        this
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
}
const BC = new Dn
  , vd = new Fm
  , Qy = new Oc
  , np = new $
  , rp = new $
  , ip = new $
  , Zy = new $
  , Xg = new $
  , Jg = new it
  , jg = new it
  , Yg = new it
  , $y = new $
  , Kg = new $;
class vs extends wr {
    constructor(e=new On, t=new xa) {
        super(),
        this.isMesh = !0,
        this.type = "Mesh",
        this.geometry = e,
        this.material = t,
        this.updateMorphTargets()
    }
    copy(e, t) {
        return super.copy(e, t),
        e.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = e.morphTargetInfluences.slice()),
        e.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)),
        this.material = e.material,
        this.geometry = e.geometry,
        this
    }
    updateMorphTargets() {
        const t = this.geometry.morphAttributes
          , r = Object.keys(t);
        if (r.length > 0) {
            const i = t[r[0]];
            if (i !== void 0) {
                this.morphTargetInfluences = [],
                this.morphTargetDictionary = {};
                for (let s = 0, o = i.length; s < o; s++) {
                    const a = i[s].name || String(s);
                    this.morphTargetInfluences.push(0),
                    this.morphTargetDictionary[a] = s
                }
            }
        }
    }
    getVertexPosition(e, t) {
        const r = this.geometry
          , i = r.attributes.position
          , s = r.morphAttributes.position
          , o = r.morphTargetsRelative;
        t.fromBufferAttribute(i, e);
        const a = this.morphTargetInfluences;
        if (s && a) {
            Xg.set(0, 0, 0);
            for (let l = 0, f = s.length; l < f; l++) {
                const h = a[l]
                  , d = s[l];
                h !== 0 && (Zy.fromBufferAttribute(d, e),
                o ? Xg.addScaledVector(Zy, h) : Xg.addScaledVector(Zy.sub(t), h))
            }
            t.add(Xg)
        }
        return this.isSkinnedMesh && this.boneTransform(e, t),
        t
    }
    raycast(e, t) {
        const r = this.geometry
          , i = this.material
          , s = this.matrixWorld;
        if (i === void 0 || (r.boundingSphere === null && r.computeBoundingSphere(),
        Qy.copy(r.boundingSphere),
        Qy.applyMatrix4(s),
        e.ray.intersectsSphere(Qy) === !1) || (BC.copy(s).invert(),
        vd.copy(e.ray).applyMatrix4(BC),
        r.boundingBox !== null && vd.intersectsBox(r.boundingBox) === !1))
            return;
        let o;
        const a = r.index
          , l = r.attributes.position
          , f = r.attributes.uv
          , h = r.attributes.uv2
          , d = r.groups
          , p = r.drawRange;
        if (a !== null)
            if (Array.isArray(i))
                for (let m = 0, _ = d.length; m < _; m++) {
                    const y = d[m]
                      , x = i[y.materialIndex]
                      , S = Math.max(y.start, p.start)
                      , M = Math.min(a.count, Math.min(y.start + y.count, p.start + p.count));
                    for (let w = S, T = M; w < T; w += 3) {
                        const P = a.getX(w)
                          , I = a.getX(w + 1)
                          , k = a.getX(w + 2);
                        o = qg(this, x, e, vd, f, h, P, I, k),
                        o && (o.faceIndex = Math.floor(w / 3),
                        o.face.materialIndex = y.materialIndex,
                        t.push(o))
                    }
                }
            else {
                const m = Math.max(0, p.start)
                  , _ = Math.min(a.count, p.start + p.count);
                for (let y = m, x = _; y < x; y += 3) {
                    const S = a.getX(y)
                      , M = a.getX(y + 1)
                      , w = a.getX(y + 2);
                    o = qg(this, i, e, vd, f, h, S, M, w),
                    o && (o.faceIndex = Math.floor(y / 3),
                    t.push(o))
                }
            }
        else if (l !== void 0)
            if (Array.isArray(i))
                for (let m = 0, _ = d.length; m < _; m++) {
                    const y = d[m]
                      , x = i[y.materialIndex]
                      , S = Math.max(y.start, p.start)
                      , M = Math.min(l.count, Math.min(y.start + y.count, p.start + p.count));
                    for (let w = S, T = M; w < T; w += 3) {
                        const P = w
                          , I = w + 1
                          , k = w + 2;
                        o = qg(this, x, e, vd, f, h, P, I, k),
                        o && (o.faceIndex = Math.floor(w / 3),
                        o.face.materialIndex = y.materialIndex,
                        t.push(o))
                    }
                }
            else {
                const m = Math.max(0, p.start)
                  , _ = Math.min(l.count, p.start + p.count);
                for (let y = m, x = _; y < x; y += 3) {
                    const S = y
                      , M = y + 1
                      , w = y + 2;
                    o = qg(this, i, e, vd, f, h, S, M, w),
                    o && (o.faceIndex = Math.floor(y / 3),
                    t.push(o))
                }
            }
    }
}
function cF(n, e, t, r, i, s, o, a) {
    let l;
    if (e.side === Do ? l = r.intersectTriangle(o, s, i, !0, a) : l = r.intersectTriangle(i, s, o, e.side === El, a),
    l === null)
        return null;
    Kg.copy(a),
    Kg.applyMatrix4(n.matrixWorld);
    const f = t.ray.origin.distanceTo(Kg);
    return f < t.near || f > t.far ? null : {
        distance: f,
        point: Kg.clone(),
        object: n
    }
}
function qg(n, e, t, r, i, s, o, a, l) {
    n.getVertexPosition(o, np),
    n.getVertexPosition(a, rp),
    n.getVertexPosition(l, ip);
    const f = cF(n, e, t, r, np, rp, ip, $y);
    if (f) {
        i && (Jg.fromBufferAttribute(i, o),
        jg.fromBufferAttribute(i, a),
        Yg.fromBufferAttribute(i, l),
        f.uv = Xa.getUV($y, np, rp, ip, Jg, jg, Yg, new it)),
        s && (Jg.fromBufferAttribute(s, o),
        jg.fromBufferAttribute(s, a),
        Yg.fromBufferAttribute(s, l),
        f.uv2 = Xa.getUV($y, np, rp, ip, Jg, jg, Yg, new it));
        const h = {
            a: o,
            b: a,
            c: l,
            normal: new $,
            materialIndex: 0
        };
        Xa.getNormal(np, rp, ip, h.normal),
        f.face = h
    }
    return f
}
class Nc extends On {
    constructor(e=1, t=1, r=1, i=1, s=1, o=1) {
        super(),
        this.type = "BoxGeometry",
        this.parameters = {
            width: e,
            height: t,
            depth: r,
            widthSegments: i,
            heightSegments: s,
            depthSegments: o
        };
        const a = this;
        i = Math.floor(i),
        s = Math.floor(s),
        o = Math.floor(o);
        const l = []
          , f = []
          , h = []
          , d = [];
        let p = 0
          , m = 0;
        _("z", "y", "x", -1, -1, r, t, e, o, s, 0),
        _("z", "y", "x", 1, -1, r, t, -e, o, s, 1),
        _("x", "z", "y", 1, 1, e, r, t, i, o, 2),
        _("x", "z", "y", 1, -1, e, r, -t, i, o, 3),
        _("x", "y", "z", 1, -1, e, t, r, i, s, 4),
        _("x", "y", "z", -1, -1, e, t, -r, i, s, 5),
        this.setIndex(l),
        this.setAttribute("position", new nn(f,3)),
        this.setAttribute("normal", new nn(h,3)),
        this.setAttribute("uv", new nn(d,2));
        function _(y, x, S, M, w, T, P, I, k, R, O) {
            const H = T / k
              , W = P / R
              , te = T / 2
              , ne = P / 2
              , re = I / 2
              , pe = k + 1
              , ce = R + 1;
            let xe = 0
              , G = 0;
            const z = new $;
            for (let U = 0; U < ce; U++) {
                const fe = U * W - ne;
                for (let oe = 0; oe < pe; oe++) {
                    const Ae = oe * H - te;
                    z[y] = Ae * M,
                    z[x] = fe * w,
                    z[S] = re,
                    f.push(z.x, z.y, z.z),
                    z[y] = 0,
                    z[x] = 0,
                    z[S] = I > 0 ? 1 : -1,
                    h.push(z.x, z.y, z.z),
                    d.push(oe / k),
                    d.push(1 - U / R),
                    xe += 1
                }
            }
            for (let U = 0; U < R; U++)
                for (let fe = 0; fe < k; fe++) {
                    const oe = p + fe + pe * U
                      , Ae = p + fe + pe * (U + 1)
                      , Ue = p + (fe + 1) + pe * (U + 1)
                      , je = p + (fe + 1) + pe * U;
                    l.push(oe, Ae, je),
                    l.push(Ae, Ue, je),
                    G += 6
                }
            a.addGroup(m, G, O),
            m += G,
            p += xe
        }
    }
    static fromJSON(e) {
        return new Nc(e.width,e.height,e.depth,e.widthSegments,e.heightSegments,e.depthSegments)
    }
}
function yh(n) {
    const e = {};
    for (const t in n) {
        e[t] = {};
        for (const r in n[t]) {
            const i = n[t][r];
            i && (i.isColor || i.isMatrix3 || i.isMatrix4 || i.isVector2 || i.isVector3 || i.isVector4 || i.isTexture || i.isQuaternion) ? e[t][r] = i.clone() : Array.isArray(i) ? e[t][r] = i.slice() : e[t][r] = i
        }
    }
    return e
}
function wo(n) {
    const e = {};
    for (let t = 0; t < n.length; t++) {
        const r = yh(n[t]);
        for (const i in r)
            e[i] = r[i]
    }
    return e
}
function fF(n) {
    const e = [];
    for (let t = 0; t < n.length; t++)
        e.push(n[t].clone());
    return e
}
function e3(n) {
    return n.getRenderTarget() === null && n.outputEncoding === nr ? gl : _h
}
const WS = {
    clone: yh,
    merge: wo
};
var dF = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`
  , hF = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
class el extends as {
    constructor(e) {
        super(),
        this.isShaderMaterial = !0,
        this.type = "ShaderMaterial",
        this.defines = {},
        this.uniforms = {},
        this.uniformsGroups = [],
        this.vertexShader = dF,
        this.fragmentShader = hF,
        this.linewidth = 1,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.fog = !1,
        this.lights = !1,
        this.clipping = !1,
        this.extensions = {
            derivatives: !1,
            fragDepth: !1,
            drawBuffers: !1,
            shaderTextureLOD: !1
        },
        this.defaultAttributeValues = {
            color: [1, 1, 1],
            uv: [0, 0],
            uv2: [0, 0]
        },
        this.index0AttributeName = void 0,
        this.uniformsNeedUpdate = !1,
        this.glslVersion = null,
        e !== void 0 && this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.fragmentShader = e.fragmentShader,
        this.vertexShader = e.vertexShader,
        this.uniforms = yh(e.uniforms),
        this.uniformsGroups = fF(e.uniformsGroups),
        this.defines = Object.assign({}, e.defines),
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.fog = e.fog,
        this.lights = e.lights,
        this.clipping = e.clipping,
        this.extensions = Object.assign({}, e.extensions),
        this.glslVersion = e.glslVersion,
        this
    }
    toJSON(e) {
        const t = super.toJSON(e);
        t.glslVersion = this.glslVersion,
        t.uniforms = {};
        for (const i in this.uniforms) {
            const o = this.uniforms[i].value;
            o && o.isTexture ? t.uniforms[i] = {
                type: "t",
                value: o.toJSON(e).uuid
            } : o && o.isColor ? t.uniforms[i] = {
                type: "c",
                value: o.getHex()
            } : o && o.isVector2 ? t.uniforms[i] = {
                type: "v2",
                value: o.toArray()
            } : o && o.isVector3 ? t.uniforms[i] = {
                type: "v3",
                value: o.toArray()
            } : o && o.isVector4 ? t.uniforms[i] = {
                type: "v4",
                value: o.toArray()
            } : o && o.isMatrix3 ? t.uniforms[i] = {
                type: "m3",
                value: o.toArray()
            } : o && o.isMatrix4 ? t.uniforms[i] = {
                type: "m4",
                value: o.toArray()
            } : t.uniforms[i] = {
                value: o
            }
        }
        Object.keys(this.defines).length > 0 && (t.defines = this.defines),
        t.vertexShader = this.vertexShader,
        t.fragmentShader = this.fragmentShader;
        const r = {};
        for (const i in this.extensions)
            this.extensions[i] === !0 && (r[i] = !0);
        return Object.keys(r).length > 0 && (t.extensions = r),
        t
    }
}
class Om extends wr {
    constructor() {
        super(),
        this.isCamera = !0,
        this.type = "Camera",
        this.matrixWorldInverse = new Dn,
        this.projectionMatrix = new Dn,
        this.projectionMatrixInverse = new Dn
    }
    copy(e, t) {
        return super.copy(e, t),
        this.matrixWorldInverse.copy(e.matrixWorldInverse),
        this.projectionMatrix.copy(e.projectionMatrix),
        this.projectionMatrixInverse.copy(e.projectionMatrixInverse),
        this
    }
    getWorldDirection(e) {
        this.updateWorldMatrix(!0, !1);
        const t = this.matrixWorld.elements;
        return e.set(-t[8], -t[9], -t[10]).normalize()
    }
    updateMatrixWorld(e) {
        super.updateMatrixWorld(e),
        this.matrixWorldInverse.copy(this.matrixWorld).invert()
    }
    updateWorldMatrix(e, t) {
        super.updateWorldMatrix(e, t),
        this.matrixWorldInverse.copy(this.matrixWorld).invert()
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
class gi extends Om {
    constructor(e=50, t=1, r=.1, i=2e3) {
        super(),
        this.isPerspectiveCamera = !0,
        this.type = "PerspectiveCamera",
        this.fov = e,
        this.zoom = 1,
        this.near = r,
        this.far = i,
        this.focus = 10,
        this.aspect = t,
        this.view = null,
        this.filmGauge = 35,
        this.filmOffset = 0,
        this.updateProjectionMatrix()
    }
    copy(e, t) {
        return super.copy(e, t),
        this.fov = e.fov,
        this.zoom = e.zoom,
        this.near = e.near,
        this.far = e.far,
        this.focus = e.focus,
        this.aspect = e.aspect,
        this.view = e.view === null ? null : Object.assign({}, e.view),
        this.filmGauge = e.filmGauge,
        this.filmOffset = e.filmOffset,
        this
    }
    setFocalLength(e) {
        const t = .5 * this.getFilmHeight() / e;
        this.fov = vm * 2 * Math.atan(t),
        this.updateProjectionMatrix()
    }
    getFocalLength() {
        const e = Math.tan(Df * .5 * this.fov);
        return .5 * this.getFilmHeight() / e
    }
    getEffectiveFOV() {
        return vm * 2 * Math.atan(Math.tan(Df * .5 * this.fov) / this.zoom)
    }
    getFilmWidth() {
        return this.filmGauge * Math.min(this.aspect, 1)
    }
    getFilmHeight() {
        return this.filmGauge / Math.max(this.aspect, 1)
    }
    setViewOffset(e, t, r, i, s, o) {
        this.aspect = e / t,
        this.view === null && (this.view = {
            enabled: !0,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1
        }),
        this.view.enabled = !0,
        this.view.fullWidth = e,
        this.view.fullHeight = t,
        this.view.offsetX = r,
        this.view.offsetY = i,
        this.view.width = s,
        this.view.height = o,
        this.updateProjectionMatrix()
    }
    clearViewOffset() {
        this.view !== null && (this.view.enabled = !1),
        this.updateProjectionMatrix()
    }
    updateProjectionMatrix() {
        const e = this.near;
        let t = e * Math.tan(Df * .5 * this.fov) / this.zoom
          , r = 2 * t
          , i = this.aspect * r
          , s = -.5 * i;
        const o = this.view;
        if (this.view !== null && this.view.enabled) {
            const l = o.fullWidth
              , f = o.fullHeight;
            s += o.offsetX * i / l,
            t -= o.offsetY * r / f,
            i *= o.width / l,
            r *= o.height / f
        }
        const a = this.filmOffset;
        a !== 0 && (s += e * a / this.getFilmWidth()),
        this.projectionMatrix.makePerspective(s, s + i, t, t - r, e, this.far),
        this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return t.object.fov = this.fov,
        t.object.zoom = this.zoom,
        t.object.near = this.near,
        t.object.far = this.far,
        t.object.focus = this.focus,
        t.object.aspect = this.aspect,
        this.view !== null && (t.object.view = Object.assign({}, this.view)),
        t.object.filmGauge = this.filmGauge,
        t.object.filmOffset = this.filmOffset,
        t
    }
}
const _d = -90
  , yd = 1;
class t3 extends wr {
    constructor(e, t, r) {
        super(),
        this.type = "CubeCamera",
        this.renderTarget = r;
        const i = new gi(_d,yd,e,t);
        i.layers = this.layers,
        i.up.set(0, 1, 0),
        i.lookAt(1, 0, 0),
        this.add(i);
        const s = new gi(_d,yd,e,t);
        s.layers = this.layers,
        s.up.set(0, 1, 0),
        s.lookAt(-1, 0, 0),
        this.add(s);
        const o = new gi(_d,yd,e,t);
        o.layers = this.layers,
        o.up.set(0, 0, -1),
        o.lookAt(0, 1, 0),
        this.add(o);
        const a = new gi(_d,yd,e,t);
        a.layers = this.layers,
        a.up.set(0, 0, 1),
        a.lookAt(0, -1, 0),
        this.add(a);
        const l = new gi(_d,yd,e,t);
        l.layers = this.layers,
        l.up.set(0, 1, 0),
        l.lookAt(0, 0, 1),
        this.add(l);
        const f = new gi(_d,yd,e,t);
        f.layers = this.layers,
        f.up.set(0, 1, 0),
        f.lookAt(0, 0, -1),
        this.add(f)
    }
    update(e, t) {
        this.parent === null && this.updateMatrixWorld();
        const r = this.renderTarget
          , [i,s,o,a,l,f] = this.children
          , h = e.getRenderTarget()
          , d = e.toneMapping
          , p = e.xr.enabled;
        e.toneMapping = Ka,
        e.xr.enabled = !1;
        const m = r.texture.generateMipmaps;
        r.texture.generateMipmaps = !1,
        e.setRenderTarget(r, 0),
        e.render(t, i),
        e.setRenderTarget(r, 1),
        e.render(t, s),
        e.setRenderTarget(r, 2),
        e.render(t, o),
        e.setRenderTarget(r, 3),
        e.render(t, a),
        e.setRenderTarget(r, 4),
        e.render(t, l),
        r.texture.generateMipmaps = m,
        e.setRenderTarget(r, 5),
        e.render(t, f),
        e.setRenderTarget(h),
        e.toneMapping = d,
        e.xr.enabled = p,
        r.texture.needsPMREMUpdate = !0
    }
}
class Nm extends Ci {
    constructor(e, t, r, i, s, o, a, l, f, h) {
        e = e !== void 0 ? e : [],
        t = t !== void 0 ? t : Tu,
        super(e, t, r, i, s, o, a, l, f, h),
        this.isCubeTexture = !0,
        this.flipY = !1
    }
    get images() {
        return this.image
    }
    set images(e) {
        this.image = e
    }
}
class XS extends $a {
    constructor(e=1, t={}) {
        super(e, e, t),
        this.isWebGLCubeRenderTarget = !0;
        const r = {
            width: e,
            height: e,
            depth: 1
        }
          , i = [r, r, r, r, r, r];
        this.texture = new Nm(i,t.mapping,t.wrapS,t.wrapT,t.magFilter,t.minFilter,t.format,t.type,t.anisotropy,t.encoding),
        this.texture.isRenderTargetTexture = !0,
        this.texture.generateMipmaps = t.generateMipmaps !== void 0 ? t.generateMipmaps : !1,
        this.texture.minFilter = t.minFilter !== void 0 ? t.minFilter : si
    }
    fromEquirectangularTexture(e, t) {
        this.texture.type = t.type,
        this.texture.encoding = t.encoding,
        this.texture.generateMipmaps = t.generateMipmaps,
        this.texture.minFilter = t.minFilter,
        this.texture.magFilter = t.magFilter;
        const r = {
            uniforms: {
                tEquirect: {
                    value: null
                }
            },
            vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
            fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
        }
          , i = new Nc(5,5,5)
          , s = new el({
            name: "CubemapFromEquirect",
            uniforms: yh(r.uniforms),
            vertexShader: r.vertexShader,
            fragmentShader: r.fragmentShader,
            side: Do,
            blending: Su
        });
        s.uniforms.tEquirect.value = t;
        const o = new vs(i,s)
          , a = t.minFilter;
        return t.minFilter === Kl && (t.minFilter = si),
        new t3(1,10,this).update(e, o),
        t.minFilter = a,
        o.geometry.dispose(),
        o.material.dispose(),
        this
    }
    clear(e, t, r, i) {
        const s = e.getRenderTarget();
        for (let o = 0; o < 6; o++)
            e.setRenderTarget(this, o),
            e.clear(t, r, i);
        e.setRenderTarget(s)
    }
}
const ex = new $
  , pF = new $
  , mF = new bo;
class rc {
    constructor(e=new $(1,0,0), t=0) {
        this.isPlane = !0,
        this.normal = e,
        this.constant = t
    }
    set(e, t) {
        return this.normal.copy(e),
        this.constant = t,
        this
    }
    setComponents(e, t, r, i) {
        return this.normal.set(e, t, r),
        this.constant = i,
        this
    }
    setFromNormalAndCoplanarPoint(e, t) {
        return this.normal.copy(e),
        this.constant = -t.dot(this.normal),
        this
    }
    setFromCoplanarPoints(e, t, r) {
        const i = ex.subVectors(r, t).cross(pF.subVectors(e, t)).normalize();
        return this.setFromNormalAndCoplanarPoint(i, e),
        this
    }
    copy(e) {
        return this.normal.copy(e.normal),
        this.constant = e.constant,
        this
    }
    normalize() {
        const e = 1 / this.normal.length();
        return this.normal.multiplyScalar(e),
        this.constant *= e,
        this
    }
    negate() {
        return this.constant *= -1,
        this.normal.negate(),
        this
    }
    distanceToPoint(e) {
        return this.normal.dot(e) + this.constant
    }
    distanceToSphere(e) {
        return this.distanceToPoint(e.center) - e.radius
    }
    projectPoint(e, t) {
        return t.copy(this.normal).multiplyScalar(-this.distanceToPoint(e)).add(e)
    }
    intersectLine(e, t) {
        const r = e.delta(ex)
          , i = this.normal.dot(r);
        if (i === 0)
            return this.distanceToPoint(e.start) === 0 ? t.copy(e.start) : null;
        const s = -(e.start.dot(this.normal) + this.constant) / i;
        return s < 0 || s > 1 ? null : t.copy(r).multiplyScalar(s).add(e.start)
    }
    intersectsLine(e) {
        const t = this.distanceToPoint(e.start)
          , r = this.distanceToPoint(e.end);
        return t < 0 && r > 0 || r < 0 && t > 0
    }
    intersectsBox(e) {
        return e.intersectsPlane(this)
    }
    intersectsSphere(e) {
        return e.intersectsPlane(this)
    }
    coplanarPoint(e) {
        return e.copy(this.normal).multiplyScalar(-this.constant)
    }
    applyMatrix4(e, t) {
        const r = t || mF.getNormalMatrix(e)
          , i = this.coplanarPoint(ex).applyMatrix4(e)
          , s = this.normal.applyMatrix3(r).normalize();
        return this.constant = -i.dot(s),
        this
    }
    translate(e) {
        return this.constant -= e.dot(this.normal),
        this
    }
    equals(e) {
        return e.normal.equals(this.normal) && e.constant === this.constant
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
const xd = new Oc
  , Qg = new $;
class w_ {
    constructor(e=new rc, t=new rc, r=new rc, i=new rc, s=new rc, o=new rc) {
        this.planes = [e, t, r, i, s, o]
    }
    set(e, t, r, i, s, o) {
        const a = this.planes;
        return a[0].copy(e),
        a[1].copy(t),
        a[2].copy(r),
        a[3].copy(i),
        a[4].copy(s),
        a[5].copy(o),
        this
    }
    copy(e) {
        const t = this.planes;
        for (let r = 0; r < 6; r++)
            t[r].copy(e.planes[r]);
        return this
    }
    setFromProjectionMatrix(e) {
        const t = this.planes
          , r = e.elements
          , i = r[0]
          , s = r[1]
          , o = r[2]
          , a = r[3]
          , l = r[4]
          , f = r[5]
          , h = r[6]
          , d = r[7]
          , p = r[8]
          , m = r[9]
          , _ = r[10]
          , y = r[11]
          , x = r[12]
          , S = r[13]
          , M = r[14]
          , w = r[15];
        return t[0].setComponents(a - i, d - l, y - p, w - x).normalize(),
        t[1].setComponents(a + i, d + l, y + p, w + x).normalize(),
        t[2].setComponents(a + s, d + f, y + m, w + S).normalize(),
        t[3].setComponents(a - s, d - f, y - m, w - S).normalize(),
        t[4].setComponents(a - o, d - h, y - _, w - M).normalize(),
        t[5].setComponents(a + o, d + h, y + _, w + M).normalize(),
        this
    }
    intersectsObject(e) {
        const t = e.geometry;
        return t.boundingSphere === null && t.computeBoundingSphere(),
        xd.copy(t.boundingSphere).applyMatrix4(e.matrixWorld),
        this.intersectsSphere(xd)
    }
    intersectsSprite(e) {
        return xd.center.set(0, 0, 0),
        xd.radius = .7071067811865476,
        xd.applyMatrix4(e.matrixWorld),
        this.intersectsSphere(xd)
    }
    intersectsSphere(e) {
        const t = this.planes
          , r = e.center
          , i = -e.radius;
        for (let s = 0; s < 6; s++)
            if (t[s].distanceToPoint(r) < i)
                return !1;
        return !0
    }
    intersectsBox(e) {
        const t = this.planes;
        for (let r = 0; r < 6; r++) {
            const i = t[r];
            if (Qg.x = i.normal.x > 0 ? e.max.x : e.min.x,
            Qg.y = i.normal.y > 0 ? e.max.y : e.min.y,
            Qg.z = i.normal.z > 0 ? e.max.z : e.min.z,
            i.distanceToPoint(Qg) < 0)
                return !1
        }
        return !0
    }
    containsPoint(e) {
        const t = this.planes;
        for (let r = 0; r < 6; r++)
            if (t[r].distanceToPoint(e) < 0)
                return !1;
        return !0
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
function n3() {
    let n = null
      , e = !1
      , t = null
      , r = null;
    function i(s, o) {
        t(s, o),
        r = n.requestAnimationFrame(i)
    }
    return {
        start: function() {
            e !== !0 && t !== null && (r = n.requestAnimationFrame(i),
            e = !0)
        },
        stop: function() {
            n.cancelAnimationFrame(r),
            e = !1
        },
        setAnimationLoop: function(s) {
            t = s
        },
        setContext: function(s) {
            n = s
        }
    }
}
function gF(n, e) {
    const t = e.isWebGL2
      , r = new WeakMap;
    function i(f, h) {
        const d = f.array
          , p = f.usage
          , m = n.createBuffer();
        n.bindBuffer(h, m),
        n.bufferData(h, d, p),
        f.onUploadCallback();
        let _;
        if (d instanceof Float32Array)
            _ = 5126;
        else if (d instanceof Uint16Array)
            if (f.isFloat16BufferAttribute)
                if (t)
                    _ = 5131;
                else
                    throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");
            else
                _ = 5123;
        else if (d instanceof Int16Array)
            _ = 5122;
        else if (d instanceof Uint32Array)
            _ = 5125;
        else if (d instanceof Int32Array)
            _ = 5124;
        else if (d instanceof Int8Array)
            _ = 5120;
        else if (d instanceof Uint8Array)
            _ = 5121;
        else if (d instanceof Uint8ClampedArray)
            _ = 5121;
        else
            throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + d);
        return {
            buffer: m,
            type: _,
            bytesPerElement: d.BYTES_PER_ELEMENT,
            version: f.version
        }
    }
    function s(f, h, d) {
        const p = h.array
          , m = h.updateRange;
        n.bindBuffer(d, f),
        m.count === -1 ? n.bufferSubData(d, 0, p) : (t ? n.bufferSubData(d, m.offset * p.BYTES_PER_ELEMENT, p, m.offset, m.count) : n.bufferSubData(d, m.offset * p.BYTES_PER_ELEMENT, p.subarray(m.offset, m.offset + m.count)),
        m.count = -1),
        h.onUploadCallback()
    }
    function o(f) {
        return f.isInterleavedBufferAttribute && (f = f.data),
        r.get(f)
    }
    function a(f) {
        f.isInterleavedBufferAttribute && (f = f.data);
        const h = r.get(f);
        h && (n.deleteBuffer(h.buffer),
        r.delete(f))
    }
    function l(f, h) {
        if (f.isGLBufferAttribute) {
            const p = r.get(f);
            (!p || p.version < f.version) && r.set(f, {
                buffer: f.buffer,
                type: f.type,
                bytesPerElement: f.elementSize,
                version: f.version
            });
            return
        }
        f.isInterleavedBufferAttribute && (f = f.data);
        const d = r.get(f);
        d === void 0 ? r.set(f, i(f, h)) : d.version < f.version && (s(d.buffer, f, h),
        d.version = f.version)
    }
    return {
        get: o,
        remove: a,
        update: l
    }
}
class Ph extends On {
    constructor(e=1, t=1, r=1, i=1) {
        super(),
        this.type = "PlaneGeometry",
        this.parameters = {
            width: e,
            height: t,
            widthSegments: r,
            heightSegments: i
        };
        const s = e / 2
          , o = t / 2
          , a = Math.floor(r)
          , l = Math.floor(i)
          , f = a + 1
          , h = l + 1
          , d = e / a
          , p = t / l
          , m = []
          , _ = []
          , y = []
          , x = [];
        for (let S = 0; S < h; S++) {
            const M = S * p - o;
            for (let w = 0; w < f; w++) {
                const T = w * d - s;
                _.push(T, -M, 0),
                y.push(0, 0, 1),
                x.push(w / a),
                x.push(1 - S / l)
            }
        }
        for (let S = 0; S < l; S++)
            for (let M = 0; M < a; M++) {
                const w = M + f * S
                  , T = M + f * (S + 1)
                  , P = M + 1 + f * (S + 1)
                  , I = M + 1 + f * S;
                m.push(w, T, I),
                m.push(T, P, I)
            }
        this.setIndex(m),
        this.setAttribute("position", new nn(_,3)),
        this.setAttribute("normal", new nn(y,3)),
        this.setAttribute("uv", new nn(x,2))
    }
    static fromJSON(e) {
        return new Ph(e.width,e.height,e.widthSegments,e.heightSegments)
    }
}
var vF = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vUv ).g;
#endif`
  , _F = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`
  , yF = `#ifdef USE_ALPHATEST
	if ( diffuseColor.a < alphaTest ) discard;
#endif`
  , xF = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`
  , wF = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`
  , SF = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`
  , MF = "vec3 transformed = vec3( position );"
  , AF = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`
  , CF = `vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
	float D = D_GGX( alpha, dotNH );
	return F * ( V * D );
}
#ifdef USE_IRIDESCENCE
	vec3 BRDF_GGX_Iridescence( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float iridescence, const in vec3 iridescenceFresnel, const in float roughness ) {
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = mix( F_Schlick( f0, f90, dotVH ), iridescenceFresnel, iridescence );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif`
  , EF = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			 return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float R21 = R12;
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`
  , bF = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vUv );
		vec2 dSTdy = dFdy( vUv );
		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = dFdx( surf_pos.xyz );
		vec3 vSigmaY = dFdy( surf_pos.xyz );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`
  , TF = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`
  , DF = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`
  , PF = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`
  , RF = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`
  , BF = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`
  , IF = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`
  , LF = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`
  , FF = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`
  , kF = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
struct GeometricContext {
	vec3 position;
	vec3 normal;
	vec3 viewDir;
#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal;
#endif
};
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float luminance( const in vec3 rgb ) {
	const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );
	return dot( weights, rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}`
  , OF = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_v0 0.339
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_v1 0.276
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_v4 0.046
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_v5 0.016
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_v6 0.0038
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`
  , NF = `vec3 transformedNormal = objectNormal;
#ifdef USE_INSTANCING
	mat3 m = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
	transformedNormal = m * transformedNormal;
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`
  , zF = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`
  , GF = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );
#endif`
  , UF = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`
  , HF = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`
  , VF = "gl_FragColor = linearToOutputTexel( gl_FragColor );"
  , WF = `vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 LinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`
  , XF = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`
  , JF = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`
  , jF = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`
  , YF = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`
  , KF = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`
  , qF = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`
  , QF = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`
  , ZF = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`
  , $F = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`
  , ek = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`
  , tk = `#ifdef USE_LIGHTMAP
	vec4 lightMapTexel = texture2D( lightMap, vUv2 );
	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
	reflectedLight.indirectDiffuse += lightMapIrradiance;
#endif`
  , nk = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`
  , rk = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`
  , ik = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`
  , sk = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
uniform vec3 lightProbe[ 9 ];
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( PHYSICALLY_CORRECT_LIGHTS )
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#else
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometry.position;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometry.position;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`
  , ok = `#if defined( USE_ENVMAP )
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
#endif`
  , ak = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`
  , lk = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`
  , uk = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`
  , ck = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`
  , fk = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULARINTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;
		#endif
		#ifdef USE_SPECULARCOLORMAP
			specularColorFactor *= texture2D( specularColorMap, vUv ).rgb;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEENCOLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEENROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;
	#endif
#endif`
  , dk = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
};
vec3 clearcoatSpecular = vec3( 0.0 );
vec3 sheenSpecular = vec3( 0.0 );
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometry.normal;
		vec3 viewDir = geometry.viewDir;
		vec3 position = geometry.position;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );
	#endif
	#ifdef USE_IRIDESCENCE
		reflectedLight.directSpecular += irradiance * BRDF_GGX_Iridescence( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness );
	#else
		reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );
	#endif
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`
  , hk = `
GeometricContext geometry;
geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
#ifdef USE_CLEARCOAT
	geometry.clearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometry.viewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometry, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`
  , pk = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometry.normal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	radiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`
  , mk = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );
#endif`
  , gk = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`
  , vk = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`
  , _k = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`
  , yk = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`
  , xk = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`
  , wk = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`
  , Sk = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`
  , Mk = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	uniform mat3 uvTransform;
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`
  , Ak = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vUv );
	metalnessFactor *= texelMetalness.b;
#endif`
  , Ck = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`
  , Ek = `#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`
  , bk = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`
  , Tk = `#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		uniform sampler2DArray morphTargetsTexture;
		uniform ivec2 morphTargetsTextureSize;
		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
			int y = texelIndex / morphTargetsTextureSize.x;
			int x = texelIndex - y * morphTargetsTextureSize.x;
			ivec3 morphUV = ivec3( x, y, morphTargetIndex );
			return texelFetch( morphTargetsTexture, morphUV, 0 );
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`
  , Dk = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`
  , Pk = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	#ifdef USE_TANGENT
		vec3 tangent = normalize( vTangent );
		vec3 bitangent = normalize( vBitangent );
		#ifdef DOUBLE_SIDED
			tangent = tangent * faceDirection;
			bitangent = bitangent * faceDirection;
		#endif
		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )
			mat3 vTBN = mat3( tangent, bitangent, normal );
		#endif
	#endif
#endif
vec3 geometryNormal = normal;`
  , Rk = `#ifdef OBJECTSPACE_NORMALMAP
	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( TANGENTSPACE_NORMALMAP )
	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	#ifdef USE_TANGENT
		normal = normalize( vTBN * mapN );
	#else
		normal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );
	#endif
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`
  , Bk = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`
  , Ik = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`
  , Lk = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`
  , Fk = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef OBJECTSPACE_NORMALMAP
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )
	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( vUv.st );
		vec2 st1 = dFdy( vUv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );
		return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );
	}
#endif`
  , kk = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = geometryNormal;
#endif`
  , Ok = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	#ifdef USE_TANGENT
		clearcoatNormal = normalize( vTBN * clearcoatMapN );
	#else
		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );
	#endif
#endif`
  , Nk = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif`
  , zk = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`
  , Gk = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha + 0.1;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`
  , Uk = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec2 packDepthToRG( in highp float v ) {
	return packDepthToRGBA( v ).yx;
}
float unpackRGToDepth( const in highp vec2 v ) {
	return unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {
	return linearClipZ * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * invClipZ - far );
}`
  , Hk = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`
  , Vk = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`
  , Wk = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`
  , Xk = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`
  , Jk = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vUv );
	roughnessFactor *= texelRoughness.g;
#endif`
  , jk = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`
  , Yk = `#if NUM_SPOT_LIGHT_COORDS > 0
  varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
  uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`
  , Kk = `#if NUM_SPOT_LIGHT_COORDS > 0
  uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
  varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`
  , qk = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`
  , Qk = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`
  , Zk = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`
  , $k = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	uniform int boneTextureSize;
	mat4 getBoneMatrix( const in float i ) {
		float j = i * 4.0;
		float x = mod( j, float( boneTextureSize ) );
		float y = floor( j / float( boneTextureSize ) );
		float dx = 1.0 / float( boneTextureSize );
		float dy = 1.0 / float( boneTextureSize );
		y = dy * ( y + 0.5 );
		vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
		vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
		vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
		vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
		mat4 bone = mat4( v1, v2, v3, v4 );
		return bone;
	}
#endif`
  , eO = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`
  , tO = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`
  , nO = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`
  , rO = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`
  , iO = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`
  , sO = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return toneMappingExposure * color;
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`
  , oO = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmission = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmission.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmission.rgb, material.transmission );
#endif`
  , aO = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		#ifdef texture2DLodEXT
			return texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );
		#else
			return texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );
		#endif
	}
	vec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return radiance;
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance * radiance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
		vec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		return vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );
	}
#endif`
  , lO = `#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )
	varying vec2 vUv;
#endif`
  , uO = `#ifdef USE_UV
	#ifdef UVS_VERTEX_ONLY
		vec2 vUv;
	#else
		varying vec2 vUv;
	#endif
	uniform mat3 uvTransform;
#endif`
  , cO = `#ifdef USE_UV
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
#endif`
  , fO = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	varying vec2 vUv2;
#endif`
  , dO = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	attribute vec2 uv2;
	varying vec2 vUv2;
	uniform mat3 uv2Transform;
#endif`
  , hO = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;
#endif`
  , pO = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
const mO = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`
  , gO = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`
  , vO = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`
  , _O = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`
  , yO = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`
  , xO = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`
  , wO = `#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`
  , SO = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`
  , MO = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`
  , AO = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`
  , CO = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`
  , EO = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`
  , bO = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`
  , TO = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`
  , DO = `#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`
  , PO = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
  , RO = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`
  , BO = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
  , IO = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`
  , LO = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
  , FO = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	vViewPosition = - mvPosition.xyz;
#endif
}`
  , kO = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`
  , OO = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`
  , NO = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
  , zO = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`
  , GO = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULARINTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
	#ifdef USE_SPECULARCOLORMAP
		uniform sampler2D specularColorMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEENCOLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEENROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <bsdfs>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;
	#endif
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
  , UO = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`
  , HO = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
  , VO = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`
  , WO = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`
  , XO = `#include <common>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`
  , JO = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`
  , jO = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`
  , YO = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`
  , Vn = {
    alphamap_fragment: vF,
    alphamap_pars_fragment: _F,
    alphatest_fragment: yF,
    alphatest_pars_fragment: xF,
    aomap_fragment: wF,
    aomap_pars_fragment: SF,
    begin_vertex: MF,
    beginnormal_vertex: AF,
    bsdfs: CF,
    iridescence_fragment: EF,
    bumpmap_pars_fragment: bF,
    clipping_planes_fragment: TF,
    clipping_planes_pars_fragment: DF,
    clipping_planes_pars_vertex: PF,
    clipping_planes_vertex: RF,
    color_fragment: BF,
    color_pars_fragment: IF,
    color_pars_vertex: LF,
    color_vertex: FF,
    common: kF,
    cube_uv_reflection_fragment: OF,
    defaultnormal_vertex: NF,
    displacementmap_pars_vertex: zF,
    displacementmap_vertex: GF,
    emissivemap_fragment: UF,
    emissivemap_pars_fragment: HF,
    encodings_fragment: VF,
    encodings_pars_fragment: WF,
    envmap_fragment: XF,
    envmap_common_pars_fragment: JF,
    envmap_pars_fragment: jF,
    envmap_pars_vertex: YF,
    envmap_physical_pars_fragment: ok,
    envmap_vertex: KF,
    fog_vertex: qF,
    fog_pars_vertex: QF,
    fog_fragment: ZF,
    fog_pars_fragment: $F,
    gradientmap_pars_fragment: ek,
    lightmap_fragment: tk,
    lightmap_pars_fragment: nk,
    lights_lambert_fragment: rk,
    lights_lambert_pars_fragment: ik,
    lights_pars_begin: sk,
    lights_toon_fragment: ak,
    lights_toon_pars_fragment: lk,
    lights_phong_fragment: uk,
    lights_phong_pars_fragment: ck,
    lights_physical_fragment: fk,
    lights_physical_pars_fragment: dk,
    lights_fragment_begin: hk,
    lights_fragment_maps: pk,
    lights_fragment_end: mk,
    logdepthbuf_fragment: gk,
    logdepthbuf_pars_fragment: vk,
    logdepthbuf_pars_vertex: _k,
    logdepthbuf_vertex: yk,
    map_fragment: xk,
    map_pars_fragment: wk,
    map_particle_fragment: Sk,
    map_particle_pars_fragment: Mk,
    metalnessmap_fragment: Ak,
    metalnessmap_pars_fragment: Ck,
    morphcolor_vertex: Ek,
    morphnormal_vertex: bk,
    morphtarget_pars_vertex: Tk,
    morphtarget_vertex: Dk,
    normal_fragment_begin: Pk,
    normal_fragment_maps: Rk,
    normal_pars_fragment: Bk,
    normal_pars_vertex: Ik,
    normal_vertex: Lk,
    normalmap_pars_fragment: Fk,
    clearcoat_normal_fragment_begin: kk,
    clearcoat_normal_fragment_maps: Ok,
    clearcoat_pars_fragment: Nk,
    iridescence_pars_fragment: zk,
    output_fragment: Gk,
    packing: Uk,
    premultiplied_alpha_fragment: Hk,
    project_vertex: Vk,
    dithering_fragment: Wk,
    dithering_pars_fragment: Xk,
    roughnessmap_fragment: Jk,
    roughnessmap_pars_fragment: jk,
    shadowmap_pars_fragment: Yk,
    shadowmap_pars_vertex: Kk,
    shadowmap_vertex: qk,
    shadowmask_pars_fragment: Qk,
    skinbase_vertex: Zk,
    skinning_pars_vertex: $k,
    skinning_vertex: eO,
    skinnormal_vertex: tO,
    specularmap_fragment: nO,
    specularmap_pars_fragment: rO,
    tonemapping_fragment: iO,
    tonemapping_pars_fragment: sO,
    transmission_fragment: oO,
    transmission_pars_fragment: aO,
    uv_pars_fragment: lO,
    uv_pars_vertex: uO,
    uv_vertex: cO,
    uv2_pars_fragment: fO,
    uv2_pars_vertex: dO,
    uv2_vertex: hO,
    worldpos_vertex: pO,
    background_vert: mO,
    background_frag: gO,
    backgroundCube_vert: vO,
    backgroundCube_frag: _O,
    cube_vert: yO,
    cube_frag: xO,
    depth_vert: wO,
    depth_frag: SO,
    distanceRGBA_vert: MO,
    distanceRGBA_frag: AO,
    equirect_vert: CO,
    equirect_frag: EO,
    linedashed_vert: bO,
    linedashed_frag: TO,
    meshbasic_vert: DO,
    meshbasic_frag: PO,
    meshlambert_vert: RO,
    meshlambert_frag: BO,
    meshmatcap_vert: IO,
    meshmatcap_frag: LO,
    meshnormal_vert: FO,
    meshnormal_frag: kO,
    meshphong_vert: OO,
    meshphong_frag: NO,
    meshphysical_vert: zO,
    meshphysical_frag: GO,
    meshtoon_vert: UO,
    meshtoon_frag: HO,
    points_vert: VO,
    points_frag: WO,
    shadow_vert: XO,
    shadow_frag: JO,
    sprite_vert: jO,
    sprite_frag: YO
}
  , Lt = {
    common: {
        diffuse: {
            value: new It(16777215)
        },
        opacity: {
            value: 1
        },
        map: {
            value: null
        },
        uvTransform: {
            value: new bo
        },
        uv2Transform: {
            value: new bo
        },
        alphaMap: {
            value: null
        },
        alphaTest: {
            value: 0
        }
    },
    specularmap: {
        specularMap: {
            value: null
        }
    },
    envmap: {
        envMap: {
            value: null
        },
        flipEnvMap: {
            value: -1
        },
        reflectivity: {
            value: 1
        },
        ior: {
            value: 1.5
        },
        refractionRatio: {
            value: .98
        }
    },
    aomap: {
        aoMap: {
            value: null
        },
        aoMapIntensity: {
            value: 1
        }
    },
    lightmap: {
        lightMap: {
            value: null
        },
        lightMapIntensity: {
            value: 1
        }
    },
    emissivemap: {
        emissiveMap: {
            value: null
        }
    },
    bumpmap: {
        bumpMap: {
            value: null
        },
        bumpScale: {
            value: 1
        }
    },
    normalmap: {
        normalMap: {
            value: null
        },
        normalScale: {
            value: new it(1,1)
        }
    },
    displacementmap: {
        displacementMap: {
            value: null
        },
        displacementScale: {
            value: 1
        },
        displacementBias: {
            value: 0
        }
    },
    roughnessmap: {
        roughnessMap: {
            value: null
        }
    },
    metalnessmap: {
        metalnessMap: {
            value: null
        }
    },
    gradientmap: {
        gradientMap: {
            value: null
        }
    },
    fog: {
        fogDensity: {
            value: 25e-5
        },
        fogNear: {
            value: 1
        },
        fogFar: {
            value: 2e3
        },
        fogColor: {
            value: new It(16777215)
        }
    },
    lights: {
        ambientLightColor: {
            value: []
        },
        lightProbe: {
            value: []
        },
        directionalLights: {
            value: [],
            properties: {
                direction: {},
                color: {}
            }
        },
        directionalLightShadows: {
            value: [],
            properties: {
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {}
            }
        },
        directionalShadowMap: {
            value: []
        },
        directionalShadowMatrix: {
            value: []
        },
        spotLights: {
            value: [],
            properties: {
                color: {},
                position: {},
                direction: {},
                distance: {},
                coneCos: {},
                penumbraCos: {},
                decay: {}
            }
        },
        spotLightShadows: {
            value: [],
            properties: {
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {}
            }
        },
        spotLightMap: {
            value: []
        },
        spotShadowMap: {
            value: []
        },
        spotLightMatrix: {
            value: []
        },
        pointLights: {
            value: [],
            properties: {
                color: {},
                position: {},
                decay: {},
                distance: {}
            }
        },
        pointLightShadows: {
            value: [],
            properties: {
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {},
                shadowCameraNear: {},
                shadowCameraFar: {}
            }
        },
        pointShadowMap: {
            value: []
        },
        pointShadowMatrix: {
            value: []
        },
        hemisphereLights: {
            value: [],
            properties: {
                direction: {},
                skyColor: {},
                groundColor: {}
            }
        },
        rectAreaLights: {
            value: [],
            properties: {
                color: {},
                position: {},
                width: {},
                height: {}
            }
        },
        ltc_1: {
            value: null
        },
        ltc_2: {
            value: null
        }
    },
    points: {
        diffuse: {
            value: new It(16777215)
        },
        opacity: {
            value: 1
        },
        size: {
            value: 1
        },
        scale: {
            value: 1
        },
        map: {
            value: null
        },
        alphaMap: {
            value: null
        },
        alphaTest: {
            value: 0
        },
        uvTransform: {
            value: new bo
        }
    },
    sprite: {
        diffuse: {
            value: new It(16777215)
        },
        opacity: {
            value: 1
        },
        center: {
            value: new it(.5,.5)
        },
        rotation: {
            value: 0
        },
        map: {
            value: null
        },
        alphaMap: {
            value: null
        },
        alphaTest: {
            value: 0
        },
        uvTransform: {
            value: new bo
        }
    }
}
  , yl = {
    basic: {
        uniforms: wo([Lt.common, Lt.specularmap, Lt.envmap, Lt.aomap, Lt.lightmap, Lt.fog]),
        vertexShader: Vn.meshbasic_vert,
        fragmentShader: Vn.meshbasic_frag
    },
    lambert: {
        uniforms: wo([Lt.common, Lt.specularmap, Lt.envmap, Lt.aomap, Lt.lightmap, Lt.emissivemap, Lt.bumpmap, Lt.normalmap, Lt.displacementmap, Lt.fog, Lt.lights, {
            emissive: {
                value: new It(0)
            }
        }]),
        vertexShader: Vn.meshlambert_vert,
        fragmentShader: Vn.meshlambert_frag
    },
    phong: {
        uniforms: wo([Lt.common, Lt.specularmap, Lt.envmap, Lt.aomap, Lt.lightmap, Lt.emissivemap, Lt.bumpmap, Lt.normalmap, Lt.displacementmap, Lt.fog, Lt.lights, {
            emissive: {
                value: new It(0)
            },
            specular: {
                value: new It(1118481)
            },
            shininess: {
                value: 30
            }
        }]),
        vertexShader: Vn.meshphong_vert,
        fragmentShader: Vn.meshphong_frag
    },
    standard: {
        uniforms: wo([Lt.common, Lt.envmap, Lt.aomap, Lt.lightmap, Lt.emissivemap, Lt.bumpmap, Lt.normalmap, Lt.displacementmap, Lt.roughnessmap, Lt.metalnessmap, Lt.fog, Lt.lights, {
            emissive: {
                value: new It(0)
            },
            roughness: {
                value: 1
            },
            metalness: {
                value: 0
            },
            envMapIntensity: {
                value: 1
            }
        }]),
        vertexShader: Vn.meshphysical_vert,
        fragmentShader: Vn.meshphysical_frag
    },
    toon: {
        uniforms: wo([Lt.common, Lt.aomap, Lt.lightmap, Lt.emissivemap, Lt.bumpmap, Lt.normalmap, Lt.displacementmap, Lt.gradientmap, Lt.fog, Lt.lights, {
            emissive: {
                value: new It(0)
            }
        }]),
        vertexShader: Vn.meshtoon_vert,
        fragmentShader: Vn.meshtoon_frag
    },
    matcap: {
        uniforms: wo([Lt.common, Lt.bumpmap, Lt.normalmap, Lt.displacementmap, Lt.fog, {
            matcap: {
                value: null
            }
        }]),
        vertexShader: Vn.meshmatcap_vert,
        fragmentShader: Vn.meshmatcap_frag
    },
    points: {
        uniforms: wo([Lt.points, Lt.fog]),
        vertexShader: Vn.points_vert,
        fragmentShader: Vn.points_frag
    },
    dashed: {
        uniforms: wo([Lt.common, Lt.fog, {
            scale: {
                value: 1
            },
            dashSize: {
                value: 1
            },
            totalSize: {
                value: 2
            }
        }]),
        vertexShader: Vn.linedashed_vert,
        fragmentShader: Vn.linedashed_frag
    },
    depth: {
        uniforms: wo([Lt.common, Lt.displacementmap]),
        vertexShader: Vn.depth_vert,
        fragmentShader: Vn.depth_frag
    },
    normal: {
        uniforms: wo([Lt.common, Lt.bumpmap, Lt.normalmap, Lt.displacementmap, {
            opacity: {
                value: 1
            }
        }]),
        vertexShader: Vn.meshnormal_vert,
        fragmentShader: Vn.meshnormal_frag
    },
    sprite: {
        uniforms: wo([Lt.sprite, Lt.fog]),
        vertexShader: Vn.sprite_vert,
        fragmentShader: Vn.sprite_frag
    },
    background: {
        uniforms: {
            uvTransform: {
                value: new bo
            },
            t2D: {
                value: null
            },
            backgroundIntensity: {
                value: 1
            }
        },
        vertexShader: Vn.background_vert,
        fragmentShader: Vn.background_frag
    },
    backgroundCube: {
        uniforms: {
            envMap: {
                value: null
            },
            flipEnvMap: {
                value: -1
            },
            backgroundBlurriness: {
                value: 0
            },
            backgroundIntensity: {
                value: 1
            }
        },
        vertexShader: Vn.backgroundCube_vert,
        fragmentShader: Vn.backgroundCube_frag
    },
    cube: {
        uniforms: {
            tCube: {
                value: null
            },
            tFlip: {
                value: -1
            },
            opacity: {
                value: 1
            }
        },
        vertexShader: Vn.cube_vert,
        fragmentShader: Vn.cube_frag
    },
    equirect: {
        uniforms: {
            tEquirect: {
                value: null
            }
        },
        vertexShader: Vn.equirect_vert,
        fragmentShader: Vn.equirect_frag
    },
    distanceRGBA: {
        uniforms: wo([Lt.common, Lt.displacementmap, {
            referencePosition: {
                value: new $
            },
            nearDistance: {
                value: 1
            },
            farDistance: {
                value: 1e3
            }
        }]),
        vertexShader: Vn.distanceRGBA_vert,
        fragmentShader: Vn.distanceRGBA_frag
    },
    shadow: {
        uniforms: wo([Lt.lights, Lt.fog, {
            color: {
                value: new It(0)
            },
            opacity: {
                value: 1
            }
        }]),
        vertexShader: Vn.shadow_vert,
        fragmentShader: Vn.shadow_frag
    }
};
yl.physical = {
    uniforms: wo([yl.standard.uniforms, {
        clearcoat: {
            value: 0
        },
        clearcoatMap: {
            value: null
        },
        clearcoatRoughness: {
            value: 0
        },
        clearcoatRoughnessMap: {
            value: null
        },
        clearcoatNormalScale: {
            value: new it(1,1)
        },
        clearcoatNormalMap: {
            value: null
        },
        iridescence: {
            value: 0
        },
        iridescenceMap: {
            value: null
        },
        iridescenceIOR: {
            value: 1.3
        },
        iridescenceThicknessMinimum: {
            value: 100
        },
        iridescenceThicknessMaximum: {
            value: 400
        },
        iridescenceThicknessMap: {
            value: null
        },
        sheen: {
            value: 0
        },
        sheenColor: {
            value: new It(0)
        },
        sheenColorMap: {
            value: null
        },
        sheenRoughness: {
            value: 1
        },
        sheenRoughnessMap: {
            value: null
        },
        transmission: {
            value: 0
        },
        transmissionMap: {
            value: null
        },
        transmissionSamplerSize: {
            value: new it
        },
        transmissionSamplerMap: {
            value: null
        },
        thickness: {
            value: 0
        },
        thicknessMap: {
            value: null
        },
        attenuationDistance: {
            value: 0
        },
        attenuationColor: {
            value: new It(0)
        },
        specularIntensity: {
            value: 1
        },
        specularIntensityMap: {
            value: null
        },
        specularColor: {
            value: new It(1,1,1)
        },
        specularColorMap: {
            value: null
        }
    }]),
    vertexShader: Vn.meshphysical_vert,
    fragmentShader: Vn.meshphysical_frag
};
const Zg = {
    r: 0,
    b: 0,
    g: 0
};
function KO(n, e, t, r, i, s, o) {
    const a = new It(0);
    let l = s === !0 ? 0 : 1, f, h, d = null, p = 0, m = null;
    function _(x, S) {
        let M = !1
          , w = S.isScene === !0 ? S.background : null;
        w && w.isTexture && (w = (S.backgroundBlurriness > 0 ? t : e).get(w));
        const T = n.xr
          , P = T.getSession && T.getSession();
        P && P.environmentBlendMode === "additive" && (w = null),
        w === null ? y(a, l) : w && w.isColor && (y(w, 1),
        M = !0),
        (n.autoClear || M) && n.clear(n.autoClearColor, n.autoClearDepth, n.autoClearStencil),
        w && (w.isCubeTexture || w.mapping === Dh) ? (h === void 0 && (h = new vs(new Nc(1,1,1),new el({
            name: "BackgroundCubeMaterial",
            uniforms: yh(yl.backgroundCube.uniforms),
            vertexShader: yl.backgroundCube.vertexShader,
            fragmentShader: yl.backgroundCube.fragmentShader,
            side: Do,
            depthTest: !1,
            depthWrite: !1,
            fog: !1
        })),
        h.geometry.deleteAttribute("normal"),
        h.geometry.deleteAttribute("uv"),
        h.onBeforeRender = function(I, k, R) {
            this.matrixWorld.copyPosition(R.matrixWorld)
        }
        ,
        Object.defineProperty(h.material, "envMap", {
            get: function() {
                return this.uniforms.envMap.value
            }
        }),
        i.update(h)),
        h.material.uniforms.envMap.value = w,
        h.material.uniforms.flipEnvMap.value = w.isCubeTexture && w.isRenderTargetTexture === !1 ? -1 : 1,
        h.material.uniforms.backgroundBlurriness.value = S.backgroundBlurriness,
        h.material.uniforms.backgroundIntensity.value = S.backgroundIntensity,
        h.material.toneMapped = w.encoding !== nr,
        (d !== w || p !== w.version || m !== n.toneMapping) && (h.material.needsUpdate = !0,
        d = w,
        p = w.version,
        m = n.toneMapping),
        h.layers.enableAll(),
        x.unshift(h, h.geometry, h.material, 0, 0, null)) : w && w.isTexture && (f === void 0 && (f = new vs(new Ph(2,2),new el({
            name: "BackgroundMaterial",
            uniforms: yh(yl.background.uniforms),
            vertexShader: yl.background.vertexShader,
            fragmentShader: yl.background.fragmentShader,
            side: El,
            depthTest: !1,
            depthWrite: !1,
            fog: !1
        })),
        f.geometry.deleteAttribute("normal"),
        Object.defineProperty(f.material, "map", {
            get: function() {
                return this.uniforms.t2D.value
            }
        }),
        i.update(f)),
        f.material.uniforms.t2D.value = w,
        f.material.uniforms.backgroundIntensity.value = S.backgroundIntensity,
        f.material.toneMapped = w.encoding !== nr,
        w.matrixAutoUpdate === !0 && w.updateMatrix(),
        f.material.uniforms.uvTransform.value.copy(w.matrix),
        (d !== w || p !== w.version || m !== n.toneMapping) && (f.material.needsUpdate = !0,
        d = w,
        p = w.version,
        m = n.toneMapping),
        f.layers.enableAll(),
        x.unshift(f, f.geometry, f.material, 0, 0, null))
    }
    function y(x, S) {
        x.getRGB(Zg, e3(n)),
        r.buffers.color.setClear(Zg.r, Zg.g, Zg.b, S, o)
    }
    return {
        getClearColor: function() {
            return a
        },
        setClearColor: function(x, S=1) {
            a.set(x),
            l = S,
            y(a, l)
        },
        getClearAlpha: function() {
            return l
        },
        setClearAlpha: function(x) {
            l = x,
            y(a, l)
        },
        render: _
    }
}
function qO(n, e, t, r) {
    const i = n.getParameter(34921)
      , s = r.isWebGL2 ? null : e.get("OES_vertex_array_object")
      , o = r.isWebGL2 || s !== null
      , a = {}
      , l = x(null);
    let f = l
      , h = !1;
    function d(re, pe, ce, xe, G) {
        let z = !1;
        if (o) {
            const U = y(xe, ce, pe);
            f !== U && (f = U,
            m(f.object)),
            z = S(re, xe, ce, G),
            z && M(re, xe, ce, G)
        } else {
            const U = pe.wireframe === !0;
            (f.geometry !== xe.id || f.program !== ce.id || f.wireframe !== U) && (f.geometry = xe.id,
            f.program = ce.id,
            f.wireframe = U,
            z = !0)
        }
        G !== null && t.update(G, 34963),
        (z || h) && (h = !1,
        R(re, pe, ce, xe),
        G !== null && n.bindBuffer(34963, t.get(G).buffer))
    }
    function p() {
        return r.isWebGL2 ? n.createVertexArray() : s.createVertexArrayOES()
    }
    function m(re) {
        return r.isWebGL2 ? n.bindVertexArray(re) : s.bindVertexArrayOES(re)
    }
    function _(re) {
        return r.isWebGL2 ? n.deleteVertexArray(re) : s.deleteVertexArrayOES(re)
    }
    function y(re, pe, ce) {
        const xe = ce.wireframe === !0;
        let G = a[re.id];
        G === void 0 && (G = {},
        a[re.id] = G);
        let z = G[pe.id];
        z === void 0 && (z = {},
        G[pe.id] = z);
        let U = z[xe];
        return U === void 0 && (U = x(p()),
        z[xe] = U),
        U
    }
    function x(re) {
        const pe = []
          , ce = []
          , xe = [];
        for (let G = 0; G < i; G++)
            pe[G] = 0,
            ce[G] = 0,
            xe[G] = 0;
        return {
            geometry: null,
            program: null,
            wireframe: !1,
            newAttributes: pe,
            enabledAttributes: ce,
            attributeDivisors: xe,
            object: re,
            attributes: {},
            index: null
        }
    }
    function S(re, pe, ce, xe) {
        const G = f.attributes
          , z = pe.attributes;
        let U = 0;
        const fe = ce.getAttributes();
        for (const oe in fe)
            if (fe[oe].location >= 0) {
                const Ue = G[oe];
                let je = z[oe];
                if (je === void 0 && (oe === "instanceMatrix" && re.instanceMatrix && (je = re.instanceMatrix),
                oe === "instanceColor" && re.instanceColor && (je = re.instanceColor)),
                Ue === void 0 || Ue.attribute !== je || je && Ue.data !== je.data)
                    return !0;
                U++
            }
        return f.attributesNum !== U || f.index !== xe
    }
    function M(re, pe, ce, xe) {
        const G = {}
          , z = pe.attributes;
        let U = 0;
        const fe = ce.getAttributes();
        for (const oe in fe)
            if (fe[oe].location >= 0) {
                let Ue = z[oe];
                Ue === void 0 && (oe === "instanceMatrix" && re.instanceMatrix && (Ue = re.instanceMatrix),
                oe === "instanceColor" && re.instanceColor && (Ue = re.instanceColor));
                const je = {};
                je.attribute = Ue,
                Ue && Ue.data && (je.data = Ue.data),
                G[oe] = je,
                U++
            }
        f.attributes = G,
        f.attributesNum = U,
        f.index = xe
    }
    function w() {
        const re = f.newAttributes;
        for (let pe = 0, ce = re.length; pe < ce; pe++)
            re[pe] = 0
    }
    function T(re) {
        P(re, 0)
    }
    function P(re, pe) {
        const ce = f.newAttributes
          , xe = f.enabledAttributes
          , G = f.attributeDivisors;
        ce[re] = 1,
        xe[re] === 0 && (n.enableVertexAttribArray(re),
        xe[re] = 1),
        G[re] !== pe && ((r.isWebGL2 ? n : e.get("ANGLE_instanced_arrays"))[r.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](re, pe),
        G[re] = pe)
    }
    function I() {
        const re = f.newAttributes
          , pe = f.enabledAttributes;
        for (let ce = 0, xe = pe.length; ce < xe; ce++)
            pe[ce] !== re[ce] && (n.disableVertexAttribArray(ce),
            pe[ce] = 0)
    }
    function k(re, pe, ce, xe, G, z) {
        r.isWebGL2 === !0 && (ce === 5124 || ce === 5125) ? n.vertexAttribIPointer(re, pe, ce, G, z) : n.vertexAttribPointer(re, pe, ce, xe, G, z)
    }
    function R(re, pe, ce, xe) {
        if (r.isWebGL2 === !1 && (re.isInstancedMesh || xe.isInstancedBufferGeometry) && e.get("ANGLE_instanced_arrays") === null)
            return;
        w();
        const G = xe.attributes
          , z = ce.getAttributes()
          , U = pe.defaultAttributeValues;
        for (const fe in z) {
            const oe = z[fe];
            if (oe.location >= 0) {
                let Ae = G[fe];
                if (Ae === void 0 && (fe === "instanceMatrix" && re.instanceMatrix && (Ae = re.instanceMatrix),
                fe === "instanceColor" && re.instanceColor && (Ae = re.instanceColor)),
                Ae !== void 0) {
                    const Ue = Ae.normalized
                      , je = Ae.itemSize
                      , de = t.get(Ae);
                    if (de === void 0)
                        continue;
                    const qe = de.buffer
                      , Ne = de.type
                      , Tt = de.bytesPerElement;
                    if (Ae.isInterleavedBufferAttribute) {
                        const He = Ae.data
                          , gt = He.stride
                          , be = Ae.offset;
                        if (He.isInstancedInterleavedBuffer) {
                            for (let Ee = 0; Ee < oe.locationSize; Ee++)
                                P(oe.location + Ee, He.meshPerAttribute);
                            re.isInstancedMesh !== !0 && xe._maxInstanceCount === void 0 && (xe._maxInstanceCount = He.meshPerAttribute * He.count)
                        } else
                            for (let Ee = 0; Ee < oe.locationSize; Ee++)
                                T(oe.location + Ee);
                        n.bindBuffer(34962, qe);
                        for (let Ee = 0; Ee < oe.locationSize; Ee++)
                            k(oe.location + Ee, je / oe.locationSize, Ne, Ue, gt * Tt, (be + je / oe.locationSize * Ee) * Tt)
                    } else {
                        if (Ae.isInstancedBufferAttribute) {
                            for (let He = 0; He < oe.locationSize; He++)
                                P(oe.location + He, Ae.meshPerAttribute);
                            re.isInstancedMesh !== !0 && xe._maxInstanceCount === void 0 && (xe._maxInstanceCount = Ae.meshPerAttribute * Ae.count)
                        } else
                            for (let He = 0; He < oe.locationSize; He++)
                                T(oe.location + He);
                        n.bindBuffer(34962, qe);
                        for (let He = 0; He < oe.locationSize; He++)
                            k(oe.location + He, je / oe.locationSize, Ne, Ue, je * Tt, je / oe.locationSize * He * Tt)
                    }
                } else if (U !== void 0) {
                    const Ue = U[fe];
                    if (Ue !== void 0)
                        switch (Ue.length) {
                        case 2:
                            n.vertexAttrib2fv(oe.location, Ue);
                            break;
                        case 3:
                            n.vertexAttrib3fv(oe.location, Ue);
                            break;
                        case 4:
                            n.vertexAttrib4fv(oe.location, Ue);
                            break;
                        default:
                            n.vertexAttrib1fv(oe.location, Ue)
                        }
                }
            }
        }
        I()
    }
    function O() {
        te();
        for (const re in a) {
            const pe = a[re];
            for (const ce in pe) {
                const xe = pe[ce];
                for (const G in xe)
                    _(xe[G].object),
                    delete xe[G];
                delete pe[ce]
            }
            delete a[re]
        }
    }
    function H(re) {
        if (a[re.id] === void 0)
            return;
        const pe = a[re.id];
        for (const ce in pe) {
            const xe = pe[ce];
            for (const G in xe)
                _(xe[G].object),
                delete xe[G];
            delete pe[ce]
        }
        delete a[re.id]
    }
    function W(re) {
        for (const pe in a) {
            const ce = a[pe];
            if (ce[re.id] === void 0)
                continue;
            const xe = ce[re.id];
            for (const G in xe)
                _(xe[G].object),
                delete xe[G];
            delete ce[re.id]
        }
    }
    function te() {
        ne(),
        h = !0,
        f !== l && (f = l,
        m(f.object))
    }
    function ne() {
        l.geometry = null,
        l.program = null,
        l.wireframe = !1
    }
    return {
        setup: d,
        reset: te,
        resetDefaultState: ne,
        dispose: O,
        releaseStatesOfGeometry: H,
        releaseStatesOfProgram: W,
        initAttributes: w,
        enableAttribute: T,
        disableUnusedAttributes: I
    }
}
function QO(n, e, t, r) {
    const i = r.isWebGL2;
    let s;
    function o(f) {
        s = f
    }
    function a(f, h) {
        n.drawArrays(s, f, h),
        t.update(h, s, 1)
    }
    function l(f, h, d) {
        if (d === 0)
            return;
        let p, m;
        if (i)
            p = n,
            m = "drawArraysInstanced";
        else if (p = e.get("ANGLE_instanced_arrays"),
        m = "drawArraysInstancedANGLE",
        p === null) {
            console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
            return
        }
        p[m](s, f, h, d),
        t.update(h, s, d)
    }
    this.setMode = o,
    this.render = a,
    this.renderInstances = l
}
function ZO(n, e, t) {
    let r;
    function i() {
        if (r !== void 0)
            return r;
        if (e.has("EXT_texture_filter_anisotropic") === !0) {
            const k = e.get("EXT_texture_filter_anisotropic");
            r = n.getParameter(k.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
        } else
            r = 0;
        return r
    }
    function s(k) {
        if (k === "highp") {
            if (n.getShaderPrecisionFormat(35633, 36338).precision > 0 && n.getShaderPrecisionFormat(35632, 36338).precision > 0)
                return "highp";
            k = "mediump"
        }
        return k === "mediump" && n.getShaderPrecisionFormat(35633, 36337).precision > 0 && n.getShaderPrecisionFormat(35632, 36337).precision > 0 ? "mediump" : "lowp"
    }
    const o = typeof WebGL2RenderingContext < "u" && n instanceof WebGL2RenderingContext;
    let a = t.precision !== void 0 ? t.precision : "highp";
    const l = s(a);
    l !== a && (console.warn("THREE.WebGLRenderer:", a, "not supported, using", l, "instead."),
    a = l);
    const f = o || e.has("WEBGL_draw_buffers")
      , h = t.logarithmicDepthBuffer === !0
      , d = n.getParameter(34930)
      , p = n.getParameter(35660)
      , m = n.getParameter(3379)
      , _ = n.getParameter(34076)
      , y = n.getParameter(34921)
      , x = n.getParameter(36347)
      , S = n.getParameter(36348)
      , M = n.getParameter(36349)
      , w = p > 0
      , T = o || e.has("OES_texture_float")
      , P = w && T
      , I = o ? n.getParameter(36183) : 0;
    return {
        isWebGL2: o,
        drawBuffers: f,
        getMaxAnisotropy: i,
        getMaxPrecision: s,
        precision: a,
        logarithmicDepthBuffer: h,
        maxTextures: d,
        maxVertexTextures: p,
        maxTextureSize: m,
        maxCubemapSize: _,
        maxAttributes: y,
        maxVertexUniforms: x,
        maxVaryings: S,
        maxFragmentUniforms: M,
        vertexTextures: w,
        floatFragmentTextures: T,
        floatVertexTextures: P,
        maxSamples: I
    }
}
function $O(n) {
    const e = this;
    let t = null
      , r = 0
      , i = !1
      , s = !1;
    const o = new rc
      , a = new bo
      , l = {
        value: null,
        needsUpdate: !1
    };
    this.uniform = l,
    this.numPlanes = 0,
    this.numIntersection = 0,
    this.init = function(d, p) {
        const m = d.length !== 0 || p || r !== 0 || i;
        return i = p,
        r = d.length,
        m
    }
    ,
    this.beginShadows = function() {
        s = !0,
        h(null)
    }
    ,
    this.endShadows = function() {
        s = !1
    }
    ,
    this.setGlobalState = function(d, p) {
        t = h(d, p, 0)
    }
    ,
    this.setState = function(d, p, m) {
        const _ = d.clippingPlanes
          , y = d.clipIntersection
          , x = d.clipShadows
          , S = n.get(d);
        if (!i || _ === null || _.length === 0 || s && !x)
            s ? h(null) : f();
        else {
            const M = s ? 0 : r
              , w = M * 4;
            let T = S.clippingState || null;
            l.value = T,
            T = h(_, p, w, m);
            for (let P = 0; P !== w; ++P)
                T[P] = t[P];
            S.clippingState = T,
            this.numIntersection = y ? this.numPlanes : 0,
            this.numPlanes += M
        }
    }
    ;
    function f() {
        l.value !== t && (l.value = t,
        l.needsUpdate = r > 0),
        e.numPlanes = r,
        e.numIntersection = 0
    }
    function h(d, p, m, _) {
        const y = d !== null ? d.length : 0;
        let x = null;
        if (y !== 0) {
            if (x = l.value,
            _ !== !0 || x === null) {
                const S = m + y * 4
                  , M = p.matrixWorldInverse;
                a.getNormalMatrix(M),
                (x === null || x.length < S) && (x = new Float32Array(S));
                for (let w = 0, T = m; w !== y; ++w,
                T += 4)
                    o.copy(d[w]).applyMatrix4(M, a),
                    o.normal.toArray(x, T),
                    x[T + 3] = o.constant
            }
            l.value = x,
            l.needsUpdate = !0
        }
        return e.numPlanes = y,
        e.numIntersection = 0,
        x
    }
}
function eN(n) {
    let e = new WeakMap;
    function t(o, a) {
        return a === mh ? o.mapping = Tu : a === hm && (o.mapping = Ec),
        o
    }
    function r(o) {
        if (o && o.isTexture && o.isRenderTargetTexture === !1) {
            const a = o.mapping;
            if (a === mh || a === hm)
                if (e.has(o)) {
                    const l = e.get(o).texture;
                    return t(l, o.mapping)
                } else {
                    const l = o.image;
                    if (l && l.height > 0) {
                        const f = new XS(l.height / 2);
                        return f.fromEquirectangularTexture(n, o),
                        e.set(o, f),
                        o.addEventListener("dispose", i),
                        t(f.texture, o.mapping)
                    } else
                        return null
                }
        }
        return o
    }
    function i(o) {
        const a = o.target;
        a.removeEventListener("dispose", i);
        const l = e.get(a);
        l !== void 0 && (e.delete(a),
        l.dispose())
    }
    function s() {
        e = new WeakMap
    }
    return {
        get: r,
        dispose: s
    }
}
class Mu extends Om {
    constructor(e=-1, t=1, r=1, i=-1, s=.1, o=2e3) {
        super(),
        this.isOrthographicCamera = !0,
        this.type = "OrthographicCamera",
        this.zoom = 1,
        this.view = null,
        this.left = e,
        this.right = t,
        this.top = r,
        this.bottom = i,
        this.near = s,
        this.far = o,
        this.updateProjectionMatrix()
    }
    copy(e, t) {
        return super.copy(e, t),
        this.left = e.left,
        this.right = e.right,
        this.top = e.top,
        this.bottom = e.bottom,
        this.near = e.near,
        this.far = e.far,
        this.zoom = e.zoom,
        this.view = e.view === null ? null : Object.assign({}, e.view),
        this
    }
    setViewOffset(e, t, r, i, s, o) {
        this.view === null && (this.view = {
            enabled: !0,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1
        }),
        this.view.enabled = !0,
        this.view.fullWidth = e,
        this.view.fullHeight = t,
        this.view.offsetX = r,
        this.view.offsetY = i,
        this.view.width = s,
        this.view.height = o,
        this.updateProjectionMatrix()
    }
    clearViewOffset() {
        this.view !== null && (this.view.enabled = !1),
        this.updateProjectionMatrix()
    }
    updateProjectionMatrix() {
        const e = (this.right - this.left) / (2 * this.zoom)
          , t = (this.top - this.bottom) / (2 * this.zoom)
          , r = (this.right + this.left) / 2
          , i = (this.top + this.bottom) / 2;
        let s = r - e
          , o = r + e
          , a = i + t
          , l = i - t;
        if (this.view !== null && this.view.enabled) {
            const f = (this.right - this.left) / this.view.fullWidth / this.zoom
              , h = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
            s += f * this.view.offsetX,
            o = s + f * this.view.width,
            a -= h * this.view.offsetY,
            l = a - h * this.view.height
        }
        this.projectionMatrix.makeOrthographic(s, o, a, l, this.near, this.far),
        this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return t.object.zoom = this.zoom,
        t.object.left = this.left,
        t.object.right = this.right,
        t.object.top = this.top,
        t.object.bottom = this.bottom,
        t.object.near = this.near,
        t.object.far = this.far,
        this.view !== null && (t.object.view = Object.assign({}, this.view)),
        t
    }
}
const Xd = 4
  , IC = [.125, .215, .35, .446, .526, .582]
  , mf = 20
  , tx = new Mu
  , LC = new It;
let nx = null;
const cf = (1 + Math.sqrt(5)) / 2
  , wd = 1 / cf
  , FC = [new $(1,1,1), new $(-1,1,1), new $(1,1,-1), new $(-1,1,-1), new $(0,cf,wd), new $(0,cf,-wd), new $(wd,0,cf), new $(-wd,0,cf), new $(cf,wd,0), new $(-cf,wd,0)];
class fw {
    constructor(e) {
        this._renderer = e,
        this._pingPongRenderTarget = null,
        this._lodMax = 0,
        this._cubeSize = 0,
        this._lodPlanes = [],
        this._sizeLods = [],
        this._sigmas = [],
        this._blurMaterial = null,
        this._cubemapMaterial = null,
        this._equirectMaterial = null,
        this._compileMaterial(this._blurMaterial)
    }
    fromScene(e, t=0, r=.1, i=100) {
        nx = this._renderer.getRenderTarget(),
        this._setSize(256);
        const s = this._allocateTargets();
        return s.depthBuffer = !0,
        this._sceneToCubeUV(e, r, i, s),
        t > 0 && this._blur(s, 0, 0, t),
        this._applyPMREM(s),
        this._cleanup(s),
        s
    }
    fromEquirectangular(e, t=null) {
        return this._fromTexture(e, t)
    }
    fromCubemap(e, t=null) {
        return this._fromTexture(e, t)
    }
    compileCubemapShader() {
        this._cubemapMaterial === null && (this._cubemapMaterial = NC(),
        this._compileMaterial(this._cubemapMaterial))
    }
    compileEquirectangularShader() {
        this._equirectMaterial === null && (this._equirectMaterial = OC(),
        this._compileMaterial(this._equirectMaterial))
    }
    dispose() {
        this._dispose(),
        this._cubemapMaterial !== null && this._cubemapMaterial.dispose(),
        this._equirectMaterial !== null && this._equirectMaterial.dispose()
    }
    _setSize(e) {
        this._lodMax = Math.floor(Math.log2(e)),
        this._cubeSize = Math.pow(2, this._lodMax)
    }
    _dispose() {
        this._blurMaterial !== null && this._blurMaterial.dispose(),
        this._pingPongRenderTarget !== null && this._pingPongRenderTarget.dispose();
        for (let e = 0; e < this._lodPlanes.length; e++)
            this._lodPlanes[e].dispose()
    }
    _cleanup(e) {
        this._renderer.setRenderTarget(nx),
        e.scissorTest = !1,
        $g(e, 0, 0, e.width, e.height)
    }
    _fromTexture(e, t) {
        e.mapping === Tu || e.mapping === Ec ? this._setSize(e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width) : this._setSize(e.image.width / 4),
        nx = this._renderer.getRenderTarget();
        const r = t || this._allocateTargets();
        return this._textureToCubeUV(e, r),
        this._applyPMREM(r),
        this._cleanup(r),
        r
    }
    _allocateTargets() {
        const e = 3 * Math.max(this._cubeSize, 112)
          , t = 4 * this._cubeSize
          , r = {
            magFilter: si,
            minFilter: si,
            generateMipmaps: !1,
            type: ja,
            format: ga,
            encoding: bl,
            depthBuffer: !1
        }
          , i = kC(e, t, r);
        if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== e || this._pingPongRenderTarget.height !== t) {
            this._pingPongRenderTarget !== null && this._dispose(),
            this._pingPongRenderTarget = kC(e, t, r);
            const {_lodMax: s} = this;
            ({sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas} = tN(s)),
            this._blurMaterial = nN(s, e, t)
        }
        return i
    }
    _compileMaterial(e) {
        const t = new vs(this._lodPlanes[0],e);
        this._renderer.compile(t, tx)
    }
    _sceneToCubeUV(e, t, r, i) {
        const a = new gi(90,1,t,r)
          , l = [1, -1, 1, 1, 1, 1]
          , f = [1, 1, 1, -1, -1, -1]
          , h = this._renderer
          , d = h.autoClear
          , p = h.toneMapping;
        h.getClearColor(LC),
        h.toneMapping = Ka,
        h.autoClear = !1;
        const m = new xa({
            name: "PMREM.Background",
            side: Do,
            depthWrite: !1,
            depthTest: !1
        })
          , _ = new vs(new Nc,m);
        let y = !1;
        const x = e.background;
        x ? x.isColor && (m.color.copy(x),
        e.background = null,
        y = !0) : (m.color.copy(LC),
        y = !0);
        for (let S = 0; S < 6; S++) {
            const M = S % 3;
            M === 0 ? (a.up.set(0, l[S], 0),
            a.lookAt(f[S], 0, 0)) : M === 1 ? (a.up.set(0, 0, l[S]),
            a.lookAt(0, f[S], 0)) : (a.up.set(0, l[S], 0),
            a.lookAt(0, 0, f[S]));
            const w = this._cubeSize;
            $g(i, M * w, S > 2 ? w : 0, w, w),
            h.setRenderTarget(i),
            y && h.render(_, a),
            h.render(e, a)
        }
        _.geometry.dispose(),
        _.material.dispose(),
        h.toneMapping = p,
        h.autoClear = d,
        e.background = x
    }
    _textureToCubeUV(e, t) {
        const r = this._renderer
          , i = e.mapping === Tu || e.mapping === Ec;
        i ? (this._cubemapMaterial === null && (this._cubemapMaterial = NC()),
        this._cubemapMaterial.uniforms.flipEnvMap.value = e.isRenderTargetTexture === !1 ? -1 : 1) : this._equirectMaterial === null && (this._equirectMaterial = OC());
        const s = i ? this._cubemapMaterial : this._equirectMaterial
          , o = new vs(this._lodPlanes[0],s)
          , a = s.uniforms;
        a.envMap.value = e;
        const l = this._cubeSize;
        $g(t, 0, 0, 3 * l, 2 * l),
        r.setRenderTarget(t),
        r.render(o, tx)
    }
    _applyPMREM(e) {
        const t = this._renderer
          , r = t.autoClear;
        t.autoClear = !1;
        for (let i = 1; i < this._lodPlanes.length; i++) {
            const s = Math.sqrt(this._sigmas[i] * this._sigmas[i] - this._sigmas[i - 1] * this._sigmas[i - 1])
              , o = FC[(i - 1) % FC.length];
            this._blur(e, i - 1, i, s, o)
        }
        t.autoClear = r
    }
    _blur(e, t, r, i, s) {
        const o = this._pingPongRenderTarget;
        this._halfBlur(e, o, t, r, i, "latitudinal", s),
        this._halfBlur(o, e, r, r, i, "longitudinal", s)
    }
    _halfBlur(e, t, r, i, s, o, a) {
        const l = this._renderer
          , f = this._blurMaterial;
        o !== "latitudinal" && o !== "longitudinal" && console.error("blur direction must be either latitudinal or longitudinal!");
        const h = 3
          , d = new vs(this._lodPlanes[i],f)
          , p = f.uniforms
          , m = this._sizeLods[r] - 1
          , _ = isFinite(s) ? Math.PI / (2 * m) : 2 * Math.PI / (2 * mf - 1)
          , y = s / _
          , x = isFinite(s) ? 1 + Math.floor(h * y) : mf;
        x > mf && console.warn(`sigmaRadians, ${s}, is too large and will clip, as it requested ${x} samples when the maximum is set to ${mf}`);
        const S = [];
        let M = 0;
        for (let k = 0; k < mf; ++k) {
            const R = k / y
              , O = Math.exp(-R * R / 2);
            S.push(O),
            k === 0 ? M += O : k < x && (M += 2 * O)
        }
        for (let k = 0; k < S.length; k++)
            S[k] = S[k] / M;
        p.envMap.value = e.texture,
        p.samples.value = x,
        p.weights.value = S,
        p.latitudinal.value = o === "latitudinal",
        a && (p.poleAxis.value = a);
        const {_lodMax: w} = this;
        p.dTheta.value = _,
        p.mipInt.value = w - r;
        const T = this._sizeLods[i]
          , P = 3 * T * (i > w - Xd ? i - w + Xd : 0)
          , I = 4 * (this._cubeSize - T);
        $g(t, P, I, 3 * T, 2 * T),
        l.setRenderTarget(t),
        l.render(d, tx)
    }
}
function tN(n) {
    const e = []
      , t = []
      , r = [];
    let i = n;
    const s = n - Xd + 1 + IC.length;
    for (let o = 0; o < s; o++) {
        const a = Math.pow(2, i);
        t.push(a);
        let l = 1 / a;
        o > n - Xd ? l = IC[o - n + Xd - 1] : o === 0 && (l = 0),
        r.push(l);
        const f = 1 / (a - 2)
          , h = -f
          , d = 1 + f
          , p = [h, h, d, h, d, d, h, h, d, d, h, d]
          , m = 6
          , _ = 6
          , y = 3
          , x = 2
          , S = 1
          , M = new Float32Array(y * _ * m)
          , w = new Float32Array(x * _ * m)
          , T = new Float32Array(S * _ * m);
        for (let I = 0; I < m; I++) {
            const k = I % 3 * 2 / 3 - 1
              , R = I > 2 ? 0 : -1
              , O = [k, R, 0, k + 2 / 3, R, 0, k + 2 / 3, R + 1, 0, k, R, 0, k + 2 / 3, R + 1, 0, k, R + 1, 0];
            M.set(O, y * _ * I),
            w.set(p, x * _ * I);
            const H = [I, I, I, I, I, I];
            T.set(H, S * _ * I)
        }
        const P = new On;
        P.setAttribute("position", new Dr(M,y)),
        P.setAttribute("uv", new Dr(w,x)),
        P.setAttribute("faceIndex", new Dr(T,S)),
        e.push(P),
        i > Xd && i--
    }
    return {
        lodPlanes: e,
        sizeLods: t,
        sigmas: r
    }
}
function kC(n, e, t) {
    const r = new $a(n,e,t);
    return r.texture.mapping = Dh,
    r.texture.name = "PMREM.cubeUv",
    r.scissorTest = !0,
    r
}
function $g(n, e, t, r, i) {
    n.viewport.set(e, t, r, i),
    n.scissor.set(e, t, r, i)
}
function nN(n, e, t) {
    const r = new Float32Array(mf)
      , i = new $(0,1,0);
    return new el({
        name: "SphericalGaussianBlur",
        defines: {
            n: mf,
            CUBEUV_TEXEL_WIDTH: 1 / e,
            CUBEUV_TEXEL_HEIGHT: 1 / t,
            CUBEUV_MAX_MIP: `${n}.0`
        },
        uniforms: {
            envMap: {
                value: null
            },
            samples: {
                value: 1
            },
            weights: {
                value: r
            },
            latitudinal: {
                value: !1
            },
            dTheta: {
                value: 0
            },
            mipInt: {
                value: 0
            },
            poleAxis: {
                value: i
            }
        },
        vertexShader: JS(),
        fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
        blending: Su,
        depthTest: !1,
        depthWrite: !1
    })
}
function OC() {
    return new el({
        name: "EquirectangularToCubeUV",
        uniforms: {
            envMap: {
                value: null
            }
        },
        vertexShader: JS(),
        fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
        blending: Su,
        depthTest: !1,
        depthWrite: !1
    })
}
function NC() {
    return new el({
        name: "CubemapToCubeUV",
        uniforms: {
            envMap: {
                value: null
            },
            flipEnvMap: {
                value: -1
            }
        },
        vertexShader: JS(),
        fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
        blending: Su,
        depthTest: !1,
        depthWrite: !1
    })
}
function JS() {
    return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`
}
function rN(n) {
    let e = new WeakMap
      , t = null;
    function r(a) {
        if (a && a.isTexture) {
            const l = a.mapping
              , f = l === mh || l === hm
              , h = l === Tu || l === Ec;
            if (f || h)
                if (a.isRenderTargetTexture && a.needsPMREMUpdate === !0) {
                    a.needsPMREMUpdate = !1;
                    let d = e.get(a);
                    return t === null && (t = new fw(n)),
                    d = f ? t.fromEquirectangular(a, d) : t.fromCubemap(a, d),
                    e.set(a, d),
                    d.texture
                } else {
                    if (e.has(a))
                        return e.get(a).texture;
                    {
                        const d = a.image;
                        if (f && d && d.height > 0 || h && d && i(d)) {
                            t === null && (t = new fw(n));
                            const p = f ? t.fromEquirectangular(a) : t.fromCubemap(a);
                            return e.set(a, p),
                            a.addEventListener("dispose", s),
                            p.texture
                        } else
                            return null
                    }
                }
        }
        return a
    }
    function i(a) {
        let l = 0;
        const f = 6;
        for (let h = 0; h < f; h++)
            a[h] !== void 0 && l++;
        return l === f
    }
    function s(a) {
        const l = a.target;
        l.removeEventListener("dispose", s);
        const f = e.get(l);
        f !== void 0 && (e.delete(l),
        f.dispose())
    }
    function o() {
        e = new WeakMap,
        t !== null && (t.dispose(),
        t = null)
    }
    return {
        get: r,
        dispose: o
    }
}
function iN(n) {
    const e = {};
    function t(r) {
        if (e[r] !== void 0)
            return e[r];
        let i;
        switch (r) {
        case "WEBGL_depth_texture":
            i = n.getExtension("WEBGL_depth_texture") || n.getExtension("MOZ_WEBGL_depth_texture") || n.getExtension("WEBKIT_WEBGL_depth_texture");
            break;
        case "EXT_texture_filter_anisotropic":
            i = n.getExtension("EXT_texture_filter_anisotropic") || n.getExtension("MOZ_EXT_texture_filter_anisotropic") || n.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
            break;
        case "WEBGL_compressed_texture_s3tc":
            i = n.getExtension("WEBGL_compressed_texture_s3tc") || n.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || n.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
            break;
        case "WEBGL_compressed_texture_pvrtc":
            i = n.getExtension("WEBGL_compressed_texture_pvrtc") || n.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
            break;
        default:
            i = n.getExtension(r)
        }
        return e[r] = i,
        i
    }
    return {
        has: function(r) {
            return t(r) !== null
        },
        init: function(r) {
            r.isWebGL2 ? t("EXT_color_buffer_float") : (t("WEBGL_depth_texture"),
            t("OES_texture_float"),
            t("OES_texture_half_float"),
            t("OES_texture_half_float_linear"),
            t("OES_standard_derivatives"),
            t("OES_element_index_uint"),
            t("OES_vertex_array_object"),
            t("ANGLE_instanced_arrays")),
            t("OES_texture_float_linear"),
            t("EXT_color_buffer_half_float"),
            t("WEBGL_multisampled_render_to_texture")
        },
        get: function(r) {
            const i = t(r);
            return i === null && console.warn("THREE.WebGLRenderer: " + r + " extension not supported."),
            i
        }
    }
}
function sN(n, e, t, r) {
    const i = {}
      , s = new WeakMap;
    function o(d) {
        const p = d.target;
        p.index !== null && e.remove(p.index);
        for (const _ in p.attributes)
            e.remove(p.attributes[_]);
        p.removeEventListener("dispose", o),
        delete i[p.id];
        const m = s.get(p);
        m && (e.remove(m),
        s.delete(p)),
        r.releaseStatesOfGeometry(p),
        p.isInstancedBufferGeometry === !0 && delete p._maxInstanceCount,
        t.memory.geometries--
    }
    function a(d, p) {
        return i[p.id] === !0 || (p.addEventListener("dispose", o),
        i[p.id] = !0,
        t.memory.geometries++),
        p
    }
    function l(d) {
        const p = d.attributes;
        for (const _ in p)
            e.update(p[_], 34962);
        const m = d.morphAttributes;
        for (const _ in m) {
            const y = m[_];
            for (let x = 0, S = y.length; x < S; x++)
                e.update(y[x], 34962)
        }
    }
    function f(d) {
        const p = []
          , m = d.index
          , _ = d.attributes.position;
        let y = 0;
        if (m !== null) {
            const M = m.array;
            y = m.version;
            for (let w = 0, T = M.length; w < T; w += 3) {
                const P = M[w + 0]
                  , I = M[w + 1]
                  , k = M[w + 2];
                p.push(P, I, I, k, k, P)
            }
        } else {
            const M = _.array;
            y = _.version;
            for (let w = 0, T = M.length / 3 - 1; w < T; w += 3) {
                const P = w + 0
                  , I = w + 1
                  , k = w + 2;
                p.push(P, I, I, k, k, P)
            }
        }
        const x = new (Z2(p) ? VS : HS)(p,1);
        x.version = y;
        const S = s.get(d);
        S && e.remove(S),
        s.set(d, x)
    }
    function h(d) {
        const p = s.get(d);
        if (p) {
            const m = d.index;
            m !== null && p.version < m.version && f(d)
        } else
            f(d);
        return s.get(d)
    }
    return {
        get: a,
        update: l,
        getWireframeAttribute: h
    }
}
function oN(n, e, t, r) {
    const i = r.isWebGL2;
    let s;
    function o(p) {
        s = p
    }
    let a, l;
    function f(p) {
        a = p.type,
        l = p.bytesPerElement
    }
    function h(p, m) {
        n.drawElements(s, m, a, p * l),
        t.update(m, s, 1)
    }
    function d(p, m, _) {
        if (_ === 0)
            return;
        let y, x;
        if (i)
            y = n,
            x = "drawElementsInstanced";
        else if (y = e.get("ANGLE_instanced_arrays"),
        x = "drawElementsInstancedANGLE",
        y === null) {
            console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
            return
        }
        y[x](s, m, a, p * l, _),
        t.update(m, s, _)
    }
    this.setMode = o,
    this.setIndex = f,
    this.render = h,
    this.renderInstances = d
}
function aN(n) {
    const e = {
        geometries: 0,
        textures: 0
    }
      , t = {
        frame: 0,
        calls: 0,
        triangles: 0,
        points: 0,
        lines: 0
    };
    function r(s, o, a) {
        switch (t.calls++,
        o) {
        case 4:
            t.triangles += a * (s / 3);
            break;
        case 1:
            t.lines += a * (s / 2);
            break;
        case 3:
            t.lines += a * (s - 1);
            break;
        case 2:
            t.lines += a * s;
            break;
        case 0:
            t.points += a * s;
            break;
        default:
            console.error("THREE.WebGLInfo: Unknown draw mode:", o);
            break
        }
    }
    function i() {
        t.frame++,
        t.calls = 0,
        t.triangles = 0,
        t.points = 0,
        t.lines = 0
    }
    return {
        memory: e,
        render: t,
        programs: null,
        autoReset: !0,
        reset: i,
        update: r
    }
}
function lN(n, e) {
    return n[0] - e[0]
}
function uN(n, e) {
    return Math.abs(e[1]) - Math.abs(n[1])
}
function cN(n, e, t) {
    const r = {}
      , i = new Float32Array(8)
      , s = new WeakMap
      , o = new zr
      , a = [];
    for (let f = 0; f < 8; f++)
        a[f] = [f, 0];
    function l(f, h, d, p) {
        const m = f.morphTargetInfluences;
        if (e.isWebGL2 === !0) {
            const y = h.morphAttributes.position || h.morphAttributes.normal || h.morphAttributes.color
              , x = y !== void 0 ? y.length : 0;
            let S = s.get(h);
            if (S === void 0 || S.count !== x) {
                let ce = function() {
                    re.dispose(),
                    s.delete(h),
                    h.removeEventListener("dispose", ce)
                };
                var _ = ce;
                S !== void 0 && S.texture.dispose();
                const T = h.morphAttributes.position !== void 0
                  , P = h.morphAttributes.normal !== void 0
                  , I = h.morphAttributes.color !== void 0
                  , k = h.morphAttributes.position || []
                  , R = h.morphAttributes.normal || []
                  , O = h.morphAttributes.color || [];
                let H = 0;
                T === !0 && (H = 1),
                P === !0 && (H = 2),
                I === !0 && (H = 3);
                let W = h.attributes.position.count * H
                  , te = 1;
                W > e.maxTextureSize && (te = Math.ceil(W / e.maxTextureSize),
                W = e.maxTextureSize);
                const ne = new Float32Array(W * te * 4 * x)
                  , re = new x_(ne,W,te,x);
                re.type = ya,
                re.needsUpdate = !0;
                const pe = H * 4;
                for (let xe = 0; xe < x; xe++) {
                    const G = k[xe]
                      , z = R[xe]
                      , U = O[xe]
                      , fe = W * te * 4 * xe;
                    for (let oe = 0; oe < G.count; oe++) {
                        const Ae = oe * pe;
                        T === !0 && (o.fromBufferAttribute(G, oe),
                        ne[fe + Ae + 0] = o.x,
                        ne[fe + Ae + 1] = o.y,
                        ne[fe + Ae + 2] = o.z,
                        ne[fe + Ae + 3] = 0),
                        P === !0 && (o.fromBufferAttribute(z, oe),
                        ne[fe + Ae + 4] = o.x,
                        ne[fe + Ae + 5] = o.y,
                        ne[fe + Ae + 6] = o.z,
                        ne[fe + Ae + 7] = 0),
                        I === !0 && (o.fromBufferAttribute(U, oe),
                        ne[fe + Ae + 8] = o.x,
                        ne[fe + Ae + 9] = o.y,
                        ne[fe + Ae + 10] = o.z,
                        ne[fe + Ae + 11] = U.itemSize === 4 ? o.w : 1)
                    }
                }
                S = {
                    count: x,
                    texture: re,
                    size: new it(W,te)
                },
                s.set(h, S),
                h.addEventListener("dispose", ce)
            }
            let M = 0;
            for (let T = 0; T < m.length; T++)
                M += m[T];
            const w = h.morphTargetsRelative ? 1 : 1 - M;
            p.getUniforms().setValue(n, "morphTargetBaseInfluence", w),
            p.getUniforms().setValue(n, "morphTargetInfluences", m),
            p.getUniforms().setValue(n, "morphTargetsTexture", S.texture, t),
            p.getUniforms().setValue(n, "morphTargetsTextureSize", S.size)
        } else {
            const y = m === void 0 ? 0 : m.length;
            let x = r[h.id];
            if (x === void 0 || x.length !== y) {
                x = [];
                for (let P = 0; P < y; P++)
                    x[P] = [P, 0];
                r[h.id] = x
            }
            for (let P = 0; P < y; P++) {
                const I = x[P];
                I[0] = P,
                I[1] = m[P]
            }
            x.sort(uN);
            for (let P = 0; P < 8; P++)
                P < y && x[P][1] ? (a[P][0] = x[P][0],
                a[P][1] = x[P][1]) : (a[P][0] = Number.MAX_SAFE_INTEGER,
                a[P][1] = 0);
            a.sort(lN);
            const S = h.morphAttributes.position
              , M = h.morphAttributes.normal;
            let w = 0;
            for (let P = 0; P < 8; P++) {
                const I = a[P]
                  , k = I[0]
                  , R = I[1];
                k !== Number.MAX_SAFE_INTEGER && R ? (S && h.getAttribute("morphTarget" + P) !== S[k] && h.setAttribute("morphTarget" + P, S[k]),
                M && h.getAttribute("morphNormal" + P) !== M[k] && h.setAttribute("morphNormal" + P, M[k]),
                i[P] = R,
                w += R) : (S && h.hasAttribute("morphTarget" + P) === !0 && h.deleteAttribute("morphTarget" + P),
                M && h.hasAttribute("morphNormal" + P) === !0 && h.deleteAttribute("morphNormal" + P),
                i[P] = 0)
            }
            const T = h.morphTargetsRelative ? 1 : 1 - w;
            p.getUniforms().setValue(n, "morphTargetBaseInfluence", T),
            p.getUniforms().setValue(n, "morphTargetInfluences", i)
        }
    }
    return {
        update: l
    }
}
function fN(n, e, t, r) {
    let i = new WeakMap;
    function s(l) {
        const f = r.render.frame
          , h = l.geometry
          , d = e.get(l, h);
        return i.get(d) !== f && (e.update(d),
        i.set(d, f)),
        l.isInstancedMesh && (l.hasEventListener("dispose", a) === !1 && l.addEventListener("dispose", a),
        t.update(l.instanceMatrix, 34962),
        l.instanceColor !== null && t.update(l.instanceColor, 34962)),
        d
    }
    function o() {
        i = new WeakMap
    }
    function a(l) {
        const f = l.target;
        f.removeEventListener("dispose", a),
        t.remove(f.instanceMatrix),
        f.instanceColor !== null && t.remove(f.instanceColor)
    }
    return {
        update: s,
        dispose: o
    }
}
const r3 = new Ci
  , i3 = new x_
  , s3 = new US
  , o3 = new Nm
  , zC = []
  , GC = []
  , UC = new Float32Array(16)
  , HC = new Float32Array(9)
  , VC = new Float32Array(4);
function Rh(n, e, t) {
    const r = n[0];
    if (r <= 0 || r > 0)
        return n;
    const i = e * t;
    let s = zC[i];
    if (s === void 0 && (s = new Float32Array(i),
    zC[i] = s),
    e !== 0) {
        r.toArray(s, 0);
        for (let o = 1, a = 0; o !== e; ++o)
            a += t,
            n[o].toArray(s, a)
    }
    return s
}
function _s(n, e) {
    if (n.length !== e.length)
        return !1;
    for (let t = 0, r = n.length; t < r; t++)
        if (n[t] !== e[t])
            return !1;
    return !0
}
function ys(n, e) {
    for (let t = 0, r = e.length; t < r; t++)
        n[t] = e[t]
}
function S_(n, e) {
    let t = GC[e];
    t === void 0 && (t = new Int32Array(e),
    GC[e] = t);
    for (let r = 0; r !== e; ++r)
        t[r] = n.allocateTextureUnit();
    return t
}
function dN(n, e) {
    const t = this.cache;
    t[0] !== e && (n.uniform1f(this.addr, e),
    t[0] = e)
}
function hN(n, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y) && (n.uniform2f(this.addr, e.x, e.y),
        t[0] = e.x,
        t[1] = e.y);
    else {
        if (_s(t, e))
            return;
        n.uniform2fv(this.addr, e),
        ys(t, e)
    }
}
function pN(n, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (n.uniform3f(this.addr, e.x, e.y, e.z),
        t[0] = e.x,
        t[1] = e.y,
        t[2] = e.z);
    else if (e.r !== void 0)
        (t[0] !== e.r || t[1] !== e.g || t[2] !== e.b) && (n.uniform3f(this.addr, e.r, e.g, e.b),
        t[0] = e.r,
        t[1] = e.g,
        t[2] = e.b);
    else {
        if (_s(t, e))
            return;
        n.uniform3fv(this.addr, e),
        ys(t, e)
    }
}
function mN(n, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (n.uniform4f(this.addr, e.x, e.y, e.z, e.w),
        t[0] = e.x,
        t[1] = e.y,
        t[2] = e.z,
        t[3] = e.w);
    else {
        if (_s(t, e))
            return;
        n.uniform4fv(this.addr, e),
        ys(t, e)
    }
}
function gN(n, e) {
    const t = this.cache
      , r = e.elements;
    if (r === void 0) {
        if (_s(t, e))
            return;
        n.uniformMatrix2fv(this.addr, !1, e),
        ys(t, e)
    } else {
        if (_s(t, r))
            return;
        VC.set(r),
        n.uniformMatrix2fv(this.addr, !1, VC),
        ys(t, r)
    }
}
function vN(n, e) {
    const t = this.cache
      , r = e.elements;
    if (r === void 0) {
        if (_s(t, e))
            return;
        n.uniformMatrix3fv(this.addr, !1, e),
        ys(t, e)
    } else {
        if (_s(t, r))
            return;
        HC.set(r),
        n.uniformMatrix3fv(this.addr, !1, HC),
        ys(t, r)
    }
}
function _N(n, e) {
    const t = this.cache
      , r = e.elements;
    if (r === void 0) {
        if (_s(t, e))
            return;
        n.uniformMatrix4fv(this.addr, !1, e),
        ys(t, e)
    } else {
        if (_s(t, r))
            return;
        UC.set(r),
        n.uniformMatrix4fv(this.addr, !1, UC),
        ys(t, r)
    }
}
function yN(n, e) {
    const t = this.cache;
    t[0] !== e && (n.uniform1i(this.addr, e),
    t[0] = e)
}
function xN(n, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y) && (n.uniform2i(this.addr, e.x, e.y),
        t[0] = e.x,
        t[1] = e.y);
    else {
        if (_s(t, e))
            return;
        n.uniform2iv(this.addr, e),
        ys(t, e)
    }
}
function wN(n, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (n.uniform3i(this.addr, e.x, e.y, e.z),
        t[0] = e.x,
        t[1] = e.y,
        t[2] = e.z);
    else {
        if (_s(t, e))
            return;
        n.uniform3iv(this.addr, e),
        ys(t, e)
    }
}
function SN(n, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (n.uniform4i(this.addr, e.x, e.y, e.z, e.w),
        t[0] = e.x,
        t[1] = e.y,
        t[2] = e.z,
        t[3] = e.w);
    else {
        if (_s(t, e))
            return;
        n.uniform4iv(this.addr, e),
        ys(t, e)
    }
}
function MN(n, e) {
    const t = this.cache;
    t[0] !== e && (n.uniform1ui(this.addr, e),
    t[0] = e)
}
function AN(n, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y) && (n.uniform2ui(this.addr, e.x, e.y),
        t[0] = e.x,
        t[1] = e.y);
    else {
        if (_s(t, e))
            return;
        n.uniform2uiv(this.addr, e),
        ys(t, e)
    }
}
function CN(n, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (n.uniform3ui(this.addr, e.x, e.y, e.z),
        t[0] = e.x,
        t[1] = e.y,
        t[2] = e.z);
    else {
        if (_s(t, e))
            return;
        n.uniform3uiv(this.addr, e),
        ys(t, e)
    }
}
function EN(n, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (n.uniform4ui(this.addr, e.x, e.y, e.z, e.w),
        t[0] = e.x,
        t[1] = e.y,
        t[2] = e.z,
        t[3] = e.w);
    else {
        if (_s(t, e))
            return;
        n.uniform4uiv(this.addr, e),
        ys(t, e)
    }
}
function bN(n, e, t) {
    const r = this.cache
      , i = t.allocateTextureUnit();
    r[0] !== i && (n.uniform1i(this.addr, i),
    r[0] = i),
    t.setTexture2D(e || r3, i)
}
function TN(n, e, t) {
    const r = this.cache
      , i = t.allocateTextureUnit();
    r[0] !== i && (n.uniform1i(this.addr, i),
    r[0] = i),
    t.setTexture3D(e || s3, i)
}
function DN(n, e, t) {
    const r = this.cache
      , i = t.allocateTextureUnit();
    r[0] !== i && (n.uniform1i(this.addr, i),
    r[0] = i),
    t.setTextureCube(e || o3, i)
}
function PN(n, e, t) {
    const r = this.cache
      , i = t.allocateTextureUnit();
    r[0] !== i && (n.uniform1i(this.addr, i),
    r[0] = i),
    t.setTexture2DArray(e || i3, i)
}
function RN(n) {
    switch (n) {
    case 5126:
        return dN;
    case 35664:
        return hN;
    case 35665:
        return pN;
    case 35666:
        return mN;
    case 35674:
        return gN;
    case 35675:
        return vN;
    case 35676:
        return _N;
    case 5124:
    case 35670:
        return yN;
    case 35667:
    case 35671:
        return xN;
    case 35668:
    case 35672:
        return wN;
    case 35669:
    case 35673:
        return SN;
    case 5125:
        return MN;
    case 36294:
        return AN;
    case 36295:
        return CN;
    case 36296:
        return EN;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
        return bN;
    case 35679:
    case 36299:
    case 36307:
        return TN;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
        return DN;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
        return PN
    }
}
function BN(n, e) {
    n.uniform1fv(this.addr, e)
}
function IN(n, e) {
    const t = Rh(e, this.size, 2);
    n.uniform2fv(this.addr, t)
}
function LN(n, e) {
    const t = Rh(e, this.size, 3);
    n.uniform3fv(this.addr, t)
}
function FN(n, e) {
    const t = Rh(e, this.size, 4);
    n.uniform4fv(this.addr, t)
}
function kN(n, e) {
    const t = Rh(e, this.size, 4);
    n.uniformMatrix2fv(this.addr, !1, t)
}
function ON(n, e) {
    const t = Rh(e, this.size, 9);
    n.uniformMatrix3fv(this.addr, !1, t)
}
function NN(n, e) {
    const t = Rh(e, this.size, 16);
    n.uniformMatrix4fv(this.addr, !1, t)
}
function zN(n, e) {
    n.uniform1iv(this.addr, e)
}
function GN(n, e) {
    n.uniform2iv(this.addr, e)
}
function UN(n, e) {
    n.uniform3iv(this.addr, e)
}
function HN(n, e) {
    n.uniform4iv(this.addr, e)
}
function VN(n, e) {
    n.uniform1uiv(this.addr, e)
}
function WN(n, e) {
    n.uniform2uiv(this.addr, e)
}
function XN(n, e) {
    n.uniform3uiv(this.addr, e)
}
function JN(n, e) {
    n.uniform4uiv(this.addr, e)
}
function jN(n, e, t) {
    const r = this.cache
      , i = e.length
      , s = S_(t, i);
    _s(r, s) || (n.uniform1iv(this.addr, s),
    ys(r, s));
    for (let o = 0; o !== i; ++o)
        t.setTexture2D(e[o] || r3, s[o])
}
function YN(n, e, t) {
    const r = this.cache
      , i = e.length
      , s = S_(t, i);
    _s(r, s) || (n.uniform1iv(this.addr, s),
    ys(r, s));
    for (let o = 0; o !== i; ++o)
        t.setTexture3D(e[o] || s3, s[o])
}
function KN(n, e, t) {
    const r = this.cache
      , i = e.length
      , s = S_(t, i);
    _s(r, s) || (n.uniform1iv(this.addr, s),
    ys(r, s));
    for (let o = 0; o !== i; ++o)
        t.setTextureCube(e[o] || o3, s[o])
}
function qN(n, e, t) {
    const r = this.cache
      , i = e.length
      , s = S_(t, i);
    _s(r, s) || (n.uniform1iv(this.addr, s),
    ys(r, s));
    for (let o = 0; o !== i; ++o)
        t.setTexture2DArray(e[o] || i3, s[o])
}
function QN(n) {
    switch (n) {
    case 5126:
        return BN;
    case 35664:
        return IN;
    case 35665:
        return LN;
    case 35666:
        return FN;
    case 35674:
        return kN;
    case 35675:
        return ON;
    case 35676:
        return NN;
    case 5124:
    case 35670:
        return zN;
    case 35667:
    case 35671:
        return GN;
    case 35668:
    case 35672:
        return UN;
    case 35669:
    case 35673:
        return HN;
    case 5125:
        return VN;
    case 36294:
        return WN;
    case 36295:
        return XN;
    case 36296:
        return JN;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
        return jN;
    case 35679:
    case 36299:
    case 36307:
        return YN;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
        return KN;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
        return qN
    }
}
class ZN {
    constructor(e, t, r) {
        this.id = e,
        this.addr = r,
        this.cache = [],
        this.setValue = RN(t.type)
    }
}
class $N {
    constructor(e, t, r) {
        this.id = e,
        this.addr = r,
        this.cache = [],
        this.size = t.size,
        this.setValue = QN(t.type)
    }
}
class ez {
    constructor(e) {
        this.id = e,
        this.seq = [],
        this.map = {}
    }
    setValue(e, t, r) {
        const i = this.seq;
        for (let s = 0, o = i.length; s !== o; ++s) {
            const a = i[s];
            a.setValue(e, t[a.id], r)
        }
    }
}
const rx = /(\w+)(\])?(\[|\.)?/g;
function WC(n, e) {
    n.seq.push(e),
    n.map[e.id] = e
}
function tz(n, e, t) {
    const r = n.name
      , i = r.length;
    for (rx.lastIndex = 0; ; ) {
        const s = rx.exec(r)
          , o = rx.lastIndex;
        let a = s[1];
        const l = s[2] === "]"
          , f = s[3];
        if (l && (a = a | 0),
        f === void 0 || f === "[" && o + 2 === i) {
            WC(t, f === void 0 ? new ZN(a,n,e) : new $N(a,n,e));
            break
        } else {
            let d = t.map[a];
            d === void 0 && (d = new ez(a),
            WC(t, d)),
            t = d
        }
    }
}
class uv {
    constructor(e, t) {
        this.seq = [],
        this.map = {};
        const r = e.getProgramParameter(t, 35718);
        for (let i = 0; i < r; ++i) {
            const s = e.getActiveUniform(t, i)
              , o = e.getUniformLocation(t, s.name);
            tz(s, o, this)
        }
    }
    setValue(e, t, r, i) {
        const s = this.map[t];
        s !== void 0 && s.setValue(e, r, i)
    }
    setOptional(e, t, r) {
        const i = t[r];
        i !== void 0 && this.setValue(e, r, i)
    }
    static upload(e, t, r, i) {
        for (let s = 0, o = t.length; s !== o; ++s) {
            const a = t[s]
              , l = r[a.id];
            l.needsUpdate !== !1 && a.setValue(e, l.value, i)
        }
    }
    static seqWithValue(e, t) {
        const r = [];
        for (let i = 0, s = e.length; i !== s; ++i) {
            const o = e[i];
            o.id in t && r.push(o)
        }
        return r
    }
}
function XC(n, e, t) {
    const r = n.createShader(e);
    return n.shaderSource(r, t),
    n.compileShader(r),
    r
}
let nz = 0;
function rz(n, e) {
    const t = n.split(`
`)
      , r = []
      , i = Math.max(e - 6, 0)
      , s = Math.min(e + 6, t.length);
    for (let o = i; o < s; o++) {
        const a = o + 1;
        r.push(`${a === e ? ">" : " "} ${a}: ${t[o]}`)
    }
    return r.join(`
`)
}
function iz(n) {
    switch (n) {
    case bl:
        return ["Linear", "( value )"];
    case nr:
        return ["sRGB", "( value )"];
    default:
        return console.warn("THREE.WebGLProgram: Unsupported encoding:", n),
        ["Linear", "( value )"]
    }
}
function JC(n, e, t) {
    const r = n.getShaderParameter(e, 35713)
      , i = n.getShaderInfoLog(e).trim();
    if (r && i === "")
        return "";
    const s = /ERROR: 0:(\d+)/.exec(i);
    if (s) {
        const o = parseInt(s[1]);
        return t.toUpperCase() + `

` + i + `

` + rz(n.getShaderSource(e), o)
    } else
        return i
}
function sz(n, e) {
    const t = iz(e);
    return "vec4 " + n + "( vec4 value ) { return LinearTo" + t[0] + t[1] + "; }"
}
function oz(n, e) {
    let t;
    switch (e) {
    case A2:
        t = "Linear";
        break;
    case C2:
        t = "Reinhard";
        break;
    case E2:
        t = "OptimizedCineon";
        break;
    case FS:
        t = "ACESFilmic";
        break;
    case b2:
        t = "Custom";
        break;
    default:
        console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e),
        t = "Linear"
    }
    return "vec3 " + n + "( vec3 color ) { return " + t + "ToneMapping( color ); }"
}
function az(n) {
    return [n.extensionDerivatives || n.envMapCubeUVHeight || n.bumpMap || n.tangentSpaceNormalMap || n.clearcoatNormalMap || n.flatShading || n.shaderID === "physical" ? "#extension GL_OES_standard_derivatives : enable" : "", (n.extensionFragDepth || n.logarithmicDepthBuffer) && n.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", n.extensionDrawBuffers && n.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (n.extensionShaderTextureLOD || n.envMap || n.transmission) && n.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(Mp).join(`
`)
}
function lz(n) {
    const e = [];
    for (const t in n) {
        const r = n[t];
        r !== !1 && e.push("#define " + t + " " + r)
    }
    return e.join(`
`)
}
function uz(n, e) {
    const t = {}
      , r = n.getProgramParameter(e, 35721);
    for (let i = 0; i < r; i++) {
        const s = n.getActiveAttrib(e, i)
          , o = s.name;
        let a = 1;
        s.type === 35674 && (a = 2),
        s.type === 35675 && (a = 3),
        s.type === 35676 && (a = 4),
        t[o] = {
            type: s.type,
            location: n.getAttribLocation(e, o),
            locationSize: a
        }
    }
    return t
}
function Mp(n) {
    return n !== ""
}
function jC(n, e) {
    const t = e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps;
    return n.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, t).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows)
}
function YC(n, e) {
    return n.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection)
}
const cz = /^[ \t]*#include +<([\w\d./]+)>/gm;
function dw(n) {
    return n.replace(cz, fz)
}
function fz(n, e) {
    const t = Vn[e];
    if (t === void 0)
        throw new Error("Can not resolve #include <" + e + ">");
    return dw(t)
}
const dz = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function KC(n) {
    return n.replace(dz, hz)
}
function hz(n, e, t, r) {
    let i = "";
    for (let s = parseInt(e); s < parseInt(t); s++)
        i += r.replace(/\[\s*i\s*\]/g, "[ " + s + " ]").replace(/UNROLLED_LOOP_INDEX/g, s);
    return i
}
function qC(n) {
    let e = "precision " + n.precision + ` float;
precision ` + n.precision + " int;";
    return n.precision === "highp" ? e += `
#define HIGH_PRECISION` : n.precision === "mediump" ? e += `
#define MEDIUM_PRECISION` : n.precision === "lowp" && (e += `
#define LOW_PRECISION`),
    e
}
function pz(n) {
    let e = "SHADOWMAP_TYPE_BASIC";
    return n.shadowMapType === m_ ? e = "SHADOWMAP_TYPE_PCF" : n.shadowMapType === Np ? e = "SHADOWMAP_TYPE_PCF_SOFT" : n.shadowMapType === yf && (e = "SHADOWMAP_TYPE_VSM"),
    e
}
function mz(n) {
    let e = "ENVMAP_TYPE_CUBE";
    if (n.envMap)
        switch (n.envMapMode) {
        case Tu:
        case Ec:
            e = "ENVMAP_TYPE_CUBE";
            break;
        case Dh:
            e = "ENVMAP_TYPE_CUBE_UV";
            break
        }
    return e
}
function gz(n) {
    let e = "ENVMAP_MODE_REFLECTION";
    if (n.envMap)
        switch (n.envMapMode) {
        case Ec:
            e = "ENVMAP_MODE_REFRACTION";
            break
        }
    return e
}
function vz(n) {
    let e = "ENVMAP_BLENDING_NONE";
    if (n.envMap)
        switch (n.combine) {
        case Lm:
            e = "ENVMAP_BLENDING_MULTIPLY";
            break;
        case S2:
            e = "ENVMAP_BLENDING_MIX";
            break;
        case M2:
            e = "ENVMAP_BLENDING_ADD";
            break
        }
    return e
}
function _z(n) {
    const e = n.envMapCubeUVHeight;
    if (e === null)
        return null;
    const t = Math.log2(e) - 2
      , r = 1 / e;
    return {
        texelWidth: 1 / (3 * Math.max(Math.pow(2, t), 7 * 16)),
        texelHeight: r,
        maxMip: t
    }
}
function yz(n, e, t, r) {
    const i = n.getContext()
      , s = t.defines;
    let o = t.vertexShader
      , a = t.fragmentShader;
    const l = pz(t)
      , f = mz(t)
      , h = gz(t)
      , d = vz(t)
      , p = _z(t)
      , m = t.isWebGL2 ? "" : az(t)
      , _ = lz(s)
      , y = i.createProgram();
    let x, S, M = t.glslVersion ? "#version " + t.glslVersion + `
` : "";
    t.isRawShaderMaterial ? (x = [_].filter(Mp).join(`
`),
    x.length > 0 && (x += `
`),
    S = [m, _].filter(Mp).join(`
`),
    S.length > 0 && (S += `
`)) : (x = [qC(t), "#define SHADER_NAME " + t.shaderName, _, t.instancing ? "#define USE_INSTANCING" : "", t.instancingColor ? "#define USE_INSTANCING_COLOR" : "", t.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", t.useFog && t.fog ? "#define USE_FOG" : "", t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "", t.map ? "#define USE_MAP" : "", t.envMap ? "#define USE_ENVMAP" : "", t.envMap ? "#define " + h : "", t.lightMap ? "#define USE_LIGHTMAP" : "", t.aoMap ? "#define USE_AOMAP" : "", t.emissiveMap ? "#define USE_EMISSIVEMAP" : "", t.bumpMap ? "#define USE_BUMPMAP" : "", t.normalMap ? "#define USE_NORMALMAP" : "", t.normalMap && t.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", t.normalMap && t.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", t.displacementMap && t.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", t.specularMap ? "#define USE_SPECULARMAP" : "", t.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", t.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "", t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", t.metalnessMap ? "#define USE_METALNESSMAP" : "", t.alphaMap ? "#define USE_ALPHAMAP" : "", t.transmission ? "#define USE_TRANSMISSION" : "", t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", t.thicknessMap ? "#define USE_THICKNESSMAP" : "", t.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "", t.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "", t.vertexTangents ? "#define USE_TANGENT" : "", t.vertexColors ? "#define USE_COLOR" : "", t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", t.vertexUvs ? "#define USE_UV" : "", t.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", t.flatShading ? "#define FLAT_SHADED" : "", t.skinning ? "#define USE_SKINNING" : "", t.morphTargets ? "#define USE_MORPHTARGETS" : "", t.morphNormals && t.flatShading === !1 ? "#define USE_MORPHNORMALS" : "", t.morphColors && t.isWebGL2 ? "#define USE_MORPHCOLORS" : "", t.morphTargetsCount > 0 && t.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "", t.morphTargetsCount > 0 && t.isWebGL2 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + t.morphTextureStride : "", t.morphTargetsCount > 0 && t.isWebGL2 ? "#define MORPHTARGETS_COUNT " + t.morphTargetsCount : "", t.doubleSided ? "#define DOUBLE_SIDED" : "", t.flipSided ? "#define FLIP_SIDED" : "", t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", t.shadowMapEnabled ? "#define " + l : "", t.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", t.logarithmicDepthBuffer && t.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "	attribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "	attribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "	attribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "	attribute vec4 color;", "#elif defined( USE_COLOR )", "	attribute vec3 color;", "#endif", "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )", "	attribute vec3 morphTarget0;", "	attribute vec3 morphTarget1;", "	attribute vec3 morphTarget2;", "	attribute vec3 morphTarget3;", "	#ifdef USE_MORPHNORMALS", "		attribute vec3 morphNormal0;", "		attribute vec3 morphNormal1;", "		attribute vec3 morphNormal2;", "		attribute vec3 morphNormal3;", "	#else", "		attribute vec3 morphTarget4;", "		attribute vec3 morphTarget5;", "		attribute vec3 morphTarget6;", "		attribute vec3 morphTarget7;", "	#endif", "#endif", "#ifdef USE_SKINNING", "	attribute vec4 skinIndex;", "	attribute vec4 skinWeight;", "#endif", `
`].filter(Mp).join(`
`),
    S = [m, qC(t), "#define SHADER_NAME " + t.shaderName, _, t.useFog && t.fog ? "#define USE_FOG" : "", t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "", t.map ? "#define USE_MAP" : "", t.matcap ? "#define USE_MATCAP" : "", t.envMap ? "#define USE_ENVMAP" : "", t.envMap ? "#define " + f : "", t.envMap ? "#define " + h : "", t.envMap ? "#define " + d : "", p ? "#define CUBEUV_TEXEL_WIDTH " + p.texelWidth : "", p ? "#define CUBEUV_TEXEL_HEIGHT " + p.texelHeight : "", p ? "#define CUBEUV_MAX_MIP " + p.maxMip + ".0" : "", t.lightMap ? "#define USE_LIGHTMAP" : "", t.aoMap ? "#define USE_AOMAP" : "", t.emissiveMap ? "#define USE_EMISSIVEMAP" : "", t.bumpMap ? "#define USE_BUMPMAP" : "", t.normalMap ? "#define USE_NORMALMAP" : "", t.normalMap && t.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", t.normalMap && t.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", t.clearcoat ? "#define USE_CLEARCOAT" : "", t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", t.iridescence ? "#define USE_IRIDESCENCE" : "", t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", t.specularMap ? "#define USE_SPECULARMAP" : "", t.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", t.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "", t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", t.metalnessMap ? "#define USE_METALNESSMAP" : "", t.alphaMap ? "#define USE_ALPHAMAP" : "", t.alphaTest ? "#define USE_ALPHATEST" : "", t.sheen ? "#define USE_SHEEN" : "", t.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "", t.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "", t.transmission ? "#define USE_TRANSMISSION" : "", t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", t.thicknessMap ? "#define USE_THICKNESSMAP" : "", t.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "", t.vertexTangents ? "#define USE_TANGENT" : "", t.vertexColors || t.instancingColor ? "#define USE_COLOR" : "", t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", t.vertexUvs ? "#define USE_UV" : "", t.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", t.gradientMap ? "#define USE_GRADIENTMAP" : "", t.flatShading ? "#define FLAT_SHADED" : "", t.doubleSided ? "#define DOUBLE_SIDED" : "", t.flipSided ? "#define FLIP_SIDED" : "", t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", t.shadowMapEnabled ? "#define " + l : "", t.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", t.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", t.logarithmicDepthBuffer && t.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", t.toneMapping !== Ka ? "#define TONE_MAPPING" : "", t.toneMapping !== Ka ? Vn.tonemapping_pars_fragment : "", t.toneMapping !== Ka ? oz("toneMapping", t.toneMapping) : "", t.dithering ? "#define DITHERING" : "", t.opaque ? "#define OPAQUE" : "", Vn.encodings_pars_fragment, sz("linearToOutputTexel", t.outputEncoding), t.useDepthPacking ? "#define DEPTH_PACKING " + t.depthPacking : "", `
`].filter(Mp).join(`
`)),
    o = dw(o),
    o = jC(o, t),
    o = YC(o, t),
    a = dw(a),
    a = jC(a, t),
    a = YC(a, t),
    o = KC(o),
    a = KC(a),
    t.isWebGL2 && t.isRawShaderMaterial !== !0 && (M = `#version 300 es
`,
    x = ["precision mediump sampler2DArray;", "#define attribute in", "#define varying out", "#define texture2D texture"].join(`
`) + `
` + x,
    S = ["#define varying in", t.glslVersion === uw ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", t.glslVersion === uw ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join(`
`) + `
` + S);
    const w = M + x + o
      , T = M + S + a
      , P = XC(i, 35633, w)
      , I = XC(i, 35632, T);
    if (i.attachShader(y, P),
    i.attachShader(y, I),
    t.index0AttributeName !== void 0 ? i.bindAttribLocation(y, 0, t.index0AttributeName) : t.morphTargets === !0 && i.bindAttribLocation(y, 0, "position"),
    i.linkProgram(y),
    n.debug.checkShaderErrors) {
        const O = i.getProgramInfoLog(y).trim()
          , H = i.getShaderInfoLog(P).trim()
          , W = i.getShaderInfoLog(I).trim();
        let te = !0
          , ne = !0;
        if (i.getProgramParameter(y, 35714) === !1) {
            te = !1;
            const re = JC(i, P, "vertex")
              , pe = JC(i, I, "fragment");
            console.error("THREE.WebGLProgram: Shader Error " + i.getError() + " - VALIDATE_STATUS " + i.getProgramParameter(y, 35715) + `

Program Info Log: ` + O + `
` + re + `
` + pe)
        } else
            O !== "" ? console.warn("THREE.WebGLProgram: Program Info Log:", O) : (H === "" || W === "") && (ne = !1);
        ne && (this.diagnostics = {
            runnable: te,
            programLog: O,
            vertexShader: {
                log: H,
                prefix: x
            },
            fragmentShader: {
                log: W,
                prefix: S
            }
        })
    }
    i.deleteShader(P),
    i.deleteShader(I);
    let k;
    this.getUniforms = function() {
        return k === void 0 && (k = new uv(i,y)),
        k
    }
    ;
    let R;
    return this.getAttributes = function() {
        return R === void 0 && (R = uz(i, y)),
        R
    }
    ,
    this.destroy = function() {
        r.releaseStatesOfProgram(this),
        i.deleteProgram(y),
        this.program = void 0
    }
    ,
    this.name = t.shaderName,
    this.id = nz++,
    this.cacheKey = e,
    this.usedTimes = 1,
    this.program = y,
    this.vertexShader = P,
    this.fragmentShader = I,
    this
}
let xz = 0;
class wz {
    constructor() {
        this.shaderCache = new Map,
        this.materialCache = new Map
    }
    update(e) {
        const t = e.vertexShader
          , r = e.fragmentShader
          , i = this._getShaderStage(t)
          , s = this._getShaderStage(r)
          , o = this._getShaderCacheForMaterial(e);
        return o.has(i) === !1 && (o.add(i),
        i.usedTimes++),
        o.has(s) === !1 && (o.add(s),
        s.usedTimes++),
        this
    }
    remove(e) {
        const t = this.materialCache.get(e);
        for (const r of t)
            r.usedTimes--,
            r.usedTimes === 0 && this.shaderCache.delete(r.code);
        return this.materialCache.delete(e),
        this
    }
    getVertexShaderID(e) {
        return this._getShaderStage(e.vertexShader).id
    }
    getFragmentShaderID(e) {
        return this._getShaderStage(e.fragmentShader).id
    }
    dispose() {
        this.shaderCache.clear(),
        this.materialCache.clear()
    }
    _getShaderCacheForMaterial(e) {
        const t = this.materialCache;
        let r = t.get(e);
        return r === void 0 && (r = new Set,
        t.set(e, r)),
        r
    }
    _getShaderStage(e) {
        const t = this.shaderCache;
        let r = t.get(e);
        return r === void 0 && (r = new Sz(e),
        t.set(e, r)),
        r
    }
}
class Sz {
    constructor(e) {
        this.id = xz++,
        this.code = e,
        this.usedTimes = 0
    }
}
function Mz(n, e, t, r, i, s, o) {
    const a = new Rf
      , l = new wz
      , f = []
      , h = i.isWebGL2
      , d = i.logarithmicDepthBuffer
      , p = i.vertexTextures;
    let m = i.precision;
    const _ = {
        MeshDepthMaterial: "depth",
        MeshDistanceMaterial: "distanceRGBA",
        MeshNormalMaterial: "normal",
        MeshBasicMaterial: "basic",
        MeshLambertMaterial: "lambert",
        MeshPhongMaterial: "phong",
        MeshToonMaterial: "toon",
        MeshStandardMaterial: "physical",
        MeshPhysicalMaterial: "physical",
        MeshMatcapMaterial: "matcap",
        LineBasicMaterial: "basic",
        LineDashedMaterial: "dashed",
        PointsMaterial: "points",
        ShadowMaterial: "shadow",
        SpriteMaterial: "sprite"
    };
    function y(R, O, H, W, te) {
        const ne = W.fog
          , re = te.geometry
          , pe = R.isMeshStandardMaterial ? W.environment : null
          , ce = (R.isMeshStandardMaterial ? t : e).get(R.envMap || pe)
          , xe = ce && ce.mapping === Dh ? ce.image.height : null
          , G = _[R.type];
        R.precision !== null && (m = i.getMaxPrecision(R.precision),
        m !== R.precision && console.warn("THREE.WebGLProgram.getParameters:", R.precision, "not supported, using", m, "instead."));
        const z = re.morphAttributes.position || re.morphAttributes.normal || re.morphAttributes.color
          , U = z !== void 0 ? z.length : 0;
        let fe = 0;
        re.morphAttributes.position !== void 0 && (fe = 1),
        re.morphAttributes.normal !== void 0 && (fe = 2),
        re.morphAttributes.color !== void 0 && (fe = 3);
        let oe, Ae, Ue, je;
        if (G) {
            const gt = yl[G];
            oe = gt.vertexShader,
            Ae = gt.fragmentShader
        } else
            oe = R.vertexShader,
            Ae = R.fragmentShader,
            l.update(R),
            Ue = l.getVertexShaderID(R),
            je = l.getFragmentShaderID(R);
        const de = n.getRenderTarget()
          , qe = R.alphaTest > 0
          , Ne = R.clearcoat > 0
          , Tt = R.iridescence > 0;
        return {
            isWebGL2: h,
            shaderID: G,
            shaderName: R.type,
            vertexShader: oe,
            fragmentShader: Ae,
            defines: R.defines,
            customVertexShaderID: Ue,
            customFragmentShaderID: je,
            isRawShaderMaterial: R.isRawShaderMaterial === !0,
            glslVersion: R.glslVersion,
            precision: m,
            instancing: te.isInstancedMesh === !0,
            instancingColor: te.isInstancedMesh === !0 && te.instanceColor !== null,
            supportsVertexTextures: p,
            outputEncoding: de === null ? n.outputEncoding : de.isXRRenderTarget === !0 ? de.texture.encoding : bl,
            map: !!R.map,
            matcap: !!R.matcap,
            envMap: !!ce,
            envMapMode: ce && ce.mapping,
            envMapCubeUVHeight: xe,
            lightMap: !!R.lightMap,
            aoMap: !!R.aoMap,
            emissiveMap: !!R.emissiveMap,
            bumpMap: !!R.bumpMap,
            normalMap: !!R.normalMap,
            objectSpaceNormalMap: R.normalMapType === K2,
            tangentSpaceNormalMap: R.normalMapType === Ru,
            decodeVideoTexture: !!R.map && R.map.isVideoTexture === !0 && R.map.encoding === nr,
            clearcoat: Ne,
            clearcoatMap: Ne && !!R.clearcoatMap,
            clearcoatRoughnessMap: Ne && !!R.clearcoatRoughnessMap,
            clearcoatNormalMap: Ne && !!R.clearcoatNormalMap,
            iridescence: Tt,
            iridescenceMap: Tt && !!R.iridescenceMap,
            iridescenceThicknessMap: Tt && !!R.iridescenceThicknessMap,
            displacementMap: !!R.displacementMap,
            roughnessMap: !!R.roughnessMap,
            metalnessMap: !!R.metalnessMap,
            specularMap: !!R.specularMap,
            specularIntensityMap: !!R.specularIntensityMap,
            specularColorMap: !!R.specularColorMap,
            opaque: R.transparent === !1 && R.blending === bf,
            alphaMap: !!R.alphaMap,
            alphaTest: qe,
            gradientMap: !!R.gradientMap,
            sheen: R.sheen > 0,
            sheenColorMap: !!R.sheenColorMap,
            sheenRoughnessMap: !!R.sheenRoughnessMap,
            transmission: R.transmission > 0,
            transmissionMap: !!R.transmissionMap,
            thicknessMap: !!R.thicknessMap,
            combine: R.combine,
            vertexTangents: !!R.normalMap && !!re.attributes.tangent,
            vertexColors: R.vertexColors,
            vertexAlphas: R.vertexColors === !0 && !!re.attributes.color && re.attributes.color.itemSize === 4,
            vertexUvs: !!R.map || !!R.bumpMap || !!R.normalMap || !!R.specularMap || !!R.alphaMap || !!R.emissiveMap || !!R.roughnessMap || !!R.metalnessMap || !!R.clearcoatMap || !!R.clearcoatRoughnessMap || !!R.clearcoatNormalMap || !!R.iridescenceMap || !!R.iridescenceThicknessMap || !!R.displacementMap || !!R.transmissionMap || !!R.thicknessMap || !!R.specularIntensityMap || !!R.specularColorMap || !!R.sheenColorMap || !!R.sheenRoughnessMap,
            uvsVertexOnly: !(R.map || R.bumpMap || R.normalMap || R.specularMap || R.alphaMap || R.emissiveMap || R.roughnessMap || R.metalnessMap || R.clearcoatNormalMap || R.iridescenceMap || R.iridescenceThicknessMap || R.transmission > 0 || R.transmissionMap || R.thicknessMap || R.specularIntensityMap || R.specularColorMap || R.sheen > 0 || R.sheenColorMap || R.sheenRoughnessMap) && !!R.displacementMap,
            fog: !!ne,
            useFog: R.fog === !0,
            fogExp2: ne && ne.isFogExp2,
            flatShading: !!R.flatShading,
            sizeAttenuation: R.sizeAttenuation,
            logarithmicDepthBuffer: d,
            skinning: te.isSkinnedMesh === !0,
            morphTargets: re.morphAttributes.position !== void 0,
            morphNormals: re.morphAttributes.normal !== void 0,
            morphColors: re.morphAttributes.color !== void 0,
            morphTargetsCount: U,
            morphTextureStride: fe,
            numDirLights: O.directional.length,
            numPointLights: O.point.length,
            numSpotLights: O.spot.length,
            numSpotLightMaps: O.spotLightMap.length,
            numRectAreaLights: O.rectArea.length,
            numHemiLights: O.hemi.length,
            numDirLightShadows: O.directionalShadowMap.length,
            numPointLightShadows: O.pointShadowMap.length,
            numSpotLightShadows: O.spotShadowMap.length,
            numSpotLightShadowsWithMaps: O.numSpotLightShadowsWithMaps,
            numClippingPlanes: o.numPlanes,
            numClipIntersection: o.numIntersection,
            dithering: R.dithering,
            shadowMapEnabled: n.shadowMap.enabled && H.length > 0,
            shadowMapType: n.shadowMap.type,
            toneMapping: R.toneMapped ? n.toneMapping : Ka,
            physicallyCorrectLights: n.physicallyCorrectLights,
            premultipliedAlpha: R.premultipliedAlpha,
            doubleSided: R.side === Sl,
            flipSided: R.side === Do,
            useDepthPacking: !!R.depthPacking,
            depthPacking: R.depthPacking || 0,
            index0AttributeName: R.index0AttributeName,
            extensionDerivatives: R.extensions && R.extensions.derivatives,
            extensionFragDepth: R.extensions && R.extensions.fragDepth,
            extensionDrawBuffers: R.extensions && R.extensions.drawBuffers,
            extensionShaderTextureLOD: R.extensions && R.extensions.shaderTextureLOD,
            rendererExtensionFragDepth: h || r.has("EXT_frag_depth"),
            rendererExtensionDrawBuffers: h || r.has("WEBGL_draw_buffers"),
            rendererExtensionShaderTextureLod: h || r.has("EXT_shader_texture_lod"),
            customProgramCacheKey: R.customProgramCacheKey()
        }
    }
    function x(R) {
        const O = [];
        if (R.shaderID ? O.push(R.shaderID) : (O.push(R.customVertexShaderID),
        O.push(R.customFragmentShaderID)),
        R.defines !== void 0)
            for (const H in R.defines)
                O.push(H),
                O.push(R.defines[H]);
        return R.isRawShaderMaterial === !1 && (S(O, R),
        M(O, R),
        O.push(n.outputEncoding)),
        O.push(R.customProgramCacheKey),
        O.join()
    }
    function S(R, O) {
        R.push(O.precision),
        R.push(O.outputEncoding),
        R.push(O.envMapMode),
        R.push(O.envMapCubeUVHeight),
        R.push(O.combine),
        R.push(O.vertexUvs),
        R.push(O.fogExp2),
        R.push(O.sizeAttenuation),
        R.push(O.morphTargetsCount),
        R.push(O.morphAttributeCount),
        R.push(O.numDirLights),
        R.push(O.numPointLights),
        R.push(O.numSpotLights),
        R.push(O.numSpotLightMaps),
        R.push(O.numHemiLights),
        R.push(O.numRectAreaLights),
        R.push(O.numDirLightShadows),
        R.push(O.numPointLightShadows),
        R.push(O.numSpotLightShadows),
        R.push(O.numSpotLightShadowsWithMaps),
        R.push(O.shadowMapType),
        R.push(O.toneMapping),
        R.push(O.numClippingPlanes),
        R.push(O.numClipIntersection),
        R.push(O.depthPacking)
    }
    function M(R, O) {
        a.disableAll(),
        O.isWebGL2 && a.enable(0),
        O.supportsVertexTextures && a.enable(1),
        O.instancing && a.enable(2),
        O.instancingColor && a.enable(3),
        O.map && a.enable(4),
        O.matcap && a.enable(5),
        O.envMap && a.enable(6),
        O.lightMap && a.enable(7),
        O.aoMap && a.enable(8),
        O.emissiveMap && a.enable(9),
        O.bumpMap && a.enable(10),
        O.normalMap && a.enable(11),
        O.objectSpaceNormalMap && a.enable(12),
        O.tangentSpaceNormalMap && a.enable(13),
        O.clearcoat && a.enable(14),
        O.clearcoatMap && a.enable(15),
        O.clearcoatRoughnessMap && a.enable(16),
        O.clearcoatNormalMap && a.enable(17),
        O.iridescence && a.enable(18),
        O.iridescenceMap && a.enable(19),
        O.iridescenceThicknessMap && a.enable(20),
        O.displacementMap && a.enable(21),
        O.specularMap && a.enable(22),
        O.roughnessMap && a.enable(23),
        O.metalnessMap && a.enable(24),
        O.gradientMap && a.enable(25),
        O.alphaMap && a.enable(26),
        O.alphaTest && a.enable(27),
        O.vertexColors && a.enable(28),
        O.vertexAlphas && a.enable(29),
        O.vertexUvs && a.enable(30),
        O.vertexTangents && a.enable(31),
        O.uvsVertexOnly && a.enable(32),
        R.push(a.mask),
        a.disableAll(),
        O.fog && a.enable(0),
        O.useFog && a.enable(1),
        O.flatShading && a.enable(2),
        O.logarithmicDepthBuffer && a.enable(3),
        O.skinning && a.enable(4),
        O.morphTargets && a.enable(5),
        O.morphNormals && a.enable(6),
        O.morphColors && a.enable(7),
        O.premultipliedAlpha && a.enable(8),
        O.shadowMapEnabled && a.enable(9),
        O.physicallyCorrectLights && a.enable(10),
        O.doubleSided && a.enable(11),
        O.flipSided && a.enable(12),
        O.useDepthPacking && a.enable(13),
        O.dithering && a.enable(14),
        O.specularIntensityMap && a.enable(15),
        O.specularColorMap && a.enable(16),
        O.transmission && a.enable(17),
        O.transmissionMap && a.enable(18),
        O.thicknessMap && a.enable(19),
        O.sheen && a.enable(20),
        O.sheenColorMap && a.enable(21),
        O.sheenRoughnessMap && a.enable(22),
        O.decodeVideoTexture && a.enable(23),
        O.opaque && a.enable(24),
        R.push(a.mask)
    }
    function w(R) {
        const O = _[R.type];
        let H;
        if (O) {
            const W = yl[O];
            H = WS.clone(W.uniforms)
        } else
            H = R.uniforms;
        return H
    }
    function T(R, O) {
        let H;
        for (let W = 0, te = f.length; W < te; W++) {
            const ne = f[W];
            if (ne.cacheKey === O) {
                H = ne,
                ++H.usedTimes;
                break
            }
        }
        return H === void 0 && (H = new yz(n,O,R,s),
        f.push(H)),
        H
    }
    function P(R) {
        if (--R.usedTimes === 0) {
            const O = f.indexOf(R);
            f[O] = f[f.length - 1],
            f.pop(),
            R.destroy()
        }
    }
    function I(R) {
        l.remove(R)
    }
    function k() {
        l.dispose()
    }
    return {
        getParameters: y,
        getProgramCacheKey: x,
        getUniforms: w,
        acquireProgram: T,
        releaseProgram: P,
        releaseShaderCache: I,
        programs: f,
        dispose: k
    }
}
function Az() {
    let n = new WeakMap;
    function e(s) {
        let o = n.get(s);
        return o === void 0 && (o = {},
        n.set(s, o)),
        o
    }
    function t(s) {
        n.delete(s)
    }
    function r(s, o, a) {
        n.get(s)[o] = a
    }
    function i() {
        n = new WeakMap
    }
    return {
        get: e,
        remove: t,
        update: r,
        dispose: i
    }
}
function Cz(n, e) {
    return n.groupOrder !== e.groupOrder ? n.groupOrder - e.groupOrder : n.renderOrder !== e.renderOrder ? n.renderOrder - e.renderOrder : n.material.id !== e.material.id ? n.material.id - e.material.id : n.z !== e.z ? n.z - e.z : n.id - e.id
}
function QC(n, e) {
    return n.groupOrder !== e.groupOrder ? n.groupOrder - e.groupOrder : n.renderOrder !== e.renderOrder ? n.renderOrder - e.renderOrder : n.z !== e.z ? e.z - n.z : n.id - e.id
}
function ZC() {
    const n = [];
    let e = 0;
    const t = []
      , r = []
      , i = [];
    function s() {
        e = 0,
        t.length = 0,
        r.length = 0,
        i.length = 0
    }
    function o(d, p, m, _, y, x) {
        let S = n[e];
        return S === void 0 ? (S = {
            id: d.id,
            object: d,
            geometry: p,
            material: m,
            groupOrder: _,
            renderOrder: d.renderOrder,
            z: y,
            group: x
        },
        n[e] = S) : (S.id = d.id,
        S.object = d,
        S.geometry = p,
        S.material = m,
        S.groupOrder = _,
        S.renderOrder = d.renderOrder,
        S.z = y,
        S.group = x),
        e++,
        S
    }
    function a(d, p, m, _, y, x) {
        const S = o(d, p, m, _, y, x);
        m.transmission > 0 ? r.push(S) : m.transparent === !0 ? i.push(S) : t.push(S)
    }
    function l(d, p, m, _, y, x) {
        const S = o(d, p, m, _, y, x);
        m.transmission > 0 ? r.unshift(S) : m.transparent === !0 ? i.unshift(S) : t.unshift(S)
    }
    function f(d, p) {
        t.length > 1 && t.sort(d || Cz),
        r.length > 1 && r.sort(p || QC),
        i.length > 1 && i.sort(p || QC)
    }
    function h() {
        for (let d = e, p = n.length; d < p; d++) {
            const m = n[d];
            if (m.id === null)
                break;
            m.id = null,
            m.object = null,
            m.geometry = null,
            m.material = null,
            m.group = null
        }
    }
    return {
        opaque: t,
        transmissive: r,
        transparent: i,
        init: s,
        push: a,
        unshift: l,
        finish: h,
        sort: f
    }
}
function Ez() {
    let n = new WeakMap;
    function e(r, i) {
        const s = n.get(r);
        let o;
        return s === void 0 ? (o = new ZC,
        n.set(r, [o])) : i >= s.length ? (o = new ZC,
        s.push(o)) : o = s[i],
        o
    }
    function t() {
        n = new WeakMap
    }
    return {
        get: e,
        dispose: t
    }
}
function bz() {
    const n = {};
    return {
        get: function(e) {
            if (n[e.id] !== void 0)
                return n[e.id];
            let t;
            switch (e.type) {
            case "DirectionalLight":
                t = {
                    direction: new $,
                    color: new It
                };
                break;
            case "SpotLight":
                t = {
                    position: new $,
                    direction: new $,
                    color: new It,
                    distance: 0,
                    coneCos: 0,
                    penumbraCos: 0,
                    decay: 0
                };
                break;
            case "PointLight":
                t = {
                    position: new $,
                    color: new It,
                    distance: 0,
                    decay: 0
                };
                break;
            case "HemisphereLight":
                t = {
                    direction: new $,
                    skyColor: new It,
                    groundColor: new It
                };
                break;
            case "RectAreaLight":
                t = {
                    color: new It,
                    position: new $,
                    halfWidth: new $,
                    halfHeight: new $
                };
                break
            }
            return n[e.id] = t,
            t
        }
    }
}
function Tz() {
    const n = {};
    return {
        get: function(e) {
            if (n[e.id] !== void 0)
                return n[e.id];
            let t;
            switch (e.type) {
            case "DirectionalLight":
                t = {
                    shadowBias: 0,
                    shadowNormalBias: 0,
                    shadowRadius: 1,
                    shadowMapSize: new it
                };
                break;
            case "SpotLight":
                t = {
                    shadowBias: 0,
                    shadowNormalBias: 0,
                    shadowRadius: 1,
                    shadowMapSize: new it
                };
                break;
            case "PointLight":
                t = {
                    shadowBias: 0,
                    shadowNormalBias: 0,
                    shadowRadius: 1,
                    shadowMapSize: new it,
                    shadowCameraNear: 1,
                    shadowCameraFar: 1e3
                };
                break
            }
            return n[e.id] = t,
            t
        }
    }
}
let Dz = 0;
function Pz(n, e) {
    return (e.castShadow ? 2 : 0) - (n.castShadow ? 2 : 0) + (e.map ? 1 : 0) - (n.map ? 1 : 0)
}
function Rz(n, e) {
    const t = new bz
      , r = Tz()
      , i = {
        version: 0,
        hash: {
            directionalLength: -1,
            pointLength: -1,
            spotLength: -1,
            rectAreaLength: -1,
            hemiLength: -1,
            numDirectionalShadows: -1,
            numPointShadows: -1,
            numSpotShadows: -1,
            numSpotMaps: -1
        },
        ambient: [0, 0, 0],
        probe: [],
        directional: [],
        directionalShadow: [],
        directionalShadowMap: [],
        directionalShadowMatrix: [],
        spot: [],
        spotLightMap: [],
        spotShadow: [],
        spotShadowMap: [],
        spotLightMatrix: [],
        rectArea: [],
        rectAreaLTC1: null,
        rectAreaLTC2: null,
        point: [],
        pointShadow: [],
        pointShadowMap: [],
        pointShadowMatrix: [],
        hemi: [],
        numSpotLightShadowsWithMaps: 0
    };
    for (let h = 0; h < 9; h++)
        i.probe.push(new $);
    const s = new $
      , o = new Dn
      , a = new Dn;
    function l(h, d) {
        let p = 0
          , m = 0
          , _ = 0;
        for (let W = 0; W < 9; W++)
            i.probe[W].set(0, 0, 0);
        let y = 0
          , x = 0
          , S = 0
          , M = 0
          , w = 0
          , T = 0
          , P = 0
          , I = 0
          , k = 0
          , R = 0;
        h.sort(Pz);
        const O = d !== !0 ? Math.PI : 1;
        for (let W = 0, te = h.length; W < te; W++) {
            const ne = h[W]
              , re = ne.color
              , pe = ne.intensity
              , ce = ne.distance
              , xe = ne.shadow && ne.shadow.map ? ne.shadow.map.texture : null;
            if (ne.isAmbientLight)
                p += re.r * pe * O,
                m += re.g * pe * O,
                _ += re.b * pe * O;
            else if (ne.isLightProbe)
                for (let G = 0; G < 9; G++)
                    i.probe[G].addScaledVector(ne.sh.coefficients[G], pe);
            else if (ne.isDirectionalLight) {
                const G = t.get(ne);
                if (G.color.copy(ne.color).multiplyScalar(ne.intensity * O),
                ne.castShadow) {
                    const z = ne.shadow
                      , U = r.get(ne);
                    U.shadowBias = z.bias,
                    U.shadowNormalBias = z.normalBias,
                    U.shadowRadius = z.radius,
                    U.shadowMapSize = z.mapSize,
                    i.directionalShadow[y] = U,
                    i.directionalShadowMap[y] = xe,
                    i.directionalShadowMatrix[y] = ne.shadow.matrix,
                    T++
                }
                i.directional[y] = G,
                y++
            } else if (ne.isSpotLight) {
                const G = t.get(ne);
                G.position.setFromMatrixPosition(ne.matrixWorld),
                G.color.copy(re).multiplyScalar(pe * O),
                G.distance = ce,
                G.coneCos = Math.cos(ne.angle),
                G.penumbraCos = Math.cos(ne.angle * (1 - ne.penumbra)),
                G.decay = ne.decay,
                i.spot[S] = G;
                const z = ne.shadow;
                if (ne.map && (i.spotLightMap[k] = ne.map,
                k++,
                z.updateMatrices(ne),
                ne.castShadow && R++),
                i.spotLightMatrix[S] = z.matrix,
                ne.castShadow) {
                    const U = r.get(ne);
                    U.shadowBias = z.bias,
                    U.shadowNormalBias = z.normalBias,
                    U.shadowRadius = z.radius,
                    U.shadowMapSize = z.mapSize,
                    i.spotShadow[S] = U,
                    i.spotShadowMap[S] = xe,
                    I++
                }
                S++
            } else if (ne.isRectAreaLight) {
                const G = t.get(ne);
                G.color.copy(re).multiplyScalar(pe),
                G.halfWidth.set(ne.width * .5, 0, 0),
                G.halfHeight.set(0, ne.height * .5, 0),
                i.rectArea[M] = G,
                M++
            } else if (ne.isPointLight) {
                const G = t.get(ne);
                if (G.color.copy(ne.color).multiplyScalar(ne.intensity * O),
                G.distance = ne.distance,
                G.decay = ne.decay,
                ne.castShadow) {
                    const z = ne.shadow
                      , U = r.get(ne);
                    U.shadowBias = z.bias,
                    U.shadowNormalBias = z.normalBias,
                    U.shadowRadius = z.radius,
                    U.shadowMapSize = z.mapSize,
                    U.shadowCameraNear = z.camera.near,
                    U.shadowCameraFar = z.camera.far,
                    i.pointShadow[x] = U,
                    i.pointShadowMap[x] = xe,
                    i.pointShadowMatrix[x] = ne.shadow.matrix,
                    P++
                }
                i.point[x] = G,
                x++
            } else if (ne.isHemisphereLight) {
                const G = t.get(ne);
                G.skyColor.copy(ne.color).multiplyScalar(pe * O),
                G.groundColor.copy(ne.groundColor).multiplyScalar(pe * O),
                i.hemi[w] = G,
                w++
            }
        }
        M > 0 && (e.isWebGL2 || n.has("OES_texture_float_linear") === !0 ? (i.rectAreaLTC1 = Lt.LTC_FLOAT_1,
        i.rectAreaLTC2 = Lt.LTC_FLOAT_2) : n.has("OES_texture_half_float_linear") === !0 ? (i.rectAreaLTC1 = Lt.LTC_HALF_1,
        i.rectAreaLTC2 = Lt.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")),
        i.ambient[0] = p,
        i.ambient[1] = m,
        i.ambient[2] = _;
        const H = i.hash;
        (H.directionalLength !== y || H.pointLength !== x || H.spotLength !== S || H.rectAreaLength !== M || H.hemiLength !== w || H.numDirectionalShadows !== T || H.numPointShadows !== P || H.numSpotShadows !== I || H.numSpotMaps !== k) && (i.directional.length = y,
        i.spot.length = S,
        i.rectArea.length = M,
        i.point.length = x,
        i.hemi.length = w,
        i.directionalShadow.length = T,
        i.directionalShadowMap.length = T,
        i.pointShadow.length = P,
        i.pointShadowMap.length = P,
        i.spotShadow.length = I,
        i.spotShadowMap.length = I,
        i.directionalShadowMatrix.length = T,
        i.pointShadowMatrix.length = P,
        i.spotLightMatrix.length = I + k - R,
        i.spotLightMap.length = k,
        i.numSpotLightShadowsWithMaps = R,
        H.directionalLength = y,
        H.pointLength = x,
        H.spotLength = S,
        H.rectAreaLength = M,
        H.hemiLength = w,
        H.numDirectionalShadows = T,
        H.numPointShadows = P,
        H.numSpotShadows = I,
        H.numSpotMaps = k,
        i.version = Dz++)
    }
    function f(h, d) {
        let p = 0
          , m = 0
          , _ = 0
          , y = 0
          , x = 0;
        const S = d.matrixWorldInverse;
        for (let M = 0, w = h.length; M < w; M++) {
            const T = h[M];
            if (T.isDirectionalLight) {
                const P = i.directional[p];
                P.direction.setFromMatrixPosition(T.matrixWorld),
                s.setFromMatrixPosition(T.target.matrixWorld),
                P.direction.sub(s),
                P.direction.transformDirection(S),
                p++
            } else if (T.isSpotLight) {
                const P = i.spot[_];
                P.position.setFromMatrixPosition(T.matrixWorld),
                P.position.applyMatrix4(S),
                P.direction.setFromMatrixPosition(T.matrixWorld),
                s.setFromMatrixPosition(T.target.matrixWorld),
                P.direction.sub(s),
                P.direction.transformDirection(S),
                _++
            } else if (T.isRectAreaLight) {
                const P = i.rectArea[y];
                P.position.setFromMatrixPosition(T.matrixWorld),
                P.position.applyMatrix4(S),
                a.identity(),
                o.copy(T.matrixWorld),
                o.premultiply(S),
                a.extractRotation(o),
                P.halfWidth.set(T.width * .5, 0, 0),
                P.halfHeight.set(0, T.height * .5, 0),
                P.halfWidth.applyMatrix4(a),
                P.halfHeight.applyMatrix4(a),
                y++
            } else if (T.isPointLight) {
                const P = i.point[m];
                P.position.setFromMatrixPosition(T.matrixWorld),
                P.position.applyMatrix4(S),
                m++
            } else if (T.isHemisphereLight) {
                const P = i.hemi[x];
                P.direction.setFromMatrixPosition(T.matrixWorld),
                P.direction.transformDirection(S),
                x++
            }
        }
    }
    return {
        setup: l,
        setupView: f,
        state: i
    }
}
function $C(n, e) {
    const t = new Rz(n,e)
      , r = []
      , i = [];
    function s() {
        r.length = 0,
        i.length = 0
    }
    function o(d) {
        r.push(d)
    }
    function a(d) {
        i.push(d)
    }
    function l(d) {
        t.setup(r, d)
    }
    function f(d) {
        t.setupView(r, d)
    }
    return {
        init: s,
        state: {
            lightsArray: r,
            shadowsArray: i,
            lights: t
        },
        setupLights: l,
        setupLightsView: f,
        pushLight: o,
        pushShadow: a
    }
}
function Bz(n, e) {
    let t = new WeakMap;
    function r(s, o=0) {
        const a = t.get(s);
        let l;
        return a === void 0 ? (l = new $C(n,e),
        t.set(s, [l])) : o >= a.length ? (l = new $C(n,e),
        a.push(l)) : l = a[o],
        l
    }
    function i() {
        t = new WeakMap
    }
    return {
        get: r,
        dispose: i
    }
}
class jS extends as {
    constructor(e) {
        super(),
        this.isMeshDepthMaterial = !0,
        this.type = "MeshDepthMaterial",
        this.depthPacking = j2,
        this.map = null,
        this.alphaMap = null,
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.depthPacking = e.depthPacking,
        this.map = e.map,
        this.alphaMap = e.alphaMap,
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this
    }
}
class YS extends as {
    constructor(e) {
        super(),
        this.isMeshDistanceMaterial = !0,
        this.type = "MeshDistanceMaterial",
        this.referencePosition = new $,
        this.nearDistance = 1,
        this.farDistance = 1e3,
        this.map = null,
        this.alphaMap = null,
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.referencePosition.copy(e.referencePosition),
        this.nearDistance = e.nearDistance,
        this.farDistance = e.farDistance,
        this.map = e.map,
        this.alphaMap = e.alphaMap,
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this
    }
}
const Iz = `void main() {
	gl_Position = vec4( position, 1.0 );
}`
  , Lz = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;
function Fz(n, e, t) {
    let r = new w_;
    const i = new it
      , s = new it
      , o = new zr
      , a = new jS({
        depthPacking: Y2
    })
      , l = new YS
      , f = {}
      , h = t.maxTextureSize
      , d = {
        [El]: Do,
        [Do]: El,
        [Sl]: Sl
    }
      , p = new el({
        defines: {
            VSM_SAMPLES: 8
        },
        uniforms: {
            shadow_pass: {
                value: null
            },
            resolution: {
                value: new it
            },
            radius: {
                value: 4
            }
        },
        vertexShader: Iz,
        fragmentShader: Lz
    })
      , m = p.clone();
    m.defines.HORIZONTAL_PASS = 1;
    const _ = new On;
    _.setAttribute("position", new Dr(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]),3));
    const y = new vs(_,p)
      , x = this;
    this.enabled = !1,
    this.autoUpdate = !0,
    this.needsUpdate = !1,
    this.type = m_,
    this.render = function(T, P, I) {
        if (x.enabled === !1 || x.autoUpdate === !1 && x.needsUpdate === !1 || T.length === 0)
            return;
        const k = n.getRenderTarget()
          , R = n.getActiveCubeFace()
          , O = n.getActiveMipmapLevel()
          , H = n.state;
        H.setBlending(Su),
        H.buffers.color.setClear(1, 1, 1, 1),
        H.buffers.depth.setTest(!0),
        H.setScissorTest(!1);
        for (let W = 0, te = T.length; W < te; W++) {
            const ne = T[W]
              , re = ne.shadow;
            if (re === void 0) {
                console.warn("THREE.WebGLShadowMap:", ne, "has no shadow.");
                continue
            }
            if (re.autoUpdate === !1 && re.needsUpdate === !1)
                continue;
            i.copy(re.mapSize);
            const pe = re.getFrameExtents();
            if (i.multiply(pe),
            s.copy(re.mapSize),
            (i.x > h || i.y > h) && (i.x > h && (s.x = Math.floor(h / pe.x),
            i.x = s.x * pe.x,
            re.mapSize.x = s.x),
            i.y > h && (s.y = Math.floor(h / pe.y),
            i.y = s.y * pe.y,
            re.mapSize.y = s.y)),
            re.map === null) {
                const xe = this.type !== yf ? {
                    minFilter: Ji,
                    magFilter: Ji
                } : {};
                re.map = new $a(i.x,i.y,xe),
                re.map.texture.name = ne.name + ".shadowMap",
                re.camera.updateProjectionMatrix()
            }
            n.setRenderTarget(re.map),
            n.clear();
            const ce = re.getViewportCount();
            for (let xe = 0; xe < ce; xe++) {
                const G = re.getViewport(xe);
                o.set(s.x * G.x, s.y * G.y, s.x * G.z, s.y * G.w),
                H.viewport(o),
                re.updateMatrices(ne, xe),
                r = re.getFrustum(),
                w(P, I, re.camera, ne, this.type)
            }
            re.isPointLightShadow !== !0 && this.type === yf && S(re, I),
            re.needsUpdate = !1
        }
        x.needsUpdate = !1,
        n.setRenderTarget(k, R, O)
    }
    ;
    function S(T, P) {
        const I = e.update(y);
        p.defines.VSM_SAMPLES !== T.blurSamples && (p.defines.VSM_SAMPLES = T.blurSamples,
        m.defines.VSM_SAMPLES = T.blurSamples,
        p.needsUpdate = !0,
        m.needsUpdate = !0),
        T.mapPass === null && (T.mapPass = new $a(i.x,i.y)),
        p.uniforms.shadow_pass.value = T.map.texture,
        p.uniforms.resolution.value = T.mapSize,
        p.uniforms.radius.value = T.radius,
        n.setRenderTarget(T.mapPass),
        n.clear(),
        n.renderBufferDirect(P, null, I, p, y, null),
        m.uniforms.shadow_pass.value = T.mapPass.texture,
        m.uniforms.resolution.value = T.mapSize,
        m.uniforms.radius.value = T.radius,
        n.setRenderTarget(T.map),
        n.clear(),
        n.renderBufferDirect(P, null, I, m, y, null)
    }
    function M(T, P, I, k, R, O) {
        let H = null;
        const W = I.isPointLight === !0 ? T.customDistanceMaterial : T.customDepthMaterial;
        if (W !== void 0)
            H = W;
        else if (H = I.isPointLight === !0 ? l : a,
        n.localClippingEnabled && P.clipShadows === !0 && Array.isArray(P.clippingPlanes) && P.clippingPlanes.length !== 0 || P.displacementMap && P.displacementScale !== 0 || P.alphaMap && P.alphaTest > 0 || P.map && P.alphaTest > 0) {
            const te = H.uuid
              , ne = P.uuid;
            let re = f[te];
            re === void 0 && (re = {},
            f[te] = re);
            let pe = re[ne];
            pe === void 0 && (pe = H.clone(),
            re[ne] = pe),
            H = pe
        }
        return H.visible = P.visible,
        H.wireframe = P.wireframe,
        O === yf ? H.side = P.shadowSide !== null ? P.shadowSide : P.side : H.side = P.shadowSide !== null ? P.shadowSide : d[P.side],
        H.alphaMap = P.alphaMap,
        H.alphaTest = P.alphaTest,
        H.map = P.map,
        H.clipShadows = P.clipShadows,
        H.clippingPlanes = P.clippingPlanes,
        H.clipIntersection = P.clipIntersection,
        H.displacementMap = P.displacementMap,
        H.displacementScale = P.displacementScale,
        H.displacementBias = P.displacementBias,
        H.wireframeLinewidth = P.wireframeLinewidth,
        H.linewidth = P.linewidth,
        I.isPointLight === !0 && H.isMeshDistanceMaterial === !0 && (H.referencePosition.setFromMatrixPosition(I.matrixWorld),
        H.nearDistance = k,
        H.farDistance = R),
        H
    }
    function w(T, P, I, k, R) {
        if (T.visible === !1)
            return;
        if (T.layers.test(P.layers) && (T.isMesh || T.isLine || T.isPoints) && (T.castShadow || T.receiveShadow && R === yf) && (!T.frustumCulled || r.intersectsObject(T))) {
            T.modelViewMatrix.multiplyMatrices(I.matrixWorldInverse, T.matrixWorld);
            const W = e.update(T)
              , te = T.material;
            if (Array.isArray(te)) {
                const ne = W.groups;
                for (let re = 0, pe = ne.length; re < pe; re++) {
                    const ce = ne[re]
                      , xe = te[ce.materialIndex];
                    if (xe && xe.visible) {
                        const G = M(T, xe, k, I.near, I.far, R);
                        n.renderBufferDirect(I, null, W, G, T, ce)
                    }
                }
            } else if (te.visible) {
                const ne = M(T, te, k, I.near, I.far, R);
                n.renderBufferDirect(I, null, W, ne, T, null)
            }
        }
        const H = T.children;
        for (let W = 0, te = H.length; W < te; W++)
            w(H[W], P, I, k, R)
    }
}
function kz(n, e, t) {
    const r = t.isWebGL2;
    function i() {
        let ae = !1;
        const De = new zr;
        let Je = null;
        const vt = new zr(0,0,0,0);
        return {
            setMask: function(Et) {
                Je !== Et && !ae && (n.colorMask(Et, Et, Et, Et),
                Je = Et)
            },
            setLocked: function(Et) {
                ae = Et
            },
            setClear: function(Et, rn, dn, or, mn) {
                mn === !0 && (Et *= or,
                rn *= or,
                dn *= or),
                De.set(Et, rn, dn, or),
                vt.equals(De) === !1 && (n.clearColor(Et, rn, dn, or),
                vt.copy(De))
            },
            reset: function() {
                ae = !1,
                Je = null,
                vt.set(-1, 0, 0, 0)
            }
        }
    }
    function s() {
        let ae = !1
          , De = null
          , Je = null
          , vt = null;
        return {
            setTest: function(Et) {
                Et ? qe(2929) : Ne(2929)
            },
            setMask: function(Et) {
                De !== Et && !ae && (n.depthMask(Et),
                De = Et)
            },
            setFunc: function(Et) {
                if (Je !== Et) {
                    switch (Et) {
                    case m2:
                        n.depthFunc(512);
                        break;
                    case g2:
                        n.depthFunc(519);
                        break;
                    case v2:
                        n.depthFunc(513);
                        break;
                    case Hv:
                        n.depthFunc(515);
                        break;
                    case _2:
                        n.depthFunc(514);
                        break;
                    case y2:
                        n.depthFunc(518);
                        break;
                    case x2:
                        n.depthFunc(516);
                        break;
                    case w2:
                        n.depthFunc(517);
                        break;
                    default:
                        n.depthFunc(515)
                    }
                    Je = Et
                }
            },
            setLocked: function(Et) {
                ae = Et
            },
            setClear: function(Et) {
                vt !== Et && (n.clearDepth(Et),
                vt = Et)
            },
            reset: function() {
                ae = !1,
                De = null,
                Je = null,
                vt = null
            }
        }
    }
    function o() {
        let ae = !1
          , De = null
          , Je = null
          , vt = null
          , Et = null
          , rn = null
          , dn = null
          , or = null
          , mn = null;
        return {
            setTest: function(St) {
                ae || (St ? qe(2960) : Ne(2960))
            },
            setMask: function(St) {
                De !== St && !ae && (n.stencilMask(St),
                De = St)
            },
            setFunc: function(St, ut, Nt) {
                (Je !== St || vt !== ut || Et !== Nt) && (n.stencilFunc(St, ut, Nt),
                Je = St,
                vt = ut,
                Et = Nt)
            },
            setOp: function(St, ut, Nt) {
                (rn !== St || dn !== ut || or !== Nt) && (n.stencilOp(St, ut, Nt),
                rn = St,
                dn = ut,
                or = Nt)
            },
            setLocked: function(St) {
                ae = St
            },
            setClear: function(St) {
                mn !== St && (n.clearStencil(St),
                mn = St)
            },
            reset: function() {
                ae = !1,
                De = null,
                Je = null,
                vt = null,
                Et = null,
                rn = null,
                dn = null,
                or = null,
                mn = null
            }
        }
    }
    const a = new i
      , l = new s
      , f = new o
      , h = new WeakMap
      , d = new WeakMap;
    let p = {}
      , m = {}
      , _ = new WeakMap
      , y = []
      , x = null
      , S = !1
      , M = null
      , w = null
      , T = null
      , P = null
      , I = null
      , k = null
      , R = null
      , O = !1
      , H = null
      , W = null
      , te = null
      , ne = null
      , re = null;
    const pe = n.getParameter(35661);
    let ce = !1
      , xe = 0;
    const G = n.getParameter(7938);
    G.indexOf("WebGL") !== -1 ? (xe = parseFloat(/^WebGL (\d)/.exec(G)[1]),
    ce = xe >= 1) : G.indexOf("OpenGL ES") !== -1 && (xe = parseFloat(/^OpenGL ES (\d)/.exec(G)[1]),
    ce = xe >= 2);
    let z = null
      , U = {};
    const fe = n.getParameter(3088)
      , oe = n.getParameter(2978)
      , Ae = new zr().fromArray(fe)
      , Ue = new zr().fromArray(oe);
    function je(ae, De, Je) {
        const vt = new Uint8Array(4)
          , Et = n.createTexture();
        n.bindTexture(ae, Et),
        n.texParameteri(ae, 10241, 9728),
        n.texParameteri(ae, 10240, 9728);
        for (let rn = 0; rn < Je; rn++)
            n.texImage2D(De + rn, 0, 6408, 1, 1, 0, 6408, 5121, vt);
        return Et
    }
    const de = {};
    de[3553] = je(3553, 3553, 1),
    de[34067] = je(34067, 34069, 6),
    a.setClear(0, 0, 0, 1),
    l.setClear(1),
    f.setClear(0),
    qe(2929),
    l.setFunc(Hv),
    Ce(!1),
    ee(L1),
    qe(2884),
    at(Su);
    function qe(ae) {
        p[ae] !== !0 && (n.enable(ae),
        p[ae] = !0)
    }
    function Ne(ae) {
        p[ae] !== !1 && (n.disable(ae),
        p[ae] = !1)
    }
    function Tt(ae, De) {
        return m[ae] !== De ? (n.bindFramebuffer(ae, De),
        m[ae] = De,
        r && (ae === 36009 && (m[36160] = De),
        ae === 36160 && (m[36009] = De)),
        !0) : !1
    }
    function He(ae, De) {
        let Je = y
          , vt = !1;
        if (ae)
            if (Je = _.get(De),
            Je === void 0 && (Je = [],
            _.set(De, Je)),
            ae.isWebGLMultipleRenderTargets) {
                const Et = ae.texture;
                if (Je.length !== Et.length || Je[0] !== 36064) {
                    for (let rn = 0, dn = Et.length; rn < dn; rn++)
                        Je[rn] = 36064 + rn;
                    Je.length = Et.length,
                    vt = !0
                }
            } else
                Je[0] !== 36064 && (Je[0] = 36064,
                vt = !0);
        else
            Je[0] !== 1029 && (Je[0] = 1029,
            vt = !0);
        vt && (t.isWebGL2 ? n.drawBuffers(Je) : e.get("WEBGL_draw_buffers").drawBuffersWEBGL(Je))
    }
    function gt(ae) {
        return x !== ae ? (n.useProgram(ae),
        x = ae,
        !0) : !1
    }
    const be = {
        [pf]: 32774,
        [i2]: 32778,
        [s2]: 32779
    };
    if (r)
        be[N1] = 32775,
        be[z1] = 32776;
    else {
        const ae = e.get("EXT_blend_minmax");
        ae !== null && (be[N1] = ae.MIN_EXT,
        be[z1] = ae.MAX_EXT)
    }
    const Ee = {
        [o2]: 0,
        [a2]: 1,
        [l2]: 768,
        [IS]: 770,
        [p2]: 776,
        [d2]: 774,
        [c2]: 772,
        [u2]: 769,
        [LS]: 771,
        [h2]: 775,
        [f2]: 773
    };
    function at(ae, De, Je, vt, Et, rn, dn, or) {
        if (ae === Su) {
            S === !0 && (Ne(3042),
            S = !1);
            return
        }
        if (S === !1 && (qe(3042),
        S = !0),
        ae !== r2) {
            if (ae !== M || or !== O) {
                if ((w !== pf || I !== pf) && (n.blendEquation(32774),
                w = pf,
                I = pf),
                or)
                    switch (ae) {
                    case bf:
                        n.blendFuncSeparate(1, 771, 1, 771);
                        break;
                    case F1:
                        n.blendFunc(1, 1);
                        break;
                    case k1:
                        n.blendFuncSeparate(0, 769, 0, 1);
                        break;
                    case O1:
                        n.blendFuncSeparate(0, 768, 0, 770);
                        break;
                    default:
                        console.error("THREE.WebGLState: Invalid blending: ", ae);
                        break
                    }
                else
                    switch (ae) {
                    case bf:
                        n.blendFuncSeparate(770, 771, 1, 771);
                        break;
                    case F1:
                        n.blendFunc(770, 1);
                        break;
                    case k1:
                        n.blendFuncSeparate(0, 769, 0, 1);
                        break;
                    case O1:
                        n.blendFunc(0, 768);
                        break;
                    default:
                        console.error("THREE.WebGLState: Invalid blending: ", ae);
                        break
                    }
                T = null,
                P = null,
                k = null,
                R = null,
                M = ae,
                O = or
            }
            return
        }
        Et = Et || De,
        rn = rn || Je,
        dn = dn || vt,
        (De !== w || Et !== I) && (n.blendEquationSeparate(be[De], be[Et]),
        w = De,
        I = Et),
        (Je !== T || vt !== P || rn !== k || dn !== R) && (n.blendFuncSeparate(Ee[Je], Ee[vt], Ee[rn], Ee[dn]),
        T = Je,
        P = vt,
        k = rn,
        R = dn),
        M = ae,
        O = !1
    }
    function _t(ae, De) {
        ae.side === Sl ? Ne(2884) : qe(2884);
        let Je = ae.side === Do;
        De && (Je = !Je),
        Ce(Je),
        ae.blending === bf && ae.transparent === !1 ? at(Su) : at(ae.blending, ae.blendEquation, ae.blendSrc, ae.blendDst, ae.blendEquationAlpha, ae.blendSrcAlpha, ae.blendDstAlpha, ae.premultipliedAlpha),
        l.setFunc(ae.depthFunc),
        l.setTest(ae.depthTest),
        l.setMask(ae.depthWrite),
        a.setMask(ae.colorWrite);
        const vt = ae.stencilWrite;
        f.setTest(vt),
        vt && (f.setMask(ae.stencilWriteMask),
        f.setFunc(ae.stencilFunc, ae.stencilRef, ae.stencilFuncMask),
        f.setOp(ae.stencilFail, ae.stencilZFail, ae.stencilZPass)),
        Ze(ae.polygonOffset, ae.polygonOffsetFactor, ae.polygonOffsetUnits),
        ae.alphaToCoverage === !0 ? qe(32926) : Ne(32926)
    }
    function Ce(ae) {
        H !== ae && (ae ? n.frontFace(2304) : n.frontFace(2305),
        H = ae)
    }
    function ee(ae) {
        ae !== e2 ? (qe(2884),
        ae !== W && (ae === L1 ? n.cullFace(1029) : ae === t2 ? n.cullFace(1028) : n.cullFace(1032))) : Ne(2884),
        W = ae
    }
    function et(ae) {
        ae !== te && (ce && n.lineWidth(ae),
        te = ae)
    }
    function Ze(ae, De, Je) {
        ae ? (qe(32823),
        (ne !== De || re !== Je) && (n.polygonOffset(De, Je),
        ne = De,
        re = Je)) : Ne(32823)
    }
    function ft(ae) {
        ae ? qe(3089) : Ne(3089)
    }
    function Pt(ae) {
        ae === void 0 && (ae = 33984 + pe - 1),
        z !== ae && (n.activeTexture(ae),
        z = ae)
    }
    function Z(ae, De, Je) {
        Je === void 0 && (z === null ? Je = 33984 + pe - 1 : Je = z);
        let vt = U[Je];
        vt === void 0 && (vt = {
            type: void 0,
            texture: void 0
        },
        U[Je] = vt),
        (vt.type !== ae || vt.texture !== De) && (z !== Je && (n.activeTexture(Je),
        z = Je),
        n.bindTexture(ae, De || de[ae]),
        vt.type = ae,
        vt.texture = De)
    }
    function V() {
        const ae = U[z];
        ae !== void 0 && ae.type !== void 0 && (n.bindTexture(ae.type, null),
        ae.type = void 0,
        ae.texture = void 0)
    }
    function ye() {
        try {
            n.compressedTexImage2D.apply(n, arguments)
        } catch (ae) {
            console.error("THREE.WebGLState:", ae)
        }
    }
    function tt() {
        try {
            n.compressedTexImage3D.apply(n, arguments)
        } catch (ae) {
            console.error("THREE.WebGLState:", ae)
        }
    }
    function Ve() {
        try {
            n.texSubImage2D.apply(n, arguments)
        } catch (ae) {
            console.error("THREE.WebGLState:", ae)
        }
    }
    function Ke() {
        try {
            n.texSubImage3D.apply(n, arguments)
        } catch (ae) {
            console.error("THREE.WebGLState:", ae)
        }
    }
    function dt() {
        try {
            n.compressedTexSubImage2D.apply(n, arguments)
        } catch (ae) {
            console.error("THREE.WebGLState:", ae)
        }
    }
    function ct() {
        try {
            n.compressedTexSubImage3D.apply(n, arguments)
        } catch (ae) {
            console.error("THREE.WebGLState:", ae)
        }
    }
    function Fe() {
        try {
            n.texStorage2D.apply(n, arguments)
        } catch (ae) {
            console.error("THREE.WebGLState:", ae)
        }
    }
    function Rt() {
        try {
            n.texStorage3D.apply(n, arguments)
        } catch (ae) {
            console.error("THREE.WebGLState:", ae)
        }
    }
    function le() {
        try {
            n.texImage2D.apply(n, arguments)
        } catch (ae) {
            console.error("THREE.WebGLState:", ae)
        }
    }
    function Le() {
        try {
            n.texImage3D.apply(n, arguments)
        } catch (ae) {
            console.error("THREE.WebGLState:", ae)
        }
    }
    function rt(ae) {
        Ae.equals(ae) === !1 && (n.scissor(ae.x, ae.y, ae.z, ae.w),
        Ae.copy(ae))
    }
    function st(ae) {
        Ue.equals(ae) === !1 && (n.viewport(ae.x, ae.y, ae.z, ae.w),
        Ue.copy(ae))
    }
    function Ut(ae, De) {
        let Je = d.get(De);
        Je === void 0 && (Je = new WeakMap,
        d.set(De, Je));
        let vt = Je.get(ae);
        vt === void 0 && (vt = n.getUniformBlockIndex(De, ae.name),
        Je.set(ae, vt))
    }
    function Mt(ae, De) {
        const vt = d.get(De).get(ae);
        h.get(De) !== vt && (n.uniformBlockBinding(De, vt, ae.__bindingPointIndex),
        h.set(De, vt))
    }
    function wn() {
        n.disable(3042),
        n.disable(2884),
        n.disable(2929),
        n.disable(32823),
        n.disable(3089),
        n.disable(2960),
        n.disable(32926),
        n.blendEquation(32774),
        n.blendFunc(1, 0),
        n.blendFuncSeparate(1, 0, 1, 0),
        n.colorMask(!0, !0, !0, !0),
        n.clearColor(0, 0, 0, 0),
        n.depthMask(!0),
        n.depthFunc(513),
        n.clearDepth(1),
        n.stencilMask(4294967295),
        n.stencilFunc(519, 0, 4294967295),
        n.stencilOp(7680, 7680, 7680),
        n.clearStencil(0),
        n.cullFace(1029),
        n.frontFace(2305),
        n.polygonOffset(0, 0),
        n.activeTexture(33984),
        n.bindFramebuffer(36160, null),
        r === !0 && (n.bindFramebuffer(36009, null),
        n.bindFramebuffer(36008, null)),
        n.useProgram(null),
        n.lineWidth(1),
        n.scissor(0, 0, n.canvas.width, n.canvas.height),
        n.viewport(0, 0, n.canvas.width, n.canvas.height),
        p = {},
        z = null,
        U = {},
        m = {},
        _ = new WeakMap,
        y = [],
        x = null,
        S = !1,
        M = null,
        w = null,
        T = null,
        P = null,
        I = null,
        k = null,
        R = null,
        O = !1,
        H = null,
        W = null,
        te = null,
        ne = null,
        re = null,
        Ae.set(0, 0, n.canvas.width, n.canvas.height),
        Ue.set(0, 0, n.canvas.width, n.canvas.height),
        a.reset(),
        l.reset(),
        f.reset()
    }
    return {
        buffers: {
            color: a,
            depth: l,
            stencil: f
        },
        enable: qe,
        disable: Ne,
        bindFramebuffer: Tt,
        drawBuffers: He,
        useProgram: gt,
        setBlending: at,
        setMaterial: _t,
        setFlipSided: Ce,
        setCullFace: ee,
        setLineWidth: et,
        setPolygonOffset: Ze,
        setScissorTest: ft,
        activeTexture: Pt,
        bindTexture: Z,
        unbindTexture: V,
        compressedTexImage2D: ye,
        compressedTexImage3D: tt,
        texImage2D: le,
        texImage3D: Le,
        updateUBOMapping: Ut,
        uniformBlockBinding: Mt,
        texStorage2D: Fe,
        texStorage3D: Rt,
        texSubImage2D: Ve,
        texSubImage3D: Ke,
        compressedTexSubImage2D: dt,
        compressedTexSubImage3D: ct,
        scissor: rt,
        viewport: st,
        reset: wn
    }
}
function Oz(n, e, t, r, i, s, o) {
    const a = i.isWebGL2
      , l = i.maxTextures
      , f = i.maxCubemapSize
      , h = i.maxTextureSize
      , d = i.maxSamples
      , p = e.has("WEBGL_multisampled_render_to_texture") ? e.get("WEBGL_multisampled_render_to_texture") : null
      , m = typeof navigator > "u" ? !1 : /OculusBrowser/g.test(navigator.userAgent)
      , _ = new WeakMap;
    let y;
    const x = new WeakMap;
    let S = !1;
    try {
        S = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1,1).getContext("2d") !== null
    } catch {}
    function M(Z, V) {
        return S ? new OffscreenCanvas(Z,V) : _m("canvas")
    }
    function w(Z, V, ye, tt) {
        let Ve = 1;
        if ((Z.width > tt || Z.height > tt) && (Ve = tt / Math.max(Z.width, Z.height)),
        Ve < 1 || V === !0)
            if (typeof HTMLImageElement < "u" && Z instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && Z instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && Z instanceof ImageBitmap) {
                const Ke = V ? Wv : Math.floor
                  , dt = Ke(Ve * Z.width)
                  , ct = Ke(Ve * Z.height);
                y === void 0 && (y = M(dt, ct));
                const Fe = ye ? M(dt, ct) : y;
                return Fe.width = dt,
                Fe.height = ct,
                Fe.getContext("2d").drawImage(Z, 0, 0, dt, ct),
                console.warn("THREE.WebGLRenderer: Texture has been resized from (" + Z.width + "x" + Z.height + ") to (" + dt + "x" + ct + ")."),
                Fe
            } else
                return "data"in Z && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + Z.width + "x" + Z.height + ")."),
                Z;
        return Z
    }
    function T(Z) {
        return cw(Z.width) && cw(Z.height)
    }
    function P(Z) {
        return a ? !1 : Z.wrapS !== Us || Z.wrapT !== Us || Z.minFilter !== Ji && Z.minFilter !== si
    }
    function I(Z, V) {
        return Z.generateMipmaps && V && Z.minFilter !== Ji && Z.minFilter !== si
    }
    function k(Z) {
        n.generateMipmap(Z)
    }
    function R(Z, V, ye, tt, Ve=!1) {
        if (a === !1)
            return V;
        if (Z !== null) {
            if (n[Z] !== void 0)
                return n[Z];
            console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + Z + "'")
        }
        let Ke = V;
        return V === 6403 && (ye === 5126 && (Ke = 33326),
        ye === 5131 && (Ke = 33325),
        ye === 5121 && (Ke = 33321)),
        V === 33319 && (ye === 5126 && (Ke = 33328),
        ye === 5131 && (Ke = 33327),
        ye === 5121 && (Ke = 33323)),
        V === 6408 && (ye === 5126 && (Ke = 34836),
        ye === 5131 && (Ke = 34842),
        ye === 5121 && (Ke = tt === nr && Ve === !1 ? 35907 : 32856),
        ye === 32819 && (Ke = 32854),
        ye === 32820 && (Ke = 32855)),
        (Ke === 33325 || Ke === 33326 || Ke === 33327 || Ke === 33328 || Ke === 34842 || Ke === 34836) && e.get("EXT_color_buffer_float"),
        Ke
    }
    function O(Z, V, ye) {
        return I(Z, ye) === !0 || Z.isFramebufferTexture && Z.minFilter !== Ji && Z.minFilter !== si ? Math.log2(Math.max(V.width, V.height)) + 1 : Z.mipmaps !== void 0 && Z.mipmaps.length > 0 ? Z.mipmaps.length : Z.isCompressedTexture && Array.isArray(Z.image) ? V.mipmaps.length : 1
    }
    function H(Z) {
        return Z === Ji || Z === pm || Z === ih ? 9728 : 9729
    }
    function W(Z) {
        const V = Z.target;
        V.removeEventListener("dispose", W),
        ne(V),
        V.isVideoTexture && _.delete(V)
    }
    function te(Z) {
        const V = Z.target;
        V.removeEventListener("dispose", te),
        pe(V)
    }
    function ne(Z) {
        const V = r.get(Z);
        if (V.__webglInit === void 0)
            return;
        const ye = Z.source
          , tt = x.get(ye);
        if (tt) {
            const Ve = tt[V.__cacheKey];
            Ve.usedTimes--,
            Ve.usedTimes === 0 && re(Z),
            Object.keys(tt).length === 0 && x.delete(ye)
        }
        r.remove(Z)
    }
    function re(Z) {
        const V = r.get(Z);
        n.deleteTexture(V.__webglTexture);
        const ye = Z.source
          , tt = x.get(ye);
        delete tt[V.__cacheKey],
        o.memory.textures--
    }
    function pe(Z) {
        const V = Z.texture
          , ye = r.get(Z)
          , tt = r.get(V);
        if (tt.__webglTexture !== void 0 && (n.deleteTexture(tt.__webglTexture),
        o.memory.textures--),
        Z.depthTexture && Z.depthTexture.dispose(),
        Z.isWebGLCubeRenderTarget)
            for (let Ve = 0; Ve < 6; Ve++)
                n.deleteFramebuffer(ye.__webglFramebuffer[Ve]),
                ye.__webglDepthbuffer && n.deleteRenderbuffer(ye.__webglDepthbuffer[Ve]);
        else {
            if (n.deleteFramebuffer(ye.__webglFramebuffer),
            ye.__webglDepthbuffer && n.deleteRenderbuffer(ye.__webglDepthbuffer),
            ye.__webglMultisampledFramebuffer && n.deleteFramebuffer(ye.__webglMultisampledFramebuffer),
            ye.__webglColorRenderbuffer)
                for (let Ve = 0; Ve < ye.__webglColorRenderbuffer.length; Ve++)
                    ye.__webglColorRenderbuffer[Ve] && n.deleteRenderbuffer(ye.__webglColorRenderbuffer[Ve]);
            ye.__webglDepthRenderbuffer && n.deleteRenderbuffer(ye.__webglDepthRenderbuffer)
        }
        if (Z.isWebGLMultipleRenderTargets)
            for (let Ve = 0, Ke = V.length; Ve < Ke; Ve++) {
                const dt = r.get(V[Ve]);
                dt.__webglTexture && (n.deleteTexture(dt.__webglTexture),
                o.memory.textures--),
                r.remove(V[Ve])
            }
        r.remove(V),
        r.remove(Z)
    }
    let ce = 0;
    function xe() {
        ce = 0
    }
    function G() {
        const Z = ce;
        return Z >= l && console.warn("THREE.WebGLTextures: Trying to use " + Z + " texture units while this GPU supports only " + l),
        ce += 1,
        Z
    }
    function z(Z) {
        const V = [];
        return V.push(Z.wrapS),
        V.push(Z.wrapT),
        V.push(Z.wrapR || 0),
        V.push(Z.magFilter),
        V.push(Z.minFilter),
        V.push(Z.anisotropy),
        V.push(Z.internalFormat),
        V.push(Z.format),
        V.push(Z.type),
        V.push(Z.generateMipmaps),
        V.push(Z.premultiplyAlpha),
        V.push(Z.flipY),
        V.push(Z.unpackAlignment),
        V.push(Z.encoding),
        V.join()
    }
    function U(Z, V) {
        const ye = r.get(Z);
        if (Z.isVideoTexture && ft(Z),
        Z.isRenderTargetTexture === !1 && Z.version > 0 && ye.__version !== Z.version) {
            const tt = Z.image;
            if (tt === null)
                console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
            else if (tt.complete === !1)
                console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
            else {
                Ne(ye, Z, V);
                return
            }
        }
        t.bindTexture(3553, ye.__webglTexture, 33984 + V)
    }
    function fe(Z, V) {
        const ye = r.get(Z);
        if (Z.version > 0 && ye.__version !== Z.version) {
            Ne(ye, Z, V);
            return
        }
        t.bindTexture(35866, ye.__webglTexture, 33984 + V)
    }
    function oe(Z, V) {
        const ye = r.get(Z);
        if (Z.version > 0 && ye.__version !== Z.version) {
            Ne(ye, Z, V);
            return
        }
        t.bindTexture(32879, ye.__webglTexture, 33984 + V)
    }
    function Ae(Z, V) {
        const ye = r.get(Z);
        if (Z.version > 0 && ye.__version !== Z.version) {
            Tt(ye, Z, V);
            return
        }
        t.bindTexture(34067, ye.__webglTexture, 33984 + V)
    }
    const Ue = {
        [bc]: 10497,
        [Us]: 33071,
        [gh]: 33648
    }
      , je = {
        [Ji]: 9728,
        [pm]: 9984,
        [ih]: 9986,
        [si]: 9729,
        [v_]: 9985,
        [Kl]: 9987
    };
    function de(Z, V, ye) {
        if (ye ? (n.texParameteri(Z, 10242, Ue[V.wrapS]),
        n.texParameteri(Z, 10243, Ue[V.wrapT]),
        (Z === 32879 || Z === 35866) && n.texParameteri(Z, 32882, Ue[V.wrapR]),
        n.texParameteri(Z, 10240, je[V.magFilter]),
        n.texParameteri(Z, 10241, je[V.minFilter])) : (n.texParameteri(Z, 10242, 33071),
        n.texParameteri(Z, 10243, 33071),
        (Z === 32879 || Z === 35866) && n.texParameteri(Z, 32882, 33071),
        (V.wrapS !== Us || V.wrapT !== Us) && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."),
        n.texParameteri(Z, 10240, H(V.magFilter)),
        n.texParameteri(Z, 10241, H(V.minFilter)),
        V.minFilter !== Ji && V.minFilter !== si && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")),
        e.has("EXT_texture_filter_anisotropic") === !0) {
            const tt = e.get("EXT_texture_filter_anisotropic");
            if (V.magFilter === Ji || V.minFilter !== ih && V.minFilter !== Kl || V.type === ya && e.has("OES_texture_float_linear") === !1 || a === !1 && V.type === ja && e.has("OES_texture_half_float_linear") === !1)
                return;
            (V.anisotropy > 1 || r.get(V).__currentAnisotropy) && (n.texParameterf(Z, tt.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(V.anisotropy, i.getMaxAnisotropy())),
            r.get(V).__currentAnisotropy = V.anisotropy)
        }
    }
    function qe(Z, V) {
        let ye = !1;
        Z.__webglInit === void 0 && (Z.__webglInit = !0,
        V.addEventListener("dispose", W));
        const tt = V.source;
        let Ve = x.get(tt);
        Ve === void 0 && (Ve = {},
        x.set(tt, Ve));
        const Ke = z(V);
        if (Ke !== Z.__cacheKey) {
            Ve[Ke] === void 0 && (Ve[Ke] = {
                texture: n.createTexture(),
                usedTimes: 0
            },
            o.memory.textures++,
            ye = !0),
            Ve[Ke].usedTimes++;
            const dt = Ve[Z.__cacheKey];
            dt !== void 0 && (Ve[Z.__cacheKey].usedTimes--,
            dt.usedTimes === 0 && re(V)),
            Z.__cacheKey = Ke,
            Z.__webglTexture = Ve[Ke].texture
        }
        return ye
    }
    function Ne(Z, V, ye) {
        let tt = 3553;
        (V.isDataArrayTexture || V.isCompressedArrayTexture) && (tt = 35866),
        V.isData3DTexture && (tt = 32879);
        const Ve = qe(Z, V)
          , Ke = V.source;
        t.bindTexture(tt, Z.__webglTexture, 33984 + ye);
        const dt = r.get(Ke);
        if (Ke.version !== dt.__version || Ve === !0) {
            t.activeTexture(33984 + ye),
            n.pixelStorei(37440, V.flipY),
            n.pixelStorei(37441, V.premultiplyAlpha),
            n.pixelStorei(3317, V.unpackAlignment),
            n.pixelStorei(37443, 0);
            const ct = P(V) && T(V.image) === !1;
            let Fe = w(V.image, ct, !1, h);
            Fe = Pt(V, Fe);
            const Rt = T(Fe) || a
              , le = s.convert(V.format, V.encoding);
            let Le = s.convert(V.type)
              , rt = R(V.internalFormat, le, Le, V.encoding, V.isVideoTexture);
            de(tt, V, Rt);
            let st;
            const Ut = V.mipmaps
              , Mt = a && V.isVideoTexture !== !0
              , wn = dt.__version === void 0 || Ve === !0
              , ae = O(V, Fe, Rt);
            if (V.isDepthTexture)
                rt = 6402,
                a ? V.type === ya ? rt = 36012 : V.type === lc ? rt = 33190 : V.type === Tf ? rt = 35056 : rt = 33189 : V.type === ya && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."),
                V.format === Sc && rt === 6402 && V.type !== kS && V.type !== lc && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),
                V.type = lc,
                Le = s.convert(V.type)),
                V.format === Uf && rt === 6402 && (rt = 34041,
                V.type !== Tf && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),
                V.type = Tf,
                Le = s.convert(V.type))),
                wn && (Mt ? t.texStorage2D(3553, 1, rt, Fe.width, Fe.height) : t.texImage2D(3553, 0, rt, Fe.width, Fe.height, 0, le, Le, null));
            else if (V.isDataTexture)
                if (Ut.length > 0 && Rt) {
                    Mt && wn && t.texStorage2D(3553, ae, rt, Ut[0].width, Ut[0].height);
                    for (let De = 0, Je = Ut.length; De < Je; De++)
                        st = Ut[De],
                        Mt ? t.texSubImage2D(3553, De, 0, 0, st.width, st.height, le, Le, st.data) : t.texImage2D(3553, De, rt, st.width, st.height, 0, le, Le, st.data);
                    V.generateMipmaps = !1
                } else
                    Mt ? (wn && t.texStorage2D(3553, ae, rt, Fe.width, Fe.height),
                    t.texSubImage2D(3553, 0, 0, 0, Fe.width, Fe.height, le, Le, Fe.data)) : t.texImage2D(3553, 0, rt, Fe.width, Fe.height, 0, le, Le, Fe.data);
            else if (V.isCompressedTexture)
                if (V.isCompressedArrayTexture) {
                    Mt && wn && t.texStorage3D(35866, ae, rt, Ut[0].width, Ut[0].height, Fe.depth);
                    for (let De = 0, Je = Ut.length; De < Je; De++)
                        st = Ut[De],
                        V.format !== ga ? le !== null ? Mt ? t.compressedTexSubImage3D(35866, De, 0, 0, 0, st.width, st.height, Fe.depth, le, st.data, 0, 0) : t.compressedTexImage3D(35866, De, rt, st.width, st.height, Fe.depth, 0, st.data, 0, 0) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : Mt ? t.texSubImage3D(35866, De, 0, 0, 0, st.width, st.height, Fe.depth, le, Le, st.data) : t.texImage3D(35866, De, rt, st.width, st.height, Fe.depth, 0, le, Le, st.data)
                } else {
                    Mt && wn && t.texStorage2D(3553, ae, rt, Ut[0].width, Ut[0].height);
                    for (let De = 0, Je = Ut.length; De < Je; De++)
                        st = Ut[De],
                        V.format !== ga ? le !== null ? Mt ? t.compressedTexSubImage2D(3553, De, 0, 0, st.width, st.height, le, st.data) : t.compressedTexImage2D(3553, De, rt, st.width, st.height, 0, st.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : Mt ? t.texSubImage2D(3553, De, 0, 0, st.width, st.height, le, Le, st.data) : t.texImage2D(3553, De, rt, st.width, st.height, 0, le, Le, st.data)
                }
            else if (V.isDataArrayTexture)
                Mt ? (wn && t.texStorage3D(35866, ae, rt, Fe.width, Fe.height, Fe.depth),
                t.texSubImage3D(35866, 0, 0, 0, 0, Fe.width, Fe.height, Fe.depth, le, Le, Fe.data)) : t.texImage3D(35866, 0, rt, Fe.width, Fe.height, Fe.depth, 0, le, Le, Fe.data);
            else if (V.isData3DTexture)
                Mt ? (wn && t.texStorage3D(32879, ae, rt, Fe.width, Fe.height, Fe.depth),
                t.texSubImage3D(32879, 0, 0, 0, 0, Fe.width, Fe.height, Fe.depth, le, Le, Fe.data)) : t.texImage3D(32879, 0, rt, Fe.width, Fe.height, Fe.depth, 0, le, Le, Fe.data);
            else if (V.isFramebufferTexture) {
                if (wn)
                    if (Mt)
                        t.texStorage2D(3553, ae, rt, Fe.width, Fe.height);
                    else {
                        let De = Fe.width
                          , Je = Fe.height;
                        for (let vt = 0; vt < ae; vt++)
                            t.texImage2D(3553, vt, rt, De, Je, 0, le, Le, null),
                            De >>= 1,
                            Je >>= 1
                    }
            } else if (Ut.length > 0 && Rt) {
                Mt && wn && t.texStorage2D(3553, ae, rt, Ut[0].width, Ut[0].height);
                for (let De = 0, Je = Ut.length; De < Je; De++)
                    st = Ut[De],
                    Mt ? t.texSubImage2D(3553, De, 0, 0, le, Le, st) : t.texImage2D(3553, De, rt, le, Le, st);
                V.generateMipmaps = !1
            } else
                Mt ? (wn && t.texStorage2D(3553, ae, rt, Fe.width, Fe.height),
                t.texSubImage2D(3553, 0, 0, 0, le, Le, Fe)) : t.texImage2D(3553, 0, rt, le, Le, Fe);
            I(V, Rt) && k(tt),
            dt.__version = Ke.version,
            V.onUpdate && V.onUpdate(V)
        }
        Z.__version = V.version
    }
    function Tt(Z, V, ye) {
        if (V.image.length !== 6)
            return;
        const tt = qe(Z, V)
          , Ve = V.source;
        t.bindTexture(34067, Z.__webglTexture, 33984 + ye);
        const Ke = r.get(Ve);
        if (Ve.version !== Ke.__version || tt === !0) {
            t.activeTexture(33984 + ye),
            n.pixelStorei(37440, V.flipY),
            n.pixelStorei(37441, V.premultiplyAlpha),
            n.pixelStorei(3317, V.unpackAlignment),
            n.pixelStorei(37443, 0);
            const dt = V.isCompressedTexture || V.image[0].isCompressedTexture
              , ct = V.image[0] && V.image[0].isDataTexture
              , Fe = [];
            for (let De = 0; De < 6; De++)
                !dt && !ct ? Fe[De] = w(V.image[De], !1, !0, f) : Fe[De] = ct ? V.image[De].image : V.image[De],
                Fe[De] = Pt(V, Fe[De]);
            const Rt = Fe[0]
              , le = T(Rt) || a
              , Le = s.convert(V.format, V.encoding)
              , rt = s.convert(V.type)
              , st = R(V.internalFormat, Le, rt, V.encoding)
              , Ut = a && V.isVideoTexture !== !0
              , Mt = Ke.__version === void 0 || tt === !0;
            let wn = O(V, Rt, le);
            de(34067, V, le);
            let ae;
            if (dt) {
                Ut && Mt && t.texStorage2D(34067, wn, st, Rt.width, Rt.height);
                for (let De = 0; De < 6; De++) {
                    ae = Fe[De].mipmaps;
                    for (let Je = 0; Je < ae.length; Je++) {
                        const vt = ae[Je];
                        V.format !== ga ? Le !== null ? Ut ? t.compressedTexSubImage2D(34069 + De, Je, 0, 0, vt.width, vt.height, Le, vt.data) : t.compressedTexImage2D(34069 + De, Je, st, vt.width, vt.height, 0, vt.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : Ut ? t.texSubImage2D(34069 + De, Je, 0, 0, vt.width, vt.height, Le, rt, vt.data) : t.texImage2D(34069 + De, Je, st, vt.width, vt.height, 0, Le, rt, vt.data)
                    }
                }
            } else {
                ae = V.mipmaps,
                Ut && Mt && (ae.length > 0 && wn++,
                t.texStorage2D(34067, wn, st, Fe[0].width, Fe[0].height));
                for (let De = 0; De < 6; De++)
                    if (ct) {
                        Ut ? t.texSubImage2D(34069 + De, 0, 0, 0, Fe[De].width, Fe[De].height, Le, rt, Fe[De].data) : t.texImage2D(34069 + De, 0, st, Fe[De].width, Fe[De].height, 0, Le, rt, Fe[De].data);
                        for (let Je = 0; Je < ae.length; Je++) {
                            const Et = ae[Je].image[De].image;
                            Ut ? t.texSubImage2D(34069 + De, Je + 1, 0, 0, Et.width, Et.height, Le, rt, Et.data) : t.texImage2D(34069 + De, Je + 1, st, Et.width, Et.height, 0, Le, rt, Et.data)
                        }
                    } else {
                        Ut ? t.texSubImage2D(34069 + De, 0, 0, 0, Le, rt, Fe[De]) : t.texImage2D(34069 + De, 0, st, Le, rt, Fe[De]);
                        for (let Je = 0; Je < ae.length; Je++) {
                            const vt = ae[Je];
                            Ut ? t.texSubImage2D(34069 + De, Je + 1, 0, 0, Le, rt, vt.image[De]) : t.texImage2D(34069 + De, Je + 1, st, Le, rt, vt.image[De])
                        }
                    }
            }
            I(V, le) && k(34067),
            Ke.__version = Ve.version,
            V.onUpdate && V.onUpdate(V)
        }
        Z.__version = V.version
    }
    function He(Z, V, ye, tt, Ve) {
        const Ke = s.convert(ye.format, ye.encoding)
          , dt = s.convert(ye.type)
          , ct = R(ye.internalFormat, Ke, dt, ye.encoding);
        r.get(V).__hasExternalTextures || (Ve === 32879 || Ve === 35866 ? t.texImage3D(Ve, 0, ct, V.width, V.height, V.depth, 0, Ke, dt, null) : t.texImage2D(Ve, 0, ct, V.width, V.height, 0, Ke, dt, null)),
        t.bindFramebuffer(36160, Z),
        Ze(V) ? p.framebufferTexture2DMultisampleEXT(36160, tt, Ve, r.get(ye).__webglTexture, 0, et(V)) : (Ve === 3553 || Ve >= 34069 && Ve <= 34074) && n.framebufferTexture2D(36160, tt, Ve, r.get(ye).__webglTexture, 0),
        t.bindFramebuffer(36160, null)
    }
    function gt(Z, V, ye) {
        if (n.bindRenderbuffer(36161, Z),
        V.depthBuffer && !V.stencilBuffer) {
            let tt = 33189;
            if (ye || Ze(V)) {
                const Ve = V.depthTexture;
                Ve && Ve.isDepthTexture && (Ve.type === ya ? tt = 36012 : Ve.type === lc && (tt = 33190));
                const Ke = et(V);
                Ze(V) ? p.renderbufferStorageMultisampleEXT(36161, Ke, tt, V.width, V.height) : n.renderbufferStorageMultisample(36161, Ke, tt, V.width, V.height)
            } else
                n.renderbufferStorage(36161, tt, V.width, V.height);
            n.framebufferRenderbuffer(36160, 36096, 36161, Z)
        } else if (V.depthBuffer && V.stencilBuffer) {
            const tt = et(V);
            ye && Ze(V) === !1 ? n.renderbufferStorageMultisample(36161, tt, 35056, V.width, V.height) : Ze(V) ? p.renderbufferStorageMultisampleEXT(36161, tt, 35056, V.width, V.height) : n.renderbufferStorage(36161, 34041, V.width, V.height),
            n.framebufferRenderbuffer(36160, 33306, 36161, Z)
        } else {
            const tt = V.isWebGLMultipleRenderTargets === !0 ? V.texture : [V.texture];
            for (let Ve = 0; Ve < tt.length; Ve++) {
                const Ke = tt[Ve]
                  , dt = s.convert(Ke.format, Ke.encoding)
                  , ct = s.convert(Ke.type)
                  , Fe = R(Ke.internalFormat, dt, ct, Ke.encoding)
                  , Rt = et(V);
                ye && Ze(V) === !1 ? n.renderbufferStorageMultisample(36161, Rt, Fe, V.width, V.height) : Ze(V) ? p.renderbufferStorageMultisampleEXT(36161, Rt, Fe, V.width, V.height) : n.renderbufferStorage(36161, Fe, V.width, V.height)
            }
        }
        n.bindRenderbuffer(36161, null)
    }
    function be(Z, V) {
        if (V && V.isWebGLCubeRenderTarget)
            throw new Error("Depth Texture with cube render targets is not supported");
        if (t.bindFramebuffer(36160, Z),
        !(V.depthTexture && V.depthTexture.isDepthTexture))
            throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
        (!r.get(V.depthTexture).__webglTexture || V.depthTexture.image.width !== V.width || V.depthTexture.image.height !== V.height) && (V.depthTexture.image.width = V.width,
        V.depthTexture.image.height = V.height,
        V.depthTexture.needsUpdate = !0),
        U(V.depthTexture, 0);
        const tt = r.get(V.depthTexture).__webglTexture
          , Ve = et(V);
        if (V.depthTexture.format === Sc)
            Ze(V) ? p.framebufferTexture2DMultisampleEXT(36160, 36096, 3553, tt, 0, Ve) : n.framebufferTexture2D(36160, 36096, 3553, tt, 0);
        else if (V.depthTexture.format === Uf)
            Ze(V) ? p.framebufferTexture2DMultisampleEXT(36160, 33306, 3553, tt, 0, Ve) : n.framebufferTexture2D(36160, 33306, 3553, tt, 0);
        else
            throw new Error("Unknown depthTexture format")
    }
    function Ee(Z) {
        const V = r.get(Z)
          , ye = Z.isWebGLCubeRenderTarget === !0;
        if (Z.depthTexture && !V.__autoAllocateDepthBuffer) {
            if (ye)
                throw new Error("target.depthTexture not supported in Cube render targets");
            be(V.__webglFramebuffer, Z)
        } else if (ye) {
            V.__webglDepthbuffer = [];
            for (let tt = 0; tt < 6; tt++)
                t.bindFramebuffer(36160, V.__webglFramebuffer[tt]),
                V.__webglDepthbuffer[tt] = n.createRenderbuffer(),
                gt(V.__webglDepthbuffer[tt], Z, !1)
        } else
            t.bindFramebuffer(36160, V.__webglFramebuffer),
            V.__webglDepthbuffer = n.createRenderbuffer(),
            gt(V.__webglDepthbuffer, Z, !1);
        t.bindFramebuffer(36160, null)
    }
    function at(Z, V, ye) {
        const tt = r.get(Z);
        V !== void 0 && He(tt.__webglFramebuffer, Z, Z.texture, 36064, 3553),
        ye !== void 0 && Ee(Z)
    }
    function _t(Z) {
        const V = Z.texture
          , ye = r.get(Z)
          , tt = r.get(V);
        Z.addEventListener("dispose", te),
        Z.isWebGLMultipleRenderTargets !== !0 && (tt.__webglTexture === void 0 && (tt.__webglTexture = n.createTexture()),
        tt.__version = V.version,
        o.memory.textures++);
        const Ve = Z.isWebGLCubeRenderTarget === !0
          , Ke = Z.isWebGLMultipleRenderTargets === !0
          , dt = T(Z) || a;
        if (Ve) {
            ye.__webglFramebuffer = [];
            for (let ct = 0; ct < 6; ct++)
                ye.__webglFramebuffer[ct] = n.createFramebuffer()
        } else {
            if (ye.__webglFramebuffer = n.createFramebuffer(),
            Ke)
                if (i.drawBuffers) {
                    const ct = Z.texture;
                    for (let Fe = 0, Rt = ct.length; Fe < Rt; Fe++) {
                        const le = r.get(ct[Fe]);
                        le.__webglTexture === void 0 && (le.__webglTexture = n.createTexture(),
                        o.memory.textures++)
                    }
                } else
                    console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");
            if (a && Z.samples > 0 && Ze(Z) === !1) {
                const ct = Ke ? V : [V];
                ye.__webglMultisampledFramebuffer = n.createFramebuffer(),
                ye.__webglColorRenderbuffer = [],
                t.bindFramebuffer(36160, ye.__webglMultisampledFramebuffer);
                for (let Fe = 0; Fe < ct.length; Fe++) {
                    const Rt = ct[Fe];
                    ye.__webglColorRenderbuffer[Fe] = n.createRenderbuffer(),
                    n.bindRenderbuffer(36161, ye.__webglColorRenderbuffer[Fe]);
                    const le = s.convert(Rt.format, Rt.encoding)
                      , Le = s.convert(Rt.type)
                      , rt = R(Rt.internalFormat, le, Le, Rt.encoding, Z.isXRRenderTarget === !0)
                      , st = et(Z);
                    n.renderbufferStorageMultisample(36161, st, rt, Z.width, Z.height),
                    n.framebufferRenderbuffer(36160, 36064 + Fe, 36161, ye.__webglColorRenderbuffer[Fe])
                }
                n.bindRenderbuffer(36161, null),
                Z.depthBuffer && (ye.__webglDepthRenderbuffer = n.createRenderbuffer(),
                gt(ye.__webglDepthRenderbuffer, Z, !0)),
                t.bindFramebuffer(36160, null)
            }
        }
        if (Ve) {
            t.bindTexture(34067, tt.__webglTexture),
            de(34067, V, dt);
            for (let ct = 0; ct < 6; ct++)
                He(ye.__webglFramebuffer[ct], Z, V, 36064, 34069 + ct);
            I(V, dt) && k(34067),
            t.unbindTexture()
        } else if (Ke) {
            const ct = Z.texture;
            for (let Fe = 0, Rt = ct.length; Fe < Rt; Fe++) {
                const le = ct[Fe]
                  , Le = r.get(le);
                t.bindTexture(3553, Le.__webglTexture),
                de(3553, le, dt),
                He(ye.__webglFramebuffer, Z, le, 36064 + Fe, 3553),
                I(le, dt) && k(3553)
            }
            t.unbindTexture()
        } else {
            let ct = 3553;
            (Z.isWebGL3DRenderTarget || Z.isWebGLArrayRenderTarget) && (a ? ct = Z.isWebGL3DRenderTarget ? 32879 : 35866 : console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.")),
            t.bindTexture(ct, tt.__webglTexture),
            de(ct, V, dt),
            He(ye.__webglFramebuffer, Z, V, 36064, ct),
            I(V, dt) && k(ct),
            t.unbindTexture()
        }
        Z.depthBuffer && Ee(Z)
    }
    function Ce(Z) {
        const V = T(Z) || a
          , ye = Z.isWebGLMultipleRenderTargets === !0 ? Z.texture : [Z.texture];
        for (let tt = 0, Ve = ye.length; tt < Ve; tt++) {
            const Ke = ye[tt];
            if (I(Ke, V)) {
                const dt = Z.isWebGLCubeRenderTarget ? 34067 : 3553
                  , ct = r.get(Ke).__webglTexture;
                t.bindTexture(dt, ct),
                k(dt),
                t.unbindTexture()
            }
        }
    }
    function ee(Z) {
        if (a && Z.samples > 0 && Ze(Z) === !1) {
            const V = Z.isWebGLMultipleRenderTargets ? Z.texture : [Z.texture]
              , ye = Z.width
              , tt = Z.height;
            let Ve = 16384;
            const Ke = []
              , dt = Z.stencilBuffer ? 33306 : 36096
              , ct = r.get(Z)
              , Fe = Z.isWebGLMultipleRenderTargets === !0;
            if (Fe)
                for (let Rt = 0; Rt < V.length; Rt++)
                    t.bindFramebuffer(36160, ct.__webglMultisampledFramebuffer),
                    n.framebufferRenderbuffer(36160, 36064 + Rt, 36161, null),
                    t.bindFramebuffer(36160, ct.__webglFramebuffer),
                    n.framebufferTexture2D(36009, 36064 + Rt, 3553, null, 0);
            t.bindFramebuffer(36008, ct.__webglMultisampledFramebuffer),
            t.bindFramebuffer(36009, ct.__webglFramebuffer);
            for (let Rt = 0; Rt < V.length; Rt++) {
                Ke.push(36064 + Rt),
                Z.depthBuffer && Ke.push(dt);
                const le = ct.__ignoreDepthValues !== void 0 ? ct.__ignoreDepthValues : !1;
                if (le === !1 && (Z.depthBuffer && (Ve |= 256),
                Z.stencilBuffer && (Ve |= 1024)),
                Fe && n.framebufferRenderbuffer(36008, 36064, 36161, ct.__webglColorRenderbuffer[Rt]),
                le === !0 && (n.invalidateFramebuffer(36008, [dt]),
                n.invalidateFramebuffer(36009, [dt])),
                Fe) {
                    const Le = r.get(V[Rt]).__webglTexture;
                    n.framebufferTexture2D(36009, 36064, 3553, Le, 0)
                }
                n.blitFramebuffer(0, 0, ye, tt, 0, 0, ye, tt, Ve, 9728),
                m && n.invalidateFramebuffer(36008, Ke)
            }
            if (t.bindFramebuffer(36008, null),
            t.bindFramebuffer(36009, null),
            Fe)
                for (let Rt = 0; Rt < V.length; Rt++) {
                    t.bindFramebuffer(36160, ct.__webglMultisampledFramebuffer),
                    n.framebufferRenderbuffer(36160, 36064 + Rt, 36161, ct.__webglColorRenderbuffer[Rt]);
                    const le = r.get(V[Rt]).__webglTexture;
                    t.bindFramebuffer(36160, ct.__webglFramebuffer),
                    n.framebufferTexture2D(36009, 36064 + Rt, 3553, le, 0)
                }
            t.bindFramebuffer(36009, ct.__webglMultisampledFramebuffer)
        }
    }
    function et(Z) {
        return Math.min(d, Z.samples)
    }
    function Ze(Z) {
        const V = r.get(Z);
        return a && Z.samples > 0 && e.has("WEBGL_multisampled_render_to_texture") === !0 && V.__useRenderToTexture !== !1
    }
    function ft(Z) {
        const V = o.render.frame;
        _.get(Z) !== V && (_.set(Z, V),
        Z.update())
    }
    function Pt(Z, V) {
        const ye = Z.encoding
          , tt = Z.format
          , Ve = Z.type;
        return Z.isCompressedTexture === !0 || Z.isVideoTexture === !0 || Z.format === Vv || ye !== bl && (ye === nr ? a === !1 ? e.has("EXT_sRGB") === !0 && tt === ga ? (Z.format = Vv,
        Z.minFilter = si,
        Z.generateMipmaps = !1) : V = GS.sRGBToLinear(V) : (tt !== ga || Ve !== Tc) && console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture encoding:", ye)),
        V
    }
    this.allocateTextureUnit = G,
    this.resetTextureUnits = xe,
    this.setTexture2D = U,
    this.setTexture2DArray = fe,
    this.setTexture3D = oe,
    this.setTextureCube = Ae,
    this.rebindTextures = at,
    this.setupRenderTarget = _t,
    this.updateRenderTargetMipmap = Ce,
    this.updateMultisampleRenderTarget = ee,
    this.setupDepthRenderbuffer = Ee,
    this.setupFrameBufferTexture = He,
    this.useMultisampledRTT = Ze
}
function a3(n, e, t) {
    const r = t.isWebGL2;
    function i(s, o=null) {
        let a;
        if (s === Tc)
            return 5121;
        if (s === R2)
            return 32819;
        if (s === B2)
            return 32820;
        if (s === T2)
            return 5120;
        if (s === D2)
            return 5122;
        if (s === kS)
            return 5123;
        if (s === P2)
            return 5124;
        if (s === lc)
            return 5125;
        if (s === ya)
            return 5126;
        if (s === ja)
            return r ? 5131 : (a = e.get("OES_texture_half_float"),
            a !== null ? a.HALF_FLOAT_OES : null);
        if (s === I2)
            return 6406;
        if (s === ga)
            return 6408;
        if (s === L2)
            return 6409;
        if (s === F2)
            return 6410;
        if (s === Sc)
            return 6402;
        if (s === Uf)
            return 34041;
        if (s === Vv)
            return a = e.get("EXT_sRGB"),
            a !== null ? a.SRGB_ALPHA_EXT : null;
        if (s === k2)
            return 6403;
        if (s === O2)
            return 36244;
        if (s === N2)
            return 33319;
        if (s === z2)
            return 33320;
        if (s === G2)
            return 36249;
        if (s === tv || s === nv || s === rv || s === iv)
            if (o === nr)
                if (a = e.get("WEBGL_compressed_texture_s3tc_srgb"),
                a !== null) {
                    if (s === tv)
                        return a.COMPRESSED_SRGB_S3TC_DXT1_EXT;
                    if (s === nv)
                        return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
                    if (s === rv)
                        return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
                    if (s === iv)
                        return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
                } else
                    return null;
            else if (a = e.get("WEBGL_compressed_texture_s3tc"),
            a !== null) {
                if (s === tv)
                    return a.COMPRESSED_RGB_S3TC_DXT1_EXT;
                if (s === nv)
                    return a.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                if (s === rv)
                    return a.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                if (s === iv)
                    return a.COMPRESSED_RGBA_S3TC_DXT5_EXT
            } else
                return null;
        if (s === G1 || s === U1 || s === H1 || s === V1)
            if (a = e.get("WEBGL_compressed_texture_pvrtc"),
            a !== null) {
                if (s === G1)
                    return a.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                if (s === U1)
                    return a.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                if (s === H1)
                    return a.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                if (s === V1)
                    return a.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
            } else
                return null;
        if (s === U2)
            return a = e.get("WEBGL_compressed_texture_etc1"),
            a !== null ? a.COMPRESSED_RGB_ETC1_WEBGL : null;
        if (s === W1 || s === X1)
            if (a = e.get("WEBGL_compressed_texture_etc"),
            a !== null) {
                if (s === W1)
                    return o === nr ? a.COMPRESSED_SRGB8_ETC2 : a.COMPRESSED_RGB8_ETC2;
                if (s === X1)
                    return o === nr ? a.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : a.COMPRESSED_RGBA8_ETC2_EAC
            } else
                return null;
        if (s === J1 || s === j1 || s === Y1 || s === K1 || s === q1 || s === Q1 || s === Z1 || s === $1 || s === ew || s === tw || s === nw || s === rw || s === iw || s === sw)
            if (a = e.get("WEBGL_compressed_texture_astc"),
            a !== null) {
                if (s === J1)
                    return o === nr ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : a.COMPRESSED_RGBA_ASTC_4x4_KHR;
                if (s === j1)
                    return o === nr ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : a.COMPRESSED_RGBA_ASTC_5x4_KHR;
                if (s === Y1)
                    return o === nr ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : a.COMPRESSED_RGBA_ASTC_5x5_KHR;
                if (s === K1)
                    return o === nr ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : a.COMPRESSED_RGBA_ASTC_6x5_KHR;
                if (s === q1)
                    return o === nr ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : a.COMPRESSED_RGBA_ASTC_6x6_KHR;
                if (s === Q1)
                    return o === nr ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : a.COMPRESSED_RGBA_ASTC_8x5_KHR;
                if (s === Z1)
                    return o === nr ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : a.COMPRESSED_RGBA_ASTC_8x6_KHR;
                if (s === $1)
                    return o === nr ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : a.COMPRESSED_RGBA_ASTC_8x8_KHR;
                if (s === ew)
                    return o === nr ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : a.COMPRESSED_RGBA_ASTC_10x5_KHR;
                if (s === tw)
                    return o === nr ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : a.COMPRESSED_RGBA_ASTC_10x6_KHR;
                if (s === nw)
                    return o === nr ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : a.COMPRESSED_RGBA_ASTC_10x8_KHR;
                if (s === rw)
                    return o === nr ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : a.COMPRESSED_RGBA_ASTC_10x10_KHR;
                if (s === iw)
                    return o === nr ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : a.COMPRESSED_RGBA_ASTC_12x10_KHR;
                if (s === sw)
                    return o === nr ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : a.COMPRESSED_RGBA_ASTC_12x12_KHR
            } else
                return null;
        if (s === sv)
            if (a = e.get("EXT_texture_compression_bptc"),
            a !== null) {
                if (s === sv)
                    return o === nr ? a.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : a.COMPRESSED_RGBA_BPTC_UNORM_EXT
            } else
                return null;
        if (s === H2 || s === ow || s === aw || s === lw)
            if (a = e.get("EXT_texture_compression_rgtc"),
            a !== null) {
                if (s === sv)
                    return a.COMPRESSED_RED_RGTC1_EXT;
                if (s === ow)
                    return a.COMPRESSED_SIGNED_RED_RGTC1_EXT;
                if (s === aw)
                    return a.COMPRESSED_RED_GREEN_RGTC2_EXT;
                if (s === lw)
                    return a.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT
            } else
                return null;
        return s === Tf ? r ? 34042 : (a = e.get("WEBGL_depth_texture"),
        a !== null ? a.UNSIGNED_INT_24_8_WEBGL : null) : n[s] !== void 0 ? n[s] : null
    }
    return {
        convert: i
    }
}
class l3 extends gi {
    constructor(e=[]) {
        super(),
        this.isArrayCamera = !0,
        this.cameras = e
    }
}
class _u extends wr {
    constructor() {
        super(),
        this.isGroup = !0,
        this.type = "Group"
    }
}
const Nz = {
    type: "move"
};
class ix {
    constructor() {
        this._targetRay = null,
        this._grip = null,
        this._hand = null
    }
    getHandSpace() {
        return this._hand === null && (this._hand = new _u,
        this._hand.matrixAutoUpdate = !1,
        this._hand.visible = !1,
        this._hand.joints = {},
        this._hand.inputState = {
            pinching: !1
        }),
        this._hand
    }
    getTargetRaySpace() {
        return this._targetRay === null && (this._targetRay = new _u,
        this._targetRay.matrixAutoUpdate = !1,
        this._targetRay.visible = !1,
        this._targetRay.hasLinearVelocity = !1,
        this._targetRay.linearVelocity = new $,
        this._targetRay.hasAngularVelocity = !1,
        this._targetRay.angularVelocity = new $),
        this._targetRay
    }
    getGripSpace() {
        return this._grip === null && (this._grip = new _u,
        this._grip.matrixAutoUpdate = !1,
        this._grip.visible = !1,
        this._grip.hasLinearVelocity = !1,
        this._grip.linearVelocity = new $,
        this._grip.hasAngularVelocity = !1,
        this._grip.angularVelocity = new $),
        this._grip
    }
    dispatchEvent(e) {
        return this._targetRay !== null && this._targetRay.dispatchEvent(e),
        this._grip !== null && this._grip.dispatchEvent(e),
        this._hand !== null && this._hand.dispatchEvent(e),
        this
    }
    connect(e) {
        if (e && e.hand) {
            const t = this._hand;
            if (t)
                for (const r of e.hand.values())
                    this._getHandJoint(t, r)
        }
        return this.dispatchEvent({
            type: "connected",
            data: e
        }),
        this
    }
    disconnect(e) {
        return this.dispatchEvent({
            type: "disconnected",
            data: e
        }),
        this._targetRay !== null && (this._targetRay.visible = !1),
        this._grip !== null && (this._grip.visible = !1),
        this._hand !== null && (this._hand.visible = !1),
        this
    }
    update(e, t, r) {
        let i = null
          , s = null
          , o = null;
        const a = this._targetRay
          , l = this._grip
          , f = this._hand;
        if (e && t.session.visibilityState !== "visible-blurred") {
            if (f && e.hand) {
                o = !0;
                for (const y of e.hand.values()) {
                    const x = t.getJointPose(y, r)
                      , S = this._getHandJoint(f, y);
                    x !== null && (S.matrix.fromArray(x.transform.matrix),
                    S.matrix.decompose(S.position, S.rotation, S.scale),
                    S.jointRadius = x.radius),
                    S.visible = x !== null
                }
                const h = f.joints["index-finger-tip"]
                  , d = f.joints["thumb-tip"]
                  , p = h.position.distanceTo(d.position)
                  , m = .02
                  , _ = .005;
                f.inputState.pinching && p > m + _ ? (f.inputState.pinching = !1,
                this.dispatchEvent({
                    type: "pinchend",
                    handedness: e.handedness,
                    target: this
                })) : !f.inputState.pinching && p <= m - _ && (f.inputState.pinching = !0,
                this.dispatchEvent({
                    type: "pinchstart",
                    handedness: e.handedness,
                    target: this
                }))
            } else
                l !== null && e.gripSpace && (s = t.getPose(e.gripSpace, r),
                s !== null && (l.matrix.fromArray(s.transform.matrix),
                l.matrix.decompose(l.position, l.rotation, l.scale),
                s.linearVelocity ? (l.hasLinearVelocity = !0,
                l.linearVelocity.copy(s.linearVelocity)) : l.hasLinearVelocity = !1,
                s.angularVelocity ? (l.hasAngularVelocity = !0,
                l.angularVelocity.copy(s.angularVelocity)) : l.hasAngularVelocity = !1));
            a !== null && (i = t.getPose(e.targetRaySpace, r),
            i === null && s !== null && (i = s),
            i !== null && (a.matrix.fromArray(i.transform.matrix),
            a.matrix.decompose(a.position, a.rotation, a.scale),
            i.linearVelocity ? (a.hasLinearVelocity = !0,
            a.linearVelocity.copy(i.linearVelocity)) : a.hasLinearVelocity = !1,
            i.angularVelocity ? (a.hasAngularVelocity = !0,
            a.angularVelocity.copy(i.angularVelocity)) : a.hasAngularVelocity = !1,
            this.dispatchEvent(Nz)))
        }
        return a !== null && (a.visible = i !== null),
        l !== null && (l.visible = s !== null),
        f !== null && (f.visible = o !== null),
        this
    }
    _getHandJoint(e, t) {
        if (e.joints[t.jointName] === void 0) {
            const r = new _u;
            r.matrixAutoUpdate = !1,
            r.visible = !1,
            e.joints[t.jointName] = r,
            e.add(r)
        }
        return e.joints[t.jointName]
    }
}
class KS extends Ci {
    constructor(e, t, r, i, s, o, a, l, f, h) {
        if (h = h !== void 0 ? h : Sc,
        h !== Sc && h !== Uf)
            throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
        r === void 0 && h === Sc && (r = lc),
        r === void 0 && h === Uf && (r = Tf),
        super(null, i, s, o, a, l, h, r, f),
        this.isDepthTexture = !0,
        this.image = {
            width: e,
            height: t
        },
        this.magFilter = a !== void 0 ? a : Ji,
        this.minFilter = l !== void 0 ? l : Ji,
        this.flipY = !1,
        this.generateMipmaps = !1
    }
}
class zz extends ql {
    constructor(e, t) {
        super();
        const r = this;
        let i = null
          , s = 1
          , o = null
          , a = "local-floor"
          , l = 1
          , f = null
          , h = null
          , d = null
          , p = null
          , m = null
          , _ = null;
        const y = t.getContextAttributes();
        let x = null
          , S = null;
        const M = []
          , w = []
          , T = new Set
          , P = new Map
          , I = new gi;
        I.layers.enable(1),
        I.viewport = new zr;
        const k = new gi;
        k.layers.enable(2),
        k.viewport = new zr;
        const R = [I, k]
          , O = new l3;
        O.layers.enable(1),
        O.layers.enable(2);
        let H = null
          , W = null;
        this.cameraAutoUpdate = !0,
        this.enabled = !1,
        this.isPresenting = !1,
        this.getController = function(oe) {
            let Ae = M[oe];
            return Ae === void 0 && (Ae = new ix,
            M[oe] = Ae),
            Ae.getTargetRaySpace()
        }
        ,
        this.getControllerGrip = function(oe) {
            let Ae = M[oe];
            return Ae === void 0 && (Ae = new ix,
            M[oe] = Ae),
            Ae.getGripSpace()
        }
        ,
        this.getHand = function(oe) {
            let Ae = M[oe];
            return Ae === void 0 && (Ae = new ix,
            M[oe] = Ae),
            Ae.getHandSpace()
        }
        ;
        function te(oe) {
            const Ae = w.indexOf(oe.inputSource);
            if (Ae === -1)
                return;
            const Ue = M[Ae];
            Ue !== void 0 && Ue.dispatchEvent({
                type: oe.type,
                data: oe.inputSource
            })
        }
        function ne() {
            i.removeEventListener("select", te),
            i.removeEventListener("selectstart", te),
            i.removeEventListener("selectend", te),
            i.removeEventListener("squeeze", te),
            i.removeEventListener("squeezestart", te),
            i.removeEventListener("squeezeend", te),
            i.removeEventListener("end", ne),
            i.removeEventListener("inputsourceschange", re);
            for (let oe = 0; oe < M.length; oe++) {
                const Ae = w[oe];
                Ae !== null && (w[oe] = null,
                M[oe].disconnect(Ae))
            }
            H = null,
            W = null,
            e.setRenderTarget(x),
            m = null,
            p = null,
            d = null,
            i = null,
            S = null,
            fe.stop(),
            r.isPresenting = !1,
            r.dispatchEvent({
                type: "sessionend"
            })
        }
        this.setFramebufferScaleFactor = function(oe) {
            s = oe,
            r.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")
        }
        ,
        this.setReferenceSpaceType = function(oe) {
            a = oe,
            r.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")
        }
        ,
        this.getReferenceSpace = function() {
            return f || o
        }
        ,
        this.setReferenceSpace = function(oe) {
            f = oe
        }
        ,
        this.getBaseLayer = function() {
            return p !== null ? p : m
        }
        ,
        this.getBinding = function() {
            return d
        }
        ,
        this.getFrame = function() {
            return _
        }
        ,
        this.getSession = function() {
            return i
        }
        ,
        this.setSession = async function(oe) {
            if (i = oe,
            i !== null) {
                if (x = e.getRenderTarget(),
                i.addEventListener("select", te),
                i.addEventListener("selectstart", te),
                i.addEventListener("selectend", te),
                i.addEventListener("squeeze", te),
                i.addEventListener("squeezestart", te),
                i.addEventListener("squeezeend", te),
                i.addEventListener("end", ne),
                i.addEventListener("inputsourceschange", re),
                y.xrCompatible !== !0 && await t.makeXRCompatible(),
                i.renderState.layers === void 0 || e.capabilities.isWebGL2 === !1) {
                    const Ae = {
                        antialias: i.renderState.layers === void 0 ? y.antialias : !0,
                        alpha: y.alpha,
                        depth: y.depth,
                        stencil: y.stencil,
                        framebufferScaleFactor: s
                    };
                    m = new XRWebGLLayer(i,t,Ae),
                    i.updateRenderState({
                        baseLayer: m
                    }),
                    S = new $a(m.framebufferWidth,m.framebufferHeight,{
                        format: ga,
                        type: Tc,
                        encoding: e.outputEncoding,
                        stencilBuffer: y.stencil
                    })
                } else {
                    let Ae = null
                      , Ue = null
                      , je = null;
                    y.depth && (je = y.stencil ? 35056 : 33190,
                    Ae = y.stencil ? Uf : Sc,
                    Ue = y.stencil ? Tf : lc);
                    const de = {
                        colorFormat: 32856,
                        depthFormat: je,
                        scaleFactor: s
                    };
                    d = new XRWebGLBinding(i,t),
                    p = d.createProjectionLayer(de),
                    i.updateRenderState({
                        layers: [p]
                    }),
                    S = new $a(p.textureWidth,p.textureHeight,{
                        format: ga,
                        type: Tc,
                        depthTexture: new KS(p.textureWidth,p.textureHeight,Ue,void 0,void 0,void 0,void 0,void 0,void 0,Ae),
                        stencilBuffer: y.stencil,
                        encoding: e.outputEncoding,
                        samples: y.antialias ? 4 : 0
                    });
                    const qe = e.properties.get(S);
                    qe.__ignoreDepthValues = p.ignoreDepthValues
                }
                S.isXRRenderTarget = !0,
                this.setFoveation(l),
                f = null,
                o = await i.requestReferenceSpace(a),
                fe.setContext(i),
                fe.start(),
                r.isPresenting = !0,
                r.dispatchEvent({
                    type: "sessionstart"
                })
            }
        }
        ;
        function re(oe) {
            for (let Ae = 0; Ae < oe.removed.length; Ae++) {
                const Ue = oe.removed[Ae]
                  , je = w.indexOf(Ue);
                je >= 0 && (w[je] = null,
                M[je].disconnect(Ue))
            }
            for (let Ae = 0; Ae < oe.added.length; Ae++) {
                const Ue = oe.added[Ae];
                let je = w.indexOf(Ue);
                if (je === -1) {
                    for (let qe = 0; qe < M.length; qe++)
                        if (qe >= w.length) {
                            w.push(Ue),
                            je = qe;
                            break
                        } else if (w[qe] === null) {
                            w[qe] = Ue,
                            je = qe;
                            break
                        }
                    if (je === -1)
                        break
                }
                const de = M[je];
                de && de.connect(Ue)
            }
        }
        const pe = new $
          , ce = new $;
        function xe(oe, Ae, Ue) {
            pe.setFromMatrixPosition(Ae.matrixWorld),
            ce.setFromMatrixPosition(Ue.matrixWorld);
            const je = pe.distanceTo(ce)
              , de = Ae.projectionMatrix.elements
              , qe = Ue.projectionMatrix.elements
              , Ne = de[14] / (de[10] - 1)
              , Tt = de[14] / (de[10] + 1)
              , He = (de[9] + 1) / de[5]
              , gt = (de[9] - 1) / de[5]
              , be = (de[8] - 1) / de[0]
              , Ee = (qe[8] + 1) / qe[0]
              , at = Ne * be
              , _t = Ne * Ee
              , Ce = je / (-be + Ee)
              , ee = Ce * -be;
            Ae.matrixWorld.decompose(oe.position, oe.quaternion, oe.scale),
            oe.translateX(ee),
            oe.translateZ(Ce),
            oe.matrixWorld.compose(oe.position, oe.quaternion, oe.scale),
            oe.matrixWorldInverse.copy(oe.matrixWorld).invert();
            const et = Ne + Ce
              , Ze = Tt + Ce
              , ft = at - ee
              , Pt = _t + (je - ee)
              , Z = He * Tt / Ze * et
              , V = gt * Tt / Ze * et;
            oe.projectionMatrix.makePerspective(ft, Pt, Z, V, et, Ze)
        }
        function G(oe, Ae) {
            Ae === null ? oe.matrixWorld.copy(oe.matrix) : oe.matrixWorld.multiplyMatrices(Ae.matrixWorld, oe.matrix),
            oe.matrixWorldInverse.copy(oe.matrixWorld).invert()
        }
        this.updateCamera = function(oe) {
            if (i === null)
                return;
            O.near = k.near = I.near = oe.near,
            O.far = k.far = I.far = oe.far,
            (H !== O.near || W !== O.far) && (i.updateRenderState({
                depthNear: O.near,
                depthFar: O.far
            }),
            H = O.near,
            W = O.far);
            const Ae = oe.parent
              , Ue = O.cameras;
            G(O, Ae);
            for (let de = 0; de < Ue.length; de++)
                G(Ue[de], Ae);
            O.matrixWorld.decompose(O.position, O.quaternion, O.scale),
            oe.matrix.copy(O.matrix),
            oe.matrix.decompose(oe.position, oe.quaternion, oe.scale);
            const je = oe.children;
            for (let de = 0, qe = je.length; de < qe; de++)
                je[de].updateMatrixWorld(!0);
            Ue.length === 2 ? xe(O, I, k) : O.projectionMatrix.copy(I.projectionMatrix)
        }
        ,
        this.getCamera = function() {
            return O
        }
        ,
        this.getFoveation = function() {
            if (!(p === null && m === null))
                return l
        }
        ,
        this.setFoveation = function(oe) {
            l = oe,
            p !== null && (p.fixedFoveation = oe),
            m !== null && m.fixedFoveation !== void 0 && (m.fixedFoveation = oe)
        }
        ,
        this.getPlanes = function() {
            return T
        }
        ;
        let z = null;
        function U(oe, Ae) {
            if (h = Ae.getViewerPose(f || o),
            _ = Ae,
            h !== null) {
                const Ue = h.views;
                m !== null && (e.setRenderTargetFramebuffer(S, m.framebuffer),
                e.setRenderTarget(S));
                let je = !1;
                Ue.length !== O.cameras.length && (O.cameras.length = 0,
                je = !0);
                for (let de = 0; de < Ue.length; de++) {
                    const qe = Ue[de];
                    let Ne = null;
                    if (m !== null)
                        Ne = m.getViewport(qe);
                    else {
                        const He = d.getViewSubImage(p, qe);
                        Ne = He.viewport,
                        de === 0 && (e.setRenderTargetTextures(S, He.colorTexture, p.ignoreDepthValues ? void 0 : He.depthStencilTexture),
                        e.setRenderTarget(S))
                    }
                    let Tt = R[de];
                    Tt === void 0 && (Tt = new gi,
                    Tt.layers.enable(de),
                    Tt.viewport = new zr,
                    R[de] = Tt),
                    Tt.matrix.fromArray(qe.transform.matrix),
                    Tt.projectionMatrix.fromArray(qe.projectionMatrix),
                    Tt.viewport.set(Ne.x, Ne.y, Ne.width, Ne.height),
                    de === 0 && O.matrix.copy(Tt.matrix),
                    je === !0 && O.cameras.push(Tt)
                }
            }
            for (let Ue = 0; Ue < M.length; Ue++) {
                const je = w[Ue]
                  , de = M[Ue];
                je !== null && de !== void 0 && de.update(je, Ae, f || o)
            }
            if (z && z(oe, Ae),
            Ae.detectedPlanes) {
                r.dispatchEvent({
                    type: "planesdetected",
                    data: Ae.detectedPlanes
                });
                let Ue = null;
                for (const je of T)
                    Ae.detectedPlanes.has(je) || (Ue === null && (Ue = []),
                    Ue.push(je));
                if (Ue !== null)
                    for (const je of Ue)
                        T.delete(je),
                        P.delete(je),
                        r.dispatchEvent({
                            type: "planeremoved",
                            data: je
                        });
                for (const je of Ae.detectedPlanes)
                    if (!T.has(je))
                        T.add(je),
                        P.set(je, Ae.lastChangedTime),
                        r.dispatchEvent({
                            type: "planeadded",
                            data: je
                        });
                    else {
                        const de = P.get(je);
                        je.lastChangedTime > de && (P.set(je, je.lastChangedTime),
                        r.dispatchEvent({
                            type: "planechanged",
                            data: je
                        }))
                    }
            }
            _ = null
        }
        const fe = new n3;
        fe.setAnimationLoop(U),
        this.setAnimationLoop = function(oe) {
            z = oe
        }
        ,
        this.dispose = function() {}
    }
}
function Gz(n, e) {
    function t(y, x) {
        x.color.getRGB(y.fogColor.value, e3(n)),
        x.isFog ? (y.fogNear.value = x.near,
        y.fogFar.value = x.far) : x.isFogExp2 && (y.fogDensity.value = x.density)
    }
    function r(y, x, S, M, w) {
        x.isMeshBasicMaterial || x.isMeshLambertMaterial ? i(y, x) : x.isMeshToonMaterial ? (i(y, x),
        h(y, x)) : x.isMeshPhongMaterial ? (i(y, x),
        f(y, x)) : x.isMeshStandardMaterial ? (i(y, x),
        d(y, x),
        x.isMeshPhysicalMaterial && p(y, x, w)) : x.isMeshMatcapMaterial ? (i(y, x),
        m(y, x)) : x.isMeshDepthMaterial ? i(y, x) : x.isMeshDistanceMaterial ? (i(y, x),
        _(y, x)) : x.isMeshNormalMaterial ? i(y, x) : x.isLineBasicMaterial ? (s(y, x),
        x.isLineDashedMaterial && o(y, x)) : x.isPointsMaterial ? a(y, x, S, M) : x.isSpriteMaterial ? l(y, x) : x.isShadowMaterial ? (y.color.value.copy(x.color),
        y.opacity.value = x.opacity) : x.isShaderMaterial && (x.uniformsNeedUpdate = !1)
    }
    function i(y, x) {
        y.opacity.value = x.opacity,
        x.color && y.diffuse.value.copy(x.color),
        x.emissive && y.emissive.value.copy(x.emissive).multiplyScalar(x.emissiveIntensity),
        x.map && (y.map.value = x.map),
        x.alphaMap && (y.alphaMap.value = x.alphaMap),
        x.bumpMap && (y.bumpMap.value = x.bumpMap,
        y.bumpScale.value = x.bumpScale,
        x.side === Do && (y.bumpScale.value *= -1)),
        x.displacementMap && (y.displacementMap.value = x.displacementMap,
        y.displacementScale.value = x.displacementScale,
        y.displacementBias.value = x.displacementBias),
        x.emissiveMap && (y.emissiveMap.value = x.emissiveMap),
        x.normalMap && (y.normalMap.value = x.normalMap,
        y.normalScale.value.copy(x.normalScale),
        x.side === Do && y.normalScale.value.negate()),
        x.specularMap && (y.specularMap.value = x.specularMap),
        x.alphaTest > 0 && (y.alphaTest.value = x.alphaTest);
        const S = e.get(x).envMap;
        if (S && (y.envMap.value = S,
        y.flipEnvMap.value = S.isCubeTexture && S.isRenderTargetTexture === !1 ? -1 : 1,
        y.reflectivity.value = x.reflectivity,
        y.ior.value = x.ior,
        y.refractionRatio.value = x.refractionRatio),
        x.lightMap) {
            y.lightMap.value = x.lightMap;
            const T = n.physicallyCorrectLights !== !0 ? Math.PI : 1;
            y.lightMapIntensity.value = x.lightMapIntensity * T
        }
        x.aoMap && (y.aoMap.value = x.aoMap,
        y.aoMapIntensity.value = x.aoMapIntensity);
        let M;
        x.map ? M = x.map : x.specularMap ? M = x.specularMap : x.displacementMap ? M = x.displacementMap : x.normalMap ? M = x.normalMap : x.bumpMap ? M = x.bumpMap : x.roughnessMap ? M = x.roughnessMap : x.metalnessMap ? M = x.metalnessMap : x.alphaMap ? M = x.alphaMap : x.emissiveMap ? M = x.emissiveMap : x.clearcoatMap ? M = x.clearcoatMap : x.clearcoatNormalMap ? M = x.clearcoatNormalMap : x.clearcoatRoughnessMap ? M = x.clearcoatRoughnessMap : x.iridescenceMap ? M = x.iridescenceMap : x.iridescenceThicknessMap ? M = x.iridescenceThicknessMap : x.specularIntensityMap ? M = x.specularIntensityMap : x.specularColorMap ? M = x.specularColorMap : x.transmissionMap ? M = x.transmissionMap : x.thicknessMap ? M = x.thicknessMap : x.sheenColorMap ? M = x.sheenColorMap : x.sheenRoughnessMap && (M = x.sheenRoughnessMap),
        M !== void 0 && (M.isWebGLRenderTarget && (M = M.texture),
        M.matrixAutoUpdate === !0 && M.updateMatrix(),
        y.uvTransform.value.copy(M.matrix));
        let w;
        x.aoMap ? w = x.aoMap : x.lightMap && (w = x.lightMap),
        w !== void 0 && (w.isWebGLRenderTarget && (w = w.texture),
        w.matrixAutoUpdate === !0 && w.updateMatrix(),
        y.uv2Transform.value.copy(w.matrix))
    }
    function s(y, x) {
        y.diffuse.value.copy(x.color),
        y.opacity.value = x.opacity
    }
    function o(y, x) {
        y.dashSize.value = x.dashSize,
        y.totalSize.value = x.dashSize + x.gapSize,
        y.scale.value = x.scale
    }
    function a(y, x, S, M) {
        y.diffuse.value.copy(x.color),
        y.opacity.value = x.opacity,
        y.size.value = x.size * S,
        y.scale.value = M * .5,
        x.map && (y.map.value = x.map),
        x.alphaMap && (y.alphaMap.value = x.alphaMap),
        x.alphaTest > 0 && (y.alphaTest.value = x.alphaTest);
        let w;
        x.map ? w = x.map : x.alphaMap && (w = x.alphaMap),
        w !== void 0 && (w.matrixAutoUpdate === !0 && w.updateMatrix(),
        y.uvTransform.value.copy(w.matrix))
    }
    function l(y, x) {
        y.diffuse.value.copy(x.color),
        y.opacity.value = x.opacity,
        y.rotation.value = x.rotation,
        x.map && (y.map.value = x.map),
        x.alphaMap && (y.alphaMap.value = x.alphaMap),
        x.alphaTest > 0 && (y.alphaTest.value = x.alphaTest);
        let S;
        x.map ? S = x.map : x.alphaMap && (S = x.alphaMap),
        S !== void 0 && (S.matrixAutoUpdate === !0 && S.updateMatrix(),
        y.uvTransform.value.copy(S.matrix))
    }
    function f(y, x) {
        y.specular.value.copy(x.specular),
        y.shininess.value = Math.max(x.shininess, 1e-4)
    }
    function h(y, x) {
        x.gradientMap && (y.gradientMap.value = x.gradientMap)
    }
    function d(y, x) {
        y.roughness.value = x.roughness,
        y.metalness.value = x.metalness,
        x.roughnessMap && (y.roughnessMap.value = x.roughnessMap),
        x.metalnessMap && (y.metalnessMap.value = x.metalnessMap),
        e.get(x).envMap && (y.envMapIntensity.value = x.envMapIntensity)
    }
    function p(y, x, S) {
        y.ior.value = x.ior,
        x.sheen > 0 && (y.sheenColor.value.copy(x.sheenColor).multiplyScalar(x.sheen),
        y.sheenRoughness.value = x.sheenRoughness,
        x.sheenColorMap && (y.sheenColorMap.value = x.sheenColorMap),
        x.sheenRoughnessMap && (y.sheenRoughnessMap.value = x.sheenRoughnessMap)),
        x.clearcoat > 0 && (y.clearcoat.value = x.clearcoat,
        y.clearcoatRoughness.value = x.clearcoatRoughness,
        x.clearcoatMap && (y.clearcoatMap.value = x.clearcoatMap),
        x.clearcoatRoughnessMap && (y.clearcoatRoughnessMap.value = x.clearcoatRoughnessMap),
        x.clearcoatNormalMap && (y.clearcoatNormalScale.value.copy(x.clearcoatNormalScale),
        y.clearcoatNormalMap.value = x.clearcoatNormalMap,
        x.side === Do && y.clearcoatNormalScale.value.negate())),
        x.iridescence > 0 && (y.iridescence.value = x.iridescence,
        y.iridescenceIOR.value = x.iridescenceIOR,
        y.iridescenceThicknessMinimum.value = x.iridescenceThicknessRange[0],
        y.iridescenceThicknessMaximum.value = x.iridescenceThicknessRange[1],
        x.iridescenceMap && (y.iridescenceMap.value = x.iridescenceMap),
        x.iridescenceThicknessMap && (y.iridescenceThicknessMap.value = x.iridescenceThicknessMap)),
        x.transmission > 0 && (y.transmission.value = x.transmission,
        y.transmissionSamplerMap.value = S.texture,
        y.transmissionSamplerSize.value.set(S.width, S.height),
        x.transmissionMap && (y.transmissionMap.value = x.transmissionMap),
        y.thickness.value = x.thickness,
        x.thicknessMap && (y.thicknessMap.value = x.thicknessMap),
        y.attenuationDistance.value = x.attenuationDistance,
        y.attenuationColor.value.copy(x.attenuationColor)),
        y.specularIntensity.value = x.specularIntensity,
        y.specularColor.value.copy(x.specularColor),
        x.specularIntensityMap && (y.specularIntensityMap.value = x.specularIntensityMap),
        x.specularColorMap && (y.specularColorMap.value = x.specularColorMap)
    }
    function m(y, x) {
        x.matcap && (y.matcap.value = x.matcap)
    }
    function _(y, x) {
        y.referencePosition.value.copy(x.referencePosition),
        y.nearDistance.value = x.nearDistance,
        y.farDistance.value = x.farDistance
    }
    return {
        refreshFogUniforms: t,
        refreshMaterialUniforms: r
    }
}
function Uz(n, e, t, r) {
    let i = {}
      , s = {}
      , o = [];
    const a = t.isWebGL2 ? n.getParameter(35375) : 0;
    function l(M, w) {
        const T = w.program;
        r.uniformBlockBinding(M, T)
    }
    function f(M, w) {
        let T = i[M.id];
        T === void 0 && (_(M),
        T = h(M),
        i[M.id] = T,
        M.addEventListener("dispose", x));
        const P = w.program;
        r.updateUBOMapping(M, P);
        const I = e.render.frame;
        s[M.id] !== I && (p(M),
        s[M.id] = I)
    }
    function h(M) {
        const w = d();
        M.__bindingPointIndex = w;
        const T = n.createBuffer()
          , P = M.__size
          , I = M.usage;
        return n.bindBuffer(35345, T),
        n.bufferData(35345, P, I),
        n.bindBuffer(35345, null),
        n.bindBufferBase(35345, w, T),
        T
    }
    function d() {
        for (let M = 0; M < a; M++)
            if (o.indexOf(M) === -1)
                return o.push(M),
                M;
        return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."),
        0
    }
    function p(M) {
        const w = i[M.id]
          , T = M.uniforms
          , P = M.__cache;
        n.bindBuffer(35345, w);
        for (let I = 0, k = T.length; I < k; I++) {
            const R = T[I];
            if (m(R, I, P) === !0) {
                const O = R.__offset
                  , H = Array.isArray(R.value) ? R.value : [R.value];
                let W = 0;
                for (let te = 0; te < H.length; te++) {
                    const ne = H[te]
                      , re = y(ne);
                    typeof ne == "number" ? (R.__data[0] = ne,
                    n.bufferSubData(35345, O + W, R.__data)) : ne.isMatrix3 ? (R.__data[0] = ne.elements[0],
                    R.__data[1] = ne.elements[1],
                    R.__data[2] = ne.elements[2],
                    R.__data[3] = ne.elements[0],
                    R.__data[4] = ne.elements[3],
                    R.__data[5] = ne.elements[4],
                    R.__data[6] = ne.elements[5],
                    R.__data[7] = ne.elements[0],
                    R.__data[8] = ne.elements[6],
                    R.__data[9] = ne.elements[7],
                    R.__data[10] = ne.elements[8],
                    R.__data[11] = ne.elements[0]) : (ne.toArray(R.__data, W),
                    W += re.storage / Float32Array.BYTES_PER_ELEMENT)
                }
                n.bufferSubData(35345, O, R.__data)
            }
        }
        n.bindBuffer(35345, null)
    }
    function m(M, w, T) {
        const P = M.value;
        if (T[w] === void 0) {
            if (typeof P == "number")
                T[w] = P;
            else {
                const I = Array.isArray(P) ? P : [P]
                  , k = [];
                for (let R = 0; R < I.length; R++)
                    k.push(I[R].clone());
                T[w] = k
            }
            return !0
        } else if (typeof P == "number") {
            if (T[w] !== P)
                return T[w] = P,
                !0
        } else {
            const I = Array.isArray(T[w]) ? T[w] : [T[w]]
              , k = Array.isArray(P) ? P : [P];
            for (let R = 0; R < I.length; R++) {
                const O = I[R];
                if (O.equals(k[R]) === !1)
                    return O.copy(k[R]),
                    !0
            }
        }
        return !1
    }
    function _(M) {
        const w = M.uniforms;
        let T = 0;
        const P = 16;
        let I = 0;
        for (let k = 0, R = w.length; k < R; k++) {
            const O = w[k]
              , H = {
                boundary: 0,
                storage: 0
            }
              , W = Array.isArray(O.value) ? O.value : [O.value];
            for (let te = 0, ne = W.length; te < ne; te++) {
                const re = W[te]
                  , pe = y(re);
                H.boundary += pe.boundary,
                H.storage += pe.storage
            }
            if (O.__data = new Float32Array(H.storage / Float32Array.BYTES_PER_ELEMENT),
            O.__offset = T,
            k > 0) {
                I = T % P;
                const te = P - I;
                I !== 0 && te - H.boundary < 0 && (T += P - I,
                O.__offset = T)
            }
            T += H.storage
        }
        return I = T % P,
        I > 0 && (T += P - I),
        M.__size = T,
        M.__cache = {},
        this
    }
    function y(M) {
        const w = {
            boundary: 0,
            storage: 0
        };
        return typeof M == "number" ? (w.boundary = 4,
        w.storage = 4) : M.isVector2 ? (w.boundary = 8,
        w.storage = 8) : M.isVector3 || M.isColor ? (w.boundary = 16,
        w.storage = 12) : M.isVector4 ? (w.boundary = 16,
        w.storage = 16) : M.isMatrix3 ? (w.boundary = 48,
        w.storage = 48) : M.isMatrix4 ? (w.boundary = 64,
        w.storage = 64) : M.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", M),
        w
    }
    function x(M) {
        const w = M.target;
        w.removeEventListener("dispose", x);
        const T = o.indexOf(w.__bindingPointIndex);
        o.splice(T, 1),
        n.deleteBuffer(i[w.id]),
        delete i[w.id],
        delete s[w.id]
    }
    function S() {
        for (const M in i)
            n.deleteBuffer(i[M]);
        o = [],
        i = {},
        s = {}
    }
    return {
        bind: l,
        update: f,
        dispose: S
    }
}
function Hz() {
    const n = _m("canvas");
    return n.style.display = "block",
    n
}
function qS(n={}) {
    this.isWebGLRenderer = !0;
    const e = n.canvas !== void 0 ? n.canvas : Hz()
      , t = n.context !== void 0 ? n.context : null
      , r = n.depth !== void 0 ? n.depth : !0
      , i = n.stencil !== void 0 ? n.stencil : !0
      , s = n.antialias !== void 0 ? n.antialias : !1
      , o = n.premultipliedAlpha !== void 0 ? n.premultipliedAlpha : !0
      , a = n.preserveDrawingBuffer !== void 0 ? n.preserveDrawingBuffer : !1
      , l = n.powerPreference !== void 0 ? n.powerPreference : "default"
      , f = n.failIfMajorPerformanceCaveat !== void 0 ? n.failIfMajorPerformanceCaveat : !1;
    let h;
    t !== null ? h = t.getContextAttributes().alpha : h = n.alpha !== void 0 ? n.alpha : !1;
    let d = null
      , p = null;
    const m = []
      , _ = [];
    this.domElement = e,
    this.debug = {
        checkShaderErrors: !0
    },
    this.autoClear = !0,
    this.autoClearColor = !0,
    this.autoClearDepth = !0,
    this.autoClearStencil = !0,
    this.sortObjects = !0,
    this.clippingPlanes = [],
    this.localClippingEnabled = !1,
    this.outputEncoding = bl,
    this.physicallyCorrectLights = !1,
    this.toneMapping = Ka,
    this.toneMappingExposure = 1;
    const y = this;
    let x = !1
      , S = 0
      , M = 0
      , w = null
      , T = -1
      , P = null;
    const I = new zr
      , k = new zr;
    let R = null
      , O = e.width
      , H = e.height
      , W = 1
      , te = null
      , ne = null;
    const re = new zr(0,0,O,H)
      , pe = new zr(0,0,O,H);
    let ce = !1;
    const xe = new w_;
    let G = !1
      , z = !1
      , U = null;
    const fe = new Dn
      , oe = new it
      , Ae = new $
      , Ue = {
        background: null,
        fog: null,
        environment: null,
        overrideMaterial: null,
        isScene: !0
    };
    function je() {
        return w === null ? W : 1
    }
    let de = t;
    function qe(j, me) {
        for (let ze = 0; ze < j.length; ze++) {
            const ge = j[ze]
              , Oe = e.getContext(ge, me);
            if (Oe !== null)
                return Oe
        }
        return null
    }
    try {
        const j = {
            alpha: !0,
            depth: r,
            stencil: i,
            antialias: s,
            premultipliedAlpha: o,
            preserveDrawingBuffer: a,
            powerPreference: l,
            failIfMajorPerformanceCaveat: f
        };
        if ("setAttribute"in e && e.setAttribute("data-engine", `three.js r ${p_}`),
        e.addEventListener("webglcontextlost", rt, !1),
        e.addEventListener("webglcontextrestored", st, !1),
        e.addEventListener("webglcontextcreationerror", Ut, !1),
        de === null) {
            const me = ["webgl2", "webgl", "experimental-webgl"];
            if (y.isWebGL1Renderer === !0 && me.shift(),
            de = qe(me, j),
            de === null)
                throw qe(me) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.")
        }
        de.getShaderPrecisionFormat === void 0 && (de.getShaderPrecisionFormat = function() {
            return {
                rangeMin: 1,
                rangeMax: 1,
                precision: 1
            }
        }
        )
    } catch (j) {
        throw console.error("THREE.WebGLRenderer: " + j.message),
        j
    }
    let Ne, Tt, He, gt, be, Ee, at, _t, Ce, ee, et, Ze, ft, Pt, Z, V, ye, tt, Ve, Ke, dt, ct, Fe, Rt;
    function le() {
        Ne = new iN(de),
        Tt = new ZO(de,Ne,n),
        Ne.init(Tt),
        ct = new a3(de,Ne,Tt),
        He = new kz(de,Ne,Tt),
        gt = new aN,
        be = new Az,
        Ee = new Oz(de,Ne,He,be,Tt,ct,gt),
        at = new eN(y),
        _t = new rN(y),
        Ce = new gF(de,Tt),
        Fe = new qO(de,Ne,Ce,Tt),
        ee = new sN(de,Ce,gt,Fe),
        et = new fN(de,ee,Ce,gt),
        Ve = new cN(de,Tt,Ee),
        V = new $O(be),
        Ze = new Mz(y,at,_t,Ne,Tt,Fe,V),
        ft = new Gz(y,be),
        Pt = new Ez,
        Z = new Bz(Ne,Tt),
        tt = new KO(y,at,_t,He,et,h,o),
        ye = new Fz(y,et,Tt),
        Rt = new Uz(de,gt,Tt,He),
        Ke = new QO(de,Ne,gt,Tt),
        dt = new oN(de,Ne,gt,Tt),
        gt.programs = Ze.programs,
        y.capabilities = Tt,
        y.extensions = Ne,
        y.properties = be,
        y.renderLists = Pt,
        y.shadowMap = ye,
        y.state = He,
        y.info = gt
    }
    le();
    const Le = new zz(y,de);
    this.xr = Le,
    this.getContext = function() {
        return de
    }
    ,
    this.getContextAttributes = function() {
        return de.getContextAttributes()
    }
    ,
    this.forceContextLoss = function() {
        const j = Ne.get("WEBGL_lose_context");
        j && j.loseContext()
    }
    ,
    this.forceContextRestore = function() {
        const j = Ne.get("WEBGL_lose_context");
        j && j.restoreContext()
    }
    ,
    this.getPixelRatio = function() {
        return W
    }
    ,
    this.setPixelRatio = function(j) {
        j !== void 0 && (W = j,
        this.setSize(O, H, !1))
    }
    ,
    this.getSize = function(j) {
        return j.set(O, H)
    }
    ,
    this.setSize = function(j, me, ze) {
        if (Le.isPresenting) {
            console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
            return
        }
        O = j,
        H = me,
        e.width = Math.floor(j * W),
        e.height = Math.floor(me * W),
        ze !== !1 && (e.style.width = j + "px",
        e.style.height = me + "px"),
        this.setViewport(0, 0, j, me)
    }
    ,
    this.getDrawingBufferSize = function(j) {
        return j.set(O * W, H * W).floor()
    }
    ,
    this.setDrawingBufferSize = function(j, me, ze) {
        O = j,
        H = me,
        W = ze,
        e.width = Math.floor(j * ze),
        e.height = Math.floor(me * ze),
        this.setViewport(0, 0, j, me)
    }
    ,
    this.getCurrentViewport = function(j) {
        return j.copy(I)
    }
    ,
    this.getViewport = function(j) {
        return j.copy(re)
    }
    ,
    this.setViewport = function(j, me, ze, ge) {
        j.isVector4 ? re.set(j.x, j.y, j.z, j.w) : re.set(j, me, ze, ge),
        He.viewport(I.copy(re).multiplyScalar(W).floor())
    }
    ,
    this.getScissor = function(j) {
        return j.copy(pe)
    }
    ,
    this.setScissor = function(j, me, ze, ge) {
        j.isVector4 ? pe.set(j.x, j.y, j.z, j.w) : pe.set(j, me, ze, ge),
        He.scissor(k.copy(pe).multiplyScalar(W).floor())
    }
    ,
    this.getScissorTest = function() {
        return ce
    }
    ,
    this.setScissorTest = function(j) {
        He.setScissorTest(ce = j)
    }
    ,
    this.setOpaqueSort = function(j) {
        te = j
    }
    ,
    this.setTransparentSort = function(j) {
        ne = j
    }
    ,
    this.getClearColor = function(j) {
        return j.copy(tt.getClearColor())
    }
    ,
    this.setClearColor = function() {
        tt.setClearColor.apply(tt, arguments)
    }
    ,
    this.getClearAlpha = function() {
        return tt.getClearAlpha()
    }
    ,
    this.setClearAlpha = function() {
        tt.setClearAlpha.apply(tt, arguments)
    }
    ,
    this.clear = function(j=!0, me=!0, ze=!0) {
        let ge = 0;
        j && (ge |= 16384),
        me && (ge |= 256),
        ze && (ge |= 1024),
        de.clear(ge)
    }
    ,
    this.clearColor = function() {
        this.clear(!0, !1, !1)
    }
    ,
    this.clearDepth = function() {
        this.clear(!1, !0, !1)
    }
    ,
    this.clearStencil = function() {
        this.clear(!1, !1, !0)
    }
    ,
    this.dispose = function() {
        e.removeEventListener("webglcontextlost", rt, !1),
        e.removeEventListener("webglcontextrestored", st, !1),
        e.removeEventListener("webglcontextcreationerror", Ut, !1),
        Pt.dispose(),
        Z.dispose(),
        be.dispose(),
        at.dispose(),
        _t.dispose(),
        et.dispose(),
        Fe.dispose(),
        Rt.dispose(),
        Ze.dispose(),
        Le.dispose(),
        Le.removeEventListener("sessionstart", vt),
        Le.removeEventListener("sessionend", Et),
        U && (U.dispose(),
        U = null),
        rn.stop()
    }
    ;
    function rt(j) {
        j.preventDefault(),
        console.log("THREE.WebGLRenderer: Context Lost."),
        x = !0
    }
    function st() {
        console.log("THREE.WebGLRenderer: Context Restored."),
        x = !1;
        const j = gt.autoReset
          , me = ye.enabled
          , ze = ye.autoUpdate
          , ge = ye.needsUpdate
          , Oe = ye.type;
        le(),
        gt.autoReset = j,
        ye.enabled = me,
        ye.autoUpdate = ze,
        ye.needsUpdate = ge,
        ye.type = Oe
    }
    function Ut(j) {
        console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", j.statusMessage)
    }
    function Mt(j) {
        const me = j.target;
        me.removeEventListener("dispose", Mt),
        wn(me)
    }
    function wn(j) {
        ae(j),
        be.remove(j)
    }
    function ae(j) {
        const me = be.get(j).programs;
        me !== void 0 && (me.forEach(function(ze) {
            Ze.releaseProgram(ze)
        }),
        j.isShaderMaterial && Ze.releaseShaderCache(j))
    }
    this.renderBufferDirect = function(j, me, ze, ge, Oe, Vt) {
        me === null && (me = Ue);
        const Ft = Oe.isMesh && Oe.matrixWorld.determinant() < 0
          , Gt = hn(j, me, ze, ge, Oe);
        He.setMaterial(ge, Ft);
        let Yt = ze.index
          , Sn = 1;
        ge.wireframe === !0 && (Yt = ee.getWireframeAttribute(ze),
        Sn = 2);
        const tn = ze.drawRange
          , Xt = ze.attributes.position;
        let en = tn.start * Sn
          , Zn = (tn.start + tn.count) * Sn;
        Vt !== null && (en = Math.max(en, Vt.start * Sn),
        Zn = Math.min(Zn, (Vt.start + Vt.count) * Sn)),
        Yt !== null ? (en = Math.max(en, 0),
        Zn = Math.min(Zn, Yt.count)) : Xt != null && (en = Math.max(en, 0),
        Zn = Math.min(Zn, Xt.count));
        const Yn = Zn - en;
        if (Yn < 0 || Yn === 1 / 0)
            return;
        Fe.setup(Oe, ge, Gt, ze, Yt);
        let es, Nn = Ke;
        if (Yt !== null && (es = Ce.get(Yt),
        Nn = dt,
        Nn.setIndex(es)),
        Oe.isMesh)
            ge.wireframe === !0 ? (He.setLineWidth(ge.wireframeLinewidth * je()),
            Nn.setMode(1)) : Nn.setMode(4);
        else if (Oe.isLine) {
            let kt = ge.linewidth;
            kt === void 0 && (kt = 1),
            He.setLineWidth(kt * je()),
            Oe.isLineSegments ? Nn.setMode(1) : Oe.isLineLoop ? Nn.setMode(2) : Nn.setMode(3)
        } else
            Oe.isPoints ? Nn.setMode(0) : Oe.isSprite && Nn.setMode(4);
        if (Oe.isInstancedMesh)
            Nn.renderInstances(en, Yn, Oe.count);
        else if (ze.isInstancedBufferGeometry) {
            const kt = ze._maxInstanceCount !== void 0 ? ze._maxInstanceCount : 1 / 0
              , Ur = Math.min(ze.instanceCount, kt);
            Nn.renderInstances(en, Yn, Ur)
        } else
            Nn.render(en, Yn)
    }
    ,
    this.compile = function(j, me) {
        function ze(ge, Oe, Vt) {
            ge.transparent === !0 && ge.side === Sl && ge.forceSinglePass === !1 ? (ge.side = Do,
            ge.needsUpdate = !0,
            Nt(ge, Oe, Vt),
            ge.side = El,
            ge.needsUpdate = !0,
            Nt(ge, Oe, Vt),
            ge.side = Sl) : Nt(ge, Oe, Vt)
        }
        p = Z.get(j),
        p.init(),
        _.push(p),
        j.traverseVisible(function(ge) {
            ge.isLight && ge.layers.test(me.layers) && (p.pushLight(ge),
            ge.castShadow && p.pushShadow(ge))
        }),
        p.setupLights(y.physicallyCorrectLights),
        j.traverse(function(ge) {
            const Oe = ge.material;
            if (Oe)
                if (Array.isArray(Oe))
                    for (let Vt = 0; Vt < Oe.length; Vt++) {
                        const Ft = Oe[Vt];
                        ze(Ft, j, ge)
                    }
                else
                    ze(Oe, j, ge)
        }),
        _.pop(),
        p = null
    }
    ;
    let De = null;
    function Je(j) {
        De && De(j)
    }
    function vt() {
        rn.stop()
    }
    function Et() {
        rn.start()
    }
    const rn = new n3;
    rn.setAnimationLoop(Je),
    typeof self < "u" && rn.setContext(self),
    this.setAnimationLoop = function(j) {
        De = j,
        Le.setAnimationLoop(j),
        j === null ? rn.stop() : rn.start()
    }
    ,
    Le.addEventListener("sessionstart", vt),
    Le.addEventListener("sessionend", Et),
    this.render = function(j, me) {
        if (me !== void 0 && me.isCamera !== !0) {
            console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
            return
        }
        if (x === !0)
            return;
        j.matrixWorldAutoUpdate === !0 && j.updateMatrixWorld(),
        me.parent === null && me.matrixWorldAutoUpdate === !0 && me.updateMatrixWorld(),
        Le.enabled === !0 && Le.isPresenting === !0 && (Le.cameraAutoUpdate === !0 && Le.updateCamera(me),
        me = Le.getCamera()),
        j.isScene === !0 && j.onBeforeRender(y, j, me, w),
        p = Z.get(j, _.length),
        p.init(),
        _.push(p),
        fe.multiplyMatrices(me.projectionMatrix, me.matrixWorldInverse),
        xe.setFromProjectionMatrix(fe),
        z = this.localClippingEnabled,
        G = V.init(this.clippingPlanes, z),
        d = Pt.get(j, m.length),
        d.init(),
        m.push(d),
        dn(j, me, 0, y.sortObjects),
        d.finish(),
        y.sortObjects === !0 && d.sort(te, ne),
        G === !0 && V.beginShadows();
        const ze = p.state.shadowsArray;
        if (ye.render(ze, j, me),
        G === !0 && V.endShadows(),
        this.info.autoReset === !0 && this.info.reset(),
        tt.render(d, j),
        p.setupLights(y.physicallyCorrectLights),
        me.isArrayCamera) {
            const ge = me.cameras;
            for (let Oe = 0, Vt = ge.length; Oe < Vt; Oe++) {
                const Ft = ge[Oe];
                or(d, j, Ft, Ft.viewport)
            }
        } else
            or(d, j, me);
        w !== null && (Ee.updateMultisampleRenderTarget(w),
        Ee.updateRenderTargetMipmap(w)),
        j.isScene === !0 && j.onAfterRender(y, j, me),
        Fe.resetDefaultState(),
        T = -1,
        P = null,
        _.pop(),
        _.length > 0 ? p = _[_.length - 1] : p = null,
        m.pop(),
        m.length > 0 ? d = m[m.length - 1] : d = null
    }
    ;
    function dn(j, me, ze, ge) {
        if (j.visible === !1)
            return;
        if (j.layers.test(me.layers)) {
            if (j.isGroup)
                ze = j.renderOrder;
            else if (j.isLOD)
                j.autoUpdate === !0 && j.update(me);
            else if (j.isLight)
                p.pushLight(j),
                j.castShadow && p.pushShadow(j);
            else if (j.isSprite) {
                if (!j.frustumCulled || xe.intersectsSprite(j)) {
                    ge && Ae.setFromMatrixPosition(j.matrixWorld).applyMatrix4(fe);
                    const Ft = et.update(j)
                      , Gt = j.material;
                    Gt.visible && d.push(j, Ft, Gt, ze, Ae.z, null)
                }
            } else if ((j.isMesh || j.isLine || j.isPoints) && (j.isSkinnedMesh && j.skeleton.frame !== gt.render.frame && (j.skeleton.update(),
            j.skeleton.frame = gt.render.frame),
            !j.frustumCulled || xe.intersectsObject(j))) {
                ge && Ae.setFromMatrixPosition(j.matrixWorld).applyMatrix4(fe);
                const Ft = et.update(j)
                  , Gt = j.material;
                if (Array.isArray(Gt)) {
                    const Yt = Ft.groups;
                    for (let Sn = 0, tn = Yt.length; Sn < tn; Sn++) {
                        const Xt = Yt[Sn]
                          , en = Gt[Xt.materialIndex];
                        en && en.visible && d.push(j, Ft, en, ze, Ae.z, Xt)
                    }
                } else
                    Gt.visible && d.push(j, Ft, Gt, ze, Ae.z, null)
            }
        }
        const Vt = j.children;
        for (let Ft = 0, Gt = Vt.length; Ft < Gt; Ft++)
            dn(Vt[Ft], me, ze, ge)
    }
    function or(j, me, ze, ge) {
        const Oe = j.opaque
          , Vt = j.transmissive
          , Ft = j.transparent;
        p.setupLightsView(ze),
        G === !0 && V.setGlobalState(y.clippingPlanes, ze),
        Vt.length > 0 && mn(Oe, me, ze),
        ge && He.viewport(I.copy(ge)),
        Oe.length > 0 && St(Oe, me, ze),
        Vt.length > 0 && St(Vt, me, ze),
        Ft.length > 0 && St(Ft, me, ze),
        He.buffers.depth.setTest(!0),
        He.buffers.depth.setMask(!0),
        He.buffers.color.setMask(!0),
        He.setPolygonOffset(!1)
    }
    function mn(j, me, ze) {
        const ge = Tt.isWebGL2;
        U === null && (U = new $a(1,1,{
            generateMipmaps: !0,
            type: Ne.has("EXT_color_buffer_half_float") ? ja : Tc,
            minFilter: Kl,
            samples: ge && s === !0 ? 4 : 0
        })),
        y.getDrawingBufferSize(oe),
        ge ? U.setSize(oe.x, oe.y) : U.setSize(Wv(oe.x), Wv(oe.y));
        const Oe = y.getRenderTarget();
        y.setRenderTarget(U),
        y.clear();
        const Vt = y.toneMapping;
        y.toneMapping = Ka,
        St(j, me, ze),
        y.toneMapping = Vt,
        Ee.updateMultisampleRenderTarget(U),
        Ee.updateRenderTargetMipmap(U),
        y.setRenderTarget(Oe)
    }
    function St(j, me, ze) {
        const ge = me.isScene === !0 ? me.overrideMaterial : null;
        for (let Oe = 0, Vt = j.length; Oe < Vt; Oe++) {
            const Ft = j[Oe]
              , Gt = Ft.object
              , Yt = Ft.geometry
              , Sn = ge === null ? Ft.material : ge
              , tn = Ft.group;
            Gt.layers.test(ze.layers) && ut(Gt, me, ze, Yt, Sn, tn)
        }
    }
    function ut(j, me, ze, ge, Oe, Vt) {
        j.onBeforeRender(y, me, ze, ge, Oe, Vt),
        j.modelViewMatrix.multiplyMatrices(ze.matrixWorldInverse, j.matrixWorld),
        j.normalMatrix.getNormalMatrix(j.modelViewMatrix),
        Oe.onBeforeRender(y, me, ze, ge, j, Vt),
        Oe.transparent === !0 && Oe.side === Sl && Oe.forceSinglePass === !1 ? (Oe.side = Do,
        Oe.needsUpdate = !0,
        y.renderBufferDirect(ze, me, ge, Oe, j, Vt),
        Oe.side = El,
        Oe.needsUpdate = !0,
        y.renderBufferDirect(ze, me, ge, Oe, j, Vt),
        Oe.side = Sl) : y.renderBufferDirect(ze, me, ge, Oe, j, Vt),
        j.onAfterRender(y, me, ze, ge, Oe, Vt)
    }
    function Nt(j, me, ze) {
        me.isScene !== !0 && (me = Ue);
        const ge = be.get(j)
          , Oe = p.state.lights
          , Vt = p.state.shadowsArray
          , Ft = Oe.state.version
          , Gt = Ze.getParameters(j, Oe.state, Vt, me, ze)
          , Yt = Ze.getProgramCacheKey(Gt);
        let Sn = ge.programs;
        ge.environment = j.isMeshStandardMaterial ? me.environment : null,
        ge.fog = me.fog,
        ge.envMap = (j.isMeshStandardMaterial ? _t : at).get(j.envMap || ge.environment),
        Sn === void 0 && (j.addEventListener("dispose", Mt),
        Sn = new Map,
        ge.programs = Sn);
        let tn = Sn.get(Yt);
        if (tn !== void 0) {
            if (ge.currentProgram === tn && ge.lightsStateVersion === Ft)
                return $t(j, Gt),
                tn
        } else
            Gt.uniforms = Ze.getUniforms(j),
            j.onBuild(ze, Gt, y),
            j.onBeforeCompile(Gt, y),
            tn = Ze.acquireProgram(Gt, Yt),
            Sn.set(Yt, tn),
            ge.uniforms = Gt.uniforms;
        const Xt = ge.uniforms;
        (!j.isShaderMaterial && !j.isRawShaderMaterial || j.clipping === !0) && (Xt.clippingPlanes = V.uniform),
        $t(j, Gt),
        ge.needsLights = vn(j),
        ge.lightsStateVersion = Ft,
        ge.needsLights && (Xt.ambientLightColor.value = Oe.state.ambient,
        Xt.lightProbe.value = Oe.state.probe,
        Xt.directionalLights.value = Oe.state.directional,
        Xt.directionalLightShadows.value = Oe.state.directionalShadow,
        Xt.spotLights.value = Oe.state.spot,
        Xt.spotLightShadows.value = Oe.state.spotShadow,
        Xt.rectAreaLights.value = Oe.state.rectArea,
        Xt.ltc_1.value = Oe.state.rectAreaLTC1,
        Xt.ltc_2.value = Oe.state.rectAreaLTC2,
        Xt.pointLights.value = Oe.state.point,
        Xt.pointLightShadows.value = Oe.state.pointShadow,
        Xt.hemisphereLights.value = Oe.state.hemi,
        Xt.directionalShadowMap.value = Oe.state.directionalShadowMap,
        Xt.directionalShadowMatrix.value = Oe.state.directionalShadowMatrix,
        Xt.spotShadowMap.value = Oe.state.spotShadowMap,
        Xt.spotLightMatrix.value = Oe.state.spotLightMatrix,
        Xt.spotLightMap.value = Oe.state.spotLightMap,
        Xt.pointShadowMap.value = Oe.state.pointShadowMap,
        Xt.pointShadowMatrix.value = Oe.state.pointShadowMatrix);
        const en = tn.getUniforms()
          , Zn = uv.seqWithValue(en.seq, Xt);
        return ge.currentProgram = tn,
        ge.uniformsList = Zn,
        tn
    }
    function $t(j, me) {
        const ze = be.get(j);
        ze.outputEncoding = me.outputEncoding,
        ze.instancing = me.instancing,
        ze.skinning = me.skinning,
        ze.morphTargets = me.morphTargets,
        ze.morphNormals = me.morphNormals,
        ze.morphColors = me.morphColors,
        ze.morphTargetsCount = me.morphTargetsCount,
        ze.numClippingPlanes = me.numClippingPlanes,
        ze.numIntersection = me.numClipIntersection,
        ze.vertexAlphas = me.vertexAlphas,
        ze.vertexTangents = me.vertexTangents,
        ze.toneMapping = me.toneMapping
    }
    function hn(j, me, ze, ge, Oe) {
        me.isScene !== !0 && (me = Ue),
        Ee.resetTextureUnits();
        const Vt = me.fog
          , Ft = ge.isMeshStandardMaterial ? me.environment : null
          , Gt = w === null ? y.outputEncoding : w.isXRRenderTarget === !0 ? w.texture.encoding : bl
          , Yt = (ge.isMeshStandardMaterial ? _t : at).get(ge.envMap || Ft)
          , Sn = ge.vertexColors === !0 && !!ze.attributes.color && ze.attributes.color.itemSize === 4
          , tn = !!ge.normalMap && !!ze.attributes.tangent
          , Xt = !!ze.morphAttributes.position
          , en = !!ze.morphAttributes.normal
          , Zn = !!ze.morphAttributes.color
          , Yn = ge.toneMapped ? y.toneMapping : Ka
          , es = ze.morphAttributes.position || ze.morphAttributes.normal || ze.morphAttributes.color
          , Nn = es !== void 0 ? es.length : 0
          , kt = be.get(ge)
          , Ur = p.state.lights;
        if (G === !0 && (z === !0 || j !== P)) {
            const ir = j === P && ge.id === T;
            V.setState(ge, j, ir)
        }
        let Ln = !1;
        ge.version === kt.__version ? (kt.needsLights && kt.lightsStateVersion !== Ur.state.version || kt.outputEncoding !== Gt || Oe.isInstancedMesh && kt.instancing === !1 || !Oe.isInstancedMesh && kt.instancing === !0 || Oe.isSkinnedMesh && kt.skinning === !1 || !Oe.isSkinnedMesh && kt.skinning === !0 || kt.envMap !== Yt || ge.fog === !0 && kt.fog !== Vt || kt.numClippingPlanes !== void 0 && (kt.numClippingPlanes !== V.numPlanes || kt.numIntersection !== V.numIntersection) || kt.vertexAlphas !== Sn || kt.vertexTangents !== tn || kt.morphTargets !== Xt || kt.morphNormals !== en || kt.morphColors !== Zn || kt.toneMapping !== Yn || Tt.isWebGL2 === !0 && kt.morphTargetsCount !== Nn) && (Ln = !0) : (Ln = !0,
        kt.__version = ge.version);
        let Bs = kt.currentProgram;
        Ln === !0 && (Bs = Nt(ge, me, Oe));
        let qr = !1
          , Qr = !1
          , xs = !1;
        const Mn = Bs.getUniforms()
          , An = kt.uniforms;
        if (He.useProgram(Bs.program) && (qr = !0,
        Qr = !0,
        xs = !0),
        ge.id !== T && (T = ge.id,
        Qr = !0),
        qr || P !== j) {
            if (Mn.setValue(de, "projectionMatrix", j.projectionMatrix),
            Tt.logarithmicDepthBuffer && Mn.setValue(de, "logDepthBufFC", 2 / (Math.log(j.far + 1) / Math.LN2)),
            P !== j && (P = j,
            Qr = !0,
            xs = !0),
            ge.isShaderMaterial || ge.isMeshPhongMaterial || ge.isMeshToonMaterial || ge.isMeshStandardMaterial || ge.envMap) {
                const ir = Mn.map.cameraPosition;
                ir !== void 0 && ir.setValue(de, Ae.setFromMatrixPosition(j.matrixWorld))
            }
            (ge.isMeshPhongMaterial || ge.isMeshToonMaterial || ge.isMeshLambertMaterial || ge.isMeshBasicMaterial || ge.isMeshStandardMaterial || ge.isShaderMaterial) && Mn.setValue(de, "isOrthographic", j.isOrthographicCamera === !0),
            (ge.isMeshPhongMaterial || ge.isMeshToonMaterial || ge.isMeshLambertMaterial || ge.isMeshBasicMaterial || ge.isMeshStandardMaterial || ge.isShaderMaterial || ge.isShadowMaterial || Oe.isSkinnedMesh) && Mn.setValue(de, "viewMatrix", j.matrixWorldInverse)
        }
        if (Oe.isSkinnedMesh) {
            Mn.setOptional(de, Oe, "bindMatrix"),
            Mn.setOptional(de, Oe, "bindMatrixInverse");
            const ir = Oe.skeleton;
            ir && (Tt.floatVertexTextures ? (ir.boneTexture === null && ir.computeBoneTexture(),
            Mn.setValue(de, "boneTexture", ir.boneTexture, Ee),
            Mn.setValue(de, "boneTextureSize", ir.boneTextureSize)) : console.warn("THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."))
        }
        const ws = ze.morphAttributes;
        if ((ws.position !== void 0 || ws.normal !== void 0 || ws.color !== void 0 && Tt.isWebGL2 === !0) && Ve.update(Oe, ze, ge, Bs),
        (Qr || kt.receiveShadow !== Oe.receiveShadow) && (kt.receiveShadow = Oe.receiveShadow,
        Mn.setValue(de, "receiveShadow", Oe.receiveShadow)),
        ge.isMeshGouraudMaterial && ge.envMap !== null && (An.envMap.value = Yt,
        An.flipEnvMap.value = Yt.isCubeTexture && Yt.isRenderTargetTexture === !1 ? -1 : 1),
        Qr && (Mn.setValue(de, "toneMappingExposure", y.toneMappingExposure),
        kt.needsLights && Qn(An, xs),
        Vt && ge.fog === !0 && ft.refreshFogUniforms(An, Vt),
        ft.refreshMaterialUniforms(An, ge, W, H, U),
        uv.upload(de, kt.uniformsList, An, Ee)),
        ge.isShaderMaterial && ge.uniformsNeedUpdate === !0 && (uv.upload(de, kt.uniformsList, An, Ee),
        ge.uniformsNeedUpdate = !1),
        ge.isSpriteMaterial && Mn.setValue(de, "center", Oe.center),
        Mn.setValue(de, "modelViewMatrix", Oe.modelViewMatrix),
        Mn.setValue(de, "normalMatrix", Oe.normalMatrix),
        Mn.setValue(de, "modelMatrix", Oe.matrixWorld),
        ge.isShaderMaterial || ge.isRawShaderMaterial) {
            const ir = ge.uniformsGroups;
            for (let Ni = 0, Js = ir.length; Ni < Js; Ni++)
                if (Tt.isWebGL2) {
                    const ea = ir[Ni];
                    Rt.update(ea, Bs),
                    Rt.bind(ea, Bs)
                } else
                    console.warn("THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.")
        }
        return Bs
    }
    function Qn(j, me) {
        j.ambientLightColor.needsUpdate = me,
        j.lightProbe.needsUpdate = me,
        j.directionalLights.needsUpdate = me,
        j.directionalLightShadows.needsUpdate = me,
        j.pointLights.needsUpdate = me,
        j.pointLightShadows.needsUpdate = me,
        j.spotLights.needsUpdate = me,
        j.spotLightShadows.needsUpdate = me,
        j.rectAreaLights.needsUpdate = me,
        j.hemisphereLights.needsUpdate = me
    }
    function vn(j) {
        return j.isMeshLambertMaterial || j.isMeshToonMaterial || j.isMeshPhongMaterial || j.isMeshStandardMaterial || j.isShadowMaterial || j.isShaderMaterial && j.lights === !0
    }
    this.getActiveCubeFace = function() {
        return S
    }
    ,
    this.getActiveMipmapLevel = function() {
        return M
    }
    ,
    this.getRenderTarget = function() {
        return w
    }
    ,
    this.setRenderTargetTextures = function(j, me, ze) {
        be.get(j.texture).__webglTexture = me,
        be.get(j.depthTexture).__webglTexture = ze;
        const ge = be.get(j);
        ge.__hasExternalTextures = !0,
        ge.__hasExternalTextures && (ge.__autoAllocateDepthBuffer = ze === void 0,
        ge.__autoAllocateDepthBuffer || Ne.has("WEBGL_multisampled_render_to_texture") === !0 && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"),
        ge.__useRenderToTexture = !1))
    }
    ,
    this.setRenderTargetFramebuffer = function(j, me) {
        const ze = be.get(j);
        ze.__webglFramebuffer = me,
        ze.__useDefaultFramebuffer = me === void 0
    }
    ,
    this.setRenderTarget = function(j, me=0, ze=0) {
        w = j,
        S = me,
        M = ze;
        let ge = !0
          , Oe = null
          , Vt = !1
          , Ft = !1;
        if (j) {
            const Yt = be.get(j);
            Yt.__useDefaultFramebuffer !== void 0 ? (He.bindFramebuffer(36160, null),
            ge = !1) : Yt.__webglFramebuffer === void 0 ? Ee.setupRenderTarget(j) : Yt.__hasExternalTextures && Ee.rebindTextures(j, be.get(j.texture).__webglTexture, be.get(j.depthTexture).__webglTexture);
            const Sn = j.texture;
            (Sn.isData3DTexture || Sn.isDataArrayTexture || Sn.isCompressedArrayTexture) && (Ft = !0);
            const tn = be.get(j).__webglFramebuffer;
            j.isWebGLCubeRenderTarget ? (Oe = tn[me],
            Vt = !0) : Tt.isWebGL2 && j.samples > 0 && Ee.useMultisampledRTT(j) === !1 ? Oe = be.get(j).__webglMultisampledFramebuffer : Oe = tn,
            I.copy(j.viewport),
            k.copy(j.scissor),
            R = j.scissorTest
        } else
            I.copy(re).multiplyScalar(W).floor(),
            k.copy(pe).multiplyScalar(W).floor(),
            R = ce;
        if (He.bindFramebuffer(36160, Oe) && Tt.drawBuffers && ge && He.drawBuffers(j, Oe),
        He.viewport(I),
        He.scissor(k),
        He.setScissorTest(R),
        Vt) {
            const Yt = be.get(j.texture);
            de.framebufferTexture2D(36160, 36064, 34069 + me, Yt.__webglTexture, ze)
        } else if (Ft) {
            const Yt = be.get(j.texture)
              , Sn = me || 0;
            de.framebufferTextureLayer(36160, 36064, Yt.__webglTexture, ze || 0, Sn)
        }
        T = -1
    }
    ,
    this.readRenderTargetPixels = function(j, me, ze, ge, Oe, Vt, Ft) {
        if (!(j && j.isWebGLRenderTarget)) {
            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
            return
        }
        let Gt = be.get(j).__webglFramebuffer;
        if (j.isWebGLCubeRenderTarget && Ft !== void 0 && (Gt = Gt[Ft]),
        Gt) {
            He.bindFramebuffer(36160, Gt);
            try {
                const Yt = j.texture
                  , Sn = Yt.format
                  , tn = Yt.type;
                if (Sn !== ga && ct.convert(Sn) !== de.getParameter(35739)) {
                    console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                    return
                }
                const Xt = tn === ja && (Ne.has("EXT_color_buffer_half_float") || Tt.isWebGL2 && Ne.has("EXT_color_buffer_float"));
                if (tn !== Tc && ct.convert(tn) !== de.getParameter(35738) && !(tn === ya && (Tt.isWebGL2 || Ne.has("OES_texture_float") || Ne.has("WEBGL_color_buffer_float"))) && !Xt) {
                    console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                    return
                }
                me >= 0 && me <= j.width - ge && ze >= 0 && ze <= j.height - Oe && de.readPixels(me, ze, ge, Oe, ct.convert(Sn), ct.convert(tn), Vt)
            } finally {
                const Yt = w !== null ? be.get(w).__webglFramebuffer : null;
                He.bindFramebuffer(36160, Yt)
            }
        }
    }
    ,
    this.copyFramebufferToTexture = function(j, me, ze=0) {
        const ge = Math.pow(2, -ze)
          , Oe = Math.floor(me.image.width * ge)
          , Vt = Math.floor(me.image.height * ge);
        Ee.setTexture2D(me, 0),
        de.copyTexSubImage2D(3553, ze, 0, 0, j.x, j.y, Oe, Vt),
        He.unbindTexture()
    }
    ,
    this.copyTextureToTexture = function(j, me, ze, ge=0) {
        const Oe = me.image.width
          , Vt = me.image.height
          , Ft = ct.convert(ze.format)
          , Gt = ct.convert(ze.type);
        Ee.setTexture2D(ze, 0),
        de.pixelStorei(37440, ze.flipY),
        de.pixelStorei(37441, ze.premultiplyAlpha),
        de.pixelStorei(3317, ze.unpackAlignment),
        me.isDataTexture ? de.texSubImage2D(3553, ge, j.x, j.y, Oe, Vt, Ft, Gt, me.image.data) : me.isCompressedTexture ? de.compressedTexSubImage2D(3553, ge, j.x, j.y, me.mipmaps[0].width, me.mipmaps[0].height, Ft, me.mipmaps[0].data) : de.texSubImage2D(3553, ge, j.x, j.y, Ft, Gt, me.image),
        ge === 0 && ze.generateMipmaps && de.generateMipmap(3553),
        He.unbindTexture()
    }
    ,
    this.copyTextureToTexture3D = function(j, me, ze, ge, Oe=0) {
        if (y.isWebGL1Renderer) {
            console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
            return
        }
        const Vt = j.max.x - j.min.x + 1
          , Ft = j.max.y - j.min.y + 1
          , Gt = j.max.z - j.min.z + 1
          , Yt = ct.convert(ge.format)
          , Sn = ct.convert(ge.type);
        let tn;
        if (ge.isData3DTexture)
            Ee.setTexture3D(ge, 0),
            tn = 32879;
        else if (ge.isDataArrayTexture)
            Ee.setTexture2DArray(ge, 0),
            tn = 35866;
        else {
            console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
            return
        }
        de.pixelStorei(37440, ge.flipY),
        de.pixelStorei(37441, ge.premultiplyAlpha),
        de.pixelStorei(3317, ge.unpackAlignment);
        const Xt = de.getParameter(3314)
          , en = de.getParameter(32878)
          , Zn = de.getParameter(3316)
          , Yn = de.getParameter(3315)
          , es = de.getParameter(32877)
          , Nn = ze.isCompressedTexture ? ze.mipmaps[0] : ze.image;
        de.pixelStorei(3314, Nn.width),
        de.pixelStorei(32878, Nn.height),
        de.pixelStorei(3316, j.min.x),
        de.pixelStorei(3315, j.min.y),
        de.pixelStorei(32877, j.min.z),
        ze.isDataTexture || ze.isData3DTexture ? de.texSubImage3D(tn, Oe, me.x, me.y, me.z, Vt, Ft, Gt, Yt, Sn, Nn.data) : ze.isCompressedArrayTexture ? (console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."),
        de.compressedTexSubImage3D(tn, Oe, me.x, me.y, me.z, Vt, Ft, Gt, Yt, Nn.data)) : de.texSubImage3D(tn, Oe, me.x, me.y, me.z, Vt, Ft, Gt, Yt, Sn, Nn),
        de.pixelStorei(3314, Xt),
        de.pixelStorei(32878, en),
        de.pixelStorei(3316, Zn),
        de.pixelStorei(3315, Yn),
        de.pixelStorei(32877, es),
        Oe === 0 && ge.generateMipmaps && de.generateMipmap(tn),
        He.unbindTexture()
    }
    ,
    this.initTexture = function(j) {
        j.isCubeTexture ? Ee.setTextureCube(j, 0) : j.isData3DTexture ? Ee.setTexture3D(j, 0) : j.isDataArrayTexture || j.isCompressedArrayTexture ? Ee.setTexture2DArray(j, 0) : Ee.setTexture2D(j, 0),
        He.unbindTexture()
    }
    ,
    this.resetState = function() {
        S = 0,
        M = 0,
        w = null,
        He.reset(),
        Fe.reset()
    }
    ,
    typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{
        detail: this
    }))
}
class u3 extends qS {
}
u3.prototype.isWebGL1Renderer = !0;
class M_ {
    constructor(e, t=25e-5) {
        this.isFogExp2 = !0,
        this.name = "",
        this.color = new It(e),
        this.density = t
    }
    clone() {
        return new M_(this.color,this.density)
    }
    toJSON() {
        return {
            type: "FogExp2",
            color: this.color.getHex(),
            density: this.density
        }
    }
}
class A_ {
    constructor(e, t=1, r=1e3) {
        this.isFog = !0,
        this.name = "",
        this.color = new It(e),
        this.near = t,
        this.far = r
    }
    clone() {
        return new A_(this.color,this.near,this.far)
    }
    toJSON() {
        return {
            type: "Fog",
            color: this.color.getHex(),
            near: this.near,
            far: this.far
        }
    }
}
class C_ extends wr {
    constructor() {
        super(),
        this.isScene = !0,
        this.type = "Scene",
        this.background = null,
        this.environment = null,
        this.fog = null,
        this.backgroundBlurriness = 0,
        this.backgroundIntensity = 1,
        this.overrideMaterial = null,
        typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{
            detail: this
        }))
    }
    copy(e, t) {
        return super.copy(e, t),
        e.background !== null && (this.background = e.background.clone()),
        e.environment !== null && (this.environment = e.environment.clone()),
        e.fog !== null && (this.fog = e.fog.clone()),
        this.backgroundBlurriness = e.backgroundBlurriness,
        this.backgroundIntensity = e.backgroundIntensity,
        e.overrideMaterial !== null && (this.overrideMaterial = e.overrideMaterial.clone()),
        this.matrixAutoUpdate = e.matrixAutoUpdate,
        this
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return this.fog !== null && (t.object.fog = this.fog.toJSON()),
        this.backgroundBlurriness > 0 && (t.object.backgroundBlurriness = this.backgroundBlurriness),
        this.backgroundIntensity !== 1 && (t.object.backgroundIntensity = this.backgroundIntensity),
        t
    }
    get autoUpdate() {
        return console.warn("THREE.Scene: autoUpdate was renamed to matrixWorldAutoUpdate in r144."),
        this.matrixWorldAutoUpdate
    }
    set autoUpdate(e) {
        console.warn("THREE.Scene: autoUpdate was renamed to matrixWorldAutoUpdate in r144."),
        this.matrixWorldAutoUpdate = e
    }
}
class zm {
    constructor(e, t) {
        this.isInterleavedBuffer = !0,
        this.array = e,
        this.stride = t,
        this.count = e !== void 0 ? e.length / t : 0,
        this.usage = gm,
        this.updateRange = {
            offset: 0,
            count: -1
        },
        this.version = 0,
        this.uuid = Sa()
    }
    onUploadCallback() {}
    set needsUpdate(e) {
        e === !0 && this.version++
    }
    setUsage(e) {
        return this.usage = e,
        this
    }
    copy(e) {
        return this.array = new e.array.constructor(e.array),
        this.count = e.count,
        this.stride = e.stride,
        this.usage = e.usage,
        this
    }
    copyAt(e, t, r) {
        e *= this.stride,
        r *= t.stride;
        for (let i = 0, s = this.stride; i < s; i++)
            this.array[e + i] = t.array[r + i];
        return this
    }
    set(e, t=0) {
        return this.array.set(e, t),
        this
    }
    clone(e) {
        e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
        this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = Sa()),
        e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
        const t = new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid])
          , r = new this.constructor(t,this.stride);
        return r.setUsage(this.usage),
        r
    }
    onUpload(e) {
        return this.onUploadCallback = e,
        this
    }
    toJSON(e) {
        return e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
        this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = Sa()),
        e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))),
        {
            uuid: this.uuid,
            buffer: this.array.buffer._uuid,
            type: this.array.constructor.name,
            stride: this.stride
        }
    }
}
const yo = new $;
class Dc {
    constructor(e, t, r, i=!1) {
        this.isInterleavedBufferAttribute = !0,
        this.name = "",
        this.data = e,
        this.itemSize = t,
        this.offset = r,
        this.normalized = i
    }
    get count() {
        return this.data.count
    }
    get array() {
        return this.data.array
    }
    set needsUpdate(e) {
        this.data.needsUpdate = e
    }
    applyMatrix4(e) {
        for (let t = 0, r = this.data.count; t < r; t++)
            yo.fromBufferAttribute(this, t),
            yo.applyMatrix4(e),
            this.setXYZ(t, yo.x, yo.y, yo.z);
        return this
    }
    applyNormalMatrix(e) {
        for (let t = 0, r = this.count; t < r; t++)
            yo.fromBufferAttribute(this, t),
            yo.applyNormalMatrix(e),
            this.setXYZ(t, yo.x, yo.y, yo.z);
        return this
    }
    transformDirection(e) {
        for (let t = 0, r = this.count; t < r; t++)
            yo.fromBufferAttribute(this, t),
            yo.transformDirection(e),
            this.setXYZ(t, yo.x, yo.y, yo.z);
        return this
    }
    setX(e, t) {
        return this.normalized && (t = ii(t, this.array)),
        this.data.array[e * this.data.stride + this.offset] = t,
        this
    }
    setY(e, t) {
        return this.normalized && (t = ii(t, this.array)),
        this.data.array[e * this.data.stride + this.offset + 1] = t,
        this
    }
    setZ(e, t) {
        return this.normalized && (t = ii(t, this.array)),
        this.data.array[e * this.data.stride + this.offset + 2] = t,
        this
    }
    setW(e, t) {
        return this.normalized && (t = ii(t, this.array)),
        this.data.array[e * this.data.stride + this.offset + 3] = t,
        this
    }
    getX(e) {
        let t = this.data.array[e * this.data.stride + this.offset];
        return this.normalized && (t = vu(t, this.array)),
        t
    }
    getY(e) {
        let t = this.data.array[e * this.data.stride + this.offset + 1];
        return this.normalized && (t = vu(t, this.array)),
        t
    }
    getZ(e) {
        let t = this.data.array[e * this.data.stride + this.offset + 2];
        return this.normalized && (t = vu(t, this.array)),
        t
    }
    getW(e) {
        let t = this.data.array[e * this.data.stride + this.offset + 3];
        return this.normalized && (t = vu(t, this.array)),
        t
    }
    setXY(e, t, r) {
        return e = e * this.data.stride + this.offset,
        this.normalized && (t = ii(t, this.array),
        r = ii(r, this.array)),
        this.data.array[e + 0] = t,
        this.data.array[e + 1] = r,
        this
    }
    setXYZ(e, t, r, i) {
        return e = e * this.data.stride + this.offset,
        this.normalized && (t = ii(t, this.array),
        r = ii(r, this.array),
        i = ii(i, this.array)),
        this.data.array[e + 0] = t,
        this.data.array[e + 1] = r,
        this.data.array[e + 2] = i,
        this
    }
    setXYZW(e, t, r, i, s) {
        return e = e * this.data.stride + this.offset,
        this.normalized && (t = ii(t, this.array),
        r = ii(r, this.array),
        i = ii(i, this.array),
        s = ii(s, this.array)),
        this.data.array[e + 0] = t,
        this.data.array[e + 1] = r,
        this.data.array[e + 2] = i,
        this.data.array[e + 3] = s,
        this
    }
    clone(e) {
        if (e === void 0) {
            console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");
            const t = [];
            for (let r = 0; r < this.count; r++) {
                const i = r * this.data.stride + this.offset;
                for (let s = 0; s < this.itemSize; s++)
                    t.push(this.data.array[i + s])
            }
            return new Dr(new this.array.constructor(t),this.itemSize,this.normalized)
        } else
            return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}),
            e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)),
            new Dc(e.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)
    }
    toJSON(e) {
        if (e === void 0) {
            console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");
            const t = [];
            for (let r = 0; r < this.count; r++) {
                const i = r * this.data.stride + this.offset;
                for (let s = 0; s < this.itemSize; s++)
                    t.push(this.data.array[i + s])
            }
            return {
                itemSize: this.itemSize,
                type: this.array.constructor.name,
                array: t,
                normalized: this.normalized
            }
        } else
            return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}),
            e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)),
            {
                isInterleavedBufferAttribute: !0,
                itemSize: this.itemSize,
                data: this.data.uuid,
                offset: this.offset,
                normalized: this.normalized
            }
    }
}
class QS extends as {
    constructor(e) {
        super(),
        this.isSpriteMaterial = !0,
        this.type = "SpriteMaterial",
        this.color = new It(16777215),
        this.map = null,
        this.alphaMap = null,
        this.rotation = 0,
        this.sizeAttenuation = !0,
        this.transparent = !0,
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.color.copy(e.color),
        this.map = e.map,
        this.alphaMap = e.alphaMap,
        this.rotation = e.rotation,
        this.sizeAttenuation = e.sizeAttenuation,
        this.fog = e.fog,
        this
    }
}
let Sd;
const sp = new $
  , Md = new $
  , Ad = new $
  , Cd = new it
  , op = new it
  , c3 = new Dn
  , e0 = new $
  , ap = new $
  , t0 = new $
  , eE = new it
  , sx = new it
  , tE = new it;
class f3 extends wr {
    constructor(e) {
        if (super(),
        this.isSprite = !0,
        this.type = "Sprite",
        Sd === void 0) {
            Sd = new On;
            const t = new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1])
              , r = new zm(t,5);
            Sd.setIndex([0, 1, 2, 0, 2, 3]),
            Sd.setAttribute("position", new Dc(r,3,0,!1)),
            Sd.setAttribute("uv", new Dc(r,2,3,!1))
        }
        this.geometry = Sd,
        this.material = e !== void 0 ? e : new QS,
        this.center = new it(.5,.5)
    }
    raycast(e, t) {
        e.camera === null && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'),
        Md.setFromMatrixScale(this.matrixWorld),
        c3.copy(e.camera.matrixWorld),
        this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse, this.matrixWorld),
        Ad.setFromMatrixPosition(this.modelViewMatrix),
        e.camera.isPerspectiveCamera && this.material.sizeAttenuation === !1 && Md.multiplyScalar(-Ad.z);
        const r = this.material.rotation;
        let i, s;
        r !== 0 && (s = Math.cos(r),
        i = Math.sin(r));
        const o = this.center;
        n0(e0.set(-.5, -.5, 0), Ad, o, Md, i, s),
        n0(ap.set(.5, -.5, 0), Ad, o, Md, i, s),
        n0(t0.set(.5, .5, 0), Ad, o, Md, i, s),
        eE.set(0, 0),
        sx.set(1, 0),
        tE.set(1, 1);
        let a = e.ray.intersectTriangle(e0, ap, t0, !1, sp);
        if (a === null && (n0(ap.set(-.5, .5, 0), Ad, o, Md, i, s),
        sx.set(0, 1),
        a = e.ray.intersectTriangle(e0, t0, ap, !1, sp),
        a === null))
            return;
        const l = e.ray.origin.distanceTo(sp);
        l < e.near || l > e.far || t.push({
            distance: l,
            point: sp.clone(),
            uv: Xa.getUV(sp, e0, ap, t0, eE, sx, tE, new it),
            face: null,
            object: this
        })
    }
    copy(e, t) {
        return super.copy(e, t),
        e.center !== void 0 && this.center.copy(e.center),
        this.material = e.material,
        this
    }
}
function n0(n, e, t, r, i, s) {
    Cd.subVectors(n, t).addScalar(.5).multiply(r),
    i !== void 0 ? (op.x = s * Cd.x - i * Cd.y,
    op.y = i * Cd.x + s * Cd.y) : op.copy(Cd),
    n.copy(e),
    n.x += op.x,
    n.y += op.y,
    n.applyMatrix4(c3)
}
const r0 = new $
  , nE = new $;
class d3 extends wr {
    constructor() {
        super(),
        this._currentLevel = 0,
        this.type = "LOD",
        Object.defineProperties(this, {
            levels: {
                enumerable: !0,
                value: []
            },
            isLOD: {
                value: !0
            }
        }),
        this.autoUpdate = !0
    }
    copy(e) {
        super.copy(e, !1);
        const t = e.levels;
        for (let r = 0, i = t.length; r < i; r++) {
            const s = t[r];
            this.addLevel(s.object.clone(), s.distance, s.hysteresis)
        }
        return this.autoUpdate = e.autoUpdate,
        this
    }
    addLevel(e, t=0, r=0) {
        t = Math.abs(t);
        const i = this.levels;
        let s;
        for (s = 0; s < i.length && !(t < i[s].distance); s++)
            ;
        return i.splice(s, 0, {
            distance: t,
            hysteresis: r,
            object: e
        }),
        this.add(e),
        this
    }
    getCurrentLevel() {
        return this._currentLevel
    }
    getObjectForDistance(e) {
        const t = this.levels;
        if (t.length > 0) {
            let r, i;
            for (r = 1,
            i = t.length; r < i; r++) {
                let s = t[r].distance;
                if (t[r].object.visible && (s -= s * t[r].hysteresis),
                e < s)
                    break
            }
            return t[r - 1].object
        }
        return null
    }
    raycast(e, t) {
        if (this.levels.length > 0) {
            r0.setFromMatrixPosition(this.matrixWorld);
            const i = e.ray.origin.distanceTo(r0);
            this.getObjectForDistance(i).raycast(e, t)
        }
    }
    update(e) {
        const t = this.levels;
        if (t.length > 1) {
            r0.setFromMatrixPosition(e.matrixWorld),
            nE.setFromMatrixPosition(this.matrixWorld);
            const r = r0.distanceTo(nE) / e.zoom;
            t[0].object.visible = !0;
            let i, s;
            for (i = 1,
            s = t.length; i < s; i++) {
                let o = t[i].distance;
                if (t[i].object.visible && (o -= o * t[i].hysteresis),
                r >= o)
                    t[i - 1].object.visible = !1,
                    t[i].object.visible = !0;
                else
                    break
            }
            for (this._currentLevel = i - 1; i < s; i++)
                t[i].object.visible = !1
        }
    }
    toJSON(e) {
        const t = super.toJSON(e);
        this.autoUpdate === !1 && (t.object.autoUpdate = !1),
        t.object.levels = [];
        const r = this.levels;
        for (let i = 0, s = r.length; i < s; i++) {
            const o = r[i];
            t.object.levels.push({
                object: o.object.uuid,
                distance: o.distance,
                hysteresis: o.hysteresis
            })
        }
        return t
    }
}
const rE = new $
  , iE = new zr
  , sE = new zr
  , Vz = new $
  , oE = new Dn;
class ZS extends vs {
    constructor(e, t) {
        super(e, t),
        this.isSkinnedMesh = !0,
        this.type = "SkinnedMesh",
        this.bindMode = "attached",
        this.bindMatrix = new Dn,
        this.bindMatrixInverse = new Dn
    }
    copy(e, t) {
        return super.copy(e, t),
        this.bindMode = e.bindMode,
        this.bindMatrix.copy(e.bindMatrix),
        this.bindMatrixInverse.copy(e.bindMatrixInverse),
        this.skeleton = e.skeleton,
        this
    }
    bind(e, t) {
        this.skeleton = e,
        t === void 0 && (this.updateMatrixWorld(!0),
        this.skeleton.calculateInverses(),
        t = this.matrixWorld),
        this.bindMatrix.copy(t),
        this.bindMatrixInverse.copy(t).invert()
    }
    pose() {
        this.skeleton.pose()
    }
    normalizeSkinWeights() {
        const e = new zr
          , t = this.geometry.attributes.skinWeight;
        for (let r = 0, i = t.count; r < i; r++) {
            e.fromBufferAttribute(t, r);
            const s = 1 / e.manhattanLength();
            s !== 1 / 0 ? e.multiplyScalar(s) : e.set(1, 0, 0, 0),
            t.setXYZW(r, e.x, e.y, e.z, e.w)
        }
    }
    updateMatrixWorld(e) {
        super.updateMatrixWorld(e),
        this.bindMode === "attached" ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : this.bindMode === "detached" ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
    }
    boneTransform(e, t) {
        const r = this.skeleton
          , i = this.geometry;
        iE.fromBufferAttribute(i.attributes.skinIndex, e),
        sE.fromBufferAttribute(i.attributes.skinWeight, e),
        rE.copy(t).applyMatrix4(this.bindMatrix),
        t.set(0, 0, 0);
        for (let s = 0; s < 4; s++) {
            const o = sE.getComponent(s);
            if (o !== 0) {
                const a = iE.getComponent(s);
                oE.multiplyMatrices(r.bones[a].matrixWorld, r.boneInverses[a]),
                t.addScaledVector(Vz.copy(rE).applyMatrix4(oE), o)
            }
        }
        return t.applyMatrix4(this.bindMatrixInverse)
    }
}
class E_ extends wr {
    constructor() {
        super(),
        this.isBone = !0,
        this.type = "Bone"
    }
}
class sh extends Ci {
    constructor(e=null, t=1, r=1, i, s, o, a, l, f=Ji, h=Ji, d, p) {
        super(null, o, a, l, f, h, i, s, d, p),
        this.isDataTexture = !0,
        this.image = {
            data: e,
            width: t,
            height: r
        },
        this.generateMipmaps = !1,
        this.flipY = !1,
        this.unpackAlignment = 1
    }
}
const aE = new Dn
  , Wz = new Dn;
class Gm {
    constructor(e=[], t=[]) {
        this.uuid = Sa(),
        this.bones = e.slice(0),
        this.boneInverses = t,
        this.boneMatrices = null,
        this.boneTexture = null,
        this.boneTextureSize = 0,
        this.frame = -1,
        this.init()
    }
    init() {
        const e = this.bones
          , t = this.boneInverses;
        if (this.boneMatrices = new Float32Array(e.length * 16),
        t.length === 0)
            this.calculateInverses();
        else if (e.length !== t.length) {
            console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."),
            this.boneInverses = [];
            for (let r = 0, i = this.bones.length; r < i; r++)
                this.boneInverses.push(new Dn)
        }
    }
    calculateInverses() {
        this.boneInverses.length = 0;
        for (let e = 0, t = this.bones.length; e < t; e++) {
            const r = new Dn;
            this.bones[e] && r.copy(this.bones[e].matrixWorld).invert(),
            this.boneInverses.push(r)
        }
    }
    pose() {
        for (let e = 0, t = this.bones.length; e < t; e++) {
            const r = this.bones[e];
            r && r.matrixWorld.copy(this.boneInverses[e]).invert()
        }
        for (let e = 0, t = this.bones.length; e < t; e++) {
            const r = this.bones[e];
            r && (r.parent && r.parent.isBone ? (r.matrix.copy(r.parent.matrixWorld).invert(),
            r.matrix.multiply(r.matrixWorld)) : r.matrix.copy(r.matrixWorld),
            r.matrix.decompose(r.position, r.quaternion, r.scale))
        }
    }
    update() {
        const e = this.bones
          , t = this.boneInverses
          , r = this.boneMatrices
          , i = this.boneTexture;
        for (let s = 0, o = e.length; s < o; s++) {
            const a = e[s] ? e[s].matrixWorld : Wz;
            aE.multiplyMatrices(a, t[s]),
            aE.toArray(r, s * 16)
        }
        i !== null && (i.needsUpdate = !0)
    }
    clone() {
        return new Gm(this.bones,this.boneInverses)
    }
    computeBoneTexture() {
        let e = Math.sqrt(this.bones.length * 4);
        e = Q2(e),
        e = Math.max(e, 4);
        const t = new Float32Array(e * e * 4);
        t.set(this.boneMatrices);
        const r = new sh(t,e,e,ga,ya);
        return r.needsUpdate = !0,
        this.boneMatrices = t,
        this.boneTexture = r,
        this.boneTextureSize = e,
        this
    }
    getBoneByName(e) {
        for (let t = 0, r = this.bones.length; t < r; t++) {
            const i = this.bones[t];
            if (i.name === e)
                return i
        }
    }
    dispose() {
        this.boneTexture !== null && (this.boneTexture.dispose(),
        this.boneTexture = null)
    }
    fromJSON(e, t) {
        this.uuid = e.uuid;
        for (let r = 0, i = e.bones.length; r < i; r++) {
            const s = e.bones[r];
            let o = t[s];
            o === void 0 && (console.warn("THREE.Skeleton: No bone found with UUID:", s),
            o = new E_),
            this.bones.push(o),
            this.boneInverses.push(new Dn().fromArray(e.boneInverses[r]))
        }
        return this.init(),
        this
    }
    toJSON() {
        const e = {
            metadata: {
                version: 4.5,
                type: "Skeleton",
                generator: "Skeleton.toJSON"
            },
            bones: [],
            boneInverses: []
        };
        e.uuid = this.uuid;
        const t = this.bones
          , r = this.boneInverses;
        for (let i = 0, s = t.length; i < s; i++) {
            const o = t[i];
            e.bones.push(o.uuid);
            const a = r[i];
            e.boneInverses.push(a.toArray())
        }
        return e
    }
}
class xh extends Dr {
    constructor(e, t, r, i=1) {
        super(e, t, r),
        this.isInstancedBufferAttribute = !0,
        this.meshPerAttribute = i
    }
    copy(e) {
        return super.copy(e),
        this.meshPerAttribute = e.meshPerAttribute,
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.meshPerAttribute = this.meshPerAttribute,
        e.isInstancedBufferAttribute = !0,
        e
    }
}
const lE = new Dn
  , uE = new Dn
  , i0 = []
  , Xz = new Dn
  , lp = new vs;
class h3 extends vs {
    constructor(e, t, r) {
        super(e, t),
        this.isInstancedMesh = !0,
        this.instanceMatrix = new xh(new Float32Array(r * 16),16),
        this.instanceColor = null,
        this.count = r,
        this.frustumCulled = !1;
        for (let i = 0; i < r; i++)
            this.setMatrixAt(i, Xz)
    }
    copy(e, t) {
        return super.copy(e, t),
        this.instanceMatrix.copy(e.instanceMatrix),
        e.instanceColor !== null && (this.instanceColor = e.instanceColor.clone()),
        this.count = e.count,
        this
    }
    getColorAt(e, t) {
        t.fromArray(this.instanceColor.array, e * 3)
    }
    getMatrixAt(e, t) {
        t.fromArray(this.instanceMatrix.array, e * 16)
    }
    raycast(e, t) {
        const r = this.matrixWorld
          , i = this.count;
        if (lp.geometry = this.geometry,
        lp.material = this.material,
        lp.material !== void 0)
            for (let s = 0; s < i; s++) {
                this.getMatrixAt(s, lE),
                uE.multiplyMatrices(r, lE),
                lp.matrixWorld = uE,
                lp.raycast(e, i0);
                for (let o = 0, a = i0.length; o < a; o++) {
                    const l = i0[o];
                    l.instanceId = s,
                    l.object = this,
                    t.push(l)
                }
                i0.length = 0
            }
    }
    setColorAt(e, t) {
        this.instanceColor === null && (this.instanceColor = new xh(new Float32Array(this.instanceMatrix.count * 3),3)),
        t.toArray(this.instanceColor.array, e * 3)
    }
    setMatrixAt(e, t) {
        t.toArray(this.instanceMatrix.array, e * 16)
    }
    updateMorphTargets() {}
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
}
class lo extends as {
    constructor(e) {
        super(),
        this.isLineBasicMaterial = !0,
        this.type = "LineBasicMaterial",
        this.color = new It(16777215),
        this.linewidth = 1,
        this.linecap = "round",
        this.linejoin = "round",
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.color.copy(e.color),
        this.linewidth = e.linewidth,
        this.linecap = e.linecap,
        this.linejoin = e.linejoin,
        this.fog = e.fog,
        this
    }
}
const cE = new $
  , fE = new $
  , dE = new Dn
  , ox = new Fm
  , s0 = new Oc;
class Du extends wr {
    constructor(e=new On, t=new lo) {
        super(),
        this.isLine = !0,
        this.type = "Line",
        this.geometry = e,
        this.material = t,
        this.updateMorphTargets()
    }
    copy(e, t) {
        return super.copy(e, t),
        this.material = e.material,
        this.geometry = e.geometry,
        this
    }
    computeLineDistances() {
        const e = this.geometry;
        if (e.index === null) {
            const t = e.attributes.position
              , r = [0];
            for (let i = 1, s = t.count; i < s; i++)
                cE.fromBufferAttribute(t, i - 1),
                fE.fromBufferAttribute(t, i),
                r[i] = r[i - 1],
                r[i] += cE.distanceTo(fE);
            e.setAttribute("lineDistance", new nn(r,1))
        } else
            console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
        return this
    }
    raycast(e, t) {
        const r = this.geometry
          , i = this.matrixWorld
          , s = e.params.Line.threshold
          , o = r.drawRange;
        if (r.boundingSphere === null && r.computeBoundingSphere(),
        s0.copy(r.boundingSphere),
        s0.applyMatrix4(i),
        s0.radius += s,
        e.ray.intersectsSphere(s0) === !1)
            return;
        dE.copy(i).invert(),
        ox.copy(e.ray).applyMatrix4(dE);
        const a = s / ((this.scale.x + this.scale.y + this.scale.z) / 3)
          , l = a * a
          , f = new $
          , h = new $
          , d = new $
          , p = new $
          , m = this.isLineSegments ? 2 : 1
          , _ = r.index
          , x = r.attributes.position;
        if (_ !== null) {
            const S = Math.max(0, o.start)
              , M = Math.min(_.count, o.start + o.count);
            for (let w = S, T = M - 1; w < T; w += m) {
                const P = _.getX(w)
                  , I = _.getX(w + 1);
                if (f.fromBufferAttribute(x, P),
                h.fromBufferAttribute(x, I),
                ox.distanceSqToSegment(f, h, p, d) > l)
                    continue;
                p.applyMatrix4(this.matrixWorld);
                const R = e.ray.origin.distanceTo(p);
                R < e.near || R > e.far || t.push({
                    distance: R,
                    point: d.clone().applyMatrix4(this.matrixWorld),
                    index: w,
                    face: null,
                    faceIndex: null,
                    object: this
                })
            }
        } else {
            const S = Math.max(0, o.start)
              , M = Math.min(x.count, o.start + o.count);
            for (let w = S, T = M - 1; w < T; w += m) {
                if (f.fromBufferAttribute(x, w),
                h.fromBufferAttribute(x, w + 1),
                ox.distanceSqToSegment(f, h, p, d) > l)
                    continue;
                p.applyMatrix4(this.matrixWorld);
                const I = e.ray.origin.distanceTo(p);
                I < e.near || I > e.far || t.push({
                    distance: I,
                    point: d.clone().applyMatrix4(this.matrixWorld),
                    index: w,
                    face: null,
                    faceIndex: null,
                    object: this
                })
            }
        }
    }
    updateMorphTargets() {
        const t = this.geometry.morphAttributes
          , r = Object.keys(t);
        if (r.length > 0) {
            const i = t[r[0]];
            if (i !== void 0) {
                this.morphTargetInfluences = [],
                this.morphTargetDictionary = {};
                for (let s = 0, o = i.length; s < o; s++) {
                    const a = i[s].name || String(s);
                    this.morphTargetInfluences.push(0),
                    this.morphTargetDictionary[a] = s
                }
            }
        }
    }
}
const hE = new $
  , pE = new $;
class Tl extends Du {
    constructor(e, t) {
        super(e, t),
        this.isLineSegments = !0,
        this.type = "LineSegments"
    }
    computeLineDistances() {
        const e = this.geometry;
        if (e.index === null) {
            const t = e.attributes.position
              , r = [];
            for (let i = 0, s = t.count; i < s; i += 2)
                hE.fromBufferAttribute(t, i),
                pE.fromBufferAttribute(t, i + 1),
                r[i] = i === 0 ? 0 : r[i - 1],
                r[i + 1] = r[i] + hE.distanceTo(pE);
            e.setAttribute("lineDistance", new nn(r,1))
        } else
            console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
        return this
    }
}
class $S extends Du {
    constructor(e, t) {
        super(e, t),
        this.isLineLoop = !0,
        this.type = "LineLoop"
    }
}
class b_ extends as {
    constructor(e) {
        super(),
        this.isPointsMaterial = !0,
        this.type = "PointsMaterial",
        this.color = new It(16777215),
        this.map = null,
        this.alphaMap = null,
        this.size = 1,
        this.sizeAttenuation = !0,
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.color.copy(e.color),
        this.map = e.map,
        this.alphaMap = e.alphaMap,
        this.size = e.size,
        this.sizeAttenuation = e.sizeAttenuation,
        this.fog = e.fog,
        this
    }
}
const mE = new Dn
  , hw = new Fm
  , o0 = new Oc
  , a0 = new $;
class eM extends wr {
    constructor(e=new On, t=new b_) {
        super(),
        this.isPoints = !0,
        this.type = "Points",
        this.geometry = e,
        this.material = t,
        this.updateMorphTargets()
    }
    copy(e, t) {
        return super.copy(e, t),
        this.material = e.material,
        this.geometry = e.geometry,
        this
    }
    raycast(e, t) {
        const r = this.geometry
          , i = this.matrixWorld
          , s = e.params.Points.threshold
          , o = r.drawRange;
        if (r.boundingSphere === null && r.computeBoundingSphere(),
        o0.copy(r.boundingSphere),
        o0.applyMatrix4(i),
        o0.radius += s,
        e.ray.intersectsSphere(o0) === !1)
            return;
        mE.copy(i).invert(),
        hw.copy(e.ray).applyMatrix4(mE);
        const a = s / ((this.scale.x + this.scale.y + this.scale.z) / 3)
          , l = a * a
          , f = r.index
          , d = r.attributes.position;
        if (f !== null) {
            const p = Math.max(0, o.start)
              , m = Math.min(f.count, o.start + o.count);
            for (let _ = p, y = m; _ < y; _++) {
                const x = f.getX(_);
                a0.fromBufferAttribute(d, x),
                gE(a0, x, l, i, e, t, this)
            }
        } else {
            const p = Math.max(0, o.start)
              , m = Math.min(d.count, o.start + o.count);
            for (let _ = p, y = m; _ < y; _++)
                a0.fromBufferAttribute(d, _),
                gE(a0, _, l, i, e, t, this)
        }
    }
    updateMorphTargets() {
        const t = this.geometry.morphAttributes
          , r = Object.keys(t);
        if (r.length > 0) {
            const i = t[r[0]];
            if (i !== void 0) {
                this.morphTargetInfluences = [],
                this.morphTargetDictionary = {};
                for (let s = 0, o = i.length; s < o; s++) {
                    const a = i[s].name || String(s);
                    this.morphTargetInfluences.push(0),
                    this.morphTargetDictionary[a] = s
                }
            }
        }
    }
}
function gE(n, e, t, r, i, s, o) {
    const a = hw.distanceSqToPoint(n);
    if (a < t) {
        const l = new $;
        hw.closestPointToPoint(n, l),
        l.applyMatrix4(r);
        const f = i.ray.origin.distanceTo(l);
        if (f < i.near || f > i.far)
            return;
        s.push({
            distance: f,
            distanceToRay: Math.sqrt(a),
            point: l,
            index: e,
            face: null,
            object: o
        })
    }
}
class Jz extends Ci {
    constructor(e, t, r, i, s, o, a, l, f) {
        super(e, t, r, i, s, o, a, l, f),
        this.isVideoTexture = !0,
        this.minFilter = o !== void 0 ? o : si,
        this.magFilter = s !== void 0 ? s : si,
        this.generateMipmaps = !1;
        const h = this;
        function d() {
            h.needsUpdate = !0,
            e.requestVideoFrameCallback(d)
        }
        "requestVideoFrameCallback"in e && e.requestVideoFrameCallback(d)
    }
    clone() {
        return new this.constructor(this.image).copy(this)
    }
    update() {
        const e = this.image;
        "requestVideoFrameCallback"in e === !1 && e.readyState >= e.HAVE_CURRENT_DATA && (this.needsUpdate = !0)
    }
}
class jz extends Ci {
    constructor(e, t, r) {
        super({
            width: e,
            height: t
        }),
        this.isFramebufferTexture = !0,
        this.format = r,
        this.magFilter = Ji,
        this.minFilter = Ji,
        this.generateMipmaps = !1,
        this.needsUpdate = !0
    }
}
class tM extends Ci {
    constructor(e, t, r, i, s, o, a, l, f, h, d, p) {
        super(null, o, a, l, f, h, i, s, d, p),
        this.isCompressedTexture = !0,
        this.image = {
            width: t,
            height: r
        },
        this.mipmaps = e,
        this.flipY = !1,
        this.generateMipmaps = !1
    }
}
class Yz extends tM {
    constructor(e, t, r, i, s, o) {
        super(e, t, r, s, o),
        this.isCompressedArrayTexture = !0,
        this.image.depth = i,
        this.wrapR = Us
    }
}
class Kz extends Ci {
    constructor(e, t, r, i, s, o, a, l, f) {
        super(e, t, r, i, s, o, a, l, f),
        this.isCanvasTexture = !0,
        this.needsUpdate = !0
    }
}
class Dl {
    constructor() {
        this.type = "Curve",
        this.arcLengthDivisions = 200
    }
    getPoint() {
        return console.warn("THREE.Curve: .getPoint() not implemented."),
        null
    }
    getPointAt(e, t) {
        const r = this.getUtoTmapping(e);
        return this.getPoint(r, t)
    }
    getPoints(e=5) {
        const t = [];
        for (let r = 0; r <= e; r++)
            t.push(this.getPoint(r / e));
        return t
    }
    getSpacedPoints(e=5) {
        const t = [];
        for (let r = 0; r <= e; r++)
            t.push(this.getPointAt(r / e));
        return t
    }
    getLength() {
        const e = this.getLengths();
        return e[e.length - 1]
    }
    getLengths(e=this.arcLengthDivisions) {
        if (this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate)
            return this.cacheArcLengths;
        this.needsUpdate = !1;
        const t = [];
        let r, i = this.getPoint(0), s = 0;
        t.push(0);
        for (let o = 1; o <= e; o++)
            r = this.getPoint(o / e),
            s += r.distanceTo(i),
            t.push(s),
            i = r;
        return this.cacheArcLengths = t,
        t
    }
    updateArcLengths() {
        this.needsUpdate = !0,
        this.getLengths()
    }
    getUtoTmapping(e, t) {
        const r = this.getLengths();
        let i = 0;
        const s = r.length;
        let o;
        t ? o = t : o = e * r[s - 1];
        let a = 0, l = s - 1, f;
        for (; a <= l; )
            if (i = Math.floor(a + (l - a) / 2),
            f = r[i] - o,
            f < 0)
                a = i + 1;
            else if (f > 0)
                l = i - 1;
            else {
                l = i;
                break
            }
        if (i = l,
        r[i] === o)
            return i / (s - 1);
        const h = r[i]
          , p = r[i + 1] - h
          , m = (o - h) / p;
        return (i + m) / (s - 1)
    }
    getTangent(e, t) {
        let i = e - 1e-4
          , s = e + 1e-4;
        i < 0 && (i = 0),
        s > 1 && (s = 1);
        const o = this.getPoint(i)
          , a = this.getPoint(s)
          , l = t || (o.isVector2 ? new it : new $);
        return l.copy(a).sub(o).normalize(),
        l
    }
    getTangentAt(e, t) {
        const r = this.getUtoTmapping(e);
        return this.getTangent(r, t)
    }
    computeFrenetFrames(e, t) {
        const r = new $
          , i = []
          , s = []
          , o = []
          , a = new $
          , l = new Dn;
        for (let m = 0; m <= e; m++) {
            const _ = m / e;
            i[m] = this.getTangentAt(_, new $)
        }
        s[0] = new $,
        o[0] = new $;
        let f = Number.MAX_VALUE;
        const h = Math.abs(i[0].x)
          , d = Math.abs(i[0].y)
          , p = Math.abs(i[0].z);
        h <= f && (f = h,
        r.set(1, 0, 0)),
        d <= f && (f = d,
        r.set(0, 1, 0)),
        p <= f && r.set(0, 0, 1),
        a.crossVectors(i[0], r).normalize(),
        s[0].crossVectors(i[0], a),
        o[0].crossVectors(i[0], s[0]);
        for (let m = 1; m <= e; m++) {
            if (s[m] = s[m - 1].clone(),
            o[m] = o[m - 1].clone(),
            a.crossVectors(i[m - 1], i[m]),
            a.length() > Number.EPSILON) {
                a.normalize();
                const _ = Math.acos($i(i[m - 1].dot(i[m]), -1, 1));
                s[m].applyMatrix4(l.makeRotationAxis(a, _))
            }
            o[m].crossVectors(i[m], s[m])
        }
        if (t === !0) {
            let m = Math.acos($i(s[0].dot(s[e]), -1, 1));
            m /= e,
            i[0].dot(a.crossVectors(s[0], s[e])) > 0 && (m = -m);
            for (let _ = 1; _ <= e; _++)
                s[_].applyMatrix4(l.makeRotationAxis(i[_], m * _)),
                o[_].crossVectors(i[_], s[_])
        }
        return {
            tangents: i,
            normals: s,
            binormals: o
        }
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        return this.arcLengthDivisions = e.arcLengthDivisions,
        this
    }
    toJSON() {
        const e = {
            metadata: {
                version: 4.5,
                type: "Curve",
                generator: "Curve.toJSON"
            }
        };
        return e.arcLengthDivisions = this.arcLengthDivisions,
        e.type = this.type,
        e
    }
    fromJSON(e) {
        return this.arcLengthDivisions = e.arcLengthDivisions,
        this
    }
}
class T_ extends Dl {
    constructor(e=0, t=0, r=1, i=1, s=0, o=Math.PI * 2, a=!1, l=0) {
        super(),
        this.isEllipseCurve = !0,
        this.type = "EllipseCurve",
        this.aX = e,
        this.aY = t,
        this.xRadius = r,
        this.yRadius = i,
        this.aStartAngle = s,
        this.aEndAngle = o,
        this.aClockwise = a,
        this.aRotation = l
    }
    getPoint(e, t) {
        const r = t || new it
          , i = Math.PI * 2;
        let s = this.aEndAngle - this.aStartAngle;
        const o = Math.abs(s) < Number.EPSILON;
        for (; s < 0; )
            s += i;
        for (; s > i; )
            s -= i;
        s < Number.EPSILON && (o ? s = 0 : s = i),
        this.aClockwise === !0 && !o && (s === i ? s = -i : s = s - i);
        const a = this.aStartAngle + e * s;
        let l = this.aX + this.xRadius * Math.cos(a)
          , f = this.aY + this.yRadius * Math.sin(a);
        if (this.aRotation !== 0) {
            const h = Math.cos(this.aRotation)
              , d = Math.sin(this.aRotation)
              , p = l - this.aX
              , m = f - this.aY;
            l = p * h - m * d + this.aX,
            f = p * d + m * h + this.aY
        }
        return r.set(l, f)
    }
    copy(e) {
        return super.copy(e),
        this.aX = e.aX,
        this.aY = e.aY,
        this.xRadius = e.xRadius,
        this.yRadius = e.yRadius,
        this.aStartAngle = e.aStartAngle,
        this.aEndAngle = e.aEndAngle,
        this.aClockwise = e.aClockwise,
        this.aRotation = e.aRotation,
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.aX = this.aX,
        e.aY = this.aY,
        e.xRadius = this.xRadius,
        e.yRadius = this.yRadius,
        e.aStartAngle = this.aStartAngle,
        e.aEndAngle = this.aEndAngle,
        e.aClockwise = this.aClockwise,
        e.aRotation = this.aRotation,
        e
    }
    fromJSON(e) {
        return super.fromJSON(e),
        this.aX = e.aX,
        this.aY = e.aY,
        this.xRadius = e.xRadius,
        this.yRadius = e.yRadius,
        this.aStartAngle = e.aStartAngle,
        this.aEndAngle = e.aEndAngle,
        this.aClockwise = e.aClockwise,
        this.aRotation = e.aRotation,
        this
    }
}
class p3 extends T_ {
    constructor(e, t, r, i, s, o) {
        super(e, t, r, r, i, s, o),
        this.isArcCurve = !0,
        this.type = "ArcCurve"
    }
}
function nM() {
    let n = 0
      , e = 0
      , t = 0
      , r = 0;
    function i(s, o, a, l) {
        n = s,
        e = a,
        t = -3 * s + 3 * o - 2 * a - l,
        r = 2 * s - 2 * o + a + l
    }
    return {
        initCatmullRom: function(s, o, a, l, f) {
            i(o, a, f * (a - s), f * (l - o))
        },
        initNonuniformCatmullRom: function(s, o, a, l, f, h, d) {
            let p = (o - s) / f - (a - s) / (f + h) + (a - o) / h
              , m = (a - o) / h - (l - o) / (h + d) + (l - a) / d;
            p *= h,
            m *= h,
            i(o, a, p, m)
        },
        calc: function(s) {
            const o = s * s
              , a = o * s;
            return n + e * s + t * o + r * a
        }
    }
}
const l0 = new $
  , ax = new nM
  , lx = new nM
  , ux = new nM;
class m3 extends Dl {
    constructor(e=[], t=!1, r="centripetal", i=.5) {
        super(),
        this.isCatmullRomCurve3 = !0,
        this.type = "CatmullRomCurve3",
        this.points = e,
        this.closed = t,
        this.curveType = r,
        this.tension = i
    }
    getPoint(e, t=new $) {
        const r = t
          , i = this.points
          , s = i.length
          , o = (s - (this.closed ? 0 : 1)) * e;
        let a = Math.floor(o)
          , l = o - a;
        this.closed ? a += a > 0 ? 0 : (Math.floor(Math.abs(a) / s) + 1) * s : l === 0 && a === s - 1 && (a = s - 2,
        l = 1);
        let f, h;
        this.closed || a > 0 ? f = i[(a - 1) % s] : (l0.subVectors(i[0], i[1]).add(i[0]),
        f = l0);
        const d = i[a % s]
          , p = i[(a + 1) % s];
        if (this.closed || a + 2 < s ? h = i[(a + 2) % s] : (l0.subVectors(i[s - 1], i[s - 2]).add(i[s - 1]),
        h = l0),
        this.curveType === "centripetal" || this.curveType === "chordal") {
            const m = this.curveType === "chordal" ? .5 : .25;
            let _ = Math.pow(f.distanceToSquared(d), m)
              , y = Math.pow(d.distanceToSquared(p), m)
              , x = Math.pow(p.distanceToSquared(h), m);
            y < 1e-4 && (y = 1),
            _ < 1e-4 && (_ = y),
            x < 1e-4 && (x = y),
            ax.initNonuniformCatmullRom(f.x, d.x, p.x, h.x, _, y, x),
            lx.initNonuniformCatmullRom(f.y, d.y, p.y, h.y, _, y, x),
            ux.initNonuniformCatmullRom(f.z, d.z, p.z, h.z, _, y, x)
        } else
            this.curveType === "catmullrom" && (ax.initCatmullRom(f.x, d.x, p.x, h.x, this.tension),
            lx.initCatmullRom(f.y, d.y, p.y, h.y, this.tension),
            ux.initCatmullRom(f.z, d.z, p.z, h.z, this.tension));
        return r.set(ax.calc(l), lx.calc(l), ux.calc(l)),
        r
    }
    copy(e) {
        super.copy(e),
        this.points = [];
        for (let t = 0, r = e.points.length; t < r; t++) {
            const i = e.points[t];
            this.points.push(i.clone())
        }
        return this.closed = e.closed,
        this.curveType = e.curveType,
        this.tension = e.tension,
        this
    }
    toJSON() {
        const e = super.toJSON();
        e.points = [];
        for (let t = 0, r = this.points.length; t < r; t++) {
            const i = this.points[t];
            e.points.push(i.toArray())
        }
        return e.closed = this.closed,
        e.curveType = this.curveType,
        e.tension = this.tension,
        e
    }
    fromJSON(e) {
        super.fromJSON(e),
        this.points = [];
        for (let t = 0, r = e.points.length; t < r; t++) {
            const i = e.points[t];
            this.points.push(new $().fromArray(i))
        }
        return this.closed = e.closed,
        this.curveType = e.curveType,
        this.tension = e.tension,
        this
    }
}
function vE(n, e, t, r, i) {
    const s = (r - e) * .5
      , o = (i - t) * .5
      , a = n * n
      , l = n * a;
    return (2 * t - 2 * r + s + o) * l + (-3 * t + 3 * r - 2 * s - o) * a + s * n + t
}
function qz(n, e) {
    const t = 1 - n;
    return t * t * e
}
function Qz(n, e) {
    return 2 * (1 - n) * n * e
}
function Zz(n, e) {
    return n * n * e
}
function Gp(n, e, t, r) {
    return qz(n, e) + Qz(n, t) + Zz(n, r)
}
function $z(n, e) {
    const t = 1 - n;
    return t * t * t * e
}
function e4(n, e) {
    const t = 1 - n;
    return 3 * t * t * n * e
}
function t4(n, e) {
    return 3 * (1 - n) * n * n * e
}
function n4(n, e) {
    return n * n * n * e
}
function Up(n, e, t, r, i) {
    return $z(n, e) + e4(n, t) + t4(n, r) + n4(n, i)
}
class rM extends Dl {
    constructor(e=new it, t=new it, r=new it, i=new it) {
        super(),
        this.isCubicBezierCurve = !0,
        this.type = "CubicBezierCurve",
        this.v0 = e,
        this.v1 = t,
        this.v2 = r,
        this.v3 = i
    }
    getPoint(e, t=new it) {
        const r = t
          , i = this.v0
          , s = this.v1
          , o = this.v2
          , a = this.v3;
        return r.set(Up(e, i.x, s.x, o.x, a.x), Up(e, i.y, s.y, o.y, a.y)),
        r
    }
    copy(e) {
        return super.copy(e),
        this.v0.copy(e.v0),
        this.v1.copy(e.v1),
        this.v2.copy(e.v2),
        this.v3.copy(e.v3),
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.v0 = this.v0.toArray(),
        e.v1 = this.v1.toArray(),
        e.v2 = this.v2.toArray(),
        e.v3 = this.v3.toArray(),
        e
    }
    fromJSON(e) {
        return super.fromJSON(e),
        this.v0.fromArray(e.v0),
        this.v1.fromArray(e.v1),
        this.v2.fromArray(e.v2),
        this.v3.fromArray(e.v3),
        this
    }
}
class g3 extends Dl {
    constructor(e=new $, t=new $, r=new $, i=new $) {
        super(),
        this.isCubicBezierCurve3 = !0,
        this.type = "CubicBezierCurve3",
        this.v0 = e,
        this.v1 = t,
        this.v2 = r,
        this.v3 = i
    }
    getPoint(e, t=new $) {
        const r = t
          , i = this.v0
          , s = this.v1
          , o = this.v2
          , a = this.v3;
        return r.set(Up(e, i.x, s.x, o.x, a.x), Up(e, i.y, s.y, o.y, a.y), Up(e, i.z, s.z, o.z, a.z)),
        r
    }
    copy(e) {
        return super.copy(e),
        this.v0.copy(e.v0),
        this.v1.copy(e.v1),
        this.v2.copy(e.v2),
        this.v3.copy(e.v3),
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.v0 = this.v0.toArray(),
        e.v1 = this.v1.toArray(),
        e.v2 = this.v2.toArray(),
        e.v3 = this.v3.toArray(),
        e
    }
    fromJSON(e) {
        return super.fromJSON(e),
        this.v0.fromArray(e.v0),
        this.v1.fromArray(e.v1),
        this.v2.fromArray(e.v2),
        this.v3.fromArray(e.v3),
        this
    }
}
class D_ extends Dl {
    constructor(e=new it, t=new it) {
        super(),
        this.isLineCurve = !0,
        this.type = "LineCurve",
        this.v1 = e,
        this.v2 = t
    }
    getPoint(e, t=new it) {
        const r = t;
        return e === 1 ? r.copy(this.v2) : (r.copy(this.v2).sub(this.v1),
        r.multiplyScalar(e).add(this.v1)),
        r
    }
    getPointAt(e, t) {
        return this.getPoint(e, t)
    }
    getTangent(e, t) {
        const r = t || new it;
        return r.copy(this.v2).sub(this.v1).normalize(),
        r
    }
    copy(e) {
        return super.copy(e),
        this.v1.copy(e.v1),
        this.v2.copy(e.v2),
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.v1 = this.v1.toArray(),
        e.v2 = this.v2.toArray(),
        e
    }
    fromJSON(e) {
        return super.fromJSON(e),
        this.v1.fromArray(e.v1),
        this.v2.fromArray(e.v2),
        this
    }
}
class v3 extends Dl {
    constructor(e=new $, t=new $) {
        super(),
        this.isLineCurve3 = !0,
        this.type = "LineCurve3",
        this.v1 = e,
        this.v2 = t
    }
    getPoint(e, t=new $) {
        const r = t;
        return e === 1 ? r.copy(this.v2) : (r.copy(this.v2).sub(this.v1),
        r.multiplyScalar(e).add(this.v1)),
        r
    }
    getPointAt(e, t) {
        return this.getPoint(e, t)
    }
    copy(e) {
        return super.copy(e),
        this.v1.copy(e.v1),
        this.v2.copy(e.v2),
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.v1 = this.v1.toArray(),
        e.v2 = this.v2.toArray(),
        e
    }
    fromJSON(e) {
        return super.fromJSON(e),
        this.v1.fromArray(e.v1),
        this.v2.fromArray(e.v2),
        this
    }
}
class iM extends Dl {
    constructor(e=new it, t=new it, r=new it) {
        super(),
        this.isQuadraticBezierCurve = !0,
        this.type = "QuadraticBezierCurve",
        this.v0 = e,
        this.v1 = t,
        this.v2 = r
    }
    getPoint(e, t=new it) {
        const r = t
          , i = this.v0
          , s = this.v1
          , o = this.v2;
        return r.set(Gp(e, i.x, s.x, o.x), Gp(e, i.y, s.y, o.y)),
        r
    }
    copy(e) {
        return super.copy(e),
        this.v0.copy(e.v0),
        this.v1.copy(e.v1),
        this.v2.copy(e.v2),
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.v0 = this.v0.toArray(),
        e.v1 = this.v1.toArray(),
        e.v2 = this.v2.toArray(),
        e
    }
    fromJSON(e) {
        return super.fromJSON(e),
        this.v0.fromArray(e.v0),
        this.v1.fromArray(e.v1),
        this.v2.fromArray(e.v2),
        this
    }
}
class sM extends Dl {
    constructor(e=new $, t=new $, r=new $) {
        super(),
        this.isQuadraticBezierCurve3 = !0,
        this.type = "QuadraticBezierCurve3",
        this.v0 = e,
        this.v1 = t,
        this.v2 = r
    }
    getPoint(e, t=new $) {
        const r = t
          , i = this.v0
          , s = this.v1
          , o = this.v2;
        return r.set(Gp(e, i.x, s.x, o.x), Gp(e, i.y, s.y, o.y), Gp(e, i.z, s.z, o.z)),
        r
    }
    copy(e) {
        return super.copy(e),
        this.v0.copy(e.v0),
        this.v1.copy(e.v1),
        this.v2.copy(e.v2),
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.v0 = this.v0.toArray(),
        e.v1 = this.v1.toArray(),
        e.v2 = this.v2.toArray(),
        e
    }
    fromJSON(e) {
        return super.fromJSON(e),
        this.v0.fromArray(e.v0),
        this.v1.fromArray(e.v1),
        this.v2.fromArray(e.v2),
        this
    }
}
class oM extends Dl {
    constructor(e=[]) {
        super(),
        this.isSplineCurve = !0,
        this.type = "SplineCurve",
        this.points = e
    }
    getPoint(e, t=new it) {
        const r = t
          , i = this.points
          , s = (i.length - 1) * e
          , o = Math.floor(s)
          , a = s - o
          , l = i[o === 0 ? o : o - 1]
          , f = i[o]
          , h = i[o > i.length - 2 ? i.length - 1 : o + 1]
          , d = i[o > i.length - 3 ? i.length - 1 : o + 2];
        return r.set(vE(a, l.x, f.x, h.x, d.x), vE(a, l.y, f.y, h.y, d.y)),
        r
    }
    copy(e) {
        super.copy(e),
        this.points = [];
        for (let t = 0, r = e.points.length; t < r; t++) {
            const i = e.points[t];
            this.points.push(i.clone())
        }
        return this
    }
    toJSON() {
        const e = super.toJSON();
        e.points = [];
        for (let t = 0, r = this.points.length; t < r; t++) {
            const i = this.points[t];
            e.points.push(i.toArray())
        }
        return e
    }
    fromJSON(e) {
        super.fromJSON(e),
        this.points = [];
        for (let t = 0, r = e.points.length; t < r; t++) {
            const i = e.points[t];
            this.points.push(new it().fromArray(i))
        }
        return this
    }
}
var aM = Object.freeze({
    __proto__: null,
    ArcCurve: p3,
    CatmullRomCurve3: m3,
    CubicBezierCurve: rM,
    CubicBezierCurve3: g3,
    EllipseCurve: T_,
    LineCurve: D_,
    LineCurve3: v3,
    QuadraticBezierCurve: iM,
    QuadraticBezierCurve3: sM,
    SplineCurve: oM
});
class _3 extends Dl {
    constructor() {
        super(),
        this.type = "CurvePath",
        this.curves = [],
        this.autoClose = !1
    }
    add(e) {
        this.curves.push(e)
    }
    closePath() {
        const e = this.curves[0].getPoint(0)
          , t = this.curves[this.curves.length - 1].getPoint(1);
        e.equals(t) || this.curves.push(new D_(t,e))
    }
    getPoint(e, t) {
        const r = e * this.getLength()
          , i = this.getCurveLengths();
        let s = 0;
        for (; s < i.length; ) {
            if (i[s] >= r) {
                const o = i[s] - r
                  , a = this.curves[s]
                  , l = a.getLength()
                  , f = l === 0 ? 0 : 1 - o / l;
                return a.getPointAt(f, t)
            }
            s++
        }
        return null
    }
    getLength() {
        const e = this.getCurveLengths();
        return e[e.length - 1]
    }
    updateArcLengths() {
        this.needsUpdate = !0,
        this.cacheLengths = null,
        this.getCurveLengths()
    }
    getCurveLengths() {
        if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
            return this.cacheLengths;
        const e = [];
        let t = 0;
        for (let r = 0, i = this.curves.length; r < i; r++)
            t += this.curves[r].getLength(),
            e.push(t);
        return this.cacheLengths = e,
        e
    }
    getSpacedPoints(e=40) {
        const t = [];
        for (let r = 0; r <= e; r++)
            t.push(this.getPoint(r / e));
        return this.autoClose && t.push(t[0]),
        t
    }
    getPoints(e=12) {
        const t = [];
        let r;
        for (let i = 0, s = this.curves; i < s.length; i++) {
            const o = s[i]
              , a = o.isEllipseCurve ? e * 2 : o.isLineCurve || o.isLineCurve3 ? 1 : o.isSplineCurve ? e * o.points.length : e
              , l = o.getPoints(a);
            for (let f = 0; f < l.length; f++) {
                const h = l[f];
                r && r.equals(h) || (t.push(h),
                r = h)
            }
        }
        return this.autoClose && t.length > 1 && !t[t.length - 1].equals(t[0]) && t.push(t[0]),
        t
    }
    copy(e) {
        super.copy(e),
        this.curves = [];
        for (let t = 0, r = e.curves.length; t < r; t++) {
            const i = e.curves[t];
            this.curves.push(i.clone())
        }
        return this.autoClose = e.autoClose,
        this
    }
    toJSON() {
        const e = super.toJSON();
        e.autoClose = this.autoClose,
        e.curves = [];
        for (let t = 0, r = this.curves.length; t < r; t++) {
            const i = this.curves[t];
            e.curves.push(i.toJSON())
        }
        return e
    }
    fromJSON(e) {
        super.fromJSON(e),
        this.autoClose = e.autoClose,
        this.curves = [];
        for (let t = 0, r = e.curves.length; t < r; t++) {
            const i = e.curves[t];
            this.curves.push(new aM[i.type]().fromJSON(i))
        }
        return this
    }
}
class ym extends _3 {
    constructor(e) {
        super(),
        this.type = "Path",
        this.currentPoint = new it,
        e && this.setFromPoints(e)
    }
    setFromPoints(e) {
        this.moveTo(e[0].x, e[0].y);
        for (let t = 1, r = e.length; t < r; t++)
            this.lineTo(e[t].x, e[t].y);
        return this
    }
    moveTo(e, t) {
        return this.currentPoint.set(e, t),
        this
    }
    lineTo(e, t) {
        const r = new D_(this.currentPoint.clone(),new it(e,t));
        return this.curves.push(r),
        this.currentPoint.set(e, t),
        this
    }
    quadraticCurveTo(e, t, r, i) {
        const s = new iM(this.currentPoint.clone(),new it(e,t),new it(r,i));
        return this.curves.push(s),
        this.currentPoint.set(r, i),
        this
    }
    bezierCurveTo(e, t, r, i, s, o) {
        const a = new rM(this.currentPoint.clone(),new it(e,t),new it(r,i),new it(s,o));
        return this.curves.push(a),
        this.currentPoint.set(s, o),
        this
    }
    splineThru(e) {
        const t = [this.currentPoint.clone()].concat(e)
          , r = new oM(t);
        return this.curves.push(r),
        this.currentPoint.copy(e[e.length - 1]),
        this
    }
    arc(e, t, r, i, s, o) {
        const a = this.currentPoint.x
          , l = this.currentPoint.y;
        return this.absarc(e + a, t + l, r, i, s, o),
        this
    }
    absarc(e, t, r, i, s, o) {
        return this.absellipse(e, t, r, r, i, s, o),
        this
    }
    ellipse(e, t, r, i, s, o, a, l) {
        const f = this.currentPoint.x
          , h = this.currentPoint.y;
        return this.absellipse(e + f, t + h, r, i, s, o, a, l),
        this
    }
    absellipse(e, t, r, i, s, o, a, l) {
        const f = new T_(e,t,r,i,s,o,a,l);
        if (this.curves.length > 0) {
            const d = f.getPoint(0);
            d.equals(this.currentPoint) || this.lineTo(d.x, d.y)
        }
        this.curves.push(f);
        const h = f.getPoint(1);
        return this.currentPoint.copy(h),
        this
    }
    copy(e) {
        return super.copy(e),
        this.currentPoint.copy(e.currentPoint),
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.currentPoint = this.currentPoint.toArray(),
        e
    }
    fromJSON(e) {
        return super.fromJSON(e),
        this.currentPoint.fromArray(e.currentPoint),
        this
    }
}
class Bh extends On {
    constructor(e=[new it(0,-.5), new it(.5,0), new it(0,.5)], t=12, r=0, i=Math.PI * 2) {
        super(),
        this.type = "LatheGeometry",
        this.parameters = {
            points: e,
            segments: t,
            phiStart: r,
            phiLength: i
        },
        t = Math.floor(t),
        i = $i(i, 0, Math.PI * 2);
        const s = []
          , o = []
          , a = []
          , l = []
          , f = []
          , h = 1 / t
          , d = new $
          , p = new it
          , m = new $
          , _ = new $
          , y = new $;
        let x = 0
          , S = 0;
        for (let M = 0; M <= e.length - 1; M++)
            switch (M) {
            case 0:
                x = e[M + 1].x - e[M].x,
                S = e[M + 1].y - e[M].y,
                m.x = S * 1,
                m.y = -x,
                m.z = S * 0,
                y.copy(m),
                m.normalize(),
                l.push(m.x, m.y, m.z);
                break;
            case e.length - 1:
                l.push(y.x, y.y, y.z);
                break;
            default:
                x = e[M + 1].x - e[M].x,
                S = e[M + 1].y - e[M].y,
                m.x = S * 1,
                m.y = -x,
                m.z = S * 0,
                _.copy(m),
                m.x += y.x,
                m.y += y.y,
                m.z += y.z,
                m.normalize(),
                l.push(m.x, m.y, m.z),
                y.copy(_)
            }
        for (let M = 0; M <= t; M++) {
            const w = r + M * h * i
              , T = Math.sin(w)
              , P = Math.cos(w);
            for (let I = 0; I <= e.length - 1; I++) {
                d.x = e[I].x * T,
                d.y = e[I].y,
                d.z = e[I].x * P,
                o.push(d.x, d.y, d.z),
                p.x = M / t,
                p.y = I / (e.length - 1),
                a.push(p.x, p.y);
                const k = l[3 * I + 0] * T
                  , R = l[3 * I + 1]
                  , O = l[3 * I + 0] * P;
                f.push(k, R, O)
            }
        }
        for (let M = 0; M < t; M++)
            for (let w = 0; w < e.length - 1; w++) {
                const T = w + M * e.length
                  , P = T
                  , I = T + e.length
                  , k = T + e.length + 1
                  , R = T + 1;
                s.push(P, I, R),
                s.push(k, R, I)
            }
        this.setIndex(s),
        this.setAttribute("position", new nn(o,3)),
        this.setAttribute("uv", new nn(a,2)),
        this.setAttribute("normal", new nn(f,3))
    }
    static fromJSON(e) {
        return new Bh(e.points,e.segments,e.phiStart,e.phiLength)
    }
}
class Um extends Bh {
    constructor(e=1, t=1, r=4, i=8) {
        const s = new ym;
        s.absarc(0, -t / 2, e, Math.PI * 1.5, 0),
        s.absarc(0, t / 2, e, 0, Math.PI * .5),
        super(s.getPoints(r), i),
        this.type = "CapsuleGeometry",
        this.parameters = {
            radius: e,
            height: t,
            capSegments: r,
            radialSegments: i
        }
    }
    static fromJSON(e) {
        return new Um(e.radius,e.length,e.capSegments,e.radialSegments)
    }
}
class Hm extends On {
    constructor(e=1, t=32, r=0, i=Math.PI * 2) {
        super(),
        this.type = "CircleGeometry",
        this.parameters = {
            radius: e,
            segments: t,
            thetaStart: r,
            thetaLength: i
        },
        t = Math.max(3, t);
        const s = []
          , o = []
          , a = []
          , l = []
          , f = new $
          , h = new it;
        o.push(0, 0, 0),
        a.push(0, 0, 1),
        l.push(.5, .5);
        for (let d = 0, p = 3; d <= t; d++,
        p += 3) {
            const m = r + d / t * i;
            f.x = e * Math.cos(m),
            f.y = e * Math.sin(m),
            o.push(f.x, f.y, f.z),
            a.push(0, 0, 1),
            h.x = (o[p] / e + 1) / 2,
            h.y = (o[p + 1] / e + 1) / 2,
            l.push(h.x, h.y)
        }
        for (let d = 1; d <= t; d++)
            s.push(d, d + 1, 0);
        this.setIndex(s),
        this.setAttribute("position", new nn(o,3)),
        this.setAttribute("normal", new nn(a,3)),
        this.setAttribute("uv", new nn(l,2))
    }
    static fromJSON(e) {
        return new Hm(e.radius,e.segments,e.thetaStart,e.thetaLength)
    }
}
class Zf extends On {
    constructor(e=1, t=1, r=1, i=32, s=1, o=!1, a=0, l=Math.PI * 2) {
        super(),
        this.type = "CylinderGeometry",
        this.parameters = {
            radiusTop: e,
            radiusBottom: t,
            height: r,
            radialSegments: i,
            heightSegments: s,
            openEnded: o,
            thetaStart: a,
            thetaLength: l
        };
        const f = this;
        i = Math.floor(i),
        s = Math.floor(s);
        const h = []
          , d = []
          , p = []
          , m = [];
        let _ = 0;
        const y = []
          , x = r / 2;
        let S = 0;
        M(),
        o === !1 && (e > 0 && w(!0),
        t > 0 && w(!1)),
        this.setIndex(h),
        this.setAttribute("position", new nn(d,3)),
        this.setAttribute("normal", new nn(p,3)),
        this.setAttribute("uv", new nn(m,2));
        function M() {
            const T = new $
              , P = new $;
            let I = 0;
            const k = (t - e) / r;
            for (let R = 0; R <= s; R++) {
                const O = []
                  , H = R / s
                  , W = H * (t - e) + e;
                for (let te = 0; te <= i; te++) {
                    const ne = te / i
                      , re = ne * l + a
                      , pe = Math.sin(re)
                      , ce = Math.cos(re);
                    P.x = W * pe,
                    P.y = -H * r + x,
                    P.z = W * ce,
                    d.push(P.x, P.y, P.z),
                    T.set(pe, k, ce).normalize(),
                    p.push(T.x, T.y, T.z),
                    m.push(ne, 1 - H),
                    O.push(_++)
                }
                y.push(O)
            }
            for (let R = 0; R < i; R++)
                for (let O = 0; O < s; O++) {
                    const H = y[O][R]
                      , W = y[O + 1][R]
                      , te = y[O + 1][R + 1]
                      , ne = y[O][R + 1];
                    h.push(H, W, ne),
                    h.push(W, te, ne),
                    I += 6
                }
            f.addGroup(S, I, 0),
            S += I
        }
        function w(T) {
            const P = _
              , I = new it
              , k = new $;
            let R = 0;
            const O = T === !0 ? e : t
              , H = T === !0 ? 1 : -1;
            for (let te = 1; te <= i; te++)
                d.push(0, x * H, 0),
                p.push(0, H, 0),
                m.push(.5, .5),
                _++;
            const W = _;
            for (let te = 0; te <= i; te++) {
                const re = te / i * l + a
                  , pe = Math.cos(re)
                  , ce = Math.sin(re);
                k.x = O * ce,
                k.y = x * H,
                k.z = O * pe,
                d.push(k.x, k.y, k.z),
                p.push(0, H, 0),
                I.x = pe * .5 + .5,
                I.y = ce * .5 * H + .5,
                m.push(I.x, I.y),
                _++
            }
            for (let te = 0; te < i; te++) {
                const ne = P + te
                  , re = W + te;
                T === !0 ? h.push(re, re + 1, ne) : h.push(re + 1, re, ne),
                R += 3
            }
            f.addGroup(S, R, T === !0 ? 1 : 2),
            S += R
        }
    }
    static fromJSON(e) {
        return new Zf(e.radiusTop,e.radiusBottom,e.height,e.radialSegments,e.heightSegments,e.openEnded,e.thetaStart,e.thetaLength)
    }
}
class Vm extends Zf {
    constructor(e=1, t=1, r=32, i=1, s=!1, o=0, a=Math.PI * 2) {
        super(0, e, t, r, i, s, o, a),
        this.type = "ConeGeometry",
        this.parameters = {
            radius: e,
            height: t,
            radialSegments: r,
            heightSegments: i,
            openEnded: s,
            thetaStart: o,
            thetaLength: a
        }
    }
    static fromJSON(e) {
        return new Vm(e.radius,e.height,e.radialSegments,e.heightSegments,e.openEnded,e.thetaStart,e.thetaLength)
    }
}
class Bu extends On {
    constructor(e=[], t=[], r=1, i=0) {
        super(),
        this.type = "PolyhedronGeometry",
        this.parameters = {
            vertices: e,
            indices: t,
            radius: r,
            detail: i
        };
        const s = []
          , o = [];
        a(i),
        f(r),
        h(),
        this.setAttribute("position", new nn(s,3)),
        this.setAttribute("normal", new nn(s.slice(),3)),
        this.setAttribute("uv", new nn(o,2)),
        i === 0 ? this.computeVertexNormals() : this.normalizeNormals();
        function a(M) {
            const w = new $
              , T = new $
              , P = new $;
            for (let I = 0; I < t.length; I += 3)
                m(t[I + 0], w),
                m(t[I + 1], T),
                m(t[I + 2], P),
                l(w, T, P, M)
        }
        function l(M, w, T, P) {
            const I = P + 1
              , k = [];
            for (let R = 0; R <= I; R++) {
                k[R] = [];
                const O = M.clone().lerp(T, R / I)
                  , H = w.clone().lerp(T, R / I)
                  , W = I - R;
                for (let te = 0; te <= W; te++)
                    te === 0 && R === I ? k[R][te] = O : k[R][te] = O.clone().lerp(H, te / W)
            }
            for (let R = 0; R < I; R++)
                for (let O = 0; O < 2 * (I - R) - 1; O++) {
                    const H = Math.floor(O / 2);
                    O % 2 === 0 ? (p(k[R][H + 1]),
                    p(k[R + 1][H]),
                    p(k[R][H])) : (p(k[R][H + 1]),
                    p(k[R + 1][H + 1]),
                    p(k[R + 1][H]))
                }
        }
        function f(M) {
            const w = new $;
            for (let T = 0; T < s.length; T += 3)
                w.x = s[T + 0],
                w.y = s[T + 1],
                w.z = s[T + 2],
                w.normalize().multiplyScalar(M),
                s[T + 0] = w.x,
                s[T + 1] = w.y,
                s[T + 2] = w.z
        }
        function h() {
            const M = new $;
            for (let w = 0; w < s.length; w += 3) {
                M.x = s[w + 0],
                M.y = s[w + 1],
                M.z = s[w + 2];
                const T = x(M) / 2 / Math.PI + .5
                  , P = S(M) / Math.PI + .5;
                o.push(T, 1 - P)
            }
            _(),
            d()
        }
        function d() {
            for (let M = 0; M < o.length; M += 6) {
                const w = o[M + 0]
                  , T = o[M + 2]
                  , P = o[M + 4]
                  , I = Math.max(w, T, P)
                  , k = Math.min(w, T, P);
                I > .9 && k < .1 && (w < .2 && (o[M + 0] += 1),
                T < .2 && (o[M + 2] += 1),
                P < .2 && (o[M + 4] += 1))
            }
        }
        function p(M) {
            s.push(M.x, M.y, M.z)
        }
        function m(M, w) {
            const T = M * 3;
            w.x = e[T + 0],
            w.y = e[T + 1],
            w.z = e[T + 2]
        }
        function _() {
            const M = new $
              , w = new $
              , T = new $
              , P = new $
              , I = new it
              , k = new it
              , R = new it;
            for (let O = 0, H = 0; O < s.length; O += 9,
            H += 6) {
                M.set(s[O + 0], s[O + 1], s[O + 2]),
                w.set(s[O + 3], s[O + 4], s[O + 5]),
                T.set(s[O + 6], s[O + 7], s[O + 8]),
                I.set(o[H + 0], o[H + 1]),
                k.set(o[H + 2], o[H + 3]),
                R.set(o[H + 4], o[H + 5]),
                P.copy(M).add(w).add(T).divideScalar(3);
                const W = x(P);
                y(I, H + 0, M, W),
                y(k, H + 2, w, W),
                y(R, H + 4, T, W)
            }
        }
        function y(M, w, T, P) {
            P < 0 && M.x === 1 && (o[w] = M.x - 1),
            T.x === 0 && T.z === 0 && (o[w] = P / 2 / Math.PI + .5)
        }
        function x(M) {
            return Math.atan2(M.z, -M.x)
        }
        function S(M) {
            return Math.atan2(-M.y, Math.sqrt(M.x * M.x + M.z * M.z))
        }
    }
    static fromJSON(e) {
        return new Bu(e.vertices,e.indices,e.radius,e.details)
    }
}
class Wm extends Bu {
    constructor(e=1, t=0) {
        const r = (1 + Math.sqrt(5)) / 2
          , i = 1 / r
          , s = [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -i, -r, 0, -i, r, 0, i, -r, 0, i, r, -i, -r, 0, -i, r, 0, i, -r, 0, i, r, 0, -r, 0, -i, r, 0, -i, -r, 0, i, r, 0, i]
          , o = [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9];
        super(s, o, e, t),
        this.type = "DodecahedronGeometry",
        this.parameters = {
            radius: e,
            detail: t
        }
    }
    static fromJSON(e) {
        return new Wm(e.radius,e.detail)
    }
}
const u0 = new $
  , c0 = new $
  , cx = new $
  , f0 = new Xa;
class y3 extends On {
    constructor(e=null, t=1) {
        if (super(),
        this.type = "EdgesGeometry",
        this.parameters = {
            geometry: e,
            thresholdAngle: t
        },
        e !== null) {
            const i = Math.pow(10, 4)
              , s = Math.cos(Df * t)
              , o = e.getIndex()
              , a = e.getAttribute("position")
              , l = o ? o.count : a.count
              , f = [0, 0, 0]
              , h = ["a", "b", "c"]
              , d = new Array(3)
              , p = {}
              , m = [];
            for (let _ = 0; _ < l; _ += 3) {
                o ? (f[0] = o.getX(_),
                f[1] = o.getX(_ + 1),
                f[2] = o.getX(_ + 2)) : (f[0] = _,
                f[1] = _ + 1,
                f[2] = _ + 2);
                const {a: y, b: x, c: S} = f0;
                if (y.fromBufferAttribute(a, f[0]),
                x.fromBufferAttribute(a, f[1]),
                S.fromBufferAttribute(a, f[2]),
                f0.getNormal(cx),
                d[0] = `${Math.round(y.x * i)},${Math.round(y.y * i)},${Math.round(y.z * i)}`,
                d[1] = `${Math.round(x.x * i)},${Math.round(x.y * i)},${Math.round(x.z * i)}`,
                d[2] = `${Math.round(S.x * i)},${Math.round(S.y * i)},${Math.round(S.z * i)}`,
                !(d[0] === d[1] || d[1] === d[2] || d[2] === d[0]))
                    for (let M = 0; M < 3; M++) {
                        const w = (M + 1) % 3
                          , T = d[M]
                          , P = d[w]
                          , I = f0[h[M]]
                          , k = f0[h[w]]
                          , R = `${T}_ ${P}`
                          , O = `${P}_ ${T}`;
                        O in p && p[O] ? (cx.dot(p[O].normal) <= s && (m.push(I.x, I.y, I.z),
                        m.push(k.x, k.y, k.z)),
                        p[O] = null) : R in p || (p[R] = {
                            index0: f[M],
                            index1: f[w],
                            normal: cx.clone()
                        })
                    }
            }
            for (const _ in p)
                if (p[_]) {
                    const {index0: y, index1: x} = p[_];
                    u0.fromBufferAttribute(a, y),
                    c0.fromBufferAttribute(a, x),
                    m.push(u0.x, u0.y, u0.z),
                    m.push(c0.x, c0.y, c0.z)
                }
            this.setAttribute("position", new nn(m,3))
        }
    }
}
class Bf extends ym {
    constructor(e) {
        super(e),
        this.uuid = Sa(),
        this.type = "Shape",
        this.holes = []
    }
    getPointsHoles(e) {
        const t = [];
        for (let r = 0, i = this.holes.length; r < i; r++)
            t[r] = this.holes[r].getPoints(e);
        return t
    }
    extractPoints(e) {
        return {
            shape: this.getPoints(e),
            holes: this.getPointsHoles(e)
        }
    }
    copy(e) {
        super.copy(e),
        this.holes = [];
        for (let t = 0, r = e.holes.length; t < r; t++) {
            const i = e.holes[t];
            this.holes.push(i.clone())
        }
        return this
    }
    toJSON() {
        const e = super.toJSON();
        e.uuid = this.uuid,
        e.holes = [];
        for (let t = 0, r = this.holes.length; t < r; t++) {
            const i = this.holes[t];
            e.holes.push(i.toJSON())
        }
        return e
    }
    fromJSON(e) {
        super.fromJSON(e),
        this.uuid = e.uuid,
        this.holes = [];
        for (let t = 0, r = e.holes.length; t < r; t++) {
            const i = e.holes[t];
            this.holes.push(new ym().fromJSON(i))
        }
        return this
    }
}
const r4 = {
    triangulate: function(n, e, t=2) {
        const r = e && e.length
          , i = r ? e[0] * t : n.length;
        let s = x3(n, 0, i, t, !0);
        const o = [];
        if (!s || s.next === s.prev)
            return o;
        let a, l, f, h, d, p, m;
        if (r && (s = l4(n, e, s, t)),
        n.length > 80 * t) {
            a = f = n[0],
            l = h = n[1];
            for (let _ = t; _ < i; _ += t)
                d = n[_],
                p = n[_ + 1],
                d < a && (a = d),
                p < l && (l = p),
                d > f && (f = d),
                p > h && (h = p);
            m = Math.max(f - a, h - l),
            m = m !== 0 ? 32767 / m : 0
        }
        return xm(s, o, t, a, l, m, 0),
        o
    }
};
function x3(n, e, t, r, i) {
    let s, o;
    if (i === y4(n, e, t, r) > 0)
        for (s = e; s < t; s += r)
            o = _E(s, n[s], n[s + 1], o);
    else
        for (s = t - r; s >= e; s -= r)
            o = _E(s, n[s], n[s + 1], o);
    return o && P_(o, o.next) && (Sm(o),
    o = o.next),
    o
}
function Vf(n, e) {
    if (!n)
        return n;
    e || (e = n);
    let t = n, r;
    do
        if (r = !1,
        !t.steiner && (P_(t, t.next) || Fi(t.prev, t, t.next) === 0)) {
            if (Sm(t),
            t = e = t.prev,
            t === t.next)
                break;
            r = !0
        } else
            t = t.next;
    while (r || t !== e);
    return e
}
function xm(n, e, t, r, i, s, o) {
    if (!n)
        return;
    !o && s && h4(n, r, i, s);
    let a = n, l, f;
    for (; n.prev !== n.next; ) {
        if (l = n.prev,
        f = n.next,
        s ? s4(n, r, i, s) : i4(n)) {
            e.push(l.i / t | 0),
            e.push(n.i / t | 0),
            e.push(f.i / t | 0),
            Sm(n),
            n = f.next,
            a = f.next;
            continue
        }
        if (n = f,
        n === a) {
            o ? o === 1 ? (n = o4(Vf(n), e, t),
            xm(n, e, t, r, i, s, 2)) : o === 2 && a4(n, e, t, r, i, s) : xm(Vf(n), e, t, r, i, s, 1);
            break
        }
    }
}
function i4(n) {
    const e = n.prev
      , t = n
      , r = n.next;
    if (Fi(e, t, r) >= 0)
        return !1;
    const i = e.x
      , s = t.x
      , o = r.x
      , a = e.y
      , l = t.y
      , f = r.y
      , h = i < s ? i < o ? i : o : s < o ? s : o
      , d = a < l ? a < f ? a : f : l < f ? l : f
      , p = i > s ? i > o ? i : o : s > o ? s : o
      , m = a > l ? a > f ? a : f : l > f ? l : f;
    let _ = r.next;
    for (; _ !== e; ) {
        if (_.x >= h && _.x <= p && _.y >= d && _.y <= m && Jd(i, a, s, l, o, f, _.x, _.y) && Fi(_.prev, _, _.next) >= 0)
            return !1;
        _ = _.next
    }
    return !0
}
function s4(n, e, t, r) {
    const i = n.prev
      , s = n
      , o = n.next;
    if (Fi(i, s, o) >= 0)
        return !1;
    const a = i.x
      , l = s.x
      , f = o.x
      , h = i.y
      , d = s.y
      , p = o.y
      , m = a < l ? a < f ? a : f : l < f ? l : f
      , _ = h < d ? h < p ? h : p : d < p ? d : p
      , y = a > l ? a > f ? a : f : l > f ? l : f
      , x = h > d ? h > p ? h : p : d > p ? d : p
      , S = pw(m, _, e, t, r)
      , M = pw(y, x, e, t, r);
    let w = n.prevZ
      , T = n.nextZ;
    for (; w && w.z >= S && T && T.z <= M; ) {
        if (w.x >= m && w.x <= y && w.y >= _ && w.y <= x && w !== i && w !== o && Jd(a, h, l, d, f, p, w.x, w.y) && Fi(w.prev, w, w.next) >= 0 || (w = w.prevZ,
        T.x >= m && T.x <= y && T.y >= _ && T.y <= x && T !== i && T !== o && Jd(a, h, l, d, f, p, T.x, T.y) && Fi(T.prev, T, T.next) >= 0))
            return !1;
        T = T.nextZ
    }
    for (; w && w.z >= S; ) {
        if (w.x >= m && w.x <= y && w.y >= _ && w.y <= x && w !== i && w !== o && Jd(a, h, l, d, f, p, w.x, w.y) && Fi(w.prev, w, w.next) >= 0)
            return !1;
        w = w.prevZ
    }
    for (; T && T.z <= M; ) {
        if (T.x >= m && T.x <= y && T.y >= _ && T.y <= x && T !== i && T !== o && Jd(a, h, l, d, f, p, T.x, T.y) && Fi(T.prev, T, T.next) >= 0)
            return !1;
        T = T.nextZ
    }
    return !0
}
function o4(n, e, t) {
    let r = n;
    do {
        const i = r.prev
          , s = r.next.next;
        !P_(i, s) && w3(i, r, r.next, s) && wm(i, s) && wm(s, i) && (e.push(i.i / t | 0),
        e.push(r.i / t | 0),
        e.push(s.i / t | 0),
        Sm(r),
        Sm(r.next),
        r = n = s),
        r = r.next
    } while (r !== n);
    return Vf(r)
}
function a4(n, e, t, r, i, s) {
    let o = n;
    do {
        let a = o.next.next;
        for (; a !== o.prev; ) {
            if (o.i !== a.i && g4(o, a)) {
                let l = S3(o, a);
                o = Vf(o, o.next),
                l = Vf(l, l.next),
                xm(o, e, t, r, i, s, 0),
                xm(l, e, t, r, i, s, 0);
                return
            }
            a = a.next
        }
        o = o.next
    } while (o !== n)
}
function l4(n, e, t, r) {
    const i = [];
    let s, o, a, l, f;
    for (s = 0,
    o = e.length; s < o; s++)
        a = e[s] * r,
        l = s < o - 1 ? e[s + 1] * r : n.length,
        f = x3(n, a, l, r, !1),
        f === f.next && (f.steiner = !0),
        i.push(m4(f));
    for (i.sort(u4),
    s = 0; s < i.length; s++)
        t = c4(i[s], t);
    return t
}
function u4(n, e) {
    return n.x - e.x
}
function c4(n, e) {
    const t = f4(n, e);
    if (!t)
        return e;
    const r = S3(t, n);
    return Vf(r, r.next),
    Vf(t, t.next)
}
function f4(n, e) {
    let t = e, r = -1 / 0, i;
    const s = n.x
      , o = n.y;
    do {
        if (o <= t.y && o >= t.next.y && t.next.y !== t.y) {
            const p = t.x + (o - t.y) * (t.next.x - t.x) / (t.next.y - t.y);
            if (p <= s && p > r && (r = p,
            i = t.x < t.next.x ? t : t.next,
            p === s))
                return i
        }
        t = t.next
    } while (t !== e);
    if (!i)
        return null;
    const a = i
      , l = i.x
      , f = i.y;
    let h = 1 / 0, d;
    t = i;
    do
        s >= t.x && t.x >= l && s !== t.x && Jd(o < f ? s : r, o, l, f, o < f ? r : s, o, t.x, t.y) && (d = Math.abs(o - t.y) / (s - t.x),
        wm(t, n) && (d < h || d === h && (t.x > i.x || t.x === i.x && d4(i, t))) && (i = t,
        h = d)),
        t = t.next;
    while (t !== a);
    return i
}
function d4(n, e) {
    return Fi(n.prev, n, e.prev) < 0 && Fi(e.next, n, n.next) < 0
}
function h4(n, e, t, r) {
    let i = n;
    do
        i.z === 0 && (i.z = pw(i.x, i.y, e, t, r)),
        i.prevZ = i.prev,
        i.nextZ = i.next,
        i = i.next;
    while (i !== n);
    i.prevZ.nextZ = null,
    i.prevZ = null,
    p4(i)
}
function p4(n) {
    let e, t, r, i, s, o, a, l, f = 1;
    do {
        for (t = n,
        n = null,
        s = null,
        o = 0; t; ) {
            for (o++,
            r = t,
            a = 0,
            e = 0; e < f && (a++,
            r = r.nextZ,
            !!r); e++)
                ;
            for (l = f; a > 0 || l > 0 && r; )
                a !== 0 && (l === 0 || !r || t.z <= r.z) ? (i = t,
                t = t.nextZ,
                a--) : (i = r,
                r = r.nextZ,
                l--),
                s ? s.nextZ = i : n = i,
                i.prevZ = s,
                s = i;
            t = r
        }
        s.nextZ = null,
        f *= 2
    } while (o > 1);
    return n
}
function pw(n, e, t, r, i) {
    return n = (n - t) * i | 0,
    e = (e - r) * i | 0,
    n = (n | n << 8) & 16711935,
    n = (n | n << 4) & 252645135,
    n = (n | n << 2) & 858993459,
    n = (n | n << 1) & 1431655765,
    e = (e | e << 8) & 16711935,
    e = (e | e << 4) & 252645135,
    e = (e | e << 2) & 858993459,
    e = (e | e << 1) & 1431655765,
    n | e << 1
}
function m4(n) {
    let e = n
      , t = n;
    do
        (e.x < t.x || e.x === t.x && e.y < t.y) && (t = e),
        e = e.next;
    while (e !== n);
    return t
}
function Jd(n, e, t, r, i, s, o, a) {
    return (i - o) * (e - a) >= (n - o) * (s - a) && (n - o) * (r - a) >= (t - o) * (e - a) && (t - o) * (s - a) >= (i - o) * (r - a)
}
function g4(n, e) {
    return n.next.i !== e.i && n.prev.i !== e.i && !v4(n, e) && (wm(n, e) && wm(e, n) && _4(n, e) && (Fi(n.prev, n, e.prev) || Fi(n, e.prev, e)) || P_(n, e) && Fi(n.prev, n, n.next) > 0 && Fi(e.prev, e, e.next) > 0)
}
function Fi(n, e, t) {
    return (e.y - n.y) * (t.x - e.x) - (e.x - n.x) * (t.y - e.y)
}
function P_(n, e) {
    return n.x === e.x && n.y === e.y
}
function w3(n, e, t, r) {
    const i = h0(Fi(n, e, t))
      , s = h0(Fi(n, e, r))
      , o = h0(Fi(t, r, n))
      , a = h0(Fi(t, r, e));
    return !!(i !== s && o !== a || i === 0 && d0(n, t, e) || s === 0 && d0(n, r, e) || o === 0 && d0(t, n, r) || a === 0 && d0(t, e, r))
}
function d0(n, e, t) {
    return e.x <= Math.max(n.x, t.x) && e.x >= Math.min(n.x, t.x) && e.y <= Math.max(n.y, t.y) && e.y >= Math.min(n.y, t.y)
}
function h0(n) {
    return n > 0 ? 1 : n < 0 ? -1 : 0
}
function v4(n, e) {
    let t = n;
    do {
        if (t.i !== n.i && t.next.i !== n.i && t.i !== e.i && t.next.i !== e.i && w3(t, t.next, n, e))
            return !0;
        t = t.next
    } while (t !== n);
    return !1
}
function wm(n, e) {
    return Fi(n.prev, n, n.next) < 0 ? Fi(n, e, n.next) >= 0 && Fi(n, n.prev, e) >= 0 : Fi(n, e, n.prev) < 0 || Fi(n, n.next, e) < 0
}
function _4(n, e) {
    let t = n
      , r = !1;
    const i = (n.x + e.x) / 2
      , s = (n.y + e.y) / 2;
    do
        t.y > s != t.next.y > s && t.next.y !== t.y && i < (t.next.x - t.x) * (s - t.y) / (t.next.y - t.y) + t.x && (r = !r),
        t = t.next;
    while (t !== n);
    return r
}
function S3(n, e) {
    const t = new mw(n.i,n.x,n.y)
      , r = new mw(e.i,e.x,e.y)
      , i = n.next
      , s = e.prev;
    return n.next = e,
    e.prev = n,
    t.next = i,
    i.prev = t,
    r.next = t,
    t.prev = r,
    s.next = r,
    r.prev = s,
    r
}
function _E(n, e, t, r) {
    const i = new mw(n,e,t);
    return r ? (i.next = r.next,
    i.prev = r,
    r.next.prev = i,
    r.next = i) : (i.prev = i,
    i.next = i),
    i
}
function Sm(n) {
    n.next.prev = n.prev,
    n.prev.next = n.next,
    n.prevZ && (n.prevZ.nextZ = n.nextZ),
    n.nextZ && (n.nextZ.prevZ = n.prevZ)
}
function mw(n, e, t) {
    this.i = n,
    this.x = e,
    this.y = t,
    this.prev = null,
    this.next = null,
    this.z = 0,
    this.prevZ = null,
    this.nextZ = null,
    this.steiner = !1
}
function y4(n, e, t, r) {
    let i = 0;
    for (let s = e, o = t - r; s < t; s += r)
        i += (n[o] - n[s]) * (n[s + 1] + n[o + 1]),
        o = s;
    return i
}
class Jl {
    static area(e) {
        const t = e.length;
        let r = 0;
        for (let i = t - 1, s = 0; s < t; i = s++)
            r += e[i].x * e[s].y - e[s].x * e[i].y;
        return r * .5
    }
    static isClockWise(e) {
        return Jl.area(e) < 0
    }
    static triangulateShape(e, t) {
        const r = []
          , i = []
          , s = [];
        yE(e),
        xE(r, e);
        let o = e.length;
        t.forEach(yE);
        for (let l = 0; l < t.length; l++)
            i.push(o),
            o += t[l].length,
            xE(r, t[l]);
        const a = r4.triangulate(r, i);
        for (let l = 0; l < a.length; l += 3)
            s.push(a.slice(l, l + 3));
        return s
    }
}
function yE(n) {
    const e = n.length;
    e > 2 && n[e - 1].equals(n[0]) && n.pop()
}
function xE(n, e) {
    for (let t = 0; t < e.length; t++)
        n.push(e[t].x),
        n.push(e[t].y)
}
class Xm extends On {
    constructor(e=new Bf([new it(.5,.5), new it(-.5,.5), new it(-.5,-.5), new it(.5,-.5)]), t={}) {
        super(),
        this.type = "ExtrudeGeometry",
        this.parameters = {
            shapes: e,
            options: t
        },
        e = Array.isArray(e) ? e : [e];
        const r = this
          , i = []
          , s = [];
        for (let a = 0, l = e.length; a < l; a++) {
            const f = e[a];
            o(f)
        }
        this.setAttribute("position", new nn(i,3)),
        this.setAttribute("uv", new nn(s,2)),
        this.computeVertexNormals();
        function o(a) {
            const l = []
              , f = t.curveSegments !== void 0 ? t.curveSegments : 12
              , h = t.steps !== void 0 ? t.steps : 1
              , d = t.depth !== void 0 ? t.depth : 1;
            let p = t.bevelEnabled !== void 0 ? t.bevelEnabled : !0
              , m = t.bevelThickness !== void 0 ? t.bevelThickness : .2
              , _ = t.bevelSize !== void 0 ? t.bevelSize : m - .1
              , y = t.bevelOffset !== void 0 ? t.bevelOffset : 0
              , x = t.bevelSegments !== void 0 ? t.bevelSegments : 3;
            const S = t.extrudePath
              , M = t.UVGenerator !== void 0 ? t.UVGenerator : x4;
            let w, T = !1, P, I, k, R;
            S && (w = S.getSpacedPoints(h),
            T = !0,
            p = !1,
            P = S.computeFrenetFrames(h, !1),
            I = new $,
            k = new $,
            R = new $),
            p || (x = 0,
            m = 0,
            _ = 0,
            y = 0);
            const O = a.extractPoints(f);
            let H = O.shape;
            const W = O.holes;
            if (!Jl.isClockWise(H)) {
                H = H.reverse();
                for (let be = 0, Ee = W.length; be < Ee; be++) {
                    const at = W[be];
                    Jl.isClockWise(at) && (W[be] = at.reverse())
                }
            }
            const ne = Jl.triangulateShape(H, W)
              , re = H;
            for (let be = 0, Ee = W.length; be < Ee; be++) {
                const at = W[be];
                H = H.concat(at)
            }
            function pe(be, Ee, at) {
                return Ee || console.error("THREE.ExtrudeGeometry: vec does not exist"),
                Ee.clone().multiplyScalar(at).add(be)
            }
            const ce = H.length
              , xe = ne.length;
            function G(be, Ee, at) {
                let _t, Ce, ee;
                const et = be.x - Ee.x
                  , Ze = be.y - Ee.y
                  , ft = at.x - be.x
                  , Pt = at.y - be.y
                  , Z = et * et + Ze * Ze
                  , V = et * Pt - Ze * ft;
                if (Math.abs(V) > Number.EPSILON) {
                    const ye = Math.sqrt(Z)
                      , tt = Math.sqrt(ft * ft + Pt * Pt)
                      , Ve = Ee.x - Ze / ye
                      , Ke = Ee.y + et / ye
                      , dt = at.x - Pt / tt
                      , ct = at.y + ft / tt
                      , Fe = ((dt - Ve) * Pt - (ct - Ke) * ft) / (et * Pt - Ze * ft);
                    _t = Ve + et * Fe - be.x,
                    Ce = Ke + Ze * Fe - be.y;
                    const Rt = _t * _t + Ce * Ce;
                    if (Rt <= 2)
                        return new it(_t,Ce);
                    ee = Math.sqrt(Rt / 2)
                } else {
                    let ye = !1;
                    et > Number.EPSILON ? ft > Number.EPSILON && (ye = !0) : et < -Number.EPSILON ? ft < -Number.EPSILON && (ye = !0) : Math.sign(Ze) === Math.sign(Pt) && (ye = !0),
                    ye ? (_t = -Ze,
                    Ce = et,
                    ee = Math.sqrt(Z)) : (_t = et,
                    Ce = Ze,
                    ee = Math.sqrt(Z / 2))
                }
                return new it(_t / ee,Ce / ee)
            }
            const z = [];
            for (let be = 0, Ee = re.length, at = Ee - 1, _t = be + 1; be < Ee; be++,
            at++,
            _t++)
                at === Ee && (at = 0),
                _t === Ee && (_t = 0),
                z[be] = G(re[be], re[at], re[_t]);
            const U = [];
            let fe, oe = z.concat();
            for (let be = 0, Ee = W.length; be < Ee; be++) {
                const at = W[be];
                fe = [];
                for (let _t = 0, Ce = at.length, ee = Ce - 1, et = _t + 1; _t < Ce; _t++,
                ee++,
                et++)
                    ee === Ce && (ee = 0),
                    et === Ce && (et = 0),
                    fe[_t] = G(at[_t], at[ee], at[et]);
                U.push(fe),
                oe = oe.concat(fe)
            }
            for (let be = 0; be < x; be++) {
                const Ee = be / x
                  , at = m * Math.cos(Ee * Math.PI / 2)
                  , _t = _ * Math.sin(Ee * Math.PI / 2) + y;
                for (let Ce = 0, ee = re.length; Ce < ee; Ce++) {
                    const et = pe(re[Ce], z[Ce], _t);
                    qe(et.x, et.y, -at)
                }
                for (let Ce = 0, ee = W.length; Ce < ee; Ce++) {
                    const et = W[Ce];
                    fe = U[Ce];
                    for (let Ze = 0, ft = et.length; Ze < ft; Ze++) {
                        const Pt = pe(et[Ze], fe[Ze], _t);
                        qe(Pt.x, Pt.y, -at)
                    }
                }
            }
            const Ae = _ + y;
            for (let be = 0; be < ce; be++) {
                const Ee = p ? pe(H[be], oe[be], Ae) : H[be];
                T ? (k.copy(P.normals[0]).multiplyScalar(Ee.x),
                I.copy(P.binormals[0]).multiplyScalar(Ee.y),
                R.copy(w[0]).add(k).add(I),
                qe(R.x, R.y, R.z)) : qe(Ee.x, Ee.y, 0)
            }
            for (let be = 1; be <= h; be++)
                for (let Ee = 0; Ee < ce; Ee++) {
                    const at = p ? pe(H[Ee], oe[Ee], Ae) : H[Ee];
                    T ? (k.copy(P.normals[be]).multiplyScalar(at.x),
                    I.copy(P.binormals[be]).multiplyScalar(at.y),
                    R.copy(w[be]).add(k).add(I),
                    qe(R.x, R.y, R.z)) : qe(at.x, at.y, d / h * be)
                }
            for (let be = x - 1; be >= 0; be--) {
                const Ee = be / x
                  , at = m * Math.cos(Ee * Math.PI / 2)
                  , _t = _ * Math.sin(Ee * Math.PI / 2) + y;
                for (let Ce = 0, ee = re.length; Ce < ee; Ce++) {
                    const et = pe(re[Ce], z[Ce], _t);
                    qe(et.x, et.y, d + at)
                }
                for (let Ce = 0, ee = W.length; Ce < ee; Ce++) {
                    const et = W[Ce];
                    fe = U[Ce];
                    for (let Ze = 0, ft = et.length; Ze < ft; Ze++) {
                        const Pt = pe(et[Ze], fe[Ze], _t);
                        T ? qe(Pt.x, Pt.y + w[h - 1].y, w[h - 1].x + at) : qe(Pt.x, Pt.y, d + at)
                    }
                }
            }
            Ue(),
            je();
            function Ue() {
                const be = i.length / 3;
                if (p) {
                    let Ee = 0
                      , at = ce * Ee;
                    for (let _t = 0; _t < xe; _t++) {
                        const Ce = ne[_t];
                        Ne(Ce[2] + at, Ce[1] + at, Ce[0] + at)
                    }
                    Ee = h + x * 2,
                    at = ce * Ee;
                    for (let _t = 0; _t < xe; _t++) {
                        const Ce = ne[_t];
                        Ne(Ce[0] + at, Ce[1] + at, Ce[2] + at)
                    }
                } else {
                    for (let Ee = 0; Ee < xe; Ee++) {
                        const at = ne[Ee];
                        Ne(at[2], at[1], at[0])
                    }
                    for (let Ee = 0; Ee < xe; Ee++) {
                        const at = ne[Ee];
                        Ne(at[0] + ce * h, at[1] + ce * h, at[2] + ce * h)
                    }
                }
                r.addGroup(be, i.length / 3 - be, 0)
            }
            function je() {
                const be = i.length / 3;
                let Ee = 0;
                de(re, Ee),
                Ee += re.length;
                for (let at = 0, _t = W.length; at < _t; at++) {
                    const Ce = W[at];
                    de(Ce, Ee),
                    Ee += Ce.length
                }
                r.addGroup(be, i.length / 3 - be, 1)
            }
            function de(be, Ee) {
                let at = be.length;
                for (; --at >= 0; ) {
                    const _t = at;
                    let Ce = at - 1;
                    Ce < 0 && (Ce = be.length - 1);
                    for (let ee = 0, et = h + x * 2; ee < et; ee++) {
                        const Ze = ce * ee
                          , ft = ce * (ee + 1)
                          , Pt = Ee + _t + Ze
                          , Z = Ee + Ce + Ze
                          , V = Ee + Ce + ft
                          , ye = Ee + _t + ft;
                        Tt(Pt, Z, V, ye)
                    }
                }
            }
            function qe(be, Ee, at) {
                l.push(be),
                l.push(Ee),
                l.push(at)
            }
            function Ne(be, Ee, at) {
                He(be),
                He(Ee),
                He(at);
                const _t = i.length / 3
                  , Ce = M.generateTopUV(r, i, _t - 3, _t - 2, _t - 1);
                gt(Ce[0]),
                gt(Ce[1]),
                gt(Ce[2])
            }
            function Tt(be, Ee, at, _t) {
                He(be),
                He(Ee),
                He(_t),
                He(Ee),
                He(at),
                He(_t);
                const Ce = i.length / 3
                  , ee = M.generateSideWallUV(r, i, Ce - 6, Ce - 3, Ce - 2, Ce - 1);
                gt(ee[0]),
                gt(ee[1]),
                gt(ee[3]),
                gt(ee[1]),
                gt(ee[2]),
                gt(ee[3])
            }
            function He(be) {
                i.push(l[be * 3 + 0]),
                i.push(l[be * 3 + 1]),
                i.push(l[be * 3 + 2])
            }
            function gt(be) {
                s.push(be.x),
                s.push(be.y)
            }
        }
    }
    toJSON() {
        const e = super.toJSON()
          , t = this.parameters.shapes
          , r = this.parameters.options;
        return w4(t, r, e)
    }
    static fromJSON(e, t) {
        const r = [];
        for (let s = 0, o = e.shapes.length; s < o; s++) {
            const a = t[e.shapes[s]];
            r.push(a)
        }
        const i = e.options.extrudePath;
        return i !== void 0 && (e.options.extrudePath = new aM[i.type]().fromJSON(i)),
        new Xm(r,e.options)
    }
}
const x4 = {
    generateTopUV: function(n, e, t, r, i) {
        const s = e[t * 3]
          , o = e[t * 3 + 1]
          , a = e[r * 3]
          , l = e[r * 3 + 1]
          , f = e[i * 3]
          , h = e[i * 3 + 1];
        return [new it(s,o), new it(a,l), new it(f,h)]
    },
    generateSideWallUV: function(n, e, t, r, i, s) {
        const o = e[t * 3]
          , a = e[t * 3 + 1]
          , l = e[t * 3 + 2]
          , f = e[r * 3]
          , h = e[r * 3 + 1]
          , d = e[r * 3 + 2]
          , p = e[i * 3]
          , m = e[i * 3 + 1]
          , _ = e[i * 3 + 2]
          , y = e[s * 3]
          , x = e[s * 3 + 1]
          , S = e[s * 3 + 2];
        return Math.abs(a - h) < Math.abs(o - f) ? [new it(o,1 - l), new it(f,1 - d), new it(p,1 - _), new it(y,1 - S)] : [new it(a,1 - l), new it(h,1 - d), new it(m,1 - _), new it(x,1 - S)]
    }
};
function w4(n, e, t) {
    if (t.shapes = [],
    Array.isArray(n))
        for (let r = 0, i = n.length; r < i; r++) {
            const s = n[r];
            t.shapes.push(s.uuid)
        }
    else
        t.shapes.push(n.uuid);
    return t.options = Object.assign({}, e),
    e.extrudePath !== void 0 && (t.options.extrudePath = e.extrudePath.toJSON()),
    t
}
class Ih extends Bu {
    constructor(e=1, t=0) {
        const r = (1 + Math.sqrt(5)) / 2
          , i = [-1, r, 0, 1, r, 0, -1, -r, 0, 1, -r, 0, 0, -1, r, 0, 1, r, 0, -1, -r, 0, 1, -r, r, 0, -1, r, 0, 1, -r, 0, -1, -r, 0, 1]
          , s = [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1];
        super(i, s, e, t),
        this.type = "IcosahedronGeometry",
        this.parameters = {
            radius: e,
            detail: t
        }
    }
    static fromJSON(e) {
        return new Ih(e.radius,e.detail)
    }
}
class Lh extends Bu {
    constructor(e=1, t=0) {
        const r = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1]
          , i = [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2];
        super(r, i, e, t),
        this.type = "OctahedronGeometry",
        this.parameters = {
            radius: e,
            detail: t
        }
    }
    static fromJSON(e) {
        return new Lh(e.radius,e.detail)
    }
}
class Jm extends On {
    constructor(e=.5, t=1, r=32, i=1, s=0, o=Math.PI * 2) {
        super(),
        this.type = "RingGeometry",
        this.parameters = {
            innerRadius: e,
            outerRadius: t,
            thetaSegments: r,
            phiSegments: i,
            thetaStart: s,
            thetaLength: o
        },
        r = Math.max(3, r),
        i = Math.max(1, i);
        const a = []
          , l = []
          , f = []
          , h = [];
        let d = e;
        const p = (t - e) / i
          , m = new $
          , _ = new it;
        for (let y = 0; y <= i; y++) {
            for (let x = 0; x <= r; x++) {
                const S = s + x / r * o;
                m.x = d * Math.cos(S),
                m.y = d * Math.sin(S),
                l.push(m.x, m.y, m.z),
                f.push(0, 0, 1),
                _.x = (m.x / t + 1) / 2,
                _.y = (m.y / t + 1) / 2,
                h.push(_.x, _.y)
            }
            d += p
        }
        for (let y = 0; y < i; y++) {
            const x = y * (r + 1);
            for (let S = 0; S < r; S++) {
                const M = S + x
                  , w = M
                  , T = M + r + 1
                  , P = M + r + 2
                  , I = M + 1;
                a.push(w, T, I),
                a.push(T, P, I)
            }
        }
        this.setIndex(a),
        this.setAttribute("position", new nn(l,3)),
        this.setAttribute("normal", new nn(f,3)),
        this.setAttribute("uv", new nn(h,2))
    }
    static fromJSON(e) {
        return new Jm(e.innerRadius,e.outerRadius,e.thetaSegments,e.phiSegments,e.thetaStart,e.thetaLength)
    }
}
class jm extends On {
    constructor(e=new Bf([new it(0,.5), new it(-.5,-.5), new it(.5,-.5)]), t=12) {
        super(),
        this.type = "ShapeGeometry",
        this.parameters = {
            shapes: e,
            curveSegments: t
        };
        const r = []
          , i = []
          , s = []
          , o = [];
        let a = 0
          , l = 0;
        if (Array.isArray(e) === !1)
            f(e);
        else
            for (let h = 0; h < e.length; h++)
                f(e[h]),
                this.addGroup(a, l, h),
                a += l,
                l = 0;
        this.setIndex(r),
        this.setAttribute("position", new nn(i,3)),
        this.setAttribute("normal", new nn(s,3)),
        this.setAttribute("uv", new nn(o,2));
        function f(h) {
            const d = i.length / 3
              , p = h.extractPoints(t);
            let m = p.shape;
            const _ = p.holes;
            Jl.isClockWise(m) === !1 && (m = m.reverse());
            for (let x = 0, S = _.length; x < S; x++) {
                const M = _[x];
                Jl.isClockWise(M) === !0 && (_[x] = M.reverse())
            }
            const y = Jl.triangulateShape(m, _);
            for (let x = 0, S = _.length; x < S; x++) {
                const M = _[x];
                m = m.concat(M)
            }
            for (let x = 0, S = m.length; x < S; x++) {
                const M = m[x];
                i.push(M.x, M.y, 0),
                s.push(0, 0, 1),
                o.push(M.x, M.y)
            }
            for (let x = 0, S = y.length; x < S; x++) {
                const M = y[x]
                  , w = M[0] + d
                  , T = M[1] + d
                  , P = M[2] + d;
                r.push(w, T, P),
                l += 3
            }
        }
    }
    toJSON() {
        const e = super.toJSON()
          , t = this.parameters.shapes;
        return S4(t, e)
    }
    static fromJSON(e, t) {
        const r = [];
        for (let i = 0, s = e.shapes.length; i < s; i++) {
            const o = t[e.shapes[i]];
            r.push(o)
        }
        return new jm(r,e.curveSegments)
    }
}
function S4(n, e) {
    if (e.shapes = [],
    Array.isArray(n))
        for (let t = 0, r = n.length; t < r; t++) {
            const i = n[t];
            e.shapes.push(i.uuid)
        }
    else
        e.shapes.push(n.uuid);
    return e
}
class Fh extends On {
    constructor(e=1, t=32, r=16, i=0, s=Math.PI * 2, o=0, a=Math.PI) {
        super(),
        this.type = "SphereGeometry",
        this.parameters = {
            radius: e,
            widthSegments: t,
            heightSegments: r,
            phiStart: i,
            phiLength: s,
            thetaStart: o,
            thetaLength: a
        },
        t = Math.max(3, Math.floor(t)),
        r = Math.max(2, Math.floor(r));
        const l = Math.min(o + a, Math.PI);
        let f = 0;
        const h = []
          , d = new $
          , p = new $
          , m = []
          , _ = []
          , y = []
          , x = [];
        for (let S = 0; S <= r; S++) {
            const M = []
              , w = S / r;
            let T = 0;
            S == 0 && o == 0 ? T = .5 / t : S == r && l == Math.PI && (T = -.5 / t);
            for (let P = 0; P <= t; P++) {
                const I = P / t;
                d.x = -e * Math.cos(i + I * s) * Math.sin(o + w * a),
                d.y = e * Math.cos(o + w * a),
                d.z = e * Math.sin(i + I * s) * Math.sin(o + w * a),
                _.push(d.x, d.y, d.z),
                p.copy(d).normalize(),
                y.push(p.x, p.y, p.z),
                x.push(I + T, 1 - w),
                M.push(f++)
            }
            h.push(M)
        }
        for (let S = 0; S < r; S++)
            for (let M = 0; M < t; M++) {
                const w = h[S][M + 1]
                  , T = h[S][M]
                  , P = h[S + 1][M]
                  , I = h[S + 1][M + 1];
                (S !== 0 || o > 0) && m.push(w, T, I),
                (S !== r - 1 || l < Math.PI) && m.push(T, P, I)
            }
        this.setIndex(m),
        this.setAttribute("position", new nn(_,3)),
        this.setAttribute("normal", new nn(y,3)),
        this.setAttribute("uv", new nn(x,2))
    }
    static fromJSON(e) {
        return new Fh(e.radius,e.widthSegments,e.heightSegments,e.phiStart,e.phiLength,e.thetaStart,e.thetaLength)
    }
}
class Ym extends Bu {
    constructor(e=1, t=0) {
        const r = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1]
          , i = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1];
        super(r, i, e, t),
        this.type = "TetrahedronGeometry",
        this.parameters = {
            radius: e,
            detail: t
        }
    }
    static fromJSON(e) {
        return new Ym(e.radius,e.detail)
    }
}
class Km extends On {
    constructor(e=1, t=.4, r=12, i=48, s=Math.PI * 2) {
        super(),
        this.type = "TorusGeometry",
        this.parameters = {
            radius: e,
            tube: t,
            radialSegments: r,
            tubularSegments: i,
            arc: s
        },
        r = Math.floor(r),
        i = Math.floor(i);
        const o = []
          , a = []
          , l = []
          , f = []
          , h = new $
          , d = new $
          , p = new $;
        for (let m = 0; m <= r; m++)
            for (let _ = 0; _ <= i; _++) {
                const y = _ / i * s
                  , x = m / r * Math.PI * 2;
                d.x = (e + t * Math.cos(x)) * Math.cos(y),
                d.y = (e + t * Math.cos(x)) * Math.sin(y),
                d.z = t * Math.sin(x),
                a.push(d.x, d.y, d.z),
                h.x = e * Math.cos(y),
                h.y = e * Math.sin(y),
                p.subVectors(d, h).normalize(),
                l.push(p.x, p.y, p.z),
                f.push(_ / i),
                f.push(m / r)
            }
        for (let m = 1; m <= r; m++)
            for (let _ = 1; _ <= i; _++) {
                const y = (i + 1) * m + _ - 1
                  , x = (i + 1) * (m - 1) + _ - 1
                  , S = (i + 1) * (m - 1) + _
                  , M = (i + 1) * m + _;
                o.push(y, x, M),
                o.push(x, S, M)
            }
        this.setIndex(o),
        this.setAttribute("position", new nn(a,3)),
        this.setAttribute("normal", new nn(l,3)),
        this.setAttribute("uv", new nn(f,2))
    }
    static fromJSON(e) {
        return new Km(e.radius,e.tube,e.radialSegments,e.tubularSegments,e.arc)
    }
}
class qm extends On {
    constructor(e=1, t=.4, r=64, i=8, s=2, o=3) {
        super(),
        this.type = "TorusKnotGeometry",
        this.parameters = {
            radius: e,
            tube: t,
            tubularSegments: r,
            radialSegments: i,
            p: s,
            q: o
        },
        r = Math.floor(r),
        i = Math.floor(i);
        const a = []
          , l = []
          , f = []
          , h = []
          , d = new $
          , p = new $
          , m = new $
          , _ = new $
          , y = new $
          , x = new $
          , S = new $;
        for (let w = 0; w <= r; ++w) {
            const T = w / r * s * Math.PI * 2;
            M(T, s, o, e, m),
            M(T + .01, s, o, e, _),
            x.subVectors(_, m),
            S.addVectors(_, m),
            y.crossVectors(x, S),
            S.crossVectors(y, x),
            y.normalize(),
            S.normalize();
            for (let P = 0; P <= i; ++P) {
                const I = P / i * Math.PI * 2
                  , k = -t * Math.cos(I)
                  , R = t * Math.sin(I);
                d.x = m.x + (k * S.x + R * y.x),
                d.y = m.y + (k * S.y + R * y.y),
                d.z = m.z + (k * S.z + R * y.z),
                l.push(d.x, d.y, d.z),
                p.subVectors(d, m).normalize(),
                f.push(p.x, p.y, p.z),
                h.push(w / r),
                h.push(P / i)
            }
        }
        for (let w = 1; w <= r; w++)
            for (let T = 1; T <= i; T++) {
                const P = (i + 1) * (w - 1) + (T - 1)
                  , I = (i + 1) * w + (T - 1)
                  , k = (i + 1) * w + T
                  , R = (i + 1) * (w - 1) + T;
                a.push(P, I, R),
                a.push(I, k, R)
            }
        this.setIndex(a),
        this.setAttribute("position", new nn(l,3)),
        this.setAttribute("normal", new nn(f,3)),
        this.setAttribute("uv", new nn(h,2));
        function M(w, T, P, I, k) {
            const R = Math.cos(w)
              , O = Math.sin(w)
              , H = P / T * w
              , W = Math.cos(H);
            k.x = I * (2 + W) * .5 * R,
            k.y = I * (2 + W) * O * .5,
            k.z = I * Math.sin(H) * .5
        }
    }
    static fromJSON(e) {
        return new qm(e.radius,e.tube,e.tubularSegments,e.radialSegments,e.p,e.q)
    }
}
class Qm extends On {
    constructor(e=new sM(new $(-1,-1,0),new $(-1,1,0),new $(1,1,0)), t=64, r=1, i=8, s=!1) {
        super(),
        this.type = "TubeGeometry",
        this.parameters = {
            path: e,
            tubularSegments: t,
            radius: r,
            radialSegments: i,
            closed: s
        };
        const o = e.computeFrenetFrames(t, s);
        this.tangents = o.tangents,
        this.normals = o.normals,
        this.binormals = o.binormals;
        const a = new $
          , l = new $
          , f = new it;
        let h = new $;
        const d = []
          , p = []
          , m = []
          , _ = [];
        y(),
        this.setIndex(_),
        this.setAttribute("position", new nn(d,3)),
        this.setAttribute("normal", new nn(p,3)),
        this.setAttribute("uv", new nn(m,2));
        function y() {
            for (let w = 0; w < t; w++)
                x(w);
            x(s === !1 ? t : 0),
            M(),
            S()
        }
        function x(w) {
            h = e.getPointAt(w / t, h);
            const T = o.normals[w]
              , P = o.binormals[w];
            for (let I = 0; I <= i; I++) {
                const k = I / i * Math.PI * 2
                  , R = Math.sin(k)
                  , O = -Math.cos(k);
                l.x = O * T.x + R * P.x,
                l.y = O * T.y + R * P.y,
                l.z = O * T.z + R * P.z,
                l.normalize(),
                p.push(l.x, l.y, l.z),
                a.x = h.x + r * l.x,
                a.y = h.y + r * l.y,
                a.z = h.z + r * l.z,
                d.push(a.x, a.y, a.z)
            }
        }
        function S() {
            for (let w = 1; w <= t; w++)
                for (let T = 1; T <= i; T++) {
                    const P = (i + 1) * (w - 1) + (T - 1)
                      , I = (i + 1) * w + (T - 1)
                      , k = (i + 1) * w + T
                      , R = (i + 1) * (w - 1) + T;
                    _.push(P, I, R),
                    _.push(I, k, R)
                }
        }
        function M() {
            for (let w = 0; w <= t; w++)
                for (let T = 0; T <= i; T++)
                    f.x = w / t,
                    f.y = T / i,
                    m.push(f.x, f.y)
        }
    }
    toJSON() {
        const e = super.toJSON();
        return e.path = this.parameters.path.toJSON(),
        e
    }
    static fromJSON(e) {
        return new Qm(new aM[e.path.type]().fromJSON(e.path),e.tubularSegments,e.radius,e.radialSegments,e.closed)
    }
}
class M3 extends On {
    constructor(e=null) {
        if (super(),
        this.type = "WireframeGeometry",
        this.parameters = {
            geometry: e
        },
        e !== null) {
            const t = []
              , r = new Set
              , i = new $
              , s = new $;
            if (e.index !== null) {
                const o = e.attributes.position
                  , a = e.index;
                let l = e.groups;
                l.length === 0 && (l = [{
                    start: 0,
                    count: a.count,
                    materialIndex: 0
                }]);
                for (let f = 0, h = l.length; f < h; ++f) {
                    const d = l[f]
                      , p = d.start
                      , m = d.count;
                    for (let _ = p, y = p + m; _ < y; _ += 3)
                        for (let x = 0; x < 3; x++) {
                            const S = a.getX(_ + x)
                              , M = a.getX(_ + (x + 1) % 3);
                            i.fromBufferAttribute(o, S),
                            s.fromBufferAttribute(o, M),
                            wE(i, s, r) === !0 && (t.push(i.x, i.y, i.z),
                            t.push(s.x, s.y, s.z))
                        }
                }
            } else {
                const o = e.attributes.position;
                for (let a = 0, l = o.count / 3; a < l; a++)
                    for (let f = 0; f < 3; f++) {
                        const h = 3 * a + f
                          , d = 3 * a + (f + 1) % 3;
                        i.fromBufferAttribute(o, h),
                        s.fromBufferAttribute(o, d),
                        wE(i, s, r) === !0 && (t.push(i.x, i.y, i.z),
                        t.push(s.x, s.y, s.z))
                    }
            }
            this.setAttribute("position", new nn(t,3))
        }
    }
}
function wE(n, e, t) {
    const r = `${n.x},${n.y},${n.z}-${e.x},${e.y},${e.z}`
      , i = `${e.x},${e.y},${e.z}-${n.x},${n.y},${n.z}`;
    return t.has(r) === !0 || t.has(i) === !0 ? !1 : (t.add(r),
    t.add(i),
    !0)
}
var SE = Object.freeze({
    __proto__: null,
    BoxGeometry: Nc,
    CapsuleGeometry: Um,
    CircleGeometry: Hm,
    ConeGeometry: Vm,
    CylinderGeometry: Zf,
    DodecahedronGeometry: Wm,
    EdgesGeometry: y3,
    ExtrudeGeometry: Xm,
    IcosahedronGeometry: Ih,
    LatheGeometry: Bh,
    OctahedronGeometry: Lh,
    PlaneGeometry: Ph,
    PolyhedronGeometry: Bu,
    RingGeometry: Jm,
    ShapeGeometry: jm,
    SphereGeometry: Fh,
    TetrahedronGeometry: Ym,
    TorusGeometry: Km,
    TorusKnotGeometry: qm,
    TubeGeometry: Qm,
    WireframeGeometry: M3
});
class A3 extends as {
    constructor(e) {
        super(),
        this.isShadowMaterial = !0,
        this.type = "ShadowMaterial",
        this.color = new It(0),
        this.transparent = !0,
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.color.copy(e.color),
        this.fog = e.fog,
        this
    }
}
class C3 extends el {
    constructor(e) {
        super(e),
        this.isRawShaderMaterial = !0,
        this.type = "RawShaderMaterial"
    }
}
class kh extends as {
    constructor(e) {
        super(),
        this.isMeshStandardMaterial = !0,
        this.defines = {
            STANDARD: ""
        },
        this.type = "MeshStandardMaterial",
        this.color = new It(16777215),
        this.roughness = 1,
        this.metalness = 0,
        this.map = null,
        this.lightMap = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.emissive = new It(0),
        this.emissiveIntensity = 1,
        this.emissiveMap = null,
        this.bumpMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalMapType = Ru,
        this.normalScale = new it(1,1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.roughnessMap = null,
        this.metalnessMap = null,
        this.alphaMap = null,
        this.envMap = null,
        this.envMapIntensity = 1,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinecap = "round",
        this.wireframeLinejoin = "round",
        this.flatShading = !1,
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.defines = {
            STANDARD: ""
        },
        this.color.copy(e.color),
        this.roughness = e.roughness,
        this.metalness = e.metalness,
        this.map = e.map,
        this.lightMap = e.lightMap,
        this.lightMapIntensity = e.lightMapIntensity,
        this.aoMap = e.aoMap,
        this.aoMapIntensity = e.aoMapIntensity,
        this.emissive.copy(e.emissive),
        this.emissiveMap = e.emissiveMap,
        this.emissiveIntensity = e.emissiveIntensity,
        this.bumpMap = e.bumpMap,
        this.bumpScale = e.bumpScale,
        this.normalMap = e.normalMap,
        this.normalMapType = e.normalMapType,
        this.normalScale.copy(e.normalScale),
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this.roughnessMap = e.roughnessMap,
        this.metalnessMap = e.metalnessMap,
        this.alphaMap = e.alphaMap,
        this.envMap = e.envMap,
        this.envMapIntensity = e.envMapIntensity,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.wireframeLinecap = e.wireframeLinecap,
        this.wireframeLinejoin = e.wireframeLinejoin,
        this.flatShading = e.flatShading,
        this.fog = e.fog,
        this
    }
}
class Ql extends kh {
    constructor(e) {
        super(),
        this.isMeshPhysicalMaterial = !0,
        this.defines = {
            STANDARD: "",
            PHYSICAL: ""
        },
        this.type = "MeshPhysicalMaterial",
        this.clearcoatMap = null,
        this.clearcoatRoughness = 0,
        this.clearcoatRoughnessMap = null,
        this.clearcoatNormalScale = new it(1,1),
        this.clearcoatNormalMap = null,
        this.ior = 1.5,
        Object.defineProperty(this, "reflectivity", {
            get: function() {
                return $i(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1)
            },
            set: function(t) {
                this.ior = (1 + .4 * t) / (1 - .4 * t)
            }
        }),
        this.iridescenceMap = null,
        this.iridescenceIOR = 1.3,
        this.iridescenceThicknessRange = [100, 400],
        this.iridescenceThicknessMap = null,
        this.sheenColor = new It(0),
        this.sheenColorMap = null,
        this.sheenRoughness = 1,
        this.sheenRoughnessMap = null,
        this.transmissionMap = null,
        this.thickness = 0,
        this.thicknessMap = null,
        this.attenuationDistance = 1 / 0,
        this.attenuationColor = new It(1,1,1),
        this.specularIntensity = 1,
        this.specularIntensityMap = null,
        this.specularColor = new It(1,1,1),
        this.specularColorMap = null,
        this._sheen = 0,
        this._clearcoat = 0,
        this._iridescence = 0,
        this._transmission = 0,
        this.setValues(e)
    }
    get sheen() {
        return this._sheen
    }
    set sheen(e) {
        this._sheen > 0 != e > 0 && this.version++,
        this._sheen = e
    }
    get clearcoat() {
        return this._clearcoat
    }
    set clearcoat(e) {
        this._clearcoat > 0 != e > 0 && this.version++,
        this._clearcoat = e
    }
    get iridescence() {
        return this._iridescence
    }
    set iridescence(e) {
        this._iridescence > 0 != e > 0 && this.version++,
        this._iridescence = e
    }
    get transmission() {
        return this._transmission
    }
    set transmission(e) {
        this._transmission > 0 != e > 0 && this.version++,
        this._transmission = e
    }
    copy(e) {
        return super.copy(e),
        this.defines = {
            STANDARD: "",
            PHYSICAL: ""
        },
        this.clearcoat = e.clearcoat,
        this.clearcoatMap = e.clearcoatMap,
        this.clearcoatRoughness = e.clearcoatRoughness,
        this.clearcoatRoughnessMap = e.clearcoatRoughnessMap,
        this.clearcoatNormalMap = e.clearcoatNormalMap,
        this.clearcoatNormalScale.copy(e.clearcoatNormalScale),
        this.ior = e.ior,
        this.iridescence = e.iridescence,
        this.iridescenceMap = e.iridescenceMap,
        this.iridescenceIOR = e.iridescenceIOR,
        this.iridescenceThicknessRange = [...e.iridescenceThicknessRange],
        this.iridescenceThicknessMap = e.iridescenceThicknessMap,
        this.sheen = e.sheen,
        this.sheenColor.copy(e.sheenColor),
        this.sheenColorMap = e.sheenColorMap,
        this.sheenRoughness = e.sheenRoughness,
        this.sheenRoughnessMap = e.sheenRoughnessMap,
        this.transmission = e.transmission,
        this.transmissionMap = e.transmissionMap,
        this.thickness = e.thickness,
        this.thicknessMap = e.thicknessMap,
        this.attenuationDistance = e.attenuationDistance,
        this.attenuationColor.copy(e.attenuationColor),
        this.specularIntensity = e.specularIntensity,
        this.specularIntensityMap = e.specularIntensityMap,
        this.specularColor.copy(e.specularColor),
        this.specularColorMap = e.specularColorMap,
        this
    }
}
class E3 extends as {
    constructor(e) {
        super(),
        this.isMeshPhongMaterial = !0,
        this.type = "MeshPhongMaterial",
        this.color = new It(16777215),
        this.specular = new It(1118481),
        this.shininess = 30,
        this.map = null,
        this.lightMap = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.emissive = new It(0),
        this.emissiveIntensity = 1,
        this.emissiveMap = null,
        this.bumpMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalMapType = Ru,
        this.normalScale = new it(1,1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.specularMap = null,
        this.alphaMap = null,
        this.envMap = null,
        this.combine = Lm,
        this.reflectivity = 1,
        this.refractionRatio = .98,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinecap = "round",
        this.wireframeLinejoin = "round",
        this.flatShading = !1,
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.color.copy(e.color),
        this.specular.copy(e.specular),
        this.shininess = e.shininess,
        this.map = e.map,
        this.lightMap = e.lightMap,
        this.lightMapIntensity = e.lightMapIntensity,
        this.aoMap = e.aoMap,
        this.aoMapIntensity = e.aoMapIntensity,
        this.emissive.copy(e.emissive),
        this.emissiveMap = e.emissiveMap,
        this.emissiveIntensity = e.emissiveIntensity,
        this.bumpMap = e.bumpMap,
        this.bumpScale = e.bumpScale,
        this.normalMap = e.normalMap,
        this.normalMapType = e.normalMapType,
        this.normalScale.copy(e.normalScale),
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this.specularMap = e.specularMap,
        this.alphaMap = e.alphaMap,
        this.envMap = e.envMap,
        this.combine = e.combine,
        this.reflectivity = e.reflectivity,
        this.refractionRatio = e.refractionRatio,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.wireframeLinecap = e.wireframeLinecap,
        this.wireframeLinejoin = e.wireframeLinejoin,
        this.flatShading = e.flatShading,
        this.fog = e.fog,
        this
    }
}
class b3 extends as {
    constructor(e) {
        super(),
        this.isMeshToonMaterial = !0,
        this.defines = {
            TOON: ""
        },
        this.type = "MeshToonMaterial",
        this.color = new It(16777215),
        this.map = null,
        this.gradientMap = null,
        this.lightMap = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.emissive = new It(0),
        this.emissiveIntensity = 1,
        this.emissiveMap = null,
        this.bumpMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalMapType = Ru,
        this.normalScale = new it(1,1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.alphaMap = null,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinecap = "round",
        this.wireframeLinejoin = "round",
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.color.copy(e.color),
        this.map = e.map,
        this.gradientMap = e.gradientMap,
        this.lightMap = e.lightMap,
        this.lightMapIntensity = e.lightMapIntensity,
        this.aoMap = e.aoMap,
        this.aoMapIntensity = e.aoMapIntensity,
        this.emissive.copy(e.emissive),
        this.emissiveMap = e.emissiveMap,
        this.emissiveIntensity = e.emissiveIntensity,
        this.bumpMap = e.bumpMap,
        this.bumpScale = e.bumpScale,
        this.normalMap = e.normalMap,
        this.normalMapType = e.normalMapType,
        this.normalScale.copy(e.normalScale),
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this.alphaMap = e.alphaMap,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.wireframeLinecap = e.wireframeLinecap,
        this.wireframeLinejoin = e.wireframeLinejoin,
        this.fog = e.fog,
        this
    }
}
class T3 extends as {
    constructor(e) {
        super(),
        this.isMeshNormalMaterial = !0,
        this.type = "MeshNormalMaterial",
        this.bumpMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalMapType = Ru,
        this.normalScale = new it(1,1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.flatShading = !1,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.bumpMap = e.bumpMap,
        this.bumpScale = e.bumpScale,
        this.normalMap = e.normalMap,
        this.normalMapType = e.normalMapType,
        this.normalScale.copy(e.normalScale),
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.flatShading = e.flatShading,
        this
    }
}
class D3 extends as {
    constructor(e) {
        super(),
        this.isMeshLambertMaterial = !0,
        this.type = "MeshLambertMaterial",
        this.color = new It(16777215),
        this.map = null,
        this.lightMap = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.emissive = new It(0),
        this.emissiveIntensity = 1,
        this.emissiveMap = null,
        this.bumpMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalMapType = Ru,
        this.normalScale = new it(1,1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.specularMap = null,
        this.alphaMap = null,
        this.envMap = null,
        this.combine = Lm,
        this.reflectivity = 1,
        this.refractionRatio = .98,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinecap = "round",
        this.wireframeLinejoin = "round",
        this.flatShading = !1,
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.color.copy(e.color),
        this.map = e.map,
        this.lightMap = e.lightMap,
        this.lightMapIntensity = e.lightMapIntensity,
        this.aoMap = e.aoMap,
        this.aoMapIntensity = e.aoMapIntensity,
        this.emissive.copy(e.emissive),
        this.emissiveMap = e.emissiveMap,
        this.emissiveIntensity = e.emissiveIntensity,
        this.bumpMap = e.bumpMap,
        this.bumpScale = e.bumpScale,
        this.normalMap = e.normalMap,
        this.normalMapType = e.normalMapType,
        this.normalScale.copy(e.normalScale),
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this.specularMap = e.specularMap,
        this.alphaMap = e.alphaMap,
        this.envMap = e.envMap,
        this.combine = e.combine,
        this.reflectivity = e.reflectivity,
        this.refractionRatio = e.refractionRatio,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.wireframeLinecap = e.wireframeLinecap,
        this.wireframeLinejoin = e.wireframeLinejoin,
        this.flatShading = e.flatShading,
        this.fog = e.fog,
        this
    }
}
class P3 extends as {
    constructor(e) {
        super(),
        this.isMeshMatcapMaterial = !0,
        this.defines = {
            MATCAP: ""
        },
        this.type = "MeshMatcapMaterial",
        this.color = new It(16777215),
        this.matcap = null,
        this.map = null,
        this.bumpMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalMapType = Ru,
        this.normalScale = new it(1,1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.alphaMap = null,
        this.flatShading = !1,
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.defines = {
            MATCAP: ""
        },
        this.color.copy(e.color),
        this.matcap = e.matcap,
        this.map = e.map,
        this.bumpMap = e.bumpMap,
        this.bumpScale = e.bumpScale,
        this.normalMap = e.normalMap,
        this.normalMapType = e.normalMapType,
        this.normalScale.copy(e.normalScale),
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this.alphaMap = e.alphaMap,
        this.flatShading = e.flatShading,
        this.fog = e.fog,
        this
    }
}
class R3 extends lo {
    constructor(e) {
        super(),
        this.isLineDashedMaterial = !0,
        this.type = "LineDashedMaterial",
        this.scale = 1,
        this.dashSize = 3,
        this.gapSize = 1,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.scale = e.scale,
        this.dashSize = e.dashSize,
        this.gapSize = e.gapSize,
        this
    }
}
function Ga(n, e, t) {
    return lM(n) ? new n.constructor(n.subarray(e, t !== void 0 ? t : n.length)) : n.slice(e, t)
}
function Mf(n, e, t) {
    return !n || !t && n.constructor === e ? n : typeof e.BYTES_PER_ELEMENT == "number" ? new e(n) : Array.prototype.slice.call(n)
}
function lM(n) {
    return ArrayBuffer.isView(n) && !(n instanceof DataView)
}
function B3(n) {
    function e(i, s) {
        return n[i] - n[s]
    }
    const t = n.length
      , r = new Array(t);
    for (let i = 0; i !== t; ++i)
        r[i] = i;
    return r.sort(e),
    r
}
function gw(n, e, t) {
    const r = n.length
      , i = new n.constructor(r);
    for (let s = 0, o = 0; o !== r; ++s) {
        const a = t[s] * e;
        for (let l = 0; l !== e; ++l)
            i[o++] = n[a + l]
    }
    return i
}
function uM(n, e, t, r) {
    let i = 1
      , s = n[0];
    for (; s !== void 0 && s[r] === void 0; )
        s = n[i++];
    if (s === void 0)
        return;
    let o = s[r];
    if (o !== void 0)
        if (Array.isArray(o))
            do
                o = s[r],
                o !== void 0 && (e.push(s.time),
                t.push.apply(t, o)),
                s = n[i++];
            while (s !== void 0);
        else if (o.toArray !== void 0)
            do
                o = s[r],
                o !== void 0 && (e.push(s.time),
                o.toArray(t, t.length)),
                s = n[i++];
            while (s !== void 0);
        else
            do
                o = s[r],
                o !== void 0 && (e.push(s.time),
                t.push(o)),
                s = n[i++];
            while (s !== void 0)
}
function M4(n, e, t, r, i=30) {
    const s = n.clone();
    s.name = e;
    const o = [];
    for (let l = 0; l < s.tracks.length; ++l) {
        const f = s.tracks[l]
          , h = f.getValueSize()
          , d = []
          , p = [];
        for (let m = 0; m < f.times.length; ++m) {
            const _ = f.times[m] * i;
            if (!(_ < t || _ >= r)) {
                d.push(f.times[m]);
                for (let y = 0; y < h; ++y)
                    p.push(f.values[m * h + y])
            }
        }
        d.length !== 0 && (f.times = Mf(d, f.times.constructor),
        f.values = Mf(p, f.values.constructor),
        o.push(f))
    }
    s.tracks = o;
    let a = 1 / 0;
    for (let l = 0; l < s.tracks.length; ++l)
        a > s.tracks[l].times[0] && (a = s.tracks[l].times[0]);
    for (let l = 0; l < s.tracks.length; ++l)
        s.tracks[l].shift(-1 * a);
    return s.resetDuration(),
    s
}
function A4(n, e=0, t=n, r=30) {
    r <= 0 && (r = 30);
    const i = t.tracks.length
      , s = e / r;
    for (let o = 0; o < i; ++o) {
        const a = t.tracks[o]
          , l = a.ValueTypeName;
        if (l === "bool" || l === "string")
            continue;
        const f = n.tracks.find(function(S) {
            return S.name === a.name && S.ValueTypeName === l
        });
        if (f === void 0)
            continue;
        let h = 0;
        const d = a.getValueSize();
        a.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (h = d / 3);
        let p = 0;
        const m = f.getValueSize();
        f.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (p = m / 3);
        const _ = a.times.length - 1;
        let y;
        if (s <= a.times[0]) {
            const S = h
              , M = d - h;
            y = Ga(a.values, S, M)
        } else if (s >= a.times[_]) {
            const S = _ * d + h
              , M = S + d - h;
            y = Ga(a.values, S, M)
        } else {
            const S = a.createInterpolant()
              , M = h
              , w = d - h;
            S.evaluate(s),
            y = Ga(S.resultBuffer, M, w)
        }
        l === "quaternion" && new Ws().fromArray(y).normalize().conjugate().toArray(y);
        const x = f.times.length;
        for (let S = 0; S < x; ++S) {
            const M = S * m + p;
            if (l === "quaternion")
                Ws.multiplyQuaternionsFlat(f.values, M, y, 0, f.values, M);
            else {
                const w = m - p * 2;
                for (let T = 0; T < w; ++T)
                    f.values[M + T] -= y[T]
            }
        }
    }
    return n.blendMode = OS,
    n
}
var C4 = Object.freeze({
    __proto__: null,
    arraySlice: Ga,
    convertArray: Mf,
    flattenJSON: uM,
    getKeyframeOrder: B3,
    isTypedArray: lM,
    makeClipAdditive: A4,
    sortedArray: gw,
    subclip: M4
});
class Oh {
    constructor(e, t, r, i) {
        this.parameterPositions = e,
        this._cachedIndex = 0,
        this.resultBuffer = i !== void 0 ? i : new t.constructor(r),
        this.sampleValues = t,
        this.valueSize = r,
        this.settings = null,
        this.DefaultSettings_ = {}
    }
    evaluate(e) {
        const t = this.parameterPositions;
        let r = this._cachedIndex
          , i = t[r]
          , s = t[r - 1];
        e: {
            t: {
                let o;
                n: {
                    r: if (!(e < i)) {
                        for (let a = r + 2; ; ) {
                            if (i === void 0) {
                                if (e < s)
                                    break r;
                                return r = t.length,
                                this._cachedIndex = r,
                                this.copySampleValue_(r - 1)
                            }
                            if (r === a)
                                break;
                            if (s = i,
                            i = t[++r],
                            e < i)
                                break t
                        }
                        o = t.length;
                        break n
                    }
                    if (!(e >= s)) {
                        const a = t[1];
                        e < a && (r = 2,
                        s = a);
                        for (let l = r - 2; ; ) {
                            if (s === void 0)
                                return this._cachedIndex = 0,
                                this.copySampleValue_(0);
                            if (r === l)
                                break;
                            if (i = s,
                            s = t[--r - 1],
                            e >= s)
                                break t
                        }
                        o = r,
                        r = 0;
                        break n
                    }
                    break e
                }
                for (; r < o; ) {
                    const a = r + o >>> 1;
                    e < t[a] ? o = a : r = a + 1
                }
                if (i = t[r],
                s = t[r - 1],
                s === void 0)
                    return this._cachedIndex = 0,
                    this.copySampleValue_(0);
                if (i === void 0)
                    return r = t.length,
                    this._cachedIndex = r,
                    this.copySampleValue_(r - 1)
            }
            this._cachedIndex = r,
            this.intervalChanged_(r, s, i)
        }
        return this.interpolate_(r, s, e, i)
    }
    getSettings_() {
        return this.settings || this.DefaultSettings_
    }
    copySampleValue_(e) {
        const t = this.resultBuffer
          , r = this.sampleValues
          , i = this.valueSize
          , s = e * i;
        for (let o = 0; o !== i; ++o)
            t[o] = r[s + o];
        return t
    }
    interpolate_() {
        throw new Error("call to abstract method")
    }
    intervalChanged_() {}
}
class I3 extends Oh {
    constructor(e, t, r, i) {
        super(e, t, r, i),
        this._weightPrev = -0,
        this._offsetPrev = -0,
        this._weightNext = -0,
        this._offsetNext = -0,
        this.DefaultSettings_ = {
            endingStart: xf,
            endingEnd: xf
        }
    }
    intervalChanged_(e, t, r) {
        const i = this.parameterPositions;
        let s = e - 2
          , o = e + 1
          , a = i[s]
          , l = i[o];
        if (a === void 0)
            switch (this.getSettings_().endingStart) {
            case wf:
                s = e,
                a = 2 * t - r;
                break;
            case mm:
                s = i.length - 2,
                a = t + i[s] - i[s + 1];
                break;
            default:
                s = e,
                a = r
            }
        if (l === void 0)
            switch (this.getSettings_().endingEnd) {
            case wf:
                o = e,
                l = 2 * r - t;
                break;
            case mm:
                o = 1,
                l = r + i[1] - i[0];
                break;
            default:
                o = e - 1,
                l = t
            }
        const f = (r - t) * .5
          , h = this.valueSize;
        this._weightPrev = f / (t - a),
        this._weightNext = f / (l - r),
        this._offsetPrev = s * h,
        this._offsetNext = o * h
    }
    interpolate_(e, t, r, i) {
        const s = this.resultBuffer
          , o = this.sampleValues
          , a = this.valueSize
          , l = e * a
          , f = l - a
          , h = this._offsetPrev
          , d = this._offsetNext
          , p = this._weightPrev
          , m = this._weightNext
          , _ = (r - t) / (i - t)
          , y = _ * _
          , x = y * _
          , S = -p * x + 2 * p * y - p * _
          , M = (1 + p) * x + (-1.5 - 2 * p) * y + (-.5 + p) * _ + 1
          , w = (-1 - m) * x + (1.5 + m) * y + .5 * _
          , T = m * x - m * y;
        for (let P = 0; P !== a; ++P)
            s[P] = S * o[h + P] + M * o[f + P] + w * o[l + P] + T * o[d + P];
        return s
    }
}
class cM extends Oh {
    constructor(e, t, r, i) {
        super(e, t, r, i)
    }
    interpolate_(e, t, r, i) {
        const s = this.resultBuffer
          , o = this.sampleValues
          , a = this.valueSize
          , l = e * a
          , f = l - a
          , h = (r - t) / (i - t)
          , d = 1 - h;
        for (let p = 0; p !== a; ++p)
            s[p] = o[f + p] * d + o[l + p] * h;
        return s
    }
}
class L3 extends Oh {
    constructor(e, t, r, i) {
        super(e, t, r, i)
    }
    interpolate_(e) {
        return this.copySampleValue_(e - 1)
    }
}
class Pl {
    constructor(e, t, r, i) {
        if (e === void 0)
            throw new Error("THREE.KeyframeTrack: track name is undefined");
        if (t === void 0 || t.length === 0)
            throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
        this.name = e,
        this.times = Mf(t, this.TimeBufferType),
        this.values = Mf(r, this.ValueBufferType),
        this.setInterpolation(i || this.DefaultInterpolation)
    }
    static toJSON(e) {
        const t = e.constructor;
        let r;
        if (t.toJSON !== this.toJSON)
            r = t.toJSON(e);
        else {
            r = {
                name: e.name,
                times: Mf(e.times, Array),
                values: Mf(e.values, Array)
            };
            const i = e.getInterpolation();
            i !== e.DefaultInterpolation && (r.interpolation = i)
        }
        return r.type = e.ValueTypeName,
        r
    }
    InterpolantFactoryMethodDiscrete(e) {
        return new L3(this.times,this.values,this.getValueSize(),e)
    }
    InterpolantFactoryMethodLinear(e) {
        return new cM(this.times,this.values,this.getValueSize(),e)
    }
    InterpolantFactoryMethodSmooth(e) {
        return new I3(this.times,this.values,this.getValueSize(),e)
    }
    setInterpolation(e) {
        let t;
        switch (e) {
        case vh:
            t = this.InterpolantFactoryMethodDiscrete;
            break;
        case Hf:
            t = this.InterpolantFactoryMethodLinear;
            break;
        case ov:
            t = this.InterpolantFactoryMethodSmooth;
            break
        }
        if (t === void 0) {
            const r = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
            if (this.createInterpolant === void 0)
                if (e !== this.DefaultInterpolation)
                    this.setInterpolation(this.DefaultInterpolation);
                else
                    throw new Error(r);
            return console.warn("THREE.KeyframeTrack:", r),
            this
        }
        return this.createInterpolant = t,
        this
    }
    getInterpolation() {
        switch (this.createInterpolant) {
        case this.InterpolantFactoryMethodDiscrete:
            return vh;
        case this.InterpolantFactoryMethodLinear:
            return Hf;
        case this.InterpolantFactoryMethodSmooth:
            return ov
        }
    }
    getValueSize() {
        return this.values.length / this.times.length
    }
    shift(e) {
        if (e !== 0) {
            const t = this.times;
            for (let r = 0, i = t.length; r !== i; ++r)
                t[r] += e
        }
        return this
    }
    scale(e) {
        if (e !== 1) {
            const t = this.times;
            for (let r = 0, i = t.length; r !== i; ++r)
                t[r] *= e
        }
        return this
    }
    trim(e, t) {
        const r = this.times
          , i = r.length;
        let s = 0
          , o = i - 1;
        for (; s !== i && r[s] < e; )
            ++s;
        for (; o !== -1 && r[o] > t; )
            --o;
        if (++o,
        s !== 0 || o !== i) {
            s >= o && (o = Math.max(o, 1),
            s = o - 1);
            const a = this.getValueSize();
            this.times = Ga(r, s, o),
            this.values = Ga(this.values, s * a, o * a)
        }
        return this
    }
    validate() {
        let e = !0;
        const t = this.getValueSize();
        t - Math.floor(t) !== 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this),
        e = !1);
        const r = this.times
          , i = this.values
          , s = r.length;
        s === 0 && (console.error("THREE.KeyframeTrack: Track is empty.", this),
        e = !1);
        let o = null;
        for (let a = 0; a !== s; a++) {
            const l = r[a];
            if (typeof l == "number" && isNaN(l)) {
                console.error("THREE.KeyframeTrack: Time is not a valid number.", this, a, l),
                e = !1;
                break
            }
            if (o !== null && o > l) {
                console.error("THREE.KeyframeTrack: Out of order keys.", this, a, l, o),
                e = !1;
                break
            }
            o = l
        }
        if (i !== void 0 && lM(i))
            for (let a = 0, l = i.length; a !== l; ++a) {
                const f = i[a];
                if (isNaN(f)) {
                    console.error("THREE.KeyframeTrack: Value is not a valid number.", this, a, f),
                    e = !1;
                    break
                }
            }
        return e
    }
    optimize() {
        const e = Ga(this.times)
          , t = Ga(this.values)
          , r = this.getValueSize()
          , i = this.getInterpolation() === ov
          , s = e.length - 1;
        let o = 1;
        for (let a = 1; a < s; ++a) {
            let l = !1;
            const f = e[a]
              , h = e[a + 1];
            if (f !== h && (a !== 1 || f !== e[0]))
                if (i)
                    l = !0;
                else {
                    const d = a * r
                      , p = d - r
                      , m = d + r;
                    for (let _ = 0; _ !== r; ++_) {
                        const y = t[d + _];
                        if (y !== t[p + _] || y !== t[m + _]) {
                            l = !0;
                            break
                        }
                    }
                }
            if (l) {
                if (a !== o) {
                    e[o] = e[a];
                    const d = a * r
                      , p = o * r;
                    for (let m = 0; m !== r; ++m)
                        t[p + m] = t[d + m]
                }
                ++o
            }
        }
        if (s > 0) {
            e[o] = e[s];
            for (let a = s * r, l = o * r, f = 0; f !== r; ++f)
                t[l + f] = t[a + f];
            ++o
        }
        return o !== e.length ? (this.times = Ga(e, 0, o),
        this.values = Ga(t, 0, o * r)) : (this.times = e,
        this.values = t),
        this
    }
    clone() {
        const e = Ga(this.times, 0)
          , t = Ga(this.values, 0)
          , r = this.constructor
          , i = new r(this.name,e,t);
        return i.createInterpolant = this.createInterpolant,
        i
    }
}
Pl.prototype.TimeBufferType = Float32Array;
Pl.prototype.ValueBufferType = Float32Array;
Pl.prototype.DefaultInterpolation = Hf;
class $f extends Pl {
}
$f.prototype.ValueTypeName = "bool";
$f.prototype.ValueBufferType = Array;
$f.prototype.DefaultInterpolation = vh;
$f.prototype.InterpolantFactoryMethodLinear = void 0;
$f.prototype.InterpolantFactoryMethodSmooth = void 0;
class fM extends Pl {
}
fM.prototype.ValueTypeName = "color";
class wh extends Pl {
}
wh.prototype.ValueTypeName = "number";
class F3 extends Oh {
    constructor(e, t, r, i) {
        super(e, t, r, i)
    }
    interpolate_(e, t, r, i) {
        const s = this.resultBuffer
          , o = this.sampleValues
          , a = this.valueSize
          , l = (r - t) / (i - t);
        let f = e * a;
        for (let h = f + a; f !== h; f += 4)
            Ws.slerpFlat(s, 0, o, f - a, o, f, l);
        return s
    }
}
class Pc extends Pl {
    InterpolantFactoryMethodLinear(e) {
        return new F3(this.times,this.values,this.getValueSize(),e)
    }
}
Pc.prototype.ValueTypeName = "quaternion";
Pc.prototype.DefaultInterpolation = Hf;
Pc.prototype.InterpolantFactoryMethodSmooth = void 0;
class ed extends Pl {
}
ed.prototype.ValueTypeName = "string";
ed.prototype.ValueBufferType = Array;
ed.prototype.DefaultInterpolation = vh;
ed.prototype.InterpolantFactoryMethodLinear = void 0;
ed.prototype.InterpolantFactoryMethodSmooth = void 0;
class Sh extends Pl {
}
Sh.prototype.ValueTypeName = "vector";
class Mh {
    constructor(e, t=-1, r, i=__) {
        this.name = e,
        this.tracks = r,
        this.duration = t,
        this.blendMode = i,
        this.uuid = Sa(),
        this.duration < 0 && this.resetDuration()
    }
    static parse(e) {
        const t = []
          , r = e.tracks
          , i = 1 / (e.fps || 1);
        for (let o = 0, a = r.length; o !== a; ++o)
            t.push(b4(r[o]).scale(i));
        const s = new this(e.name,e.duration,t,e.blendMode);
        return s.uuid = e.uuid,
        s
    }
    static toJSON(e) {
        const t = []
          , r = e.tracks
          , i = {
            name: e.name,
            duration: e.duration,
            tracks: t,
            uuid: e.uuid,
            blendMode: e.blendMode
        };
        for (let s = 0, o = r.length; s !== o; ++s)
            t.push(Pl.toJSON(r[s]));
        return i
    }
    static CreateFromMorphTargetSequence(e, t, r, i) {
        const s = t.length
          , o = [];
        for (let a = 0; a < s; a++) {
            let l = []
              , f = [];
            l.push((a + s - 1) % s, a, (a + 1) % s),
            f.push(0, 1, 0);
            const h = B3(l);
            l = gw(l, 1, h),
            f = gw(f, 1, h),
            !i && l[0] === 0 && (l.push(s),
            f.push(f[0])),
            o.push(new wh(".morphTargetInfluences[" + t[a].name + "]",l,f).scale(1 / r))
        }
        return new this(e,-1,o)
    }
    static findByName(e, t) {
        let r = e;
        if (!Array.isArray(e)) {
            const i = e;
            r = i.geometry && i.geometry.animations || i.animations
        }
        for (let i = 0; i < r.length; i++)
            if (r[i].name === t)
                return r[i];
        return null
    }
    static CreateClipsFromMorphTargetSequences(e, t, r) {
        const i = {}
          , s = /^([\w-]*?)([\d]+)$/;
        for (let a = 0, l = e.length; a < l; a++) {
            const f = e[a]
              , h = f.name.match(s);
            if (h && h.length > 1) {
                const d = h[1];
                let p = i[d];
                p || (i[d] = p = []),
                p.push(f)
            }
        }
        const o = [];
        for (const a in i)
            o.push(this.CreateFromMorphTargetSequence(a, i[a], t, r));
        return o
    }
    static parseAnimation(e, t) {
        if (!e)
            return console.error("THREE.AnimationClip: No animation in JSONLoader data."),
            null;
        const r = function(d, p, m, _, y) {
            if (m.length !== 0) {
                const x = []
                  , S = [];
                uM(m, x, S, _),
                x.length !== 0 && y.push(new d(p,x,S))
            }
        }
          , i = []
          , s = e.name || "default"
          , o = e.fps || 30
          , a = e.blendMode;
        let l = e.length || -1;
        const f = e.hierarchy || [];
        for (let d = 0; d < f.length; d++) {
            const p = f[d].keys;
            if (!(!p || p.length === 0))
                if (p[0].morphTargets) {
                    const m = {};
                    let _;
                    for (_ = 0; _ < p.length; _++)
                        if (p[_].morphTargets)
                            for (let y = 0; y < p[_].morphTargets.length; y++)
                                m[p[_].morphTargets[y]] = -1;
                    for (const y in m) {
                        const x = []
                          , S = [];
                        for (let M = 0; M !== p[_].morphTargets.length; ++M) {
                            const w = p[_];
                            x.push(w.time),
                            S.push(w.morphTarget === y ? 1 : 0)
                        }
                        i.push(new wh(".morphTargetInfluence[" + y + "]",x,S))
                    }
                    l = m.length * o
                } else {
                    const m = ".bones[" + t[d].name + "]";
                    r(Sh, m + ".position", p, "pos", i),
                    r(Pc, m + ".quaternion", p, "rot", i),
                    r(Sh, m + ".scale", p, "scl", i)
                }
        }
        return i.length === 0 ? null : new this(s,l,i,a)
    }
    resetDuration() {
        const e = this.tracks;
        let t = 0;
        for (let r = 0, i = e.length; r !== i; ++r) {
            const s = this.tracks[r];
            t = Math.max(t, s.times[s.times.length - 1])
        }
        return this.duration = t,
        this
    }
    trim() {
        for (let e = 0; e < this.tracks.length; e++)
            this.tracks[e].trim(0, this.duration);
        return this
    }
    validate() {
        let e = !0;
        for (let t = 0; t < this.tracks.length; t++)
            e = e && this.tracks[t].validate();
        return e
    }
    optimize() {
        for (let e = 0; e < this.tracks.length; e++)
            this.tracks[e].optimize();
        return this
    }
    clone() {
        const e = [];
        for (let t = 0; t < this.tracks.length; t++)
            e.push(this.tracks[t].clone());
        return new this.constructor(this.name,this.duration,e,this.blendMode)
    }
    toJSON() {
        return this.constructor.toJSON(this)
    }
}
function E4(n) {
    switch (n.toLowerCase()) {
    case "scalar":
    case "double":
    case "float":
    case "number":
    case "integer":
        return wh;
    case "vector":
    case "vector2":
    case "vector3":
    case "vector4":
        return Sh;
    case "color":
        return fM;
    case "quaternion":
        return Pc;
    case "bool":
    case "boolean":
        return $f;
    case "string":
        return ed
    }
    throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + n)
}
function b4(n) {
    if (n.type === void 0)
        throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
    const e = E4(n.type);
    if (n.times === void 0) {
        const t = []
          , r = [];
        uM(n.keys, t, r, "value"),
        n.times = t,
        n.values = r
    }
    return e.parse !== void 0 ? e.parse(n) : new e(n.name,n.times,n.values,n.interpolation)
}
const Wf = {
    enabled: !1,
    files: {},
    add: function(n, e) {
        this.enabled !== !1 && (this.files[n] = e)
    },
    get: function(n) {
        if (this.enabled !== !1)
            return this.files[n]
    },
    remove: function(n) {
        delete this.files[n]
    },
    clear: function() {
        this.files = {}
    }
};
class dM {
    constructor(e, t, r) {
        const i = this;
        let s = !1, o = 0, a = 0, l;
        const f = [];
        this.onStart = void 0,
        this.onLoad = e,
        this.onProgress = t,
        this.onError = r,
        this.itemStart = function(h) {
            a++,
            s === !1 && i.onStart !== void 0 && i.onStart(h, o, a),
            s = !0
        }
        ,
        this.itemEnd = function(h) {
            o++,
            i.onProgress !== void 0 && i.onProgress(h, o, a),
            o === a && (s = !1,
            i.onLoad !== void 0 && i.onLoad())
        }
        ,
        this.itemError = function(h) {
            i.onError !== void 0 && i.onError(h)
        }
        ,
        this.resolveURL = function(h) {
            return l ? l(h) : h
        }
        ,
        this.setURLModifier = function(h) {
            return l = h,
            this
        }
        ,
        this.addHandler = function(h, d) {
            return f.push(h, d),
            this
        }
        ,
        this.removeHandler = function(h) {
            const d = f.indexOf(h);
            return d !== -1 && f.splice(d, 2),
            this
        }
        ,
        this.getHandler = function(h) {
            for (let d = 0, p = f.length; d < p; d += 2) {
                const m = f[d]
                  , _ = f[d + 1];
                if (m.global && (m.lastIndex = 0),
                m.test(h))
                    return _
            }
            return null
        }
    }
}
const jd = new dM;
class Bo {
    constructor(e) {
        this.manager = e !== void 0 ? e : jd,
        this.crossOrigin = "anonymous",
        this.withCredentials = !1,
        this.path = "",
        this.resourcePath = "",
        this.requestHeader = {}
    }
    load() {}
    loadAsync(e, t) {
        const r = this;
        return new Promise(function(i, s) {
            r.load(e, i, t, s)
        }
        )
    }
    parse() {}
    setCrossOrigin(e) {
        return this.crossOrigin = e,
        this
    }
    setWithCredentials(e) {
        return this.withCredentials = e,
        this
    }
    setPath(e) {
        return this.path = e,
        this
    }
    setResourcePath(e) {
        return this.resourcePath = e,
        this
    }
    setRequestHeader(e) {
        return this.requestHeader = e,
        this
    }
}
const lu = {};
class T4 extends Error {
    constructor(e, t) {
        super(e),
        this.response = t
    }
}
class Aa extends Bo {
    constructor(e) {
        super(e)
    }
    load(e, t, r, i) {
        e === void 0 && (e = ""),
        this.path !== void 0 && (e = this.path + e),
        e = this.manager.resolveURL(e);
        const s = Wf.get(e);
        if (s !== void 0)
            return this.manager.itemStart(e),
            setTimeout(()=>{
                t && t(s),
                this.manager.itemEnd(e)
            }
            , 0),
            s;
        if (lu[e] !== void 0) {
            lu[e].push({
                onLoad: t,
                onProgress: r,
                onError: i
            });
            return
        }
        lu[e] = [],
        lu[e].push({
            onLoad: t,
            onProgress: r,
            onError: i
        });
        const o = new Request(e,{
            headers: new Headers(this.requestHeader),
            credentials: this.withCredentials ? "include" : "same-origin"
        })
          , a = this.mimeType
          , l = this.responseType;
        fetch(o).then(f=>{
            if (f.status === 200 || f.status === 0) {
                if (f.status === 0 && console.warn("THREE.FileLoader: HTTP Status 0 received."),
                typeof ReadableStream > "u" || f.body === void 0 || f.body.getReader === void 0)
                    return f;
                const h = lu[e]
                  , d = f.body.getReader()
                  , p = f.headers.get("Content-Length") || f.headers.get("X-File-Size")
                  , m = p ? parseInt(p) : 0
                  , _ = m !== 0;
                let y = 0;
                const x = new ReadableStream({
                    start(S) {
                        M();
                        function M() {
                            d.read().then(({done: w, value: T})=>{
                                if (w)
                                    S.close();
                                else {
                                    y += T.byteLength;
                                    const P = new ProgressEvent("progress",{
                                        lengthComputable: _,
                                        loaded: y,
                                        total: m
                                    });
                                    for (let I = 0, k = h.length; I < k; I++) {
                                        const R = h[I];
                                        R.onProgress && R.onProgress(P)
                                    }
                                    S.enqueue(T),
                                    M()
                                }
                            }
                            )
                        }
                    }
                });
                return new Response(x)
            } else
                throw new T4(`fetch for "${f.url}" responded with ${f.status}: ${f.statusText}`,f)
        }
        ).then(f=>{
            switch (l) {
            case "arraybuffer":
                return f.arrayBuffer();
            case "blob":
                return f.blob();
            case "document":
                return f.text().then(h=>new DOMParser().parseFromString(h, a));
            case "json":
                return f.json();
            default:
                if (a === void 0)
                    return f.text();
                {
                    const d = /charset="?([^;"\s]*)"?/i.exec(a)
                      , p = d && d[1] ? d[1].toLowerCase() : void 0
                      , m = new TextDecoder(p);
                    return f.arrayBuffer().then(_=>m.decode(_))
                }
            }
        }
        ).then(f=>{
            Wf.add(e, f);
            const h = lu[e];
            delete lu[e];
            for (let d = 0, p = h.length; d < p; d++) {
                const m = h[d];
                m.onLoad && m.onLoad(f)
            }
        }
        ).catch(f=>{
            const h = lu[e];
            if (h === void 0)
                throw this.manager.itemError(e),
                f;
            delete lu[e];
            for (let d = 0, p = h.length; d < p; d++) {
                const m = h[d];
                m.onError && m.onError(f)
            }
            this.manager.itemError(e)
        }
        ).finally(()=>{
            this.manager.itemEnd(e)
        }
        ),
        this.manager.itemStart(e)
    }
    setResponseType(e) {
        return this.responseType = e,
        this
    }
    setMimeType(e) {
        return this.mimeType = e,
        this
    }
}
class D4 extends Bo {
    constructor(e) {
        super(e)
    }
    load(e, t, r, i) {
        const s = this
          , o = new Aa(this.manager);
        o.setPath(this.path),
        o.setRequestHeader(this.requestHeader),
        o.setWithCredentials(this.withCredentials),
        o.load(e, function(a) {
            try {
                t(s.parse(JSON.parse(a)))
            } catch (l) {
                i ? i(l) : console.error(l),
                s.manager.itemError(e)
            }
        }, r, i)
    }
    parse(e) {
        const t = [];
        for (let r = 0; r < e.length; r++) {
            const i = Mh.parse(e[r]);
            t.push(i)
        }
        return t
    }
}
class P4 extends Bo {
    constructor(e) {
        super(e)
    }
    load(e, t, r, i) {
        const s = this
          , o = []
          , a = new tM
          , l = new Aa(this.manager);
        l.setPath(this.path),
        l.setResponseType("arraybuffer"),
        l.setRequestHeader(this.requestHeader),
        l.setWithCredentials(s.withCredentials);
        let f = 0;
        function h(d) {
            l.load(e[d], function(p) {
                const m = s.parse(p, !0);
                o[d] = {
                    width: m.width,
                    height: m.height,
                    format: m.format,
                    mipmaps: m.mipmaps
                },
                f += 1,
                f === 6 && (m.mipmapCount === 1 && (a.minFilter = si),
                a.image = o,
                a.format = m.format,
                a.needsUpdate = !0,
                t && t(a))
            }, r, i)
        }
        if (Array.isArray(e))
            for (let d = 0, p = e.length; d < p; ++d)
                h(d);
        else
            l.load(e, function(d) {
                const p = s.parse(d, !0);
                if (p.isCubemap) {
                    const m = p.mipmaps.length / p.mipmapCount;
                    for (let _ = 0; _ < m; _++) {
                        o[_] = {
                            mipmaps: []
                        };
                        for (let y = 0; y < p.mipmapCount; y++)
                            o[_].mipmaps.push(p.mipmaps[_ * p.mipmapCount + y]),
                            o[_].format = p.format,
                            o[_].width = p.width,
                            o[_].height = p.height
                    }
                    a.image = o
                } else
                    a.image.width = p.width,
                    a.image.height = p.height,
                    a.mipmaps = p.mipmaps;
                p.mipmapCount === 1 && (a.minFilter = si),
                a.format = p.format,
                a.needsUpdate = !0,
                t && t(a)
            }, r, i);
        return a
    }
}
class Mm extends Bo {
    constructor(e) {
        super(e)
    }
    load(e, t, r, i) {
        this.path !== void 0 && (e = this.path + e),
        e = this.manager.resolveURL(e);
        const s = this
          , o = Wf.get(e);
        if (o !== void 0)
            return s.manager.itemStart(e),
            setTimeout(function() {
                t && t(o),
                s.manager.itemEnd(e)
            }, 0),
            o;
        const a = _m("img");
        function l() {
            h(),
            Wf.add(e, this),
            t && t(this),
            s.manager.itemEnd(e)
        }
        function f(d) {
            h(),
            i && i(d),
            s.manager.itemError(e),
            s.manager.itemEnd(e)
        }
        function h() {
            a.removeEventListener("load", l, !1),
            a.removeEventListener("error", f, !1)
        }
        return a.addEventListener("load", l, !1),
        a.addEventListener("error", f, !1),
        e.slice(0, 5) !== "data:" && this.crossOrigin !== void 0 && (a.crossOrigin = this.crossOrigin),
        s.manager.itemStart(e),
        a.src = e,
        a
    }
}
class k3 extends Bo {
    constructor(e) {
        super(e)
    }
    load(e, t, r, i) {
        const s = new Nm
          , o = new Mm(this.manager);
        o.setCrossOrigin(this.crossOrigin),
        o.setPath(this.path);
        let a = 0;
        function l(f) {
            o.load(e[f], function(h) {
                s.images[f] = h,
                a++,
                a === 6 && (s.needsUpdate = !0,
                t && t(s))
            }, void 0, i)
        }
        for (let f = 0; f < e.length; ++f)
            l(f);
        return s
    }
}
class O3 extends Bo {
    constructor(e) {
        super(e)
    }
    load(e, t, r, i) {
        const s = this
          , o = new sh
          , a = new Aa(this.manager);
        return a.setResponseType("arraybuffer"),
        a.setRequestHeader(this.requestHeader),
        a.setPath(this.path),
        a.setWithCredentials(s.withCredentials),
        a.load(e, function(l) {
            const f = s.parse(l);
            f && (f.image !== void 0 ? o.image = f.image : f.data !== void 0 && (o.image.width = f.width,
            o.image.height = f.height,
            o.image.data = f.data),
            o.wrapS = f.wrapS !== void 0 ? f.wrapS : Us,
            o.wrapT = f.wrapT !== void 0 ? f.wrapT : Us,
            o.magFilter = f.magFilter !== void 0 ? f.magFilter : si,
            o.minFilter = f.minFilter !== void 0 ? f.minFilter : si,
            o.anisotropy = f.anisotropy !== void 0 ? f.anisotropy : 1,
            f.encoding !== void 0 && (o.encoding = f.encoding),
            f.flipY !== void 0 && (o.flipY = f.flipY),
            f.format !== void 0 && (o.format = f.format),
            f.type !== void 0 && (o.type = f.type),
            f.mipmaps !== void 0 && (o.mipmaps = f.mipmaps,
            o.minFilter = Kl),
            f.mipmapCount === 1 && (o.minFilter = si),
            f.generateMipmaps !== void 0 && (o.generateMipmaps = f.generateMipmaps),
            o.needsUpdate = !0,
            t && t(o, f))
        }, r, i),
        o
    }
}
class N3 extends Bo {
    constructor(e) {
        super(e)
    }
    load(e, t, r, i) {
        const s = new Ci
          , o = new Mm(this.manager);
        return o.setCrossOrigin(this.crossOrigin),
        o.setPath(this.path),
        o.load(e, function(a) {
            s.image = a,
            s.needsUpdate = !0,
            t !== void 0 && t(s)
        }, r, i),
        s
    }
}
class zc extends wr {
    constructor(e, t=1) {
        super(),
        this.isLight = !0,
        this.type = "Light",
        this.color = new It(e),
        this.intensity = t
    }
    dispose() {}
    copy(e, t) {
        return super.copy(e, t),
        this.color.copy(e.color),
        this.intensity = e.intensity,
        this
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return t.object.color = this.color.getHex(),
        t.object.intensity = this.intensity,
        this.groundColor !== void 0 && (t.object.groundColor = this.groundColor.getHex()),
        this.distance !== void 0 && (t.object.distance = this.distance),
        this.angle !== void 0 && (t.object.angle = this.angle),
        this.decay !== void 0 && (t.object.decay = this.decay),
        this.penumbra !== void 0 && (t.object.penumbra = this.penumbra),
        this.shadow !== void 0 && (t.object.shadow = this.shadow.toJSON()),
        t
    }
}
class z3 extends zc {
    constructor(e, t, r) {
        super(e, r),
        this.isHemisphereLight = !0,
        this.type = "HemisphereLight",
        this.position.copy(wr.DEFAULT_UP),
        this.updateMatrix(),
        this.groundColor = new It(t)
    }
    copy(e, t) {
        return super.copy(e, t),
        this.groundColor.copy(e.groundColor),
        this
    }
}
const fx = new Dn
  , ME = new $
  , AE = new $;
class hM {
    constructor(e) {
        this.camera = e,
        this.bias = 0,
        this.normalBias = 0,
        this.radius = 1,
        this.blurSamples = 8,
        this.mapSize = new it(512,512),
        this.map = null,
        this.mapPass = null,
        this.matrix = new Dn,
        this.autoUpdate = !0,
        this.needsUpdate = !1,
        this._frustum = new w_,
        this._frameExtents = new it(1,1),
        this._viewportCount = 1,
        this._viewports = [new zr(0,0,1,1)]
    }
    getViewportCount() {
        return this._viewportCount
    }
    getFrustum() {
        return this._frustum
    }
    updateMatrices(e) {
        const t = this.camera
          , r = this.matrix;
        ME.setFromMatrixPosition(e.matrixWorld),
        t.position.copy(ME),
        AE.setFromMatrixPosition(e.target.matrixWorld),
        t.lookAt(AE),
        t.updateMatrixWorld(),
        fx.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse),
        this._frustum.setFromProjectionMatrix(fx),
        r.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1),
        r.multiply(fx)
    }
    getViewport(e) {
        return this._viewports[e]
    }
    getFrameExtents() {
        return this._frameExtents
    }
    dispose() {
        this.map && this.map.dispose(),
        this.mapPass && this.mapPass.dispose()
    }
    copy(e) {
        return this.camera = e.camera.clone(),
        this.bias = e.bias,
        this.radius = e.radius,
        this.mapSize.copy(e.mapSize),
        this
    }
    clone() {
        return new this.constructor().copy(this)
    }
    toJSON() {
        const e = {};
        return this.bias !== 0 && (e.bias = this.bias),
        this.normalBias !== 0 && (e.normalBias = this.normalBias),
        this.radius !== 1 && (e.radius = this.radius),
        (this.mapSize.x !== 512 || this.mapSize.y !== 512) && (e.mapSize = this.mapSize.toArray()),
        e.camera = this.camera.toJSON(!1).object,
        delete e.camera.matrix,
        e
    }
}
class R4 extends hM {
    constructor() {
        super(new gi(50,1,.5,500)),
        this.isSpotLightShadow = !0,
        this.focus = 1
    }
    updateMatrices(e) {
        const t = this.camera
          , r = vm * 2 * e.angle * this.focus
          , i = this.mapSize.width / this.mapSize.height
          , s = e.distance || t.far;
        (r !== t.fov || i !== t.aspect || s !== t.far) && (t.fov = r,
        t.aspect = i,
        t.far = s,
        t.updateProjectionMatrix()),
        super.updateMatrices(e)
    }
    copy(e) {
        return super.copy(e),
        this.focus = e.focus,
        this
    }
}
class pM extends zc {
    constructor(e, t, r=0, i=Math.PI / 3, s=0, o=2) {
        super(e, t),
        this.isSpotLight = !0,
        this.type = "SpotLight",
        this.position.copy(wr.DEFAULT_UP),
        this.updateMatrix(),
        this.target = new wr,
        this.distance = r,
        this.angle = i,
        this.penumbra = s,
        this.decay = o,
        this.map = null,
        this.shadow = new R4
    }
    get power() {
        return this.intensity * Math.PI
    }
    set power(e) {
        this.intensity = e / Math.PI
    }
    dispose() {
        this.shadow.dispose()
    }
    copy(e, t) {
        return super.copy(e, t),
        this.distance = e.distance,
        this.angle = e.angle,
        this.penumbra = e.penumbra,
        this.decay = e.decay,
        this.target = e.target.clone(),
        this.shadow = e.shadow.clone(),
        this
    }
}
const CE = new Dn
  , up = new $
  , dx = new $;
class B4 extends hM {
    constructor() {
        super(new gi(90,1,.5,500)),
        this.isPointLightShadow = !0,
        this._frameExtents = new it(4,2),
        this._viewportCount = 6,
        this._viewports = [new zr(2,1,1,1), new zr(0,1,1,1), new zr(3,1,1,1), new zr(1,1,1,1), new zr(3,0,1,1), new zr(1,0,1,1)],
        this._cubeDirections = [new $(1,0,0), new $(-1,0,0), new $(0,0,1), new $(0,0,-1), new $(0,1,0), new $(0,-1,0)],
        this._cubeUps = [new $(0,1,0), new $(0,1,0), new $(0,1,0), new $(0,1,0), new $(0,0,1), new $(0,0,-1)]
    }
    updateMatrices(e, t=0) {
        const r = this.camera
          , i = this.matrix
          , s = e.distance || r.far;
        s !== r.far && (r.far = s,
        r.updateProjectionMatrix()),
        up.setFromMatrixPosition(e.matrixWorld),
        r.position.copy(up),
        dx.copy(r.position),
        dx.add(this._cubeDirections[t]),
        r.up.copy(this._cubeUps[t]),
        r.lookAt(dx),
        r.updateMatrixWorld(),
        i.makeTranslation(-up.x, -up.y, -up.z),
        CE.multiplyMatrices(r.projectionMatrix, r.matrixWorldInverse),
        this._frustum.setFromProjectionMatrix(CE)
    }
}
class mM extends zc {
    constructor(e, t, r=0, i=2) {
        super(e, t),
        this.isPointLight = !0,
        this.type = "PointLight",
        this.distance = r,
        this.decay = i,
        this.shadow = new B4
    }
    get power() {
        return this.intensity * 4 * Math.PI
    }
    set power(e) {
        this.intensity = e / (4 * Math.PI)
    }
    dispose() {
        this.shadow.dispose()
    }
    copy(e, t) {
        return super.copy(e, t),
        this.distance = e.distance,
        this.decay = e.decay,
        this.shadow = e.shadow.clone(),
        this
    }
}
class I4 extends hM {
    constructor() {
        super(new Mu(-5,5,5,-5,.5,500)),
        this.isDirectionalLightShadow = !0
    }
}
class gM extends zc {
    constructor(e, t) {
        super(e, t),
        this.isDirectionalLight = !0,
        this.type = "DirectionalLight",
        this.position.copy(wr.DEFAULT_UP),
        this.updateMatrix(),
        this.target = new wr,
        this.shadow = new I4
    }
    dispose() {
        this.shadow.dispose()
    }
    copy(e) {
        return super.copy(e),
        this.target = e.target.clone(),
        this.shadow = e.shadow.clone(),
        this
    }
}
class G3 extends zc {
    constructor(e, t) {
        super(e, t),
        this.isAmbientLight = !0,
        this.type = "AmbientLight"
    }
}
class U3 extends zc {
    constructor(e, t, r=10, i=10) {
        super(e, t),
        this.isRectAreaLight = !0,
        this.type = "RectAreaLight",
        this.width = r,
        this.height = i
    }
    get power() {
        return this.intensity * this.width * this.height * Math.PI
    }
    set power(e) {
        this.intensity = e / (this.width * this.height * Math.PI)
    }
    copy(e) {
        return super.copy(e),
        this.width = e.width,
        this.height = e.height,
        this
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return t.object.width = this.width,
        t.object.height = this.height,
        t
    }
}
class H3 {
    constructor() {
        this.isSphericalHarmonics3 = !0,
        this.coefficients = [];
        for (let e = 0; e < 9; e++)
            this.coefficients.push(new $)
    }
    set(e) {
        for (let t = 0; t < 9; t++)
            this.coefficients[t].copy(e[t]);
        return this
    }
    zero() {
        for (let e = 0; e < 9; e++)
            this.coefficients[e].set(0, 0, 0);
        return this
    }
    getAt(e, t) {
        const r = e.x
          , i = e.y
          , s = e.z
          , o = this.coefficients;
        return t.copy(o[0]).multiplyScalar(.282095),
        t.addScaledVector(o[1], .488603 * i),
        t.addScaledVector(o[2], .488603 * s),
        t.addScaledVector(o[3], .488603 * r),
        t.addScaledVector(o[4], 1.092548 * (r * i)),
        t.addScaledVector(o[5], 1.092548 * (i * s)),
        t.addScaledVector(o[6], .315392 * (3 * s * s - 1)),
        t.addScaledVector(o[7], 1.092548 * (r * s)),
        t.addScaledVector(o[8], .546274 * (r * r - i * i)),
        t
    }
    getIrradianceAt(e, t) {
        const r = e.x
          , i = e.y
          , s = e.z
          , o = this.coefficients;
        return t.copy(o[0]).multiplyScalar(.886227),
        t.addScaledVector(o[1], 2 * .511664 * i),
        t.addScaledVector(o[2], 2 * .511664 * s),
        t.addScaledVector(o[3], 2 * .511664 * r),
        t.addScaledVector(o[4], 2 * .429043 * r * i),
        t.addScaledVector(o[5], 2 * .429043 * i * s),
        t.addScaledVector(o[6], .743125 * s * s - .247708),
        t.addScaledVector(o[7], 2 * .429043 * r * s),
        t.addScaledVector(o[8], .429043 * (r * r - i * i)),
        t
    }
    add(e) {
        for (let t = 0; t < 9; t++)
            this.coefficients[t].add(e.coefficients[t]);
        return this
    }
    addScaledSH(e, t) {
        for (let r = 0; r < 9; r++)
            this.coefficients[r].addScaledVector(e.coefficients[r], t);
        return this
    }
    scale(e) {
        for (let t = 0; t < 9; t++)
            this.coefficients[t].multiplyScalar(e);
        return this
    }
    lerp(e, t) {
        for (let r = 0; r < 9; r++)
            this.coefficients[r].lerp(e.coefficients[r], t);
        return this
    }
    equals(e) {
        for (let t = 0; t < 9; t++)
            if (!this.coefficients[t].equals(e.coefficients[t]))
                return !1;
        return !0
    }
    copy(e) {
        return this.set(e.coefficients)
    }
    clone() {
        return new this.constructor().copy(this)
    }
    fromArray(e, t=0) {
        const r = this.coefficients;
        for (let i = 0; i < 9; i++)
            r[i].fromArray(e, t + i * 3);
        return this
    }
    toArray(e=[], t=0) {
        const r = this.coefficients;
        for (let i = 0; i < 9; i++)
            r[i].toArray(e, t + i * 3);
        return e
    }
    static getBasisAt(e, t) {
        const r = e.x
          , i = e.y
          , s = e.z;
        t[0] = .282095,
        t[1] = .488603 * i,
        t[2] = .488603 * s,
        t[3] = .488603 * r,
        t[4] = 1.092548 * r * i,
        t[5] = 1.092548 * i * s,
        t[6] = .315392 * (3 * s * s - 1),
        t[7] = 1.092548 * r * s,
        t[8] = .546274 * (r * r - i * i)
    }
}
class R_ extends zc {
    constructor(e=new H3, t=1) {
        super(void 0, t),
        this.isLightProbe = !0,
        this.sh = e
    }
    copy(e) {
        return super.copy(e),
        this.sh.copy(e.sh),
        this
    }
    fromJSON(e) {
        return this.intensity = e.intensity,
        this.sh.fromArray(e.sh),
        this
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return t.object.sh = this.sh.toArray(),
        t
    }
}
class B_ extends Bo {
    constructor(e) {
        super(e),
        this.textures = {}
    }
    load(e, t, r, i) {
        const s = this
          , o = new Aa(s.manager);
        o.setPath(s.path),
        o.setRequestHeader(s.requestHeader),
        o.setWithCredentials(s.withCredentials),
        o.load(e, function(a) {
            try {
                t(s.parse(JSON.parse(a)))
            } catch (l) {
                i ? i(l) : console.error(l),
                s.manager.itemError(e)
            }
        }, r, i)
    }
    parse(e) {
        const t = this.textures;
        function r(s) {
            return t[s] === void 0 && console.warn("THREE.MaterialLoader: Undefined texture", s),
            t[s]
        }
        const i = B_.createMaterialFromType(e.type);
        if (e.uuid !== void 0 && (i.uuid = e.uuid),
        e.name !== void 0 && (i.name = e.name),
        e.color !== void 0 && i.color !== void 0 && i.color.setHex(e.color),
        e.roughness !== void 0 && (i.roughness = e.roughness),
        e.metalness !== void 0 && (i.metalness = e.metalness),
        e.sheen !== void 0 && (i.sheen = e.sheen),
        e.sheenColor !== void 0 && (i.sheenColor = new It().setHex(e.sheenColor)),
        e.sheenRoughness !== void 0 && (i.sheenRoughness = e.sheenRoughness),
        e.emissive !== void 0 && i.emissive !== void 0 && i.emissive.setHex(e.emissive),
        e.specular !== void 0 && i.specular !== void 0 && i.specular.setHex(e.specular),
        e.specularIntensity !== void 0 && (i.specularIntensity = e.specularIntensity),
        e.specularColor !== void 0 && i.specularColor !== void 0 && i.specularColor.setHex(e.specularColor),
        e.shininess !== void 0 && (i.shininess = e.shininess),
        e.clearcoat !== void 0 && (i.clearcoat = e.clearcoat),
        e.clearcoatRoughness !== void 0 && (i.clearcoatRoughness = e.clearcoatRoughness),
        e.iridescence !== void 0 && (i.iridescence = e.iridescence),
        e.iridescenceIOR !== void 0 && (i.iridescenceIOR = e.iridescenceIOR),
        e.iridescenceThicknessRange !== void 0 && (i.iridescenceThicknessRange = e.iridescenceThicknessRange),
        e.transmission !== void 0 && (i.transmission = e.transmission),
        e.thickness !== void 0 && (i.thickness = e.thickness),
        e.attenuationDistance !== void 0 && (i.attenuationDistance = e.attenuationDistance),
        e.attenuationColor !== void 0 && i.attenuationColor !== void 0 && i.attenuationColor.setHex(e.attenuationColor),
        e.fog !== void 0 && (i.fog = e.fog),
        e.flatShading !== void 0 && (i.flatShading = e.flatShading),
        e.blending !== void 0 && (i.blending = e.blending),
        e.combine !== void 0 && (i.combine = e.combine),
        e.side !== void 0 && (i.side = e.side),
        e.shadowSide !== void 0 && (i.shadowSide = e.shadowSide),
        e.opacity !== void 0 && (i.opacity = e.opacity),
        e.transparent !== void 0 && (i.transparent = e.transparent),
        e.alphaTest !== void 0 && (i.alphaTest = e.alphaTest),
        e.depthTest !== void 0 && (i.depthTest = e.depthTest),
        e.depthWrite !== void 0 && (i.depthWrite = e.depthWrite),
        e.colorWrite !== void 0 && (i.colorWrite = e.colorWrite),
        e.stencilWrite !== void 0 && (i.stencilWrite = e.stencilWrite),
        e.stencilWriteMask !== void 0 && (i.stencilWriteMask = e.stencilWriteMask),
        e.stencilFunc !== void 0 && (i.stencilFunc = e.stencilFunc),
        e.stencilRef !== void 0 && (i.stencilRef = e.stencilRef),
        e.stencilFuncMask !== void 0 && (i.stencilFuncMask = e.stencilFuncMask),
        e.stencilFail !== void 0 && (i.stencilFail = e.stencilFail),
        e.stencilZFail !== void 0 && (i.stencilZFail = e.stencilZFail),
        e.stencilZPass !== void 0 && (i.stencilZPass = e.stencilZPass),
        e.wireframe !== void 0 && (i.wireframe = e.wireframe),
        e.wireframeLinewidth !== void 0 && (i.wireframeLinewidth = e.wireframeLinewidth),
        e.wireframeLinecap !== void 0 && (i.wireframeLinecap = e.wireframeLinecap),
        e.wireframeLinejoin !== void 0 && (i.wireframeLinejoin = e.wireframeLinejoin),
        e.rotation !== void 0 && (i.rotation = e.rotation),
        e.linewidth !== 1 && (i.linewidth = e.linewidth),
        e.dashSize !== void 0 && (i.dashSize = e.dashSize),
        e.gapSize !== void 0 && (i.gapSize = e.gapSize),
        e.scale !== void 0 && (i.scale = e.scale),
        e.polygonOffset !== void 0 && (i.polygonOffset = e.polygonOffset),
        e.polygonOffsetFactor !== void 0 && (i.polygonOffsetFactor = e.polygonOffsetFactor),
        e.polygonOffsetUnits !== void 0 && (i.polygonOffsetUnits = e.polygonOffsetUnits),
        e.dithering !== void 0 && (i.dithering = e.dithering),
        e.alphaToCoverage !== void 0 && (i.alphaToCoverage = e.alphaToCoverage),
        e.premultipliedAlpha !== void 0 && (i.premultipliedAlpha = e.premultipliedAlpha),
        e.forceSinglePass !== void 0 && (i.forceSinglePass = e.forceSinglePass),
        e.visible !== void 0 && (i.visible = e.visible),
        e.toneMapped !== void 0 && (i.toneMapped = e.toneMapped),
        e.userData !== void 0 && (i.userData = e.userData),
        e.vertexColors !== void 0 && (typeof e.vertexColors == "number" ? i.vertexColors = e.vertexColors > 0 : i.vertexColors = e.vertexColors),
        e.uniforms !== void 0)
            for (const s in e.uniforms) {
                const o = e.uniforms[s];
                switch (i.uniforms[s] = {},
                o.type) {
                case "t":
                    i.uniforms[s].value = r(o.value);
                    break;
                case "c":
                    i.uniforms[s].value = new It().setHex(o.value);
                    break;
                case "v2":
                    i.uniforms[s].value = new it().fromArray(o.value);
                    break;
                case "v3":
                    i.uniforms[s].value = new $().fromArray(o.value);
                    break;
                case "v4":
                    i.uniforms[s].value = new zr().fromArray(o.value);
                    break;
                case "m3":
                    i.uniforms[s].value = new bo().fromArray(o.value);
                    break;
                case "m4":
                    i.uniforms[s].value = new Dn().fromArray(o.value);
                    break;
                default:
                    i.uniforms[s].value = o.value
                }
            }
        if (e.defines !== void 0 && (i.defines = e.defines),
        e.vertexShader !== void 0 && (i.vertexShader = e.vertexShader),
        e.fragmentShader !== void 0 && (i.fragmentShader = e.fragmentShader),
        e.glslVersion !== void 0 && (i.glslVersion = e.glslVersion),
        e.extensions !== void 0)
            for (const s in e.extensions)
                i.extensions[s] = e.extensions[s];
        if (e.size !== void 0 && (i.size = e.size),
        e.sizeAttenuation !== void 0 && (i.sizeAttenuation = e.sizeAttenuation),
        e.map !== void 0 && (i.map = r(e.map)),
        e.matcap !== void 0 && (i.matcap = r(e.matcap)),
        e.alphaMap !== void 0 && (i.alphaMap = r(e.alphaMap)),
        e.bumpMap !== void 0 && (i.bumpMap = r(e.bumpMap)),
        e.bumpScale !== void 0 && (i.bumpScale = e.bumpScale),
        e.normalMap !== void 0 && (i.normalMap = r(e.normalMap)),
        e.normalMapType !== void 0 && (i.normalMapType = e.normalMapType),
        e.normalScale !== void 0) {
            let s = e.normalScale;
            Array.isArray(s) === !1 && (s = [s, s]),
            i.normalScale = new it().fromArray(s)
        }
        return e.displacementMap !== void 0 && (i.displacementMap = r(e.displacementMap)),
        e.displacementScale !== void 0 && (i.displacementScale = e.displacementScale),
        e.displacementBias !== void 0 && (i.displacementBias = e.displacementBias),
        e.roughnessMap !== void 0 && (i.roughnessMap = r(e.roughnessMap)),
        e.metalnessMap !== void 0 && (i.metalnessMap = r(e.metalnessMap)),
        e.emissiveMap !== void 0 && (i.emissiveMap = r(e.emissiveMap)),
        e.emissiveIntensity !== void 0 && (i.emissiveIntensity = e.emissiveIntensity),
        e.specularMap !== void 0 && (i.specularMap = r(e.specularMap)),
        e.specularIntensityMap !== void 0 && (i.specularIntensityMap = r(e.specularIntensityMap)),
        e.specularColorMap !== void 0 && (i.specularColorMap = r(e.specularColorMap)),
        e.envMap !== void 0 && (i.envMap = r(e.envMap)),
        e.envMapIntensity !== void 0 && (i.envMapIntensity = e.envMapIntensity),
        e.reflectivity !== void 0 && (i.reflectivity = e.reflectivity),
        e.refractionRatio !== void 0 && (i.refractionRatio = e.refractionRatio),
        e.lightMap !== void 0 && (i.lightMap = r(e.lightMap)),
        e.lightMapIntensity !== void 0 && (i.lightMapIntensity = e.lightMapIntensity),
        e.aoMap !== void 0 && (i.aoMap = r(e.aoMap)),
        e.aoMapIntensity !== void 0 && (i.aoMapIntensity = e.aoMapIntensity),
        e.gradientMap !== void 0 && (i.gradientMap = r(e.gradientMap)),
        e.clearcoatMap !== void 0 && (i.clearcoatMap = r(e.clearcoatMap)),
        e.clearcoatRoughnessMap !== void 0 && (i.clearcoatRoughnessMap = r(e.clearcoatRoughnessMap)),
        e.clearcoatNormalMap !== void 0 && (i.clearcoatNormalMap = r(e.clearcoatNormalMap)),
        e.clearcoatNormalScale !== void 0 && (i.clearcoatNormalScale = new it().fromArray(e.clearcoatNormalScale)),
        e.iridescenceMap !== void 0 && (i.iridescenceMap = r(e.iridescenceMap)),
        e.iridescenceThicknessMap !== void 0 && (i.iridescenceThicknessMap = r(e.iridescenceThicknessMap)),
        e.transmissionMap !== void 0 && (i.transmissionMap = r(e.transmissionMap)),
        e.thicknessMap !== void 0 && (i.thicknessMap = r(e.thicknessMap)),
        e.sheenColorMap !== void 0 && (i.sheenColorMap = r(e.sheenColorMap)),
        e.sheenRoughnessMap !== void 0 && (i.sheenRoughnessMap = r(e.sheenRoughnessMap)),
        i
    }
    setTextures(e) {
        return this.textures = e,
        this
    }
    static createMaterialFromType(e) {
        const t = {
            ShadowMaterial: A3,
            SpriteMaterial: QS,
            RawShaderMaterial: C3,
            ShaderMaterial: el,
            PointsMaterial: b_,
            MeshPhysicalMaterial: Ql,
            MeshStandardMaterial: kh,
            MeshPhongMaterial: E3,
            MeshToonMaterial: b3,
            MeshNormalMaterial: T3,
            MeshLambertMaterial: D3,
            MeshDepthMaterial: jS,
            MeshDistanceMaterial: YS,
            MeshBasicMaterial: xa,
            MeshMatcapMaterial: P3,
            LineDashedMaterial: R3,
            LineBasicMaterial: lo,
            Material: as
        };
        return new t[e]
    }
}
class jl {
    static decodeText(e) {
        if (typeof TextDecoder < "u")
            return new TextDecoder().decode(e);
        let t = "";
        for (let r = 0, i = e.length; r < i; r++)
            t += String.fromCharCode(e[r]);
        try {
            return decodeURIComponent(escape(t))
        } catch {
            return t
        }
    }
    static extractUrlBase(e) {
        const t = e.lastIndexOf("/");
        return t === -1 ? "./" : e.slice(0, t + 1)
    }
    static resolveURL(e, t) {
        return typeof e != "string" || e === "" ? "" : (/^https?:\/\//i.test(t) && /^\//.test(e) && (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")),
        /^(https?:)?\/\//i.test(e) || /^data:.*,.*$/i.test(e) || /^blob:.*$/i.test(e) ? e : t + e)
    }
}
class V3 extends On {
    constructor() {
        super(),
        this.isInstancedBufferGeometry = !0,
        this.type = "InstancedBufferGeometry",
        this.instanceCount = 1 / 0
    }
    copy(e) {
        return super.copy(e),
        this.instanceCount = e.instanceCount,
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.instanceCount = this.instanceCount,
        e.isInstancedBufferGeometry = !0,
        e
    }
}
class W3 extends Bo {
    constructor(e) {
        super(e)
    }
    load(e, t, r, i) {
        const s = this
          , o = new Aa(s.manager);
        o.setPath(s.path),
        o.setRequestHeader(s.requestHeader),
        o.setWithCredentials(s.withCredentials),
        o.load(e, function(a) {
            try {
                t(s.parse(JSON.parse(a)))
            } catch (l) {
                i ? i(l) : console.error(l),
                s.manager.itemError(e)
            }
        }, r, i)
    }
    parse(e) {
        const t = {}
          , r = {};
        function i(m, _) {
            if (t[_] !== void 0)
                return t[_];
            const x = m.interleavedBuffers[_]
              , S = s(m, x.buffer)
              , M = Wd(x.type, S)
              , w = new zm(M,x.stride);
            return w.uuid = x.uuid,
            t[_] = w,
            w
        }
        function s(m, _) {
            if (r[_] !== void 0)
                return r[_];
            const x = m.arrayBuffers[_]
              , S = new Uint32Array(x).buffer;
            return r[_] = S,
            S
        }
        const o = e.isInstancedBufferGeometry ? new V3 : new On
          , a = e.data.index;
        if (a !== void 0) {
            const m = Wd(a.type, a.array);
            o.setIndex(new Dr(m,1))
        }
        const l = e.data.attributes;
        for (const m in l) {
            const _ = l[m];
            let y;
            if (_.isInterleavedBufferAttribute) {
                const x = i(e.data, _.data);
                y = new Dc(x,_.itemSize,_.offset,_.normalized)
            } else {
                const x = Wd(_.type, _.array)
                  , S = _.isInstancedBufferAttribute ? xh : Dr;
                y = new S(x,_.itemSize,_.normalized)
            }
            _.name !== void 0 && (y.name = _.name),
            _.usage !== void 0 && y.setUsage(_.usage),
            _.updateRange !== void 0 && (y.updateRange.offset = _.updateRange.offset,
            y.updateRange.count = _.updateRange.count),
            o.setAttribute(m, y)
        }
        const f = e.data.morphAttributes;
        if (f)
            for (const m in f) {
                const _ = f[m]
                  , y = [];
                for (let x = 0, S = _.length; x < S; x++) {
                    const M = _[x];
                    let w;
                    if (M.isInterleavedBufferAttribute) {
                        const T = i(e.data, M.data);
                        w = new Dc(T,M.itemSize,M.offset,M.normalized)
                    } else {
                        const T = Wd(M.type, M.array);
                        w = new Dr(T,M.itemSize,M.normalized)
                    }
                    M.name !== void 0 && (w.name = M.name),
                    y.push(w)
                }
                o.morphAttributes[m] = y
            }
        e.data.morphTargetsRelative && (o.morphTargetsRelative = !0);
        const d = e.data.groups || e.data.drawcalls || e.data.offsets;
        if (d !== void 0)
            for (let m = 0, _ = d.length; m !== _; ++m) {
                const y = d[m];
                o.addGroup(y.start, y.count, y.materialIndex)
            }
        const p = e.data.boundingSphere;
        if (p !== void 0) {
            const m = new $;
            p.center !== void 0 && m.fromArray(p.center),
            o.boundingSphere = new Oc(m,p.radius)
        }
        return e.name && (o.name = e.name),
        e.userData && (o.userData = e.userData),
        o
    }
}
class L4 extends Bo {
    constructor(e) {
        super(e)
    }
    load(e, t, r, i) {
        const s = this
          , o = this.path === "" ? jl.extractUrlBase(e) : this.path;
        this.resourcePath = this.resourcePath || o;
        const a = new Aa(this.manager);
        a.setPath(this.path),
        a.setRequestHeader(this.requestHeader),
        a.setWithCredentials(this.withCredentials),
        a.load(e, function(l) {
            let f = null;
            try {
                f = JSON.parse(l)
            } catch (d) {
                i !== void 0 && i(d),
                console.error("THREE:ObjectLoader: Can't parse " + e + ".", d.message);
                return
            }
            const h = f.metadata;
            if (h === void 0 || h.type === void 0 || h.type.toLowerCase() === "geometry") {
                i !== void 0 && i(new Error("THREE.ObjectLoader: Can't load " + e)),
                console.error("THREE.ObjectLoader: Can't load " + e);
                return
            }
            s.parse(f, t)
        }, r, i)
    }
    async loadAsync(e, t) {
        const r = this
          , i = this.path === "" ? jl.extractUrlBase(e) : this.path;
        this.resourcePath = this.resourcePath || i;
        const s = new Aa(this.manager);
        s.setPath(this.path),
        s.setRequestHeader(this.requestHeader),
        s.setWithCredentials(this.withCredentials);
        const o = await s.loadAsync(e, t)
          , a = JSON.parse(o)
          , l = a.metadata;
        if (l === void 0 || l.type === void 0 || l.type.toLowerCase() === "geometry")
            throw new Error("THREE.ObjectLoader: Can't load " + e);
        return await r.parseAsync(a)
    }
    parse(e, t) {
        const r = this.parseAnimations(e.animations)
          , i = this.parseShapes(e.shapes)
          , s = this.parseGeometries(e.geometries, i)
          , o = this.parseImages(e.images, function() {
            t !== void 0 && t(f)
        })
          , a = this.parseTextures(e.textures, o)
          , l = this.parseMaterials(e.materials, a)
          , f = this.parseObject(e.object, s, l, a, r)
          , h = this.parseSkeletons(e.skeletons, f);
        if (this.bindSkeletons(f, h),
        t !== void 0) {
            let d = !1;
            for (const p in o)
                if (o[p].data instanceof HTMLImageElement) {
                    d = !0;
                    break
                }
            d === !1 && t(f)
        }
        return f
    }
    async parseAsync(e) {
        const t = this.parseAnimations(e.animations)
          , r = this.parseShapes(e.shapes)
          , i = this.parseGeometries(e.geometries, r)
          , s = await this.parseImagesAsync(e.images)
          , o = this.parseTextures(e.textures, s)
          , a = this.parseMaterials(e.materials, o)
          , l = this.parseObject(e.object, i, a, o, t)
          , f = this.parseSkeletons(e.skeletons, l);
        return this.bindSkeletons(l, f),
        l
    }
    parseShapes(e) {
        const t = {};
        if (e !== void 0)
            for (let r = 0, i = e.length; r < i; r++) {
                const s = new Bf().fromJSON(e[r]);
                t[s.uuid] = s
            }
        return t
    }
    parseSkeletons(e, t) {
        const r = {}
          , i = {};
        if (t.traverse(function(s) {
            s.isBone && (i[s.uuid] = s)
        }),
        e !== void 0)
            for (let s = 0, o = e.length; s < o; s++) {
                const a = new Gm().fromJSON(e[s], i);
                r[a.uuid] = a
            }
        return r
    }
    parseGeometries(e, t) {
        const r = {};
        if (e !== void 0) {
            const i = new W3;
            for (let s = 0, o = e.length; s < o; s++) {
                let a;
                const l = e[s];
                switch (l.type) {
                case "BufferGeometry":
                case "InstancedBufferGeometry":
                    a = i.parse(l);
                    break;
                default:
                    l.type in SE ? a = SE[l.type].fromJSON(l, t) : console.warn(`THREE.ObjectLoader: Unsupported geometry type "${l.type}"`)
                }
                a.uuid = l.uuid,
                l.name !== void 0 && (a.name = l.name),
                a.isBufferGeometry === !0 && l.userData !== void 0 && (a.userData = l.userData),
                r[l.uuid] = a
            }
        }
        return r
    }
    parseMaterials(e, t) {
        const r = {}
          , i = {};
        if (e !== void 0) {
            const s = new B_;
            s.setTextures(t);
            for (let o = 0, a = e.length; o < a; o++) {
                const l = e[o];
                r[l.uuid] === void 0 && (r[l.uuid] = s.parse(l)),
                i[l.uuid] = r[l.uuid]
            }
        }
        return i
    }
    parseAnimations(e) {
        const t = {};
        if (e !== void 0)
            for (let r = 0; r < e.length; r++) {
                const i = e[r]
                  , s = Mh.parse(i);
                t[s.uuid] = s
            }
        return t
    }
    parseImages(e, t) {
        const r = this
          , i = {};
        let s;
        function o(l) {
            return r.manager.itemStart(l),
            s.load(l, function() {
                r.manager.itemEnd(l)
            }, void 0, function() {
                r.manager.itemError(l),
                r.manager.itemEnd(l)
            })
        }
        function a(l) {
            if (typeof l == "string") {
                const f = l
                  , h = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(f) ? f : r.resourcePath + f;
                return o(h)
            } else
                return l.data ? {
                    data: Wd(l.type, l.data),
                    width: l.width,
                    height: l.height
                } : null
        }
        if (e !== void 0 && e.length > 0) {
            const l = new dM(t);
            s = new Mm(l),
            s.setCrossOrigin(this.crossOrigin);
            for (let f = 0, h = e.length; f < h; f++) {
                const d = e[f]
                  , p = d.url;
                if (Array.isArray(p)) {
                    const m = [];
                    for (let _ = 0, y = p.length; _ < y; _++) {
                        const x = p[_]
                          , S = a(x);
                        S !== null && (S instanceof HTMLImageElement ? m.push(S) : m.push(new sh(S.data,S.width,S.height)))
                    }
                    i[d.uuid] = new Sf(m)
                } else {
                    const m = a(d.url);
                    i[d.uuid] = new Sf(m)
                }
            }
        }
        return i
    }
    async parseImagesAsync(e) {
        const t = this
          , r = {};
        let i;
        async function s(o) {
            if (typeof o == "string") {
                const a = o
                  , l = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(a) ? a : t.resourcePath + a;
                return await i.loadAsync(l)
            } else
                return o.data ? {
                    data: Wd(o.type, o.data),
                    width: o.width,
                    height: o.height
                } : null
        }
        if (e !== void 0 && e.length > 0) {
            i = new Mm(this.manager),
            i.setCrossOrigin(this.crossOrigin);
            for (let o = 0, a = e.length; o < a; o++) {
                const l = e[o]
                  , f = l.url;
                if (Array.isArray(f)) {
                    const h = [];
                    for (let d = 0, p = f.length; d < p; d++) {
                        const m = f[d]
                          , _ = await s(m);
                        _ !== null && (_ instanceof HTMLImageElement ? h.push(_) : h.push(new sh(_.data,_.width,_.height)))
                    }
                    r[l.uuid] = new Sf(h)
                } else {
                    const h = await s(l.url);
                    r[l.uuid] = new Sf(h)
                }
            }
        }
        return r
    }
    parseTextures(e, t) {
        function r(s, o) {
            return typeof s == "number" ? s : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", s),
            o[s])
        }
        const i = {};
        if (e !== void 0)
            for (let s = 0, o = e.length; s < o; s++) {
                const a = e[s];
                a.image === void 0 && console.warn('THREE.ObjectLoader: No "image" specified for', a.uuid),
                t[a.image] === void 0 && console.warn("THREE.ObjectLoader: Undefined image", a.image);
                const l = t[a.image]
                  , f = l.data;
                let h;
                Array.isArray(f) ? (h = new Nm,
                f.length === 6 && (h.needsUpdate = !0)) : (f && f.data ? h = new sh : h = new Ci,
                f && (h.needsUpdate = !0)),
                h.source = l,
                h.uuid = a.uuid,
                a.name !== void 0 && (h.name = a.name),
                a.mapping !== void 0 && (h.mapping = r(a.mapping, F4)),
                a.offset !== void 0 && h.offset.fromArray(a.offset),
                a.repeat !== void 0 && h.repeat.fromArray(a.repeat),
                a.center !== void 0 && h.center.fromArray(a.center),
                a.rotation !== void 0 && (h.rotation = a.rotation),
                a.wrap !== void 0 && (h.wrapS = r(a.wrap[0], EE),
                h.wrapT = r(a.wrap[1], EE)),
                a.format !== void 0 && (h.format = a.format),
                a.type !== void 0 && (h.type = a.type),
                a.encoding !== void 0 && (h.encoding = a.encoding),
                a.minFilter !== void 0 && (h.minFilter = r(a.minFilter, bE)),
                a.magFilter !== void 0 && (h.magFilter = r(a.magFilter, bE)),
                a.anisotropy !== void 0 && (h.anisotropy = a.anisotropy),
                a.flipY !== void 0 && (h.flipY = a.flipY),
                a.generateMipmaps !== void 0 && (h.generateMipmaps = a.generateMipmaps),
                a.premultiplyAlpha !== void 0 && (h.premultiplyAlpha = a.premultiplyAlpha),
                a.unpackAlignment !== void 0 && (h.unpackAlignment = a.unpackAlignment),
                a.userData !== void 0 && (h.userData = a.userData),
                i[a.uuid] = h
            }
        return i
    }
    parseObject(e, t, r, i, s) {
        let o;
        function a(p) {
            return t[p] === void 0 && console.warn("THREE.ObjectLoader: Undefined geometry", p),
            t[p]
        }
        function l(p) {
            if (p !== void 0) {
                if (Array.isArray(p)) {
                    const m = [];
                    for (let _ = 0, y = p.length; _ < y; _++) {
                        const x = p[_];
                        r[x] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", x),
                        m.push(r[x])
                    }
                    return m
                }
                return r[p] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", p),
                r[p]
            }
        }
        function f(p) {
            return i[p] === void 0 && console.warn("THREE.ObjectLoader: Undefined texture", p),
            i[p]
        }
        let h, d;
        switch (e.type) {
        case "Scene":
            o = new C_,
            e.background !== void 0 && (Number.isInteger(e.background) ? o.background = new It(e.background) : o.background = f(e.background)),
            e.environment !== void 0 && (o.environment = f(e.environment)),
            e.fog !== void 0 && (e.fog.type === "Fog" ? o.fog = new A_(e.fog.color,e.fog.near,e.fog.far) : e.fog.type === "FogExp2" && (o.fog = new M_(e.fog.color,e.fog.density))),
            e.backgroundBlurriness !== void 0 && (o.backgroundBlurriness = e.backgroundBlurriness),
            e.backgroundIntensity !== void 0 && (o.backgroundIntensity = e.backgroundIntensity);
            break;
        case "PerspectiveCamera":
            o = new gi(e.fov,e.aspect,e.near,e.far),
            e.focus !== void 0 && (o.focus = e.focus),
            e.zoom !== void 0 && (o.zoom = e.zoom),
            e.filmGauge !== void 0 && (o.filmGauge = e.filmGauge),
            e.filmOffset !== void 0 && (o.filmOffset = e.filmOffset),
            e.view !== void 0 && (o.view = Object.assign({}, e.view));
            break;
        case "OrthographicCamera":
            o = new Mu(e.left,e.right,e.top,e.bottom,e.near,e.far),
            e.zoom !== void 0 && (o.zoom = e.zoom),
            e.view !== void 0 && (o.view = Object.assign({}, e.view));
            break;
        case "AmbientLight":
            o = new G3(e.color,e.intensity);
            break;
        case "DirectionalLight":
            o = new gM(e.color,e.intensity);
            break;
        case "PointLight":
            o = new mM(e.color,e.intensity,e.distance,e.decay);
            break;
        case "RectAreaLight":
            o = new U3(e.color,e.intensity,e.width,e.height);
            break;
        case "SpotLight":
            o = new pM(e.color,e.intensity,e.distance,e.angle,e.penumbra,e.decay);
            break;
        case "HemisphereLight":
            o = new z3(e.color,e.groundColor,e.intensity);
            break;
        case "LightProbe":
            o = new R_().fromJSON(e);
            break;
        case "SkinnedMesh":
            h = a(e.geometry),
            d = l(e.material),
            o = new ZS(h,d),
            e.bindMode !== void 0 && (o.bindMode = e.bindMode),
            e.bindMatrix !== void 0 && o.bindMatrix.fromArray(e.bindMatrix),
            e.skeleton !== void 0 && (o.skeleton = e.skeleton);
            break;
        case "Mesh":
            h = a(e.geometry),
            d = l(e.material),
            o = new vs(h,d);
            break;
        case "InstancedMesh":
            h = a(e.geometry),
            d = l(e.material);
            const p = e.count
              , m = e.instanceMatrix
              , _ = e.instanceColor;
            o = new h3(h,d,p),
            o.instanceMatrix = new xh(new Float32Array(m.array),16),
            _ !== void 0 && (o.instanceColor = new xh(new Float32Array(_.array),_.itemSize));
            break;
        case "LOD":
            o = new d3;
            break;
        case "Line":
            o = new Du(a(e.geometry),l(e.material));
            break;
        case "LineLoop":
            o = new $S(a(e.geometry),l(e.material));
            break;
        case "LineSegments":
            o = new Tl(a(e.geometry),l(e.material));
            break;
        case "PointCloud":
        case "Points":
            o = new eM(a(e.geometry),l(e.material));
            break;
        case "Sprite":
            o = new f3(l(e.material));
            break;
        case "Group":
            o = new _u;
            break;
        case "Bone":
            o = new E_;
            break;
        default:
            o = new wr
        }
        if (o.uuid = e.uuid,
        e.name !== void 0 && (o.name = e.name),
        e.matrix !== void 0 ? (o.matrix.fromArray(e.matrix),
        e.matrixAutoUpdate !== void 0 && (o.matrixAutoUpdate = e.matrixAutoUpdate),
        o.matrixAutoUpdate && o.matrix.decompose(o.position, o.quaternion, o.scale)) : (e.position !== void 0 && o.position.fromArray(e.position),
        e.rotation !== void 0 && o.rotation.fromArray(e.rotation),
        e.quaternion !== void 0 && o.quaternion.fromArray(e.quaternion),
        e.scale !== void 0 && o.scale.fromArray(e.scale)),
        e.castShadow !== void 0 && (o.castShadow = e.castShadow),
        e.receiveShadow !== void 0 && (o.receiveShadow = e.receiveShadow),
        e.shadow && (e.shadow.bias !== void 0 && (o.shadow.bias = e.shadow.bias),
        e.shadow.normalBias !== void 0 && (o.shadow.normalBias = e.shadow.normalBias),
        e.shadow.radius !== void 0 && (o.shadow.radius = e.shadow.radius),
        e.shadow.mapSize !== void 0 && o.shadow.mapSize.fromArray(e.shadow.mapSize),
        e.shadow.camera !== void 0 && (o.shadow.camera = this.parseObject(e.shadow.camera))),
        e.visible !== void 0 && (o.visible = e.visible),
        e.frustumCulled !== void 0 && (o.frustumCulled = e.frustumCulled),
        e.renderOrder !== void 0 && (o.renderOrder = e.renderOrder),
        e.userData !== void 0 && (o.userData = e.userData),
        e.layers !== void 0 && (o.layers.mask = e.layers),
        e.children !== void 0) {
            const p = e.children;
            for (let m = 0; m < p.length; m++)
                o.add(this.parseObject(p[m], t, r, i, s))
        }
        if (e.animations !== void 0) {
            const p = e.animations;
            for (let m = 0; m < p.length; m++) {
                const _ = p[m];
                o.animations.push(s[_])
            }
        }
        if (e.type === "LOD") {
            e.autoUpdate !== void 0 && (o.autoUpdate = e.autoUpdate);
            const p = e.levels;
            for (let m = 0; m < p.length; m++) {
                const _ = p[m]
                  , y = o.getObjectByProperty("uuid", _.object);
                y !== void 0 && o.addLevel(y, _.distance, _.hysteresis)
            }
        }
        return o
    }
    bindSkeletons(e, t) {
        Object.keys(t).length !== 0 && e.traverse(function(r) {
            if (r.isSkinnedMesh === !0 && r.skeleton !== void 0) {
                const i = t[r.skeleton];
                i === void 0 ? console.warn("THREE.ObjectLoader: No skeleton found with UUID:", r.skeleton) : r.bind(i, r.bindMatrix)
            }
        })
    }
}
const F4 = {
    UVMapping: g_,
    CubeReflectionMapping: Tu,
    CubeRefractionMapping: Ec,
    EquirectangularReflectionMapping: mh,
    EquirectangularRefractionMapping: hm,
    CubeUVReflectionMapping: Dh
}
  , EE = {
    RepeatWrapping: bc,
    ClampToEdgeWrapping: Us,
    MirroredRepeatWrapping: gh
}
  , bE = {
    NearestFilter: Ji,
    NearestMipmapNearestFilter: pm,
    NearestMipmapLinearFilter: ih,
    LinearFilter: si,
    LinearMipmapNearestFilter: v_,
    LinearMipmapLinearFilter: Kl
};
class X3 extends Bo {
    constructor(e) {
        super(e),
        this.isImageBitmapLoader = !0,
        typeof createImageBitmap > "u" && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),
        typeof fetch > "u" && console.warn("THREE.ImageBitmapLoader: fetch() not supported."),
        this.options = {
            premultiplyAlpha: "none"
        }
    }
    setOptions(e) {
        return this.options = e,
        this
    }
    load(e, t, r, i) {
        e === void 0 && (e = ""),
        this.path !== void 0 && (e = this.path + e),
        e = this.manager.resolveURL(e);
        const s = this
          , o = Wf.get(e);
        if (o !== void 0)
            return s.manager.itemStart(e),
            setTimeout(function() {
                t && t(o),
                s.manager.itemEnd(e)
            }, 0),
            o;
        const a = {};
        a.credentials = this.crossOrigin === "anonymous" ? "same-origin" : "include",
        a.headers = this.requestHeader,
        fetch(e, a).then(function(l) {
            return l.blob()
        }).then(function(l) {
            return createImageBitmap(l, Object.assign(s.options, {
                colorSpaceConversion: "none"
            }))
        }).then(function(l) {
            Wf.add(e, l),
            t && t(l),
            s.manager.itemEnd(e)
        }).catch(function(l) {
            i && i(l),
            s.manager.itemError(e),
            s.manager.itemEnd(e)
        }),
        s.manager.itemStart(e)
    }
}
let p0;
class vM {
    static getContext() {
        return p0 === void 0 && (p0 = new (window.AudioContext || window.webkitAudioContext)),
        p0
    }
    static setContext(e) {
        p0 = e
    }
}
class k4 extends Bo {
    constructor(e) {
        super(e)
    }
    load(e, t, r, i) {
        const s = this
          , o = new Aa(this.manager);
        o.setResponseType("arraybuffer"),
        o.setPath(this.path),
        o.setRequestHeader(this.requestHeader),
        o.setWithCredentials(this.withCredentials),
        o.load(e, function(a) {
            try {
                const l = a.slice(0);
                vM.getContext().decodeAudioData(l, function(h) {
                    t(h)
                })
            } catch (l) {
                i ? i(l) : console.error(l),
                s.manager.itemError(e)
            }
        }, r, i)
    }
}
class O4 extends R_ {
    constructor(e, t, r=1) {
        super(void 0, r),
        this.isHemisphereLightProbe = !0;
        const i = new It().set(e)
          , s = new It().set(t)
          , o = new $(i.r,i.g,i.b)
          , a = new $(s.r,s.g,s.b)
          , l = Math.sqrt(Math.PI)
          , f = l * Math.sqrt(.75);
        this.sh.coefficients[0].copy(o).add(a).multiplyScalar(l),
        this.sh.coefficients[1].copy(o).sub(a).multiplyScalar(f)
    }
}
class N4 extends R_ {
    constructor(e, t=1) {
        super(void 0, t),
        this.isAmbientLightProbe = !0;
        const r = new It().set(e);
        this.sh.coefficients[0].set(r.r, r.g, r.b).multiplyScalar(2 * Math.sqrt(Math.PI))
    }
}
const TE = new Dn
  , DE = new Dn
  , ef = new Dn;
class z4 {
    constructor() {
        this.type = "StereoCamera",
        this.aspect = 1,
        this.eyeSep = .064,
        this.cameraL = new gi,
        this.cameraL.layers.enable(1),
        this.cameraL.matrixAutoUpdate = !1,
        this.cameraR = new gi,
        this.cameraR.layers.enable(2),
        this.cameraR.matrixAutoUpdate = !1,
        this._cache = {
            focus: null,
            fov: null,
            aspect: null,
            near: null,
            far: null,
            zoom: null,
            eyeSep: null
        }
    }
    update(e) {
        const t = this._cache;
        if (t.focus !== e.focus || t.fov !== e.fov || t.aspect !== e.aspect * this.aspect || t.near !== e.near || t.far !== e.far || t.zoom !== e.zoom || t.eyeSep !== this.eyeSep) {
            t.focus = e.focus,
            t.fov = e.fov,
            t.aspect = e.aspect * this.aspect,
            t.near = e.near,
            t.far = e.far,
            t.zoom = e.zoom,
            t.eyeSep = this.eyeSep,
            ef.copy(e.projectionMatrix);
            const i = t.eyeSep / 2
              , s = i * t.near / t.focus
              , o = t.near * Math.tan(Df * t.fov * .5) / t.zoom;
            let a, l;
            DE.elements[12] = -i,
            TE.elements[12] = i,
            a = -o * t.aspect + s,
            l = o * t.aspect + s,
            ef.elements[0] = 2 * t.near / (l - a),
            ef.elements[8] = (l + a) / (l - a),
            this.cameraL.projectionMatrix.copy(ef),
            a = -o * t.aspect - s,
            l = o * t.aspect - s,
            ef.elements[0] = 2 * t.near / (l - a),
            ef.elements[8] = (l + a) / (l - a),
            this.cameraR.projectionMatrix.copy(ef)
        }
        this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(DE),
        this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(TE)
    }
}
class _M {
    constructor(e=!0) {
        this.autoStart = e,
        this.startTime = 0,
        this.oldTime = 0,
        this.elapsedTime = 0,
        this.running = !1
    }
    start() {
        this.startTime = PE(),
        this.oldTime = this.startTime,
        this.elapsedTime = 0,
        this.running = !0
    }
    stop() {
        this.getElapsedTime(),
        this.running = !1,
        this.autoStart = !1
    }
    getElapsedTime() {
        return this.getDelta(),
        this.elapsedTime
    }
    getDelta() {
        let e = 0;
        if (this.autoStart && !this.running)
            return this.start(),
            0;
        if (this.running) {
            const t = PE();
            e = (t - this.oldTime) / 1e3,
            this.oldTime = t,
            this.elapsedTime += e
        }
        return e
    }
}
function PE() {
    return (typeof performance > "u" ? Date : performance).now()
}
const tf = new $
  , RE = new Ws
  , G4 = new $
  , nf = new $;
class U4 extends wr {
    constructor() {
        super(),
        this.type = "AudioListener",
        this.context = vM.getContext(),
        this.gain = this.context.createGain(),
        this.gain.connect(this.context.destination),
        this.filter = null,
        this.timeDelta = 0,
        this._clock = new _M
    }
    getInput() {
        return this.gain
    }
    removeFilter() {
        return this.filter !== null && (this.gain.disconnect(this.filter),
        this.filter.disconnect(this.context.destination),
        this.gain.connect(this.context.destination),
        this.filter = null),
        this
    }
    getFilter() {
        return this.filter
    }
    setFilter(e) {
        return this.filter !== null ? (this.gain.disconnect(this.filter),
        this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination),
        this.filter = e,
        this.gain.connect(this.filter),
        this.filter.connect(this.context.destination),
        this
    }
    getMasterVolume() {
        return this.gain.gain.value
    }
    setMasterVolume(e) {
        return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01),
        this
    }
    updateMatrixWorld(e) {
        super.updateMatrixWorld(e);
        const t = this.context.listener
          , r = this.up;
        if (this.timeDelta = this._clock.getDelta(),
        this.matrixWorld.decompose(tf, RE, G4),
        nf.set(0, 0, -1).applyQuaternion(RE),
        t.positionX) {
            const i = this.context.currentTime + this.timeDelta;
            t.positionX.linearRampToValueAtTime(tf.x, i),
            t.positionY.linearRampToValueAtTime(tf.y, i),
            t.positionZ.linearRampToValueAtTime(tf.z, i),
            t.forwardX.linearRampToValueAtTime(nf.x, i),
            t.forwardY.linearRampToValueAtTime(nf.y, i),
            t.forwardZ.linearRampToValueAtTime(nf.z, i),
            t.upX.linearRampToValueAtTime(r.x, i),
            t.upY.linearRampToValueAtTime(r.y, i),
            t.upZ.linearRampToValueAtTime(r.z, i)
        } else
            t.setPosition(tf.x, tf.y, tf.z),
            t.setOrientation(nf.x, nf.y, nf.z, r.x, r.y, r.z)
    }
}
let J3 = class extends wr {
    constructor(e) {
        super(),
        this.type = "Audio",
        this.listener = e,
        this.context = e.context,
        this.gain = this.context.createGain(),
        this.gain.connect(e.getInput()),
        this.autoplay = !1,
        this.buffer = null,
        this.detune = 0,
        this.loop = !1,
        this.loopStart = 0,
        this.loopEnd = 0,
        this.offset = 0,
        this.duration = void 0,
        this.playbackRate = 1,
        this.isPlaying = !1,
        this.hasPlaybackControl = !0,
        this.source = null,
        this.sourceType = "empty",
        this._startedAt = 0,
        this._progress = 0,
        this._connected = !1,
        this.filters = []
    }
    getOutput() {
        return this.gain
    }
    setNodeSource(e) {
        return this.hasPlaybackControl = !1,
        this.sourceType = "audioNode",
        this.source = e,
        this.connect(),
        this
    }
    setMediaElementSource(e) {
        return this.hasPlaybackControl = !1,
        this.sourceType = "mediaNode",
        this.source = this.context.createMediaElementSource(e),
        this.connect(),
        this
    }
    setMediaStreamSource(e) {
        return this.hasPlaybackControl = !1,
        this.sourceType = "mediaStreamNode",
        this.source = this.context.createMediaStreamSource(e),
        this.connect(),
        this
    }
    setBuffer(e) {
        return this.buffer = e,
        this.sourceType = "buffer",
        this.autoplay && this.play(),
        this
    }
    play(e=0) {
        if (this.isPlaying === !0) {
            console.warn("THREE.Audio: Audio is already playing.");
            return
        }
        if (this.hasPlaybackControl === !1) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return
        }
        this._startedAt = this.context.currentTime + e;
        const t = this.context.createBufferSource();
        return t.buffer = this.buffer,
        t.loop = this.loop,
        t.loopStart = this.loopStart,
        t.loopEnd = this.loopEnd,
        t.onended = this.onEnded.bind(this),
        t.start(this._startedAt, this._progress + this.offset, this.duration),
        this.isPlaying = !0,
        this.source = t,
        this.setDetune(this.detune),
        this.setPlaybackRate(this.playbackRate),
        this.connect()
    }
    pause() {
        if (this.hasPlaybackControl === !1) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return
        }
        return this.isPlaying === !0 && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate,
        this.loop === !0 && (this._progress = this._progress % (this.duration || this.buffer.duration)),
        this.source.stop(),
        this.source.onended = null,
        this.isPlaying = !1),
        this
    }
    stop() {
        if (this.hasPlaybackControl === !1) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return
        }
        return this._progress = 0,
        this.source.stop(),
        this.source.onended = null,
        this.isPlaying = !1,
        this
    }
    connect() {
        if (this.filters.length > 0) {
            this.source.connect(this.filters[0]);
            for (let e = 1, t = this.filters.length; e < t; e++)
                this.filters[e - 1].connect(this.filters[e]);
            this.filters[this.filters.length - 1].connect(this.getOutput())
        } else
            this.source.connect(this.getOutput());
        return this._connected = !0,
        this
    }
    disconnect() {
        if (this.filters.length > 0) {
            this.source.disconnect(this.filters[0]);
            for (let e = 1, t = this.filters.length; e < t; e++)
                this.filters[e - 1].disconnect(this.filters[e]);
            this.filters[this.filters.length - 1].disconnect(this.getOutput())
        } else
            this.source.disconnect(this.getOutput());
        return this._connected = !1,
        this
    }
    getFilters() {
        return this.filters
    }
    setFilters(e) {
        return e || (e = []),
        this._connected === !0 ? (this.disconnect(),
        this.filters = e.slice(),
        this.connect()) : this.filters = e.slice(),
        this
    }
    setDetune(e) {
        if (this.detune = e,
        this.source.detune !== void 0)
            return this.isPlaying === !0 && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01),
            this
    }
    getDetune() {
        return this.detune
    }
    getFilter() {
        return this.getFilters()[0]
    }
    setFilter(e) {
        return this.setFilters(e ? [e] : [])
    }
    setPlaybackRate(e) {
        if (this.hasPlaybackControl === !1) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return
        }
        return this.playbackRate = e,
        this.isPlaying === !0 && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01),
        this
    }
    getPlaybackRate() {
        return this.playbackRate
    }
    onEnded() {
        this.isPlaying = !1
    }
    getLoop() {
        return this.hasPlaybackControl === !1 ? (console.warn("THREE.Audio: this Audio has no playback control."),
        !1) : this.loop
    }
    setLoop(e) {
        if (this.hasPlaybackControl === !1) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return
        }
        return this.loop = e,
        this.isPlaying === !0 && (this.source.loop = this.loop),
        this
    }
    setLoopStart(e) {
        return this.loopStart = e,
        this
    }
    setLoopEnd(e) {
        return this.loopEnd = e,
        this
    }
    getVolume() {
        return this.gain.gain.value
    }
    setVolume(e) {
        return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01),
        this
    }
}
;
const rf = new $
  , BE = new Ws
  , H4 = new $
  , sf = new $;
class V4 extends J3 {
    constructor(e) {
        super(e),
        this.panner = this.context.createPanner(),
        this.panner.panningModel = "HRTF",
        this.panner.connect(this.gain)
    }
    disconnect() {
        super.disconnect(),
        this.panner.disconnect(this.gain)
    }
    getOutput() {
        return this.panner
    }
    getRefDistance() {
        return this.panner.refDistance
    }
    setRefDistance(e) {
        return this.panner.refDistance = e,
        this
    }
    getRolloffFactor() {
        return this.panner.rolloffFactor
    }
    setRolloffFactor(e) {
        return this.panner.rolloffFactor = e,
        this
    }
    getDistanceModel() {
        return this.panner.distanceModel
    }
    setDistanceModel(e) {
        return this.panner.distanceModel = e,
        this
    }
    getMaxDistance() {
        return this.panner.maxDistance
    }
    setMaxDistance(e) {
        return this.panner.maxDistance = e,
        this
    }
    setDirectionalCone(e, t, r) {
        return this.panner.coneInnerAngle = e,
        this.panner.coneOuterAngle = t,
        this.panner.coneOuterGain = r,
        this
    }
    updateMatrixWorld(e) {
        if (super.updateMatrixWorld(e),
        this.hasPlaybackControl === !0 && this.isPlaying === !1)
            return;
        this.matrixWorld.decompose(rf, BE, H4),
        sf.set(0, 0, 1).applyQuaternion(BE);
        const t = this.panner;
        if (t.positionX) {
            const r = this.context.currentTime + this.listener.timeDelta;
            t.positionX.linearRampToValueAtTime(rf.x, r),
            t.positionY.linearRampToValueAtTime(rf.y, r),
            t.positionZ.linearRampToValueAtTime(rf.z, r),
            t.orientationX.linearRampToValueAtTime(sf.x, r),
            t.orientationY.linearRampToValueAtTime(sf.y, r),
            t.orientationZ.linearRampToValueAtTime(sf.z, r)
        } else
            t.setPosition(rf.x, rf.y, rf.z),
            t.setOrientation(sf.x, sf.y, sf.z)
    }
}
class W4 {
    constructor(e, t=2048) {
        this.analyser = e.context.createAnalyser(),
        this.analyser.fftSize = t,
        this.data = new Uint8Array(this.analyser.frequencyBinCount),
        e.getOutput().connect(this.analyser)
    }
    getFrequencyData() {
        return this.analyser.getByteFrequencyData(this.data),
        this.data
    }
    getAverageFrequency() {
        let e = 0;
        const t = this.getFrequencyData();
        for (let r = 0; r < t.length; r++)
            e += t[r];
        return e / t.length
    }
}
class j3 {
    constructor(e, t, r) {
        this.binding = e,
        this.valueSize = r;
        let i, s, o;
        switch (t) {
        case "quaternion":
            i = this._slerp,
            s = this._slerpAdditive,
            o = this._setAdditiveIdentityQuaternion,
            this.buffer = new Float64Array(r * 6),
            this._workIndex = 5;
            break;
        case "string":
        case "bool":
            i = this._select,
            s = this._select,
            o = this._setAdditiveIdentityOther,
            this.buffer = new Array(r * 5);
            break;
        default:
            i = this._lerp,
            s = this._lerpAdditive,
            o = this._setAdditiveIdentityNumeric,
            this.buffer = new Float64Array(r * 5)
        }
        this._mixBufferRegion = i,
        this._mixBufferRegionAdditive = s,
        this._setIdentity = o,
        this._origIndex = 3,
        this._addIndex = 4,
        this.cumulativeWeight = 0,
        this.cumulativeWeightAdditive = 0,
        this.useCount = 0,
        this.referenceCount = 0
    }
    accumulate(e, t) {
        const r = this.buffer
          , i = this.valueSize
          , s = e * i + i;
        let o = this.cumulativeWeight;
        if (o === 0) {
            for (let a = 0; a !== i; ++a)
                r[s + a] = r[a];
            o = t
        } else {
            o += t;
            const a = t / o;
            this._mixBufferRegion(r, s, 0, a, i)
        }
        this.cumulativeWeight = o
    }
    accumulateAdditive(e) {
        const t = this.buffer
          , r = this.valueSize
          , i = r * this._addIndex;
        this.cumulativeWeightAdditive === 0 && this._setIdentity(),
        this._mixBufferRegionAdditive(t, i, 0, e, r),
        this.cumulativeWeightAdditive += e
    }
    apply(e) {
        const t = this.valueSize
          , r = this.buffer
          , i = e * t + t
          , s = this.cumulativeWeight
          , o = this.cumulativeWeightAdditive
          , a = this.binding;
        if (this.cumulativeWeight = 0,
        this.cumulativeWeightAdditive = 0,
        s < 1) {
            const l = t * this._origIndex;
            this._mixBufferRegion(r, i, l, 1 - s, t)
        }
        o > 0 && this._mixBufferRegionAdditive(r, i, this._addIndex * t, 1, t);
        for (let l = t, f = t + t; l !== f; ++l)
            if (r[l] !== r[l + t]) {
                a.setValue(r, i);
                break
            }
    }
    saveOriginalState() {
        const e = this.binding
          , t = this.buffer
          , r = this.valueSize
          , i = r * this._origIndex;
        e.getValue(t, i);
        for (let s = r, o = i; s !== o; ++s)
            t[s] = t[i + s % r];
        this._setIdentity(),
        this.cumulativeWeight = 0,
        this.cumulativeWeightAdditive = 0
    }
    restoreOriginalState() {
        const e = this.valueSize * 3;
        this.binding.setValue(this.buffer, e)
    }
    _setAdditiveIdentityNumeric() {
        const e = this._addIndex * this.valueSize
          , t = e + this.valueSize;
        for (let r = e; r < t; r++)
            this.buffer[r] = 0
    }
    _setAdditiveIdentityQuaternion() {
        this._setAdditiveIdentityNumeric(),
        this.buffer[this._addIndex * this.valueSize + 3] = 1
    }
    _setAdditiveIdentityOther() {
        const e = this._origIndex * this.valueSize
          , t = this._addIndex * this.valueSize;
        for (let r = 0; r < this.valueSize; r++)
            this.buffer[t + r] = this.buffer[e + r]
    }
    _select(e, t, r, i, s) {
        if (i >= .5)
            for (let o = 0; o !== s; ++o)
                e[t + o] = e[r + o]
    }
    _slerp(e, t, r, i) {
        Ws.slerpFlat(e, t, e, t, e, r, i)
    }
    _slerpAdditive(e, t, r, i, s) {
        const o = this._workIndex * s;
        Ws.multiplyQuaternionsFlat(e, o, e, t, e, r),
        Ws.slerpFlat(e, t, e, t, e, o, i)
    }
    _lerp(e, t, r, i, s) {
        const o = 1 - i;
        for (let a = 0; a !== s; ++a) {
            const l = t + a;
            e[l] = e[l] * o + e[r + a] * i
        }
    }
    _lerpAdditive(e, t, r, i, s) {
        for (let o = 0; o !== s; ++o) {
            const a = t + o;
            e[a] = e[a] + e[r + o] * i
        }
    }
}
const yM = "\\[\\]\\.:\\/"
  , X4 = new RegExp("[" + yM + "]","g")
  , xM = "[^" + yM + "]"
  , J4 = "[^" + yM.replace("\\.", "") + "]"
  , j4 = /((?:WC+[\/:])*)/.source.replace("WC", xM)
  , Y4 = /(WCOD+)?/.source.replace("WCOD", J4)
  , K4 = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", xM)
  , q4 = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", xM)
  , Q4 = new RegExp("^" + j4 + Y4 + K4 + q4 + "$")
  , Z4 = ["material", "materials", "bones", "map"];
class $4 {
    constructor(e, t, r) {
        const i = r || hr.parseTrackName(t);
        this._targetGroup = e,
        this._bindings = e.subscribe_(t, i)
    }
    getValue(e, t) {
        this.bind();
        const r = this._targetGroup.nCachedObjects_
          , i = this._bindings[r];
        i !== void 0 && i.getValue(e, t)
    }
    setValue(e, t) {
        const r = this._bindings;
        for (let i = this._targetGroup.nCachedObjects_, s = r.length; i !== s; ++i)
            r[i].setValue(e, t)
    }
    bind() {
        const e = this._bindings;
        for (let t = this._targetGroup.nCachedObjects_, r = e.length; t !== r; ++t)
            e[t].bind()
    }
    unbind() {
        const e = this._bindings;
        for (let t = this._targetGroup.nCachedObjects_, r = e.length; t !== r; ++t)
            e[t].unbind()
    }
}
class hr {
    constructor(e, t, r) {
        this.path = t,
        this.parsedPath = r || hr.parseTrackName(t),
        this.node = hr.findNode(e, this.parsedPath.nodeName) || e,
        this.rootNode = e,
        this.getValue = this._getValue_unbound,
        this.setValue = this._setValue_unbound
    }
    static create(e, t, r) {
        return e && e.isAnimationObjectGroup ? new hr.Composite(e,t,r) : new hr(e,t,r)
    }
    static sanitizeNodeName(e) {
        return e.replace(/\s/g, "_").replace(X4, "")
    }
    static parseTrackName(e) {
        const t = Q4.exec(e);
        if (t === null)
            throw new Error("PropertyBinding: Cannot parse trackName: " + e);
        const r = {
            nodeName: t[2],
            objectName: t[3],
            objectIndex: t[4],
            propertyName: t[5],
            propertyIndex: t[6]
        }
          , i = r.nodeName && r.nodeName.lastIndexOf(".");
        if (i !== void 0 && i !== -1) {
            const s = r.nodeName.substring(i + 1);
            Z4.indexOf(s) !== -1 && (r.nodeName = r.nodeName.substring(0, i),
            r.objectName = s)
        }
        if (r.propertyName === null || r.propertyName.length === 0)
            throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e);
        return r
    }
    static findNode(e, t) {
        if (t === void 0 || t === "" || t === "." || t === -1 || t === e.name || t === e.uuid)
            return e;
        if (e.skeleton) {
            const r = e.skeleton.getBoneByName(t);
            if (r !== void 0)
                return r
        }
        if (e.children) {
            const r = function(s) {
                for (let o = 0; o < s.length; o++) {
                    const a = s[o];
                    if (a.name === t || a.uuid === t)
                        return a;
                    const l = r(a.children);
                    if (l)
                        return l
                }
                return null
            }
              , i = r(e.children);
            if (i)
                return i
        }
        return null
    }
    _getValue_unavailable() {}
    _setValue_unavailable() {}
    _getValue_direct(e, t) {
        e[t] = this.targetObject[this.propertyName]
    }
    _getValue_array(e, t) {
        const r = this.resolvedProperty;
        for (let i = 0, s = r.length; i !== s; ++i)
            e[t++] = r[i]
    }
    _getValue_arrayElement(e, t) {
        e[t] = this.resolvedProperty[this.propertyIndex]
    }
    _getValue_toArray(e, t) {
        this.resolvedProperty.toArray(e, t)
    }
    _setValue_direct(e, t) {
        this.targetObject[this.propertyName] = e[t]
    }
    _setValue_direct_setNeedsUpdate(e, t) {
        this.targetObject[this.propertyName] = e[t],
        this.targetObject.needsUpdate = !0
    }
    _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
        this.targetObject[this.propertyName] = e[t],
        this.targetObject.matrixWorldNeedsUpdate = !0
    }
    _setValue_array(e, t) {
        const r = this.resolvedProperty;
        for (let i = 0, s = r.length; i !== s; ++i)
            r[i] = e[t++]
    }
    _setValue_array_setNeedsUpdate(e, t) {
        const r = this.resolvedProperty;
        for (let i = 0, s = r.length; i !== s; ++i)
            r[i] = e[t++];
        this.targetObject.needsUpdate = !0
    }
    _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
        const r = this.resolvedProperty;
        for (let i = 0, s = r.length; i !== s; ++i)
            r[i] = e[t++];
        this.targetObject.matrixWorldNeedsUpdate = !0
    }
    _setValue_arrayElement(e, t) {
        this.resolvedProperty[this.propertyIndex] = e[t]
    }
    _setValue_arrayElement_setNeedsUpdate(e, t) {
        this.resolvedProperty[this.propertyIndex] = e[t],
        this.targetObject.needsUpdate = !0
    }
    _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
        this.resolvedProperty[this.propertyIndex] = e[t],
        this.targetObject.matrixWorldNeedsUpdate = !0
    }
    _setValue_fromArray(e, t) {
        this.resolvedProperty.fromArray(e, t)
    }
    _setValue_fromArray_setNeedsUpdate(e, t) {
        this.resolvedProperty.fromArray(e, t),
        this.targetObject.needsUpdate = !0
    }
    _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
        this.resolvedProperty.fromArray(e, t),
        this.targetObject.matrixWorldNeedsUpdate = !0
    }
    _getValue_unbound(e, t) {
        this.bind(),
        this.getValue(e, t)
    }
    _setValue_unbound(e, t) {
        this.bind(),
        this.setValue(e, t)
    }
    bind() {
        let e = this.node;
        const t = this.parsedPath
          , r = t.objectName
          , i = t.propertyName;
        let s = t.propertyIndex;
        if (e || (e = hr.findNode(this.rootNode, t.nodeName) || this.rootNode,
        this.node = e),
        this.getValue = this._getValue_unavailable,
        this.setValue = this._setValue_unavailable,
        !e) {
            console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
            return
        }
        if (r) {
            let f = t.objectIndex;
            switch (r) {
            case "materials":
                if (!e.material) {
                    console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                    return
                }
                if (!e.material.materials) {
                    console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                    return
                }
                e = e.material.materials;
                break;
            case "bones":
                if (!e.skeleton) {
                    console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                    return
                }
                e = e.skeleton.bones;
                for (let h = 0; h < e.length; h++)
                    if (e[h].name === f) {
                        f = h;
                        break
                    }
                break;
            case "map":
                if ("map"in e) {
                    e = e.map;
                    break
                }
                if (!e.material) {
                    console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                    return
                }
                if (!e.material.map) {
                    console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this);
                    return
                }
                e = e.material.map;
                break;
            default:
                if (e[r] === void 0) {
                    console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                    return
                }
                e = e[r]
            }
            if (f !== void 0) {
                if (e[f] === void 0) {
                    console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e);
                    return
                }
                e = e[f]
            }
        }
        const o = e[i];
        if (o === void 0) {
            const f = t.nodeName;
            console.error("THREE.PropertyBinding: Trying to update property for track: " + f + "." + i + " but it wasn't found.", e);
            return
        }
        let a = this.Versioning.None;
        this.targetObject = e,
        e.needsUpdate !== void 0 ? a = this.Versioning.NeedsUpdate : e.matrixWorldNeedsUpdate !== void 0 && (a = this.Versioning.MatrixWorldNeedsUpdate);
        let l = this.BindingType.Direct;
        if (s !== void 0) {
            if (i === "morphTargetInfluences") {
                if (!e.geometry) {
                    console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                    return
                }
                if (!e.geometry.morphAttributes) {
                    console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                    return
                }
                e.morphTargetDictionary[s] !== void 0 && (s = e.morphTargetDictionary[s])
            }
            l = this.BindingType.ArrayElement,
            this.resolvedProperty = o,
            this.propertyIndex = s
        } else
            o.fromArray !== void 0 && o.toArray !== void 0 ? (l = this.BindingType.HasFromToArray,
            this.resolvedProperty = o) : Array.isArray(o) ? (l = this.BindingType.EntireArray,
            this.resolvedProperty = o) : this.propertyName = i;
        this.getValue = this.GetterByBindingType[l],
        this.setValue = this.SetterByBindingTypeAndVersioning[l][a]
    }
    unbind() {
        this.node = null,
        this.getValue = this._getValue_unbound,
        this.setValue = this._setValue_unbound
    }
}
hr.Composite = $4;
hr.prototype.BindingType = {
    Direct: 0,
    EntireArray: 1,
    ArrayElement: 2,
    HasFromToArray: 3
};
hr.prototype.Versioning = {
    None: 0,
    NeedsUpdate: 1,
    MatrixWorldNeedsUpdate: 2
};
hr.prototype.GetterByBindingType = [hr.prototype._getValue_direct, hr.prototype._getValue_array, hr.prototype._getValue_arrayElement, hr.prototype._getValue_toArray];
hr.prototype.SetterByBindingTypeAndVersioning = [[hr.prototype._setValue_direct, hr.prototype._setValue_direct_setNeedsUpdate, hr.prototype._setValue_direct_setMatrixWorldNeedsUpdate], [hr.prototype._setValue_array, hr.prototype._setValue_array_setNeedsUpdate, hr.prototype._setValue_array_setMatrixWorldNeedsUpdate], [hr.prototype._setValue_arrayElement, hr.prototype._setValue_arrayElement_setNeedsUpdate, hr.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate], [hr.prototype._setValue_fromArray, hr.prototype._setValue_fromArray_setNeedsUpdate, hr.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];
class eG {
    constructor() {
        this.isAnimationObjectGroup = !0,
        this.uuid = Sa(),
        this._objects = Array.prototype.slice.call(arguments),
        this.nCachedObjects_ = 0;
        const e = {};
        this._indicesByUUID = e;
        for (let r = 0, i = arguments.length; r !== i; ++r)
            e[arguments[r].uuid] = r;
        this._paths = [],
        this._parsedPaths = [],
        this._bindings = [],
        this._bindingsIndicesByPath = {};
        const t = this;
        this.stats = {
            objects: {
                get total() {
                    return t._objects.length
                },
                get inUse() {
                    return this.total - t.nCachedObjects_
                }
            },
            get bindingsPerObject() {
                return t._bindings.length
            }
        }
    }
    add() {
        const e = this._objects
          , t = this._indicesByUUID
          , r = this._paths
          , i = this._parsedPaths
          , s = this._bindings
          , o = s.length;
        let a, l = e.length, f = this.nCachedObjects_;
        for (let h = 0, d = arguments.length; h !== d; ++h) {
            const p = arguments[h]
              , m = p.uuid;
            let _ = t[m];
            if (_ === void 0) {
                _ = l++,
                t[m] = _,
                e.push(p);
                for (let y = 0, x = o; y !== x; ++y)
                    s[y].push(new hr(p,r[y],i[y]))
            } else if (_ < f) {
                a = e[_];
                const y = --f
                  , x = e[y];
                t[x.uuid] = _,
                e[_] = x,
                t[m] = y,
                e[y] = p;
                for (let S = 0, M = o; S !== M; ++S) {
                    const w = s[S]
                      , T = w[y];
                    let P = w[_];
                    w[_] = T,
                    P === void 0 && (P = new hr(p,r[S],i[S])),
                    w[y] = P
                }
            } else
                e[_] !== a && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")
        }
        this.nCachedObjects_ = f
    }
    remove() {
        const e = this._objects
          , t = this._indicesByUUID
          , r = this._bindings
          , i = r.length;
        let s = this.nCachedObjects_;
        for (let o = 0, a = arguments.length; o !== a; ++o) {
            const l = arguments[o]
              , f = l.uuid
              , h = t[f];
            if (h !== void 0 && h >= s) {
                const d = s++
                  , p = e[d];
                t[p.uuid] = h,
                e[h] = p,
                t[f] = d,
                e[d] = l;
                for (let m = 0, _ = i; m !== _; ++m) {
                    const y = r[m]
                      , x = y[d]
                      , S = y[h];
                    y[h] = x,
                    y[d] = S
                }
            }
        }
        this.nCachedObjects_ = s
    }
    uncache() {
        const e = this._objects
          , t = this._indicesByUUID
          , r = this._bindings
          , i = r.length;
        let s = this.nCachedObjects_
          , o = e.length;
        for (let a = 0, l = arguments.length; a !== l; ++a) {
            const f = arguments[a]
              , h = f.uuid
              , d = t[h];
            if (d !== void 0)
                if (delete t[h],
                d < s) {
                    const p = --s
                      , m = e[p]
                      , _ = --o
                      , y = e[_];
                    t[m.uuid] = d,
                    e[d] = m,
                    t[y.uuid] = p,
                    e[p] = y,
                    e.pop();
                    for (let x = 0, S = i; x !== S; ++x) {
                        const M = r[x]
                          , w = M[p]
                          , T = M[_];
                        M[d] = w,
                        M[p] = T,
                        M.pop()
                    }
                } else {
                    const p = --o
                      , m = e[p];
                    p > 0 && (t[m.uuid] = d),
                    e[d] = m,
                    e.pop();
                    for (let _ = 0, y = i; _ !== y; ++_) {
                        const x = r[_];
                        x[d] = x[p],
                        x.pop()
                    }
                }
        }
        this.nCachedObjects_ = s
    }
    subscribe_(e, t) {
        const r = this._bindingsIndicesByPath;
        let i = r[e];
        const s = this._bindings;
        if (i !== void 0)
            return s[i];
        const o = this._paths
          , a = this._parsedPaths
          , l = this._objects
          , f = l.length
          , h = this.nCachedObjects_
          , d = new Array(f);
        i = s.length,
        r[e] = i,
        o.push(e),
        a.push(t),
        s.push(d);
        for (let p = h, m = l.length; p !== m; ++p) {
            const _ = l[p];
            d[p] = new hr(_,e,t)
        }
        return d
    }
    unsubscribe_(e) {
        const t = this._bindingsIndicesByPath
          , r = t[e];
        if (r !== void 0) {
            const i = this._paths
              , s = this._parsedPaths
              , o = this._bindings
              , a = o.length - 1
              , l = o[a]
              , f = e[a];
            t[f] = r,
            o[r] = l,
            o.pop(),
            s[r] = s[a],
            s.pop(),
            i[r] = i[a],
            i.pop()
        }
    }
}
class tG {
    constructor(e, t, r=null, i=t.blendMode) {
        this._mixer = e,
        this._clip = t,
        this._localRoot = r,
        this.blendMode = i;
        const s = t.tracks
          , o = s.length
          , a = new Array(o)
          , l = {
            endingStart: xf,
            endingEnd: xf
        };
        for (let f = 0; f !== o; ++f) {
            const h = s[f].createInterpolant(null);
            a[f] = h,
            h.settings = l
        }
        this._interpolantSettings = l,
        this._interpolants = a,
        this._propertyBindings = new Array(o),
        this._cacheIndex = null,
        this._byClipCacheIndex = null,
        this._timeScaleInterpolant = null,
        this._weightInterpolant = null,
        this.loop = W2,
        this._loopCount = -1,
        this._startTime = null,
        this.time = 0,
        this.timeScale = 1,
        this._effectiveTimeScale = 1,
        this.weight = 1,
        this._effectiveWeight = 1,
        this.repetitions = 1 / 0,
        this.paused = !1,
        this.enabled = !0,
        this.clampWhenFinished = !1,
        this.zeroSlopeAtStart = !0,
        this.zeroSlopeAtEnd = !0
    }
    play() {
        return this._mixer._activateAction(this),
        this
    }
    stop() {
        return this._mixer._deactivateAction(this),
        this.reset()
    }
    reset() {
        return this.paused = !1,
        this.enabled = !0,
        this.time = 0,
        this._loopCount = -1,
        this._startTime = null,
        this.stopFading().stopWarping()
    }
    isRunning() {
        return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this)
    }
    isScheduled() {
        return this._mixer._isActiveAction(this)
    }
    startAt(e) {
        return this._startTime = e,
        this
    }
    setLoop(e, t) {
        return this.loop = e,
        this.repetitions = t,
        this
    }
    setEffectiveWeight(e) {
        return this.weight = e,
        this._effectiveWeight = this.enabled ? e : 0,
        this.stopFading()
    }
    getEffectiveWeight() {
        return this._effectiveWeight
    }
    fadeIn(e) {
        return this._scheduleFading(e, 0, 1)
    }
    fadeOut(e) {
        return this._scheduleFading(e, 1, 0)
    }
    crossFadeFrom(e, t, r) {
        if (e.fadeOut(t),
        this.fadeIn(t),
        r) {
            const i = this._clip.duration
              , s = e._clip.duration
              , o = s / i
              , a = i / s;
            e.warp(1, o, t),
            this.warp(a, 1, t)
        }
        return this
    }
    crossFadeTo(e, t, r) {
        return e.crossFadeFrom(this, t, r)
    }
    stopFading() {
        const e = this._weightInterpolant;
        return e !== null && (this._weightInterpolant = null,
        this._mixer._takeBackControlInterpolant(e)),
        this
    }
    setEffectiveTimeScale(e) {
        return this.timeScale = e,
        this._effectiveTimeScale = this.paused ? 0 : e,
        this.stopWarping()
    }
    getEffectiveTimeScale() {
        return this._effectiveTimeScale
    }
    setDuration(e) {
        return this.timeScale = this._clip.duration / e,
        this.stopWarping()
    }
    syncWith(e) {
        return this.time = e.time,
        this.timeScale = e.timeScale,
        this.stopWarping()
    }
    halt(e) {
        return this.warp(this._effectiveTimeScale, 0, e)
    }
    warp(e, t, r) {
        const i = this._mixer
          , s = i.time
          , o = this.timeScale;
        let a = this._timeScaleInterpolant;
        a === null && (a = i._lendControlInterpolant(),
        this._timeScaleInterpolant = a);
        const l = a.parameterPositions
          , f = a.sampleValues;
        return l[0] = s,
        l[1] = s + r,
        f[0] = e / o,
        f[1] = t / o,
        this
    }
    stopWarping() {
        const e = this._timeScaleInterpolant;
        return e !== null && (this._timeScaleInterpolant = null,
        this._mixer._takeBackControlInterpolant(e)),
        this
    }
    getMixer() {
        return this._mixer
    }
    getClip() {
        return this._clip
    }
    getRoot() {
        return this._localRoot || this._mixer._root
    }
    _update(e, t, r, i) {
        if (!this.enabled) {
            this._updateWeight(e);
            return
        }
        const s = this._startTime;
        if (s !== null) {
            const l = (e - s) * r;
            l < 0 || r === 0 ? t = 0 : (this._startTime = null,
            t = r * l)
        }
        t *= this._updateTimeScale(e);
        const o = this._updateTime(t)
          , a = this._updateWeight(e);
        if (a > 0) {
            const l = this._interpolants
              , f = this._propertyBindings;
            switch (this.blendMode) {
            case OS:
                for (let h = 0, d = l.length; h !== d; ++h)
                    l[h].evaluate(o),
                    f[h].accumulateAdditive(a);
                break;
            case __:
            default:
                for (let h = 0, d = l.length; h !== d; ++h)
                    l[h].evaluate(o),
                    f[h].accumulate(i, a)
            }
        }
    }
    _updateWeight(e) {
        let t = 0;
        if (this.enabled) {
            t = this.weight;
            const r = this._weightInterpolant;
            if (r !== null) {
                const i = r.evaluate(e)[0];
                t *= i,
                e > r.parameterPositions[1] && (this.stopFading(),
                i === 0 && (this.enabled = !1))
            }
        }
        return this._effectiveWeight = t,
        t
    }
    _updateTimeScale(e) {
        let t = 0;
        if (!this.paused) {
            t = this.timeScale;
            const r = this._timeScaleInterpolant;
            if (r !== null) {
                const i = r.evaluate(e)[0];
                t *= i,
                e > r.parameterPositions[1] && (this.stopWarping(),
                t === 0 ? this.paused = !0 : this.timeScale = t)
            }
        }
        return this._effectiveTimeScale = t,
        t
    }
    _updateTime(e) {
        const t = this._clip.duration
          , r = this.loop;
        let i = this.time + e
          , s = this._loopCount;
        const o = r === X2;
        if (e === 0)
            return s === -1 ? i : o && (s & 1) === 1 ? t - i : i;
        if (r === V2) {
            s === -1 && (this._loopCount = 0,
            this._setEndings(!0, !0, !1));
            e: {
                if (i >= t)
                    i = t;
                else if (i < 0)
                    i = 0;
                else {
                    this.time = i;
                    break e
                }
                this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                this.time = i,
                this._mixer.dispatchEvent({
                    type: "finished",
                    action: this,
                    direction: e < 0 ? -1 : 1
                })
            }
        } else {
            if (s === -1 && (e >= 0 ? (s = 0,
            this._setEndings(!0, this.repetitions === 0, o)) : this._setEndings(this.repetitions === 0, !0, o)),
            i >= t || i < 0) {
                const a = Math.floor(i / t);
                i -= t * a,
                s += Math.abs(a);
                const l = this.repetitions - s;
                if (l <= 0)
                    this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                    i = e > 0 ? t : 0,
                    this.time = i,
                    this._mixer.dispatchEvent({
                        type: "finished",
                        action: this,
                        direction: e > 0 ? 1 : -1
                    });
                else {
                    if (l === 1) {
                        const f = e < 0;
                        this._setEndings(f, !f, o)
                    } else
                        this._setEndings(!1, !1, o);
                    this._loopCount = s,
                    this.time = i,
                    this._mixer.dispatchEvent({
                        type: "loop",
                        action: this,
                        loopDelta: a
                    })
                }
            } else
                this.time = i;
            if (o && (s & 1) === 1)
                return t - i
        }
        return i
    }
    _setEndings(e, t, r) {
        const i = this._interpolantSettings;
        r ? (i.endingStart = wf,
        i.endingEnd = wf) : (e ? i.endingStart = this.zeroSlopeAtStart ? wf : xf : i.endingStart = mm,
        t ? i.endingEnd = this.zeroSlopeAtEnd ? wf : xf : i.endingEnd = mm)
    }
    _scheduleFading(e, t, r) {
        const i = this._mixer
          , s = i.time;
        let o = this._weightInterpolant;
        o === null && (o = i._lendControlInterpolant(),
        this._weightInterpolant = o);
        const a = o.parameterPositions
          , l = o.sampleValues;
        return a[0] = s,
        l[0] = t,
        a[1] = s + e,
        l[1] = r,
        this
    }
}
const nG = new Float32Array(1);
class rG extends ql {
    constructor(e) {
        super(),
        this._root = e,
        this._initMemoryManager(),
        this._accuIndex = 0,
        this.time = 0,
        this.timeScale = 1
    }
    _bindAction(e, t) {
        const r = e._localRoot || this._root
          , i = e._clip.tracks
          , s = i.length
          , o = e._propertyBindings
          , a = e._interpolants
          , l = r.uuid
          , f = this._bindingsByRootAndName;
        let h = f[l];
        h === void 0 && (h = {},
        f[l] = h);
        for (let d = 0; d !== s; ++d) {
            const p = i[d]
              , m = p.name;
            let _ = h[m];
            if (_ !== void 0)
                ++_.referenceCount,
                o[d] = _;
            else {
                if (_ = o[d],
                _ !== void 0) {
                    _._cacheIndex === null && (++_.referenceCount,
                    this._addInactiveBinding(_, l, m));
                    continue
                }
                const y = t && t._propertyBindings[d].binding.parsedPath;
                _ = new j3(hr.create(r, m, y),p.ValueTypeName,p.getValueSize()),
                ++_.referenceCount,
                this._addInactiveBinding(_, l, m),
                o[d] = _
            }
            a[d].resultBuffer = _.buffer
        }
    }
    _activateAction(e) {
        if (!this._isActiveAction(e)) {
            if (e._cacheIndex === null) {
                const r = (e._localRoot || this._root).uuid
                  , i = e._clip.uuid
                  , s = this._actionsByClip[i];
                this._bindAction(e, s && s.knownActions[0]),
                this._addInactiveAction(e, i, r)
            }
            const t = e._propertyBindings;
            for (let r = 0, i = t.length; r !== i; ++r) {
                const s = t[r];
                s.useCount++ === 0 && (this._lendBinding(s),
                s.saveOriginalState())
            }
            this._lendAction(e)
        }
    }
    _deactivateAction(e) {
        if (this._isActiveAction(e)) {
            const t = e._propertyBindings;
            for (let r = 0, i = t.length; r !== i; ++r) {
                const s = t[r];
                --s.useCount === 0 && (s.restoreOriginalState(),
                this._takeBackBinding(s))
            }
            this._takeBackAction(e)
        }
    }
    _initMemoryManager() {
        this._actions = [],
        this._nActiveActions = 0,
        this._actionsByClip = {},
        this._bindings = [],
        this._nActiveBindings = 0,
        this._bindingsByRootAndName = {},
        this._controlInterpolants = [],
        this._nActiveControlInterpolants = 0;
        const e = this;
        this.stats = {
            actions: {
                get total() {
                    return e._actions.length
                },
                get inUse() {
                    return e._nActiveActions
                }
            },
            bindings: {
                get total() {
                    return e._bindings.length
                },
                get inUse() {
                    return e._nActiveBindings
                }
            },
            controlInterpolants: {
                get total() {
                    return e._controlInterpolants.length
                },
                get inUse() {
                    return e._nActiveControlInterpolants
                }
            }
        }
    }
    _isActiveAction(e) {
        const t = e._cacheIndex;
        return t !== null && t < this._nActiveActions
    }
    _addInactiveAction(e, t, r) {
        const i = this._actions
          , s = this._actionsByClip;
        let o = s[t];
        if (o === void 0)
            o = {
                knownActions: [e],
                actionByRoot: {}
            },
            e._byClipCacheIndex = 0,
            s[t] = o;
        else {
            const a = o.knownActions;
            e._byClipCacheIndex = a.length,
            a.push(e)
        }
        e._cacheIndex = i.length,
        i.push(e),
        o.actionByRoot[r] = e
    }
    _removeInactiveAction(e) {
        const t = this._actions
          , r = t[t.length - 1]
          , i = e._cacheIndex;
        r._cacheIndex = i,
        t[i] = r,
        t.pop(),
        e._cacheIndex = null;
        const s = e._clip.uuid
          , o = this._actionsByClip
          , a = o[s]
          , l = a.knownActions
          , f = l[l.length - 1]
          , h = e._byClipCacheIndex;
        f._byClipCacheIndex = h,
        l[h] = f,
        l.pop(),
        e._byClipCacheIndex = null;
        const d = a.actionByRoot
          , p = (e._localRoot || this._root).uuid;
        delete d[p],
        l.length === 0 && delete o[s],
        this._removeInactiveBindingsForAction(e)
    }
    _removeInactiveBindingsForAction(e) {
        const t = e._propertyBindings;
        for (let r = 0, i = t.length; r !== i; ++r) {
            const s = t[r];
            --s.referenceCount === 0 && this._removeInactiveBinding(s)
        }
    }
    _lendAction(e) {
        const t = this._actions
          , r = e._cacheIndex
          , i = this._nActiveActions++
          , s = t[i];
        e._cacheIndex = i,
        t[i] = e,
        s._cacheIndex = r,
        t[r] = s
    }
    _takeBackAction(e) {
        const t = this._actions
          , r = e._cacheIndex
          , i = --this._nActiveActions
          , s = t[i];
        e._cacheIndex = i,
        t[i] = e,
        s._cacheIndex = r,
        t[r] = s
    }
    _addInactiveBinding(e, t, r) {
        const i = this._bindingsByRootAndName
          , s = this._bindings;
        let o = i[t];
        o === void 0 && (o = {},
        i[t] = o),
        o[r] = e,
        e._cacheIndex = s.length,
        s.push(e)
    }
    _removeInactiveBinding(e) {
        const t = this._bindings
          , r = e.binding
          , i = r.rootNode.uuid
          , s = r.path
          , o = this._bindingsByRootAndName
          , a = o[i]
          , l = t[t.length - 1]
          , f = e._cacheIndex;
        l._cacheIndex = f,
        t[f] = l,
        t.pop(),
        delete a[s],
        Object.keys(a).length === 0 && delete o[i]
    }
    _lendBinding(e) {
        const t = this._bindings
          , r = e._cacheIndex
          , i = this._nActiveBindings++
          , s = t[i];
        e._cacheIndex = i,
        t[i] = e,
        s._cacheIndex = r,
        t[r] = s
    }
    _takeBackBinding(e) {
        const t = this._bindings
          , r = e._cacheIndex
          , i = --this._nActiveBindings
          , s = t[i];
        e._cacheIndex = i,
        t[i] = e,
        s._cacheIndex = r,
        t[r] = s
    }
    _lendControlInterpolant() {
        const e = this._controlInterpolants
          , t = this._nActiveControlInterpolants++;
        let r = e[t];
        return r === void 0 && (r = new cM(new Float32Array(2),new Float32Array(2),1,nG),
        r.__cacheIndex = t,
        e[t] = r),
        r
    }
    _takeBackControlInterpolant(e) {
        const t = this._controlInterpolants
          , r = e.__cacheIndex
          , i = --this._nActiveControlInterpolants
          , s = t[i];
        e.__cacheIndex = i,
        t[i] = e,
        s.__cacheIndex = r,
        t[r] = s
    }
    clipAction(e, t, r) {
        const i = t || this._root
          , s = i.uuid;
        let o = typeof e == "string" ? Mh.findByName(i, e) : e;
        const a = o !== null ? o.uuid : e
          , l = this._actionsByClip[a];
        let f = null;
        if (r === void 0 && (o !== null ? r = o.blendMode : r = __),
        l !== void 0) {
            const d = l.actionByRoot[s];
            if (d !== void 0 && d.blendMode === r)
                return d;
            f = l.knownActions[0],
            o === null && (o = f._clip)
        }
        if (o === null)
            return null;
        const h = new tG(this,o,t,r);
        return this._bindAction(h, f),
        this._addInactiveAction(h, a, s),
        h
    }
    existingAction(e, t) {
        const r = t || this._root
          , i = r.uuid
          , s = typeof e == "string" ? Mh.findByName(r, e) : e
          , o = s ? s.uuid : e
          , a = this._actionsByClip[o];
        return a !== void 0 && a.actionByRoot[i] || null
    }
    stopAllAction() {
        const e = this._actions
          , t = this._nActiveActions;
        for (let r = t - 1; r >= 0; --r)
            e[r].stop();
        return this
    }
    update(e) {
        e *= this.timeScale;
        const t = this._actions
          , r = this._nActiveActions
          , i = this.time += e
          , s = Math.sign(e)
          , o = this._accuIndex ^= 1;
        for (let f = 0; f !== r; ++f)
            t[f]._update(i, e, s, o);
        const a = this._bindings
          , l = this._nActiveBindings;
        for (let f = 0; f !== l; ++f)
            a[f].apply(o);
        return this
    }
    setTime(e) {
        this.time = 0;
        for (let t = 0; t < this._actions.length; t++)
            this._actions[t].time = 0;
        return this.update(e)
    }
    getRoot() {
        return this._root
    }
    uncacheClip(e) {
        const t = this._actions
          , r = e.uuid
          , i = this._actionsByClip
          , s = i[r];
        if (s !== void 0) {
            const o = s.knownActions;
            for (let a = 0, l = o.length; a !== l; ++a) {
                const f = o[a];
                this._deactivateAction(f);
                const h = f._cacheIndex
                  , d = t[t.length - 1];
                f._cacheIndex = null,
                f._byClipCacheIndex = null,
                d._cacheIndex = h,
                t[h] = d,
                t.pop(),
                this._removeInactiveBindingsForAction(f)
            }
            delete i[r]
        }
    }
    uncacheRoot(e) {
        const t = e.uuid
          , r = this._actionsByClip;
        for (const o in r) {
            const a = r[o].actionByRoot
              , l = a[t];
            l !== void 0 && (this._deactivateAction(l),
            this._removeInactiveAction(l))
        }
        const i = this._bindingsByRootAndName
          , s = i[t];
        if (s !== void 0)
            for (const o in s) {
                const a = s[o];
                a.restoreOriginalState(),
                this._removeInactiveBinding(a)
            }
    }
    uncacheAction(e, t) {
        const r = this.existingAction(e, t);
        r !== null && (this._deactivateAction(r),
        this._removeInactiveAction(r))
    }
}
class wM {
    constructor(e) {
        this.value = e
    }
    clone() {
        return new wM(this.value.clone === void 0 ? this.value : this.value.clone())
    }
}
let iG = 0;
class sG extends ql {
    constructor() {
        super(),
        this.isUniformsGroup = !0,
        Object.defineProperty(this, "id", {
            value: iG++
        }),
        this.name = "",
        this.usage = gm,
        this.uniforms = []
    }
    add(e) {
        return this.uniforms.push(e),
        this
    }
    remove(e) {
        const t = this.uniforms.indexOf(e);
        return t !== -1 && this.uniforms.splice(t, 1),
        this
    }
    setName(e) {
        return this.name = e,
        this
    }
    setUsage(e) {
        return this.usage = e,
        this
    }
    dispose() {
        return this.dispatchEvent({
            type: "dispose"
        }),
        this
    }
    copy(e) {
        this.name = e.name,
        this.usage = e.usage;
        const t = e.uniforms;
        this.uniforms.length = 0;
        for (let r = 0, i = t.length; r < i; r++)
            this.uniforms.push(t[r].clone());
        return this
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
class oG extends zm {
    constructor(e, t, r=1) {
        super(e, t),
        this.isInstancedInterleavedBuffer = !0,
        this.meshPerAttribute = r
    }
    copy(e) {
        return super.copy(e),
        this.meshPerAttribute = e.meshPerAttribute,
        this
    }
    clone(e) {
        const t = super.clone(e);
        return t.meshPerAttribute = this.meshPerAttribute,
        t
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return t.isInstancedInterleavedBuffer = !0,
        t.meshPerAttribute = this.meshPerAttribute,
        t
    }
}
class aG {
    constructor(e, t, r, i, s) {
        this.isGLBufferAttribute = !0,
        this.name = "",
        this.buffer = e,
        this.type = t,
        this.itemSize = r,
        this.elementSize = i,
        this.count = s,
        this.version = 0
    }
    set needsUpdate(e) {
        e === !0 && this.version++
    }
    setBuffer(e) {
        return this.buffer = e,
        this
    }
    setType(e, t) {
        return this.type = e,
        this.elementSize = t,
        this
    }
    setItemSize(e) {
        return this.itemSize = e,
        this
    }
    setCount(e) {
        return this.count = e,
        this
    }
}
class SM {
    constructor(e, t, r=0, i=1 / 0) {
        this.ray = new Fm(e,t),
        this.near = r,
        this.far = i,
        this.camera = null,
        this.layers = new Rf,
        this.params = {
            Mesh: {},
            Line: {
                threshold: 1
            },
            LOD: {},
            Points: {
                threshold: 1
            },
            Sprite: {}
        }
    }
    set(e, t) {
        this.ray.set(e, t)
    }
    setFromCamera(e, t) {
        t.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld),
        this.ray.direction.set(e.x, e.y, .5).unproject(t).sub(this.ray.origin).normalize(),
        this.camera = t) : t.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (t.near + t.far) / (t.near - t.far)).unproject(t),
        this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld),
        this.camera = t) : console.error("THREE.Raycaster: Unsupported camera type: " + t.type)
    }
    intersectObject(e, t=!0, r=[]) {
        return vw(e, this, r, t),
        r.sort(IE),
        r
    }
    intersectObjects(e, t=!0, r=[]) {
        for (let i = 0, s = e.length; i < s; i++)
            vw(e[i], this, r, t);
        return r.sort(IE),
        r
    }
}
function IE(n, e) {
    return n.distance - e.distance
}
function vw(n, e, t, r) {
    if (n.layers.test(e.layers) && n.raycast(e, t),
    r === !0) {
        const i = n.children;
        for (let s = 0, o = i.length; s < o; s++)
            vw(i[s], e, t, !0)
    }
}
class _w {
    constructor(e=1, t=0, r=0) {
        return this.radius = e,
        this.phi = t,
        this.theta = r,
        this
    }
    set(e, t, r) {
        return this.radius = e,
        this.phi = t,
        this.theta = r,
        this
    }
    copy(e) {
        return this.radius = e.radius,
        this.phi = e.phi,
        this.theta = e.theta,
        this
    }
    makeSafe() {
        return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)),
        this
    }
    setFromVector3(e) {
        return this.setFromCartesianCoords(e.x, e.y, e.z)
    }
    setFromCartesianCoords(e, t, r) {
        return this.radius = Math.sqrt(e * e + t * t + r * r),
        this.radius === 0 ? (this.theta = 0,
        this.phi = 0) : (this.theta = Math.atan2(e, r),
        this.phi = Math.acos($i(t / this.radius, -1, 1))),
        this
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
class lG {
    constructor(e=1, t=0, r=0) {
        return this.radius = e,
        this.theta = t,
        this.y = r,
        this
    }
    set(e, t, r) {
        return this.radius = e,
        this.theta = t,
        this.y = r,
        this
    }
    copy(e) {
        return this.radius = e.radius,
        this.theta = e.theta,
        this.y = e.y,
        this
    }
    setFromVector3(e) {
        return this.setFromCartesianCoords(e.x, e.y, e.z)
    }
    setFromCartesianCoords(e, t, r) {
        return this.radius = Math.sqrt(e * e + r * r),
        this.theta = Math.atan2(e, r),
        this.y = t,
        this
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
const LE = new it;
class uG {
    constructor(e=new it(1 / 0,1 / 0), t=new it(-1 / 0,-1 / 0)) {
        this.isBox2 = !0,
        this.min = e,
        this.max = t
    }
    set(e, t) {
        return this.min.copy(e),
        this.max.copy(t),
        this
    }
    setFromPoints(e) {
        this.makeEmpty();
        for (let t = 0, r = e.length; t < r; t++)
            this.expandByPoint(e[t]);
        return this
    }
    setFromCenterAndSize(e, t) {
        const r = LE.copy(t).multiplyScalar(.5);
        return this.min.copy(e).sub(r),
        this.max.copy(e).add(r),
        this
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        return this.min.copy(e.min),
        this.max.copy(e.max),
        this
    }
    makeEmpty() {
        return this.min.x = this.min.y = 1 / 0,
        this.max.x = this.max.y = -1 / 0,
        this
    }
    isEmpty() {
        return this.max.x < this.min.x || this.max.y < this.min.y
    }
    getCenter(e) {
        return this.isEmpty() ? e.set(0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
    }
    getSize(e) {
        return this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min)
    }
    expandByPoint(e) {
        return this.min.min(e),
        this.max.max(e),
        this
    }
    expandByVector(e) {
        return this.min.sub(e),
        this.max.add(e),
        this
    }
    expandByScalar(e) {
        return this.min.addScalar(-e),
        this.max.addScalar(e),
        this
    }
    containsPoint(e) {
        return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y)
    }
    containsBox(e) {
        return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y
    }
    getParameter(e, t) {
        return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y))
    }
    intersectsBox(e) {
        return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y)
    }
    clampPoint(e, t) {
        return t.copy(e).clamp(this.min, this.max)
    }
    distanceToPoint(e) {
        return LE.copy(e).clamp(this.min, this.max).sub(e).length()
    }
    intersect(e) {
        return this.min.max(e.min),
        this.max.min(e.max),
        this
    }
    union(e) {
        return this.min.min(e.min),
        this.max.max(e.max),
        this
    }
    translate(e) {
        return this.min.add(e),
        this.max.add(e),
        this
    }
    equals(e) {
        return e.min.equals(this.min) && e.max.equals(this.max)
    }
}
const FE = new $
  , m0 = new $;
class cG {
    constructor(e=new $, t=new $) {
        this.start = e,
        this.end = t
    }
    set(e, t) {
        return this.start.copy(e),
        this.end.copy(t),
        this
    }
    copy(e) {
        return this.start.copy(e.start),
        this.end.copy(e.end),
        this
    }
    getCenter(e) {
        return e.addVectors(this.start, this.end).multiplyScalar(.5)
    }
    delta(e) {
        return e.subVectors(this.end, this.start)
    }
    distanceSq() {
        return this.start.distanceToSquared(this.end)
    }
    distance() {
        return this.start.distanceTo(this.end)
    }
    at(e, t) {
        return this.delta(t).multiplyScalar(e).add(this.start)
    }
    closestPointToPointParameter(e, t) {
        FE.subVectors(e, this.start),
        m0.subVectors(this.end, this.start);
        const r = m0.dot(m0);
        let s = m0.dot(FE) / r;
        return t && (s = $i(s, 0, 1)),
        s
    }
    closestPointToPoint(e, t, r) {
        const i = this.closestPointToPointParameter(e, t);
        return this.delta(r).multiplyScalar(i).add(this.start)
    }
    applyMatrix4(e) {
        return this.start.applyMatrix4(e),
        this.end.applyMatrix4(e),
        this
    }
    equals(e) {
        return e.start.equals(this.start) && e.end.equals(this.end)
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
const kE = new $;
class fG extends wr {
    constructor(e, t) {
        super(),
        this.light = e,
        this.matrix = e.matrixWorld,
        this.matrixAutoUpdate = !1,
        this.color = t,
        this.type = "SpotLightHelper";
        const r = new On
          , i = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1];
        for (let o = 0, a = 1, l = 32; o < l; o++,
        a++) {
            const f = o / l * Math.PI * 2
              , h = a / l * Math.PI * 2;
            i.push(Math.cos(f), Math.sin(f), 1, Math.cos(h), Math.sin(h), 1)
        }
        r.setAttribute("position", new nn(i,3));
        const s = new lo({
            fog: !1,
            toneMapped: !1
        });
        this.cone = new Tl(r,s),
        this.add(this.cone),
        this.update()
    }
    dispose() {
        this.cone.geometry.dispose(),
        this.cone.material.dispose()
    }
    update() {
        this.light.updateWorldMatrix(!0, !1),
        this.light.target.updateWorldMatrix(!0, !1);
        const e = this.light.distance ? this.light.distance : 1e3
          , t = e * Math.tan(this.light.angle);
        this.cone.scale.set(t, t, e),
        kE.setFromMatrixPosition(this.light.target.matrixWorld),
        this.cone.lookAt(kE),
        this.color !== void 0 ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color)
    }
}
const Zu = new $
  , g0 = new Dn
  , hx = new Dn;
class dG extends Tl {
    constructor(e) {
        const t = Y3(e)
          , r = new On
          , i = []
          , s = []
          , o = new It(0,0,1)
          , a = new It(0,1,0);
        for (let f = 0; f < t.length; f++) {
            const h = t[f];
            h.parent && h.parent.isBone && (i.push(0, 0, 0),
            i.push(0, 0, 0),
            s.push(o.r, o.g, o.b),
            s.push(a.r, a.g, a.b))
        }
        r.setAttribute("position", new nn(i,3)),
        r.setAttribute("color", new nn(s,3));
        const l = new lo({
            vertexColors: !0,
            depthTest: !1,
            depthWrite: !1,
            toneMapped: !1,
            transparent: !0
        });
        super(r, l),
        this.isSkeletonHelper = !0,
        this.type = "SkeletonHelper",
        this.root = e,
        this.bones = t,
        this.matrix = e.matrixWorld,
        this.matrixAutoUpdate = !1
    }
    updateMatrixWorld(e) {
        const t = this.bones
          , r = this.geometry
          , i = r.getAttribute("position");
        hx.copy(this.root.matrixWorld).invert();
        for (let s = 0, o = 0; s < t.length; s++) {
            const a = t[s];
            a.parent && a.parent.isBone && (g0.multiplyMatrices(hx, a.matrixWorld),
            Zu.setFromMatrixPosition(g0),
            i.setXYZ(o, Zu.x, Zu.y, Zu.z),
            g0.multiplyMatrices(hx, a.parent.matrixWorld),
            Zu.setFromMatrixPosition(g0),
            i.setXYZ(o + 1, Zu.x, Zu.y, Zu.z),
            o += 2)
        }
        r.getAttribute("position").needsUpdate = !0,
        super.updateMatrixWorld(e)
    }
    dispose() {
        this.geometry.dispose(),
        this.material.dispose()
    }
}
function Y3(n) {
    const e = [];
    n.isBone === !0 && e.push(n);
    for (let t = 0; t < n.children.length; t++)
        e.push.apply(e, Y3(n.children[t]));
    return e
}
class hG extends vs {
    constructor(e, t, r) {
        const i = new Fh(t,4,2)
          , s = new xa({
            wireframe: !0,
            fog: !1,
            toneMapped: !1
        });
        super(i, s),
        this.light = e,
        this.color = r,
        this.type = "PointLightHelper",
        this.matrix = this.light.matrixWorld,
        this.matrixAutoUpdate = !1,
        this.update()
    }
    dispose() {
        this.geometry.dispose(),
        this.material.dispose()
    }
    update() {
        this.light.updateWorldMatrix(!0, !1),
        this.color !== void 0 ? this.material.color.set(this.color) : this.material.color.copy(this.light.color)
    }
}
const pG = new $
  , OE = new It
  , NE = new It;
class mG extends wr {
    constructor(e, t, r) {
        super(),
        this.light = e,
        this.matrix = e.matrixWorld,
        this.matrixAutoUpdate = !1,
        this.color = r,
        this.type = "HemisphereLightHelper";
        const i = new Lh(t);
        i.rotateY(Math.PI * .5),
        this.material = new xa({
            wireframe: !0,
            fog: !1,
            toneMapped: !1
        }),
        this.color === void 0 && (this.material.vertexColors = !0);
        const s = i.getAttribute("position")
          , o = new Float32Array(s.count * 3);
        i.setAttribute("color", new Dr(o,3)),
        this.add(new vs(i,this.material)),
        this.update()
    }
    dispose() {
        this.children[0].geometry.dispose(),
        this.children[0].material.dispose()
    }
    update() {
        const e = this.children[0];
        if (this.color !== void 0)
            this.material.color.set(this.color);
        else {
            const t = e.geometry.getAttribute("color");
            OE.copy(this.light.color),
            NE.copy(this.light.groundColor);
            for (let r = 0, i = t.count; r < i; r++) {
                const s = r < i / 2 ? OE : NE;
                t.setXYZ(r, s.r, s.g, s.b)
            }
            t.needsUpdate = !0
        }
        this.light.updateWorldMatrix(!0, !1),
        e.lookAt(pG.setFromMatrixPosition(this.light.matrixWorld).negate())
    }
}
class gG extends Tl {
    constructor(e=10, t=10, r=4473924, i=8947848) {
        r = new It(r),
        i = new It(i);
        const s = t / 2
          , o = e / t
          , a = e / 2
          , l = []
          , f = [];
        for (let p = 0, m = 0, _ = -a; p <= t; p++,
        _ += o) {
            l.push(-a, 0, _, a, 0, _),
            l.push(_, 0, -a, _, 0, a);
            const y = p === s ? r : i;
            y.toArray(f, m),
            m += 3,
            y.toArray(f, m),
            m += 3,
            y.toArray(f, m),
            m += 3,
            y.toArray(f, m),
            m += 3
        }
        const h = new On;
        h.setAttribute("position", new nn(l,3)),
        h.setAttribute("color", new nn(f,3));
        const d = new lo({
            vertexColors: !0,
            toneMapped: !1
        });
        super(h, d),
        this.type = "GridHelper"
    }
    dispose() {
        this.geometry.dispose(),
        this.material.dispose()
    }
}
class vG extends Tl {
    constructor(e=10, t=16, r=8, i=64, s=4473924, o=8947848) {
        s = new It(s),
        o = new It(o);
        const a = []
          , l = [];
        if (t > 1)
            for (let d = 0; d < t; d++) {
                const p = d / t * (Math.PI * 2)
                  , m = Math.sin(p) * e
                  , _ = Math.cos(p) * e;
                a.push(0, 0, 0),
                a.push(m, 0, _);
                const y = d & 1 ? s : o;
                l.push(y.r, y.g, y.b),
                l.push(y.r, y.g, y.b)
            }
        for (let d = 0; d < r; d++) {
            const p = d & 1 ? s : o
              , m = e - e / r * d;
            for (let _ = 0; _ < i; _++) {
                let y = _ / i * (Math.PI * 2)
                  , x = Math.sin(y) * m
                  , S = Math.cos(y) * m;
                a.push(x, 0, S),
                l.push(p.r, p.g, p.b),
                y = (_ + 1) / i * (Math.PI * 2),
                x = Math.sin(y) * m,
                S = Math.cos(y) * m,
                a.push(x, 0, S),
                l.push(p.r, p.g, p.b)
            }
        }
        const f = new On;
        f.setAttribute("position", new nn(a,3)),
        f.setAttribute("color", new nn(l,3));
        const h = new lo({
            vertexColors: !0,
            toneMapped: !1
        });
        super(f, h),
        this.type = "PolarGridHelper"
    }
    dispose() {
        this.geometry.dispose(),
        this.material.dispose()
    }
}
const zE = new $
  , v0 = new $
  , GE = new $;
class _G extends wr {
    constructor(e, t, r) {
        super(),
        this.light = e,
        this.matrix = e.matrixWorld,
        this.matrixAutoUpdate = !1,
        this.color = r,
        this.type = "DirectionalLightHelper",
        t === void 0 && (t = 1);
        let i = new On;
        i.setAttribute("position", new nn([-t, t, 0, t, t, 0, t, -t, 0, -t, -t, 0, -t, t, 0],3));
        const s = new lo({
            fog: !1,
            toneMapped: !1
        });
        this.lightPlane = new Du(i,s),
        this.add(this.lightPlane),
        i = new On,
        i.setAttribute("position", new nn([0, 0, 0, 0, 0, 1],3)),
        this.targetLine = new Du(i,s),
        this.add(this.targetLine),
        this.update()
    }
    dispose() {
        this.lightPlane.geometry.dispose(),
        this.lightPlane.material.dispose(),
        this.targetLine.geometry.dispose(),
        this.targetLine.material.dispose()
    }
    update() {
        this.light.updateWorldMatrix(!0, !1),
        this.light.target.updateWorldMatrix(!0, !1),
        zE.setFromMatrixPosition(this.light.matrixWorld),
        v0.setFromMatrixPosition(this.light.target.matrixWorld),
        GE.subVectors(v0, zE),
        this.lightPlane.lookAt(v0),
        this.color !== void 0 ? (this.lightPlane.material.color.set(this.color),
        this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color),
        this.targetLine.material.color.copy(this.light.color)),
        this.targetLine.lookAt(v0),
        this.targetLine.scale.z = GE.length()
    }
}
const _0 = new $
  , Vi = new Om;
class yG extends Tl {
    constructor(e) {
        const t = new On
          , r = new lo({
            color: 16777215,
            vertexColors: !0,
            toneMapped: !1
        })
          , i = []
          , s = []
          , o = {};
        a("n1", "n2"),
        a("n2", "n4"),
        a("n4", "n3"),
        a("n3", "n1"),
        a("f1", "f2"),
        a("f2", "f4"),
        a("f4", "f3"),
        a("f3", "f1"),
        a("n1", "f1"),
        a("n2", "f2"),
        a("n3", "f3"),
        a("n4", "f4"),
        a("p", "n1"),
        a("p", "n2"),
        a("p", "n3"),
        a("p", "n4"),
        a("u1", "u2"),
        a("u2", "u3"),
        a("u3", "u1"),
        a("c", "t"),
        a("p", "c"),
        a("cn1", "cn2"),
        a("cn3", "cn4"),
        a("cf1", "cf2"),
        a("cf3", "cf4");
        function a(_, y) {
            l(_),
            l(y)
        }
        function l(_) {
            i.push(0, 0, 0),
            s.push(0, 0, 0),
            o[_] === void 0 && (o[_] = []),
            o[_].push(i.length / 3 - 1)
        }
        t.setAttribute("position", new nn(i,3)),
        t.setAttribute("color", new nn(s,3)),
        super(t, r),
        this.type = "CameraHelper",
        this.camera = e,
        this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(),
        this.matrix = e.matrixWorld,
        this.matrixAutoUpdate = !1,
        this.pointMap = o,
        this.update();
        const f = new It(16755200)
          , h = new It(16711680)
          , d = new It(43775)
          , p = new It(16777215)
          , m = new It(3355443);
        this.setColors(f, h, d, p, m)
    }
    setColors(e, t, r, i, s) {
        const a = this.geometry.getAttribute("color");
        a.setXYZ(0, e.r, e.g, e.b),
        a.setXYZ(1, e.r, e.g, e.b),
        a.setXYZ(2, e.r, e.g, e.b),
        a.setXYZ(3, e.r, e.g, e.b),
        a.setXYZ(4, e.r, e.g, e.b),
        a.setXYZ(5, e.r, e.g, e.b),
        a.setXYZ(6, e.r, e.g, e.b),
        a.setXYZ(7, e.r, e.g, e.b),
        a.setXYZ(8, e.r, e.g, e.b),
        a.setXYZ(9, e.r, e.g, e.b),
        a.setXYZ(10, e.r, e.g, e.b),
        a.setXYZ(11, e.r, e.g, e.b),
        a.setXYZ(12, e.r, e.g, e.b),
        a.setXYZ(13, e.r, e.g, e.b),
        a.setXYZ(14, e.r, e.g, e.b),
        a.setXYZ(15, e.r, e.g, e.b),
        a.setXYZ(16, e.r, e.g, e.b),
        a.setXYZ(17, e.r, e.g, e.b),
        a.setXYZ(18, e.r, e.g, e.b),
        a.setXYZ(19, e.r, e.g, e.b),
        a.setXYZ(20, e.r, e.g, e.b),
        a.setXYZ(21, e.r, e.g, e.b),
        a.setXYZ(22, e.r, e.g, e.b),
        a.setXYZ(23, e.r, e.g, e.b),
        a.setXYZ(24, t.r, t.g, t.b),
        a.setXYZ(25, t.r, t.g, t.b),
        a.setXYZ(26, t.r, t.g, t.b),
        a.setXYZ(27, t.r, t.g, t.b),
        a.setXYZ(28, t.r, t.g, t.b),
        a.setXYZ(29, t.r, t.g, t.b),
        a.setXYZ(30, t.r, t.g, t.b),
        a.setXYZ(31, t.r, t.g, t.b),
        a.setXYZ(32, r.r, r.g, r.b),
        a.setXYZ(33, r.r, r.g, r.b),
        a.setXYZ(34, r.r, r.g, r.b),
        a.setXYZ(35, r.r, r.g, r.b),
        a.setXYZ(36, r.r, r.g, r.b),
        a.setXYZ(37, r.r, r.g, r.b),
        a.setXYZ(38, i.r, i.g, i.b),
        a.setXYZ(39, i.r, i.g, i.b),
        a.setXYZ(40, s.r, s.g, s.b),
        a.setXYZ(41, s.r, s.g, s.b),
        a.setXYZ(42, s.r, s.g, s.b),
        a.setXYZ(43, s.r, s.g, s.b),
        a.setXYZ(44, s.r, s.g, s.b),
        a.setXYZ(45, s.r, s.g, s.b),
        a.setXYZ(46, s.r, s.g, s.b),
        a.setXYZ(47, s.r, s.g, s.b),
        a.setXYZ(48, s.r, s.g, s.b),
        a.setXYZ(49, s.r, s.g, s.b),
        a.needsUpdate = !0
    }
    update() {
        const e = this.geometry
          , t = this.pointMap
          , r = 1
          , i = 1;
        Vi.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse),
        qi("c", t, e, Vi, 0, 0, -1),
        qi("t", t, e, Vi, 0, 0, 1),
        qi("n1", t, e, Vi, -r, -i, -1),
        qi("n2", t, e, Vi, r, -i, -1),
        qi("n3", t, e, Vi, -r, i, -1),
        qi("n4", t, e, Vi, r, i, -1),
        qi("f1", t, e, Vi, -r, -i, 1),
        qi("f2", t, e, Vi, r, -i, 1),
        qi("f3", t, e, Vi, -r, i, 1),
        qi("f4", t, e, Vi, r, i, 1),
        qi("u1", t, e, Vi, r * .7, i * 1.1, -1),
        qi("u2", t, e, Vi, -r * .7, i * 1.1, -1),
        qi("u3", t, e, Vi, 0, i * 2, -1),
        qi("cf1", t, e, Vi, -r, 0, 1),
        qi("cf2", t, e, Vi, r, 0, 1),
        qi("cf3", t, e, Vi, 0, -i, 1),
        qi("cf4", t, e, Vi, 0, i, 1),
        qi("cn1", t, e, Vi, -r, 0, -1),
        qi("cn2", t, e, Vi, r, 0, -1),
        qi("cn3", t, e, Vi, 0, -i, -1),
        qi("cn4", t, e, Vi, 0, i, -1),
        e.getAttribute("position").needsUpdate = !0
    }
    dispose() {
        this.geometry.dispose(),
        this.material.dispose()
    }
}
function qi(n, e, t, r, i, s, o) {
    _0.set(i, s, o).unproject(r);
    const a = e[n];
    if (a !== void 0) {
        const l = t.getAttribute("position");
        for (let f = 0, h = a.length; f < h; f++)
            l.setXYZ(a[f], _0.x, _0.y, _0.z)
    }
}
const y0 = new kc;
class xG extends Tl {
    constructor(e, t=16776960) {
        const r = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7])
          , i = new Float32Array(8 * 3)
          , s = new On;
        s.setIndex(new Dr(r,1)),
        s.setAttribute("position", new Dr(i,3)),
        super(s, new lo({
            color: t,
            toneMapped: !1
        })),
        this.object = e,
        this.type = "BoxHelper",
        this.matrixAutoUpdate = !1,
        this.update()
    }
    update(e) {
        if (e !== void 0 && console.warn("THREE.BoxHelper: .update() has no longer arguments."),
        this.object !== void 0 && y0.setFromObject(this.object),
        y0.isEmpty())
            return;
        const t = y0.min
          , r = y0.max
          , i = this.geometry.attributes.position
          , s = i.array;
        s[0] = r.x,
        s[1] = r.y,
        s[2] = r.z,
        s[3] = t.x,
        s[4] = r.y,
        s[5] = r.z,
        s[6] = t.x,
        s[7] = t.y,
        s[8] = r.z,
        s[9] = r.x,
        s[10] = t.y,
        s[11] = r.z,
        s[12] = r.x,
        s[13] = r.y,
        s[14] = t.z,
        s[15] = t.x,
        s[16] = r.y,
        s[17] = t.z,
        s[18] = t.x,
        s[19] = t.y,
        s[20] = t.z,
        s[21] = r.x,
        s[22] = t.y,
        s[23] = t.z,
        i.needsUpdate = !0,
        this.geometry.computeBoundingSphere()
    }
    setFromObject(e) {
        return this.object = e,
        this.update(),
        this
    }
    copy(e, t) {
        return super.copy(e, t),
        this.object = e.object,
        this
    }
    dispose() {
        this.geometry.dispose(),
        this.material.dispose()
    }
}
class wG extends Tl {
    constructor(e, t=16776960) {
        const r = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7])
          , i = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1]
          , s = new On;
        s.setIndex(new Dr(r,1)),
        s.setAttribute("position", new nn(i,3)),
        super(s, new lo({
            color: t,
            toneMapped: !1
        })),
        this.box = e,
        this.type = "Box3Helper",
        this.geometry.computeBoundingSphere()
    }
    updateMatrixWorld(e) {
        const t = this.box;
        t.isEmpty() || (t.getCenter(this.position),
        t.getSize(this.scale),
        this.scale.multiplyScalar(.5),
        super.updateMatrixWorld(e))
    }
    dispose() {
        this.geometry.dispose(),
        this.material.dispose()
    }
}
class SG extends Du {
    constructor(e, t=1, r=16776960) {
        const i = r
          , s = [1, -1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0]
          , o = new On;
        o.setAttribute("position", new nn(s,3)),
        o.computeBoundingSphere(),
        super(o, new lo({
            color: i,
            toneMapped: !1
        })),
        this.type = "PlaneHelper",
        this.plane = e,
        this.size = t;
        const a = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0]
          , l = new On;
        l.setAttribute("position", new nn(a,3)),
        l.computeBoundingSphere(),
        this.add(new vs(l,new xa({
            color: i,
            opacity: .2,
            transparent: !0,
            depthWrite: !1,
            toneMapped: !1
        })))
    }
    updateMatrixWorld(e) {
        this.position.set(0, 0, 0),
        this.scale.set(.5 * this.size, .5 * this.size, 1),
        this.lookAt(this.plane.normal),
        this.translateZ(-this.plane.constant),
        super.updateMatrixWorld(e)
    }
    dispose() {
        this.geometry.dispose(),
        this.material.dispose(),
        this.children[0].geometry.dispose(),
        this.children[0].material.dispose()
    }
}
const UE = new $;
let x0, px;
class MG extends wr {
    constructor(e=new $(0,0,1), t=new $(0,0,0), r=1, i=16776960, s=r * .2, o=s * .2) {
        super(),
        this.type = "ArrowHelper",
        x0 === void 0 && (x0 = new On,
        x0.setAttribute("position", new nn([0, 0, 0, 0, 1, 0],3)),
        px = new Zf(0,.5,1,5,1),
        px.translate(0, -.5, 0)),
        this.position.copy(t),
        this.line = new Du(x0,new lo({
            color: i,
            toneMapped: !1
        })),
        this.line.matrixAutoUpdate = !1,
        this.add(this.line),
        this.cone = new vs(px,new xa({
            color: i,
            toneMapped: !1
        })),
        this.cone.matrixAutoUpdate = !1,
        this.add(this.cone),
        this.setDirection(e),
        this.setLength(r, s, o)
    }
    setDirection(e) {
        if (e.y > .99999)
            this.quaternion.set(0, 0, 0, 1);
        else if (e.y < -.99999)
            this.quaternion.set(1, 0, 0, 0);
        else {
            UE.set(e.z, 0, -e.x).normalize();
            const t = Math.acos(e.y);
            this.quaternion.setFromAxisAngle(UE, t)
        }
    }
    setLength(e, t=e * .2, r=t * .2) {
        this.line.scale.set(1, Math.max(1e-4, e - t), 1),
        this.line.updateMatrix(),
        this.cone.scale.set(r, t, r),
        this.cone.position.y = e,
        this.cone.updateMatrix()
    }
    setColor(e) {
        this.line.material.color.set(e),
        this.cone.material.color.set(e)
    }
    copy(e) {
        return super.copy(e, !1),
        this.line.copy(e.line),
        this.cone.copy(e.cone),
        this
    }
    dispose() {
        this.line.geometry.dispose(),
        this.line.material.dispose(),
        this.cone.geometry.dispose(),
        this.cone.material.dispose()
    }
}
class AG extends Tl {
    constructor(e=1) {
        const t = [0, 0, 0, e, 0, 0, 0, 0, 0, 0, e, 0, 0, 0, 0, 0, 0, e]
          , r = [1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1]
          , i = new On;
        i.setAttribute("position", new nn(t,3)),
        i.setAttribute("color", new nn(r,3));
        const s = new lo({
            vertexColors: !0,
            toneMapped: !1
        });
        super(i, s),
        this.type = "AxesHelper"
    }
    setColors(e, t, r) {
        const i = new It
          , s = this.geometry.attributes.color.array;
        return i.set(e),
        i.toArray(s, 0),
        i.toArray(s, 3),
        i.set(t),
        i.toArray(s, 6),
        i.toArray(s, 9),
        i.set(r),
        i.toArray(s, 12),
        i.toArray(s, 15),
        this.geometry.attributes.color.needsUpdate = !0,
        this
    }
    dispose() {
        this.geometry.dispose(),
        this.material.dispose()
    }
}
class CG {
    constructor() {
        this.type = "ShapePath",
        this.color = new It,
        this.subPaths = [],
        this.currentPath = null
    }
    moveTo(e, t) {
        return this.currentPath = new ym,
        this.subPaths.push(this.currentPath),
        this.currentPath.moveTo(e, t),
        this
    }
    lineTo(e, t) {
        return this.currentPath.lineTo(e, t),
        this
    }
    quadraticCurveTo(e, t, r, i) {
        return this.currentPath.quadraticCurveTo(e, t, r, i),
        this
    }
    bezierCurveTo(e, t, r, i, s, o) {
        return this.currentPath.bezierCurveTo(e, t, r, i, s, o),
        this
    }
    splineThru(e) {
        return this.currentPath.splineThru(e),
        this
    }
    toShapes(e) {
        function t(S) {
            const M = [];
            for (let w = 0, T = S.length; w < T; w++) {
                const P = S[w]
                  , I = new Bf;
                I.curves = P.curves,
                M.push(I)
            }
            return M
        }
        function r(S, M) {
            const w = M.length;
            let T = !1;
            for (let P = w - 1, I = 0; I < w; P = I++) {
                let k = M[P]
                  , R = M[I]
                  , O = R.x - k.x
                  , H = R.y - k.y;
                if (Math.abs(H) > Number.EPSILON) {
                    if (H < 0 && (k = M[I],
                    O = -O,
                    R = M[P],
                    H = -H),
                    S.y < k.y || S.y > R.y)
                        continue;
                    if (S.y === k.y) {
                        if (S.x === k.x)
                            return !0
                    } else {
                        const W = H * (S.x - k.x) - O * (S.y - k.y);
                        if (W === 0)
                            return !0;
                        if (W < 0)
                            continue;
                        T = !T
                    }
                } else {
                    if (S.y !== k.y)
                        continue;
                    if (R.x <= S.x && S.x <= k.x || k.x <= S.x && S.x <= R.x)
                        return !0
                }
            }
            return T
        }
        const i = Jl.isClockWise
          , s = this.subPaths;
        if (s.length === 0)
            return [];
        let o, a, l;
        const f = [];
        if (s.length === 1)
            return a = s[0],
            l = new Bf,
            l.curves = a.curves,
            f.push(l),
            f;
        let h = !i(s[0].getPoints());
        h = e ? !h : h;
        const d = []
          , p = [];
        let m = [], _ = 0, y;
        p[_] = void 0,
        m[_] = [];
        for (let S = 0, M = s.length; S < M; S++)
            a = s[S],
            y = a.getPoints(),
            o = i(y),
            o = e ? !o : o,
            o ? (!h && p[_] && _++,
            p[_] = {
                s: new Bf,
                p: y
            },
            p[_].s.curves = a.curves,
            h && _++,
            m[_] = []) : m[_].push({
                h: a,
                p: y[0]
            });
        if (!p[0])
            return t(s);
        if (p.length > 1) {
            let S = !1
              , M = 0;
            for (let w = 0, T = p.length; w < T; w++)
                d[w] = [];
            for (let w = 0, T = p.length; w < T; w++) {
                const P = m[w];
                for (let I = 0; I < P.length; I++) {
                    const k = P[I];
                    let R = !0;
                    for (let O = 0; O < p.length; O++)
                        r(k.p, p[O].p) && (w !== O && M++,
                        R ? (R = !1,
                        d[O].push(k)) : S = !0);
                    R && d[w].push(k)
                }
            }
            M > 0 && S === !1 && (m = d)
        }
        let x;
        for (let S = 0, M = p.length; S < M; S++) {
            l = p[S].s,
            f.push(l),
            x = m[S];
            for (let w = 0, T = x.length; w < T; w++)
                l.holes.push(x[w].h)
        }
        return f
    }
}
const du = EG();
function EG() {
    const n = new ArrayBuffer(4)
      , e = new Float32Array(n)
      , t = new Uint32Array(n)
      , r = new Uint32Array(512)
      , i = new Uint32Array(512);
    for (let l = 0; l < 256; ++l) {
        const f = l - 127;
        f < -27 ? (r[l] = 0,
        r[l | 256] = 32768,
        i[l] = 24,
        i[l | 256] = 24) : f < -14 ? (r[l] = 1024 >> -f - 14,
        r[l | 256] = 1024 >> -f - 14 | 32768,
        i[l] = -f - 1,
        i[l | 256] = -f - 1) : f <= 15 ? (r[l] = f + 15 << 10,
        r[l | 256] = f + 15 << 10 | 32768,
        i[l] = 13,
        i[l | 256] = 13) : f < 128 ? (r[l] = 31744,
        r[l | 256] = 64512,
        i[l] = 24,
        i[l | 256] = 24) : (r[l] = 31744,
        r[l | 256] = 64512,
        i[l] = 13,
        i[l | 256] = 13)
    }
    const s = new Uint32Array(2048)
      , o = new Uint32Array(64)
      , a = new Uint32Array(64);
    for (let l = 1; l < 1024; ++l) {
        let f = l << 13
          , h = 0;
        for (; !(f & 8388608); )
            f <<= 1,
            h -= 8388608;
        f &= -8388609,
        h += 947912704,
        s[l] = f | h
    }
    for (let l = 1024; l < 2048; ++l)
        s[l] = 939524096 + (l - 1024 << 13);
    for (let l = 1; l < 31; ++l)
        o[l] = l << 23;
    o[31] = 1199570944,
    o[32] = 2147483648;
    for (let l = 33; l < 63; ++l)
        o[l] = 2147483648 + (l - 32 << 23);
    o[63] = 3347054592;
    for (let l = 1; l < 64; ++l)
        l !== 32 && (a[l] = 1024);
    return {
        floatView: e,
        uint32View: t,
        baseTable: r,
        shiftTable: i,
        mantissaTable: s,
        exponentTable: o,
        offsetTable: a
    }
}
function bG(n) {
    Math.abs(n) > 65504 && console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."),
    n = $i(n, -65504, 65504),
    du.floatView[0] = n;
    const e = du.uint32View[0]
      , t = e >> 23 & 511;
    return du.baseTable[t] + ((e & 8388607) >> du.shiftTable[t])
}
function TG(n) {
    const e = n >> 10;
    return du.uint32View[0] = du.mantissaTable[du.offsetTable[e] + (n & 1023)] + du.exponentTable[e],
    du.floatView[0]
}
var Ap = Object.freeze({
    __proto__: null,
    fromHalfFloat: TG,
    toHalfFloat: bG
});
class DG extends Nc {
    constructor(e, t, r, i, s, o) {
        console.warn("THREE.BoxBufferGeometry has been renamed to THREE.BoxGeometry."),
        super(e, t, r, i, s, o)
    }
}
class PG extends Um {
    constructor(e, t, r, i) {
        console.warn("THREE.CapsuleBufferGeometry has been renamed to THREE.CapsuleGeometry."),
        super(e, t, r, i)
    }
}
class RG extends Hm {
    constructor(e, t, r, i) {
        console.warn("THREE.CircleBufferGeometry has been renamed to THREE.CircleGeometry."),
        super(e, t, r, i)
    }
}
class BG extends Vm {
    constructor(e, t, r, i, s, o, a) {
        console.warn("THREE.ConeBufferGeometry has been renamed to THREE.ConeGeometry."),
        super(e, t, r, i, s, o, a)
    }
}
class IG extends Zf {
    constructor(e, t, r, i, s, o, a, l) {
        console.warn("THREE.CylinderBufferGeometry has been renamed to THREE.CylinderGeometry."),
        super(e, t, r, i, s, o, a, l)
    }
}
class LG extends Wm {
    constructor(e, t) {
        console.warn("THREE.DodecahedronBufferGeometry has been renamed to THREE.DodecahedronGeometry."),
        super(e, t)
    }
}
class FG extends Xm {
    constructor(e, t) {
        console.warn("THREE.ExtrudeBufferGeometry has been renamed to THREE.ExtrudeGeometry."),
        super(e, t)
    }
}
class kG extends Ih {
    constructor(e, t) {
        console.warn("THREE.IcosahedronBufferGeometry has been renamed to THREE.IcosahedronGeometry."),
        super(e, t)
    }
}
class OG extends Bh {
    constructor(e, t, r, i) {
        console.warn("THREE.LatheBufferGeometry has been renamed to THREE.LatheGeometry."),
        super(e, t, r, i)
    }
}
class NG extends Lh {
    constructor(e, t) {
        console.warn("THREE.OctahedronBufferGeometry has been renamed to THREE.OctahedronGeometry."),
        super(e, t)
    }
}
class zG extends Ph {
    constructor(e, t, r, i) {
        console.warn("THREE.PlaneBufferGeometry has been renamed to THREE.PlaneGeometry."),
        super(e, t, r, i)
    }
}
class GG extends Bu {
    constructor(e, t, r, i) {
        console.warn("THREE.PolyhedronBufferGeometry has been renamed to THREE.PolyhedronGeometry."),
        super(e, t, r, i)
    }
}
class UG extends Jm {
    constructor(e, t, r, i, s, o) {
        console.warn("THREE.RingBufferGeometry has been renamed to THREE.RingGeometry."),
        super(e, t, r, i, s, o)
    }
}
class HG extends jm {
    constructor(e, t) {
        console.warn("THREE.ShapeBufferGeometry has been renamed to THREE.ShapeGeometry."),
        super(e, t)
    }
}
class VG extends Fh {
    constructor(e, t, r, i, s, o, a) {
        console.warn("THREE.SphereBufferGeometry has been renamed to THREE.SphereGeometry."),
        super(e, t, r, i, s, o, a)
    }
}
class WG extends Ym {
    constructor(e, t) {
        console.warn("THREE.TetrahedronBufferGeometry has been renamed to THREE.TetrahedronGeometry."),
        super(e, t)
    }
}
class XG extends Km {
    constructor(e, t, r, i, s) {
        console.warn("THREE.TorusBufferGeometry has been renamed to THREE.TorusGeometry."),
        super(e, t, r, i, s)
    }
}
class JG extends qm {
    constructor(e, t, r, i, s, o) {
        console.warn("THREE.TorusKnotBufferGeometry has been renamed to THREE.TorusKnotGeometry."),
        super(e, t, r, i, s, o)
    }
}
class jG extends Qm {
    constructor(e, t, r, i, s) {
        console.warn("THREE.TubeBufferGeometry has been renamed to THREE.TubeGeometry."),
        super(e, t, r, i, s)
    }
}
typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{
    detail: {
        revision: p_
    }
}));
typeof window < "u" && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = p_);
const Xv = Object.freeze(Object.defineProperty({
    __proto__: null,
    ACESFilmicToneMapping: FS,
    AddEquation: pf,
    AddOperation: M2,
    AdditiveAnimationBlendMode: OS,
    AdditiveBlending: F1,
    AlphaFormat: I2,
    AlwaysDepth: g2,
    AlwaysStencilFunc: q2,
    AmbientLight: G3,
    AmbientLightProbe: N4,
    AnimationClip: Mh,
    AnimationLoader: D4,
    AnimationMixer: rG,
    AnimationObjectGroup: eG,
    AnimationUtils: C4,
    ArcCurve: p3,
    ArrayCamera: l3,
    ArrowHelper: MG,
    Audio: J3,
    AudioAnalyser: W4,
    AudioContext: vM,
    AudioListener: U4,
    AudioLoader: k4,
    AxesHelper: AG,
    BackSide: Do,
    BasicDepthPacking: j2,
    BasicShadowMap: n2,
    Bone: E_,
    BooleanKeyframeTrack: $f,
    Box2: uG,
    Box3: kc,
    Box3Helper: wG,
    BoxBufferGeometry: DG,
    BoxGeometry: Nc,
    BoxHelper: xG,
    BufferAttribute: Dr,
    BufferGeometry: On,
    BufferGeometryLoader: W3,
    ByteType: T2,
    Cache: Wf,
    Camera: Om,
    CameraHelper: yG,
    CanvasTexture: Kz,
    CapsuleBufferGeometry: PG,
    CapsuleGeometry: Um,
    CatmullRomCurve3: m3,
    CineonToneMapping: E2,
    CircleBufferGeometry: RG,
    CircleGeometry: Hm,
    ClampToEdgeWrapping: Us,
    Clock: _M,
    Color: It,
    ColorKeyframeTrack: fM,
    ColorManagement: ro,
    CompressedArrayTexture: Yz,
    CompressedTexture: tM,
    CompressedTextureLoader: P4,
    ConeBufferGeometry: BG,
    ConeGeometry: Vm,
    CubeCamera: t3,
    CubeReflectionMapping: Tu,
    CubeRefractionMapping: Ec,
    CubeTexture: Nm,
    CubeTextureLoader: k3,
    CubeUVReflectionMapping: Dh,
    CubicBezierCurve: rM,
    CubicBezierCurve3: g3,
    CubicInterpolant: I3,
    CullFaceBack: L1,
    CullFaceFront: t2,
    CullFaceFrontBack: $I,
    CullFaceNone: e2,
    Curve: Dl,
    CurvePath: _3,
    CustomBlending: r2,
    CustomToneMapping: b2,
    CylinderBufferGeometry: IG,
    CylinderGeometry: Zf,
    Cylindrical: lG,
    Data3DTexture: US,
    DataArrayTexture: x_,
    DataTexture: sh,
    DataTextureLoader: O3,
    DataUtils: Ap,
    DecrementStencilOp: cL,
    DecrementWrapStencilOp: dL,
    DefaultLoadingManager: jd,
    DepthFormat: Sc,
    DepthStencilFormat: Uf,
    DepthTexture: KS,
    DirectionalLight: gM,
    DirectionalLightHelper: _G,
    DiscreteInterpolant: L3,
    DodecahedronBufferGeometry: LG,
    DodecahedronGeometry: Wm,
    DoubleSide: Sl,
    DstAlphaFactor: c2,
    DstColorFactor: d2,
    DynamicCopyUsage: bL,
    DynamicDrawUsage: wL,
    DynamicReadUsage: AL,
    EdgesGeometry: y3,
    EllipseCurve: T_,
    EqualDepth: _2,
    EqualStencilFunc: gL,
    EquirectangularReflectionMapping: mh,
    EquirectangularRefractionMapping: hm,
    Euler: km,
    EventDispatcher: ql,
    ExtrudeBufferGeometry: FG,
    ExtrudeGeometry: Xm,
    FileLoader: Aa,
    Float16BufferAttribute: aF,
    Float32BufferAttribute: nn,
    Float64BufferAttribute: lF,
    FloatType: ya,
    Fog: A_,
    FogExp2: M_,
    FramebufferTexture: jz,
    FrontSide: El,
    Frustum: w_,
    GLBufferAttribute: aG,
    GLSL1: DL,
    GLSL3: uw,
    GreaterDepth: x2,
    GreaterEqualDepth: y2,
    GreaterEqualStencilFunc: xL,
    GreaterStencilFunc: _L,
    GridHelper: gG,
    Group: _u,
    HalfFloatType: ja,
    HemisphereLight: z3,
    HemisphereLightHelper: mG,
    HemisphereLightProbe: O4,
    IcosahedronBufferGeometry: kG,
    IcosahedronGeometry: Ih,
    ImageBitmapLoader: X3,
    ImageLoader: Mm,
    ImageUtils: GS,
    IncrementStencilOp: uL,
    IncrementWrapStencilOp: fL,
    InstancedBufferAttribute: xh,
    InstancedBufferGeometry: V3,
    InstancedInterleavedBuffer: oG,
    InstancedMesh: h3,
    Int16BufferAttribute: sF,
    Int32BufferAttribute: oF,
    Int8BufferAttribute: nF,
    IntType: P2,
    InterleavedBuffer: zm,
    InterleavedBufferAttribute: Dc,
    Interpolant: Oh,
    InterpolateDiscrete: vh,
    InterpolateLinear: Hf,
    InterpolateSmooth: ov,
    InvertStencilOp: hL,
    KeepStencilOp: av,
    KeyframeTrack: Pl,
    LOD: d3,
    LatheBufferGeometry: OG,
    LatheGeometry: Bh,
    Layers: Rf,
    LessDepth: v2,
    LessEqualDepth: Hv,
    LessEqualStencilFunc: vL,
    LessStencilFunc: mL,
    Light: zc,
    LightProbe: R_,
    Line: Du,
    Line3: cG,
    LineBasicMaterial: lo,
    LineCurve: D_,
    LineCurve3: v3,
    LineDashedMaterial: R3,
    LineLoop: $S,
    LineSegments: Tl,
    LinearEncoding: bl,
    LinearFilter: si,
    LinearInterpolant: cM,
    LinearMipMapLinearFilter: iL,
    LinearMipMapNearestFilter: rL,
    LinearMipmapLinearFilter: Kl,
    LinearMipmapNearestFilter: v_,
    LinearSRGBColorSpace: _h,
    LinearToneMapping: A2,
    Loader: Bo,
    LoaderUtils: jl,
    LoadingManager: dM,
    LoopOnce: V2,
    LoopPingPong: X2,
    LoopRepeat: W2,
    LuminanceAlphaFormat: F2,
    LuminanceFormat: L2,
    MOUSE: lf,
    Material: as,
    MaterialLoader: B_,
    MathUtils: y_,
    Matrix3: bo,
    Matrix4: Dn,
    MaxEquation: z1,
    Mesh: vs,
    MeshBasicMaterial: xa,
    MeshDepthMaterial: jS,
    MeshDistanceMaterial: YS,
    MeshLambertMaterial: D3,
    MeshMatcapMaterial: P3,
    MeshNormalMaterial: T3,
    MeshPhongMaterial: E3,
    MeshPhysicalMaterial: Ql,
    MeshStandardMaterial: kh,
    MeshToonMaterial: b3,
    MinEquation: N1,
    MirroredRepeatWrapping: gh,
    MixOperation: S2,
    MultiplyBlending: O1,
    MultiplyOperation: Lm,
    NearestFilter: Ji,
    NearestMipMapLinearFilter: nL,
    NearestMipMapNearestFilter: tL,
    NearestMipmapLinearFilter: ih,
    NearestMipmapNearestFilter: pm,
    NeverDepth: m2,
    NeverStencilFunc: pL,
    NoBlending: Su,
    NoColorSpace: oL,
    NoToneMapping: Ka,
    NormalAnimationBlendMode: __,
    NormalBlending: bf,
    NotEqualDepth: w2,
    NotEqualStencilFunc: yL,
    NumberKeyframeTrack: wh,
    Object3D: wr,
    ObjectLoader: L4,
    ObjectSpaceNormalMap: K2,
    OctahedronBufferGeometry: NG,
    OctahedronGeometry: Lh,
    OneFactor: a2,
    OneMinusDstAlphaFactor: f2,
    OneMinusDstColorFactor: h2,
    OneMinusSrcAlphaFactor: LS,
    OneMinusSrcColorFactor: u2,
    OrthographicCamera: Mu,
    PCFShadowMap: m_,
    PCFSoftShadowMap: Np,
    PMREMGenerator: fw,
    Path: ym,
    PerspectiveCamera: gi,
    Plane: rc,
    PlaneBufferGeometry: zG,
    PlaneGeometry: Ph,
    PlaneHelper: SG,
    PointLight: mM,
    PointLightHelper: hG,
    Points: eM,
    PointsMaterial: b_,
    PolarGridHelper: vG,
    PolyhedronBufferGeometry: GG,
    PolyhedronGeometry: Bu,
    PositionalAudio: V4,
    PropertyBinding: hr,
    PropertyMixer: j3,
    QuadraticBezierCurve: iM,
    QuadraticBezierCurve3: sM,
    Quaternion: Ws,
    QuaternionKeyframeTrack: Pc,
    QuaternionLinearInterpolant: F3,
    RED_GREEN_RGTC2_Format: aw,
    RED_RGTC1_Format: H2,
    REVISION: p_,
    RGBADepthPacking: Y2,
    RGBAFormat: ga,
    RGBAIntegerFormat: G2,
    RGBA_ASTC_10x10_Format: rw,
    RGBA_ASTC_10x5_Format: ew,
    RGBA_ASTC_10x6_Format: tw,
    RGBA_ASTC_10x8_Format: nw,
    RGBA_ASTC_12x10_Format: iw,
    RGBA_ASTC_12x12_Format: sw,
    RGBA_ASTC_4x4_Format: J1,
    RGBA_ASTC_5x4_Format: j1,
    RGBA_ASTC_5x5_Format: Y1,
    RGBA_ASTC_6x5_Format: K1,
    RGBA_ASTC_6x6_Format: q1,
    RGBA_ASTC_8x5_Format: Q1,
    RGBA_ASTC_8x6_Format: Z1,
    RGBA_ASTC_8x8_Format: $1,
    RGBA_BPTC_Format: sv,
    RGBA_ETC2_EAC_Format: X1,
    RGBA_PVRTC_2BPPV1_Format: V1,
    RGBA_PVRTC_4BPPV1_Format: H1,
    RGBA_S3TC_DXT1_Format: nv,
    RGBA_S3TC_DXT3_Format: rv,
    RGBA_S3TC_DXT5_Format: iv,
    RGB_ETC1_Format: U2,
    RGB_ETC2_Format: W1,
    RGB_PVRTC_2BPPV1_Format: U1,
    RGB_PVRTC_4BPPV1_Format: G1,
    RGB_S3TC_DXT1_Format: tv,
    RGFormat: N2,
    RGIntegerFormat: z2,
    RawShaderMaterial: C3,
    Ray: Fm,
    Raycaster: SM,
    RectAreaLight: U3,
    RedFormat: k2,
    RedIntegerFormat: O2,
    ReinhardToneMapping: C2,
    RepeatWrapping: bc,
    ReplaceStencilOp: lL,
    ReverseSubtractEquation: s2,
    RingBufferGeometry: UG,
    RingGeometry: Jm,
    SIGNED_RED_GREEN_RGTC2_Format: lw,
    SIGNED_RED_RGTC1_Format: ow,
    SRGBColorSpace: gl,
    Scene: C_,
    ShaderChunk: Vn,
    ShaderLib: yl,
    ShaderMaterial: el,
    ShadowMaterial: A3,
    Shape: Bf,
    ShapeBufferGeometry: HG,
    ShapeGeometry: jm,
    ShapePath: CG,
    ShapeUtils: Jl,
    ShortType: D2,
    Skeleton: Gm,
    SkeletonHelper: dG,
    SkinnedMesh: ZS,
    Source: Sf,
    Sphere: Oc,
    SphereBufferGeometry: VG,
    SphereGeometry: Fh,
    Spherical: _w,
    SphericalHarmonics3: H3,
    SplineCurve: oM,
    SpotLight: pM,
    SpotLightHelper: fG,
    Sprite: f3,
    SpriteMaterial: QS,
    SrcAlphaFactor: IS,
    SrcAlphaSaturateFactor: p2,
    SrcColorFactor: l2,
    StaticCopyUsage: EL,
    StaticDrawUsage: gm,
    StaticReadUsage: ML,
    StereoCamera: z4,
    StreamCopyUsage: TL,
    StreamDrawUsage: SL,
    StreamReadUsage: CL,
    StringKeyframeTrack: ed,
    SubtractEquation: i2,
    SubtractiveBlending: k1,
    TOUCH: uf,
    TangentSpaceNormalMap: Ru,
    TetrahedronBufferGeometry: WG,
    TetrahedronGeometry: Ym,
    Texture: Ci,
    TextureLoader: N3,
    TorusBufferGeometry: XG,
    TorusGeometry: Km,
    TorusKnotBufferGeometry: JG,
    TorusKnotGeometry: qm,
    Triangle: Xa,
    TriangleFanDrawMode: NS,
    TriangleStripDrawMode: J2,
    TrianglesDrawMode: sL,
    TubeBufferGeometry: jG,
    TubeGeometry: Qm,
    TwoPassDoubleSide: eL,
    UVMapping: g_,
    Uint16BufferAttribute: HS,
    Uint32BufferAttribute: VS,
    Uint8BufferAttribute: rF,
    Uint8ClampedBufferAttribute: iF,
    Uniform: wM,
    UniformsGroup: sG,
    UniformsLib: Lt,
    UniformsUtils: WS,
    UnsignedByteType: Tc,
    UnsignedInt248Type: Tf,
    UnsignedIntType: lc,
    UnsignedShort4444Type: R2,
    UnsignedShort5551Type: B2,
    UnsignedShortType: kS,
    VSMShadowMap: yf,
    Vector2: it,
    Vector3: $,
    Vector4: zr,
    VectorKeyframeTrack: Sh,
    VideoTexture: Jz,
    WebGL1Renderer: u3,
    WebGL3DRenderTarget: JL,
    WebGLArrayRenderTarget: XL,
    WebGLCubeRenderTarget: XS,
    WebGLMultipleRenderTargets: jL,
    WebGLRenderTarget: $a,
    WebGLRenderer: qS,
    WebGLUtils: a3,
    WireframeGeometry: M3,
    WrapAroundEnding: mm,
    ZeroCurvatureEnding: xf,
    ZeroFactor: o2,
    ZeroSlopeEnding: wf,
    ZeroStencilOp: aL,
    _SRGBAFormat: Vv,
    sRGBEncoding: nr
}, Symbol.toStringTag, {
    value: "Module"
}));
var uc = {}
  , YG = {
    get exports() {
        return uc
    },
    set exports(n) {
        uc = n
    }
}
  , td = {};
/**
 * @license React
 * react-reconciler-constants.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
td.ConcurrentRoot = 1;
td.ContinuousEventPriority = 4;
td.DefaultEventPriority = 16;
td.DiscreteEventPriority = 1;
td.IdleEventPriority = 536870912;
td.LegacyRoot = 0;
(function(n) {
    n.exports = td
}
)(YG);
function KG(n) {
    let e;
    const t = new Set
      , r = (f,h)=>{
        const d = typeof f == "function" ? f(e) : f;
        if (d !== e) {
            const p = e;
            e = h ? d : Object.assign({}, e, d),
            t.forEach(m=>m(e, p))
        }
    }
      , i = ()=>e
      , s = (f,h=i,d=Object.is)=>{
        console.warn("[DEPRECATED] Please use `subscribeWithSelector` middleware");
        let p = h(e);
        function m() {
            const _ = h(e);
            if (!d(p, _)) {
                const y = p;
                f(p = _, y)
            }
        }
        return t.add(m),
        ()=>t.delete(m)
    }
      , l = {
        setState: r,
        getState: i,
        subscribe: (f,h,d)=>h || d ? s(f, h, d) : (t.add(f),
        ()=>t.delete(f)),
        destroy: ()=>t.clear()
    };
    return e = n(r, i, l),
    l
}
const qG = typeof window > "u" || !window.navigator || /ServerSideRendering|^Deno\//.test(window.navigator.userAgent)
  , HE = qG ? we.useEffect : we.useLayoutEffect;
function MM(n) {
    const e = typeof n == "function" ? KG(n) : n
      , t = (r=e.getState,i=Object.is)=>{
        const [,s] = we.useReducer(x=>x + 1, 0)
          , o = e.getState()
          , a = we.useRef(o)
          , l = we.useRef(r)
          , f = we.useRef(i)
          , h = we.useRef(!1)
          , d = we.useRef();
        d.current === void 0 && (d.current = r(o));
        let p, m = !1;
        (a.current !== o || l.current !== r || f.current !== i || h.current) && (p = r(o),
        m = !i(d.current, p)),
        HE(()=>{
            m && (d.current = p),
            a.current = o,
            l.current = r,
            f.current = i,
            h.current = !1
        }
        );
        const _ = we.useRef(o);
        HE(()=>{
            const x = ()=>{
                try {
                    const M = e.getState()
                      , w = l.current(M);
                    f.current(d.current, w) || (a.current = M,
                    d.current = w,
                    s())
                } catch {
                    h.current = !0,
                    s()
                }
            }
              , S = e.subscribe(x);
            return e.getState() !== _.current && x(),
            S
        }
        , []);
        const y = m ? p : d.current;
        return we.useDebugValue(y),
        y
    }
    ;
    return Object.assign(t, e),
    t[Symbol.iterator] = function() {
        console.warn("[useStore, api] = create() is deprecated and will be removed in v4");
        const r = [t, e];
        return {
            next() {
                const i = r.length <= 0;
                return {
                    value: r.shift(),
                    done: i
                }
            }
        }
    }
    ,
    t
}
var yw = {}
  , QG = {
    get exports() {
        return yw
    },
    set exports(n) {
        yw = n
    }
}
  , Jv = {}
  , ZG = {
    get exports() {
        return Jv
    },
    set exports(n) {
        Jv = n
    }
}
  , mx = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var VE;
function $G() {
    return VE || (VE = 1,
    function(n) {
        function e(G, z) {
            var U = G.length;
            G.push(z);
            e: for (; 0 < U; ) {
                var fe = U - 1 >>> 1
                  , oe = G[fe];
                if (0 < i(oe, z))
                    G[fe] = z,
                    G[U] = oe,
                    U = fe;
                else
                    break e
            }
        }
        function t(G) {
            return G.length === 0 ? null : G[0]
        }
        function r(G) {
            if (G.length === 0)
                return null;
            var z = G[0]
              , U = G.pop();
            if (U !== z) {
                G[0] = U;
                e: for (var fe = 0, oe = G.length, Ae = oe >>> 1; fe < Ae; ) {
                    var Ue = 2 * (fe + 1) - 1
                      , je = G[Ue]
                      , de = Ue + 1
                      , qe = G[de];
                    if (0 > i(je, U))
                        de < oe && 0 > i(qe, je) ? (G[fe] = qe,
                        G[de] = U,
                        fe = de) : (G[fe] = je,
                        G[Ue] = U,
                        fe = Ue);
                    else if (de < oe && 0 > i(qe, U))
                        G[fe] = qe,
                        G[de] = U,
                        fe = de;
                    else
                        break e
                }
            }
            return z
        }
        function i(G, z) {
            var U = G.sortIndex - z.sortIndex;
            return U !== 0 ? U : G.id - z.id
        }
        if (typeof performance == "object" && typeof performance.now == "function") {
            var s = performance;
            n.unstable_now = function() {
                return s.now()
            }
        } else {
            var o = Date
              , a = o.now();
            n.unstable_now = function() {
                return o.now() - a
            }
        }
        var l = []
          , f = []
          , h = 1
          , d = null
          , p = 3
          , m = !1
          , _ = !1
          , y = !1
          , x = typeof setTimeout == "function" ? setTimeout : null
          , S = typeof clearTimeout == "function" ? clearTimeout : null
          , M = typeof setImmediate < "u" ? setImmediate : null;
        typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
        function w(G) {
            for (var z = t(f); z !== null; ) {
                if (z.callback === null)
                    r(f);
                else if (z.startTime <= G)
                    r(f),
                    z.sortIndex = z.expirationTime,
                    e(l, z);
                else
                    break;
                z = t(f)
            }
        }
        function T(G) {
            if (y = !1,
            w(G),
            !_)
                if (t(l) !== null)
                    _ = !0,
                    ce(P);
                else {
                    var z = t(f);
                    z !== null && xe(T, z.startTime - G)
                }
        }
        function P(G, z) {
            _ = !1,
            y && (y = !1,
            S(R),
            R = -1),
            m = !0;
            var U = p;
            try {
                for (w(z),
                d = t(l); d !== null && (!(d.expirationTime > z) || G && !W()); ) {
                    var fe = d.callback;
                    if (typeof fe == "function") {
                        d.callback = null,
                        p = d.priorityLevel;
                        var oe = fe(d.expirationTime <= z);
                        z = n.unstable_now(),
                        typeof oe == "function" ? d.callback = oe : d === t(l) && r(l),
                        w(z)
                    } else
                        r(l);
                    d = t(l)
                }
                if (d !== null)
                    var Ae = !0;
                else {
                    var Ue = t(f);
                    Ue !== null && xe(T, Ue.startTime - z),
                    Ae = !1
                }
                return Ae
            } finally {
                d = null,
                p = U,
                m = !1
            }
        }
        var I = !1
          , k = null
          , R = -1
          , O = 5
          , H = -1;
        function W() {
            return !(n.unstable_now() - H < O)
        }
        function te() {
            if (k !== null) {
                var G = n.unstable_now();
                H = G;
                var z = !0;
                try {
                    z = k(!0, G)
                } finally {
                    z ? ne() : (I = !1,
                    k = null)
                }
            } else
                I = !1
        }
        var ne;
        if (typeof M == "function")
            ne = function() {
                M(te)
            }
            ;
        else if (typeof MessageChannel < "u") {
            var re = new MessageChannel
              , pe = re.port2;
            re.port1.onmessage = te,
            ne = function() {
                pe.postMessage(null)
            }
        } else
            ne = function() {
                x(te, 0)
            }
            ;
        function ce(G) {
            k = G,
            I || (I = !0,
            ne())
        }
        function xe(G, z) {
            R = x(function() {
                G(n.unstable_now())
            }, z)
        }
        n.unstable_IdlePriority = 5,
        n.unstable_ImmediatePriority = 1,
        n.unstable_LowPriority = 4,
        n.unstable_NormalPriority = 3,
        n.unstable_Profiling = null,
        n.unstable_UserBlockingPriority = 2,
        n.unstable_cancelCallback = function(G) {
            G.callback = null
        }
        ,
        n.unstable_continueExecution = function() {
            _ || m || (_ = !0,
            ce(P))
        }
        ,
        n.unstable_forceFrameRate = function(G) {
            0 > G || 125 < G ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : O = 0 < G ? Math.floor(1e3 / G) : 5
        }
        ,
        n.unstable_getCurrentPriorityLevel = function() {
            return p
        }
        ,
        n.unstable_getFirstCallbackNode = function() {
            return t(l)
        }
        ,
        n.unstable_next = function(G) {
            switch (p) {
            case 1:
            case 2:
            case 3:
                var z = 3;
                break;
            default:
                z = p
            }
            var U = p;
            p = z;
            try {
                return G()
            } finally {
                p = U
            }
        }
        ,
        n.unstable_pauseExecution = function() {}
        ,
        n.unstable_requestPaint = function() {}
        ,
        n.unstable_runWithPriority = function(G, z) {
            switch (G) {
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
                break;
            default:
                G = 3
            }
            var U = p;
            p = G;
            try {
                return z()
            } finally {
                p = U
            }
        }
        ,
        n.unstable_scheduleCallback = function(G, z, U) {
            var fe = n.unstable_now();
            switch (typeof U == "object" && U !== null ? (U = U.delay,
            U = typeof U == "number" && 0 < U ? fe + U : fe) : U = fe,
            G) {
            case 1:
                var oe = -1;
                break;
            case 2:
                oe = 250;
                break;
            case 5:
                oe = 1073741823;
                break;
            case 4:
                oe = 1e4;
                break;
            default:
                oe = 5e3
            }
            return oe = U + oe,
            G = {
                id: h++,
                callback: z,
                priorityLevel: G,
                startTime: U,
                expirationTime: oe,
                sortIndex: -1
            },
            U > fe ? (G.sortIndex = U,
            e(f, G),
            t(l) === null && G === t(f) && (y ? (S(R),
            R = -1) : y = !0,
            xe(T, U - fe))) : (G.sortIndex = oe,
            e(l, G),
            _ || m || (_ = !0,
            ce(P))),
            G
        }
        ,
        n.unstable_shouldYield = W,
        n.unstable_wrapCallback = function(G) {
            var z = p;
            return function() {
                var U = p;
                p = z;
                try {
                    return G.apply(this, arguments)
                } finally {
                    p = U
                }
            }
        }
    }(mx)),
    mx
}
var WE;
function eU() {
    return WE || (WE = 1,
    function(n) {
        n.exports = $G()
    }(ZG)),
    Jv
}
/**
 * @license React
 * react-reconciler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var tU = function(e) {
    var t = {}
      , r = we
      , i = eU()
      , s = Object.assign;
    function o(u) {
        for (var c = "https://reactjs.org/docs/error-decoder.html?invariant=" + u, v = 1; v < arguments.length; v++)
            c += "&args[]=" + encodeURIComponent(arguments[v]);
        return "Minified React error #" + u + "; visit " + c + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
    }
    var a = r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED
      , l = Symbol.for("react.element")
      , f = Symbol.for("react.portal")
      , h = Symbol.for("react.fragment")
      , d = Symbol.for("react.strict_mode")
      , p = Symbol.for("react.profiler")
      , m = Symbol.for("react.provider")
      , _ = Symbol.for("react.context")
      , y = Symbol.for("react.forward_ref")
      , x = Symbol.for("react.suspense")
      , S = Symbol.for("react.suspense_list")
      , M = Symbol.for("react.memo")
      , w = Symbol.for("react.lazy")
      , T = Symbol.for("react.offscreen")
      , P = Symbol.iterator;
    function I(u) {
        return u === null || typeof u != "object" ? null : (u = P && u[P] || u["@@iterator"],
        typeof u == "function" ? u : null)
    }
    function k(u) {
        if (u == null)
            return null;
        if (typeof u == "function")
            return u.displayName || u.name || null;
        if (typeof u == "string")
            return u;
        switch (u) {
        case h:
            return "Fragment";
        case f:
            return "Portal";
        case p:
            return "Profiler";
        case d:
            return "StrictMode";
        case x:
            return "Suspense";
        case S:
            return "SuspenseList"
        }
        if (typeof u == "object")
            switch (u.$$typeof) {
            case _:
                return (u.displayName || "Context") + ".Consumer";
            case m:
                return (u._context.displayName || "Context") + ".Provider";
            case y:
                var c = u.render;
                return u = u.displayName,
                u || (u = c.displayName || c.name || "",
                u = u !== "" ? "ForwardRef(" + u + ")" : "ForwardRef"),
                u;
            case M:
                return c = u.displayName || null,
                c !== null ? c : k(u.type) || "Memo";
            case w:
                c = u._payload,
                u = u._init;
                try {
                    return k(u(c))
                } catch {}
            }
        return null
    }
    function R(u) {
        var c = u.type;
        switch (u.tag) {
        case 24:
            return "Cache";
        case 9:
            return (c.displayName || "Context") + ".Consumer";
        case 10:
            return (c._context.displayName || "Context") + ".Provider";
        case 18:
            return "DehydratedFragment";
        case 11:
            return u = c.render,
            u = u.displayName || u.name || "",
            c.displayName || (u !== "" ? "ForwardRef(" + u + ")" : "ForwardRef");
        case 7:
            return "Fragment";
        case 5:
            return c;
        case 4:
            return "Portal";
        case 3:
            return "Root";
        case 6:
            return "Text";
        case 16:
            return k(c);
        case 8:
            return c === d ? "StrictMode" : "Mode";
        case 22:
            return "Offscreen";
        case 12:
            return "Profiler";
        case 21:
            return "Scope";
        case 13:
            return "Suspense";
        case 19:
            return "SuspenseList";
        case 25:
            return "TracingMarker";
        case 1:
        case 0:
        case 17:
        case 2:
        case 14:
        case 15:
            if (typeof c == "function")
                return c.displayName || c.name || null;
            if (typeof c == "string")
                return c
        }
        return null
    }
    function O(u) {
        var c = u
          , v = u;
        if (u.alternate)
            for (; c.return; )
                c = c.return;
        else {
            u = c;
            do
                c = u,
                c.flags & 4098 && (v = c.return),
                u = c.return;
            while (u)
        }
        return c.tag === 3 ? v : null
    }
    function H(u) {
        if (O(u) !== u)
            throw Error(o(188))
    }
    function W(u) {
        var c = u.alternate;
        if (!c) {
            if (c = O(u),
            c === null)
                throw Error(o(188));
            return c !== u ? null : u
        }
        for (var v = u, E = c; ; ) {
            var D = v.return;
            if (D === null)
                break;
            var L = D.alternate;
            if (L === null) {
                if (E = D.return,
                E !== null) {
                    v = E;
                    continue
                }
                break
            }
            if (D.child === L.child) {
                for (L = D.child; L; ) {
                    if (L === v)
                        return H(D),
                        u;
                    if (L === E)
                        return H(D),
                        c;
                    L = L.sibling
                }
                throw Error(o(188))
            }
            if (v.return !== E.return)
                v = D,
                E = L;
            else {
                for (var ie = !1, _e = D.child; _e; ) {
                    if (_e === v) {
                        ie = !0,
                        v = D,
                        E = L;
                        break
                    }
                    if (_e === E) {
                        ie = !0,
                        E = D,
                        v = L;
                        break
                    }
                    _e = _e.sibling
                }
                if (!ie) {
                    for (_e = L.child; _e; ) {
                        if (_e === v) {
                            ie = !0,
                            v = L,
                            E = D;
                            break
                        }
                        if (_e === E) {
                            ie = !0,
                            E = L,
                            v = D;
                            break
                        }
                        _e = _e.sibling
                    }
                    if (!ie)
                        throw Error(o(189))
                }
            }
            if (v.alternate !== E)
                throw Error(o(190))
        }
        if (v.tag !== 3)
            throw Error(o(188));
        return v.stateNode.current === v ? u : c
    }
    function te(u) {
        return u = W(u),
        u !== null ? ne(u) : null
    }
    function ne(u) {
        if (u.tag === 5 || u.tag === 6)
            return u;
        for (u = u.child; u !== null; ) {
            var c = ne(u);
            if (c !== null)
                return c;
            u = u.sibling
        }
        return null
    }
    function re(u) {
        if (u.tag === 5 || u.tag === 6)
            return u;
        for (u = u.child; u !== null; ) {
            if (u.tag !== 4) {
                var c = re(u);
                if (c !== null)
                    return c
            }
            u = u.sibling
        }
        return null
    }
    var pe = Array.isArray, ce = e.getPublicInstance, xe = e.getRootHostContext, G = e.getChildHostContext, z = e.prepareForCommit, U = e.resetAfterCommit, fe = e.createInstance, oe = e.appendInitialChild, Ae = e.finalizeInitialChildren, Ue = e.prepareUpdate, je = e.shouldSetTextContent, de = e.createTextInstance, qe = e.scheduleTimeout, Ne = e.cancelTimeout, Tt = e.noTimeout, He = e.isPrimaryRenderer, gt = e.supportsMutation, be = e.supportsPersistence, Ee = e.supportsHydration, at = e.getInstanceFromNode, _t = e.preparePortalMount, Ce = e.getCurrentEventPriority, ee = e.detachDeletedInstance, et = e.supportsMicrotasks, Ze = e.scheduleMicrotask, ft = e.supportsTestSelectors, Pt = e.findFiberRoot, Z = e.getBoundingRect, V = e.getTextContent, ye = e.isHiddenSubtree, tt = e.matchAccessibilityRole, Ve = e.setFocusIfFocusable, Ke = e.setupIntersectionObserver, dt = e.appendChild, ct = e.appendChildToContainer, Fe = e.commitTextUpdate, Rt = e.commitMount, le = e.commitUpdate, Le = e.insertBefore, rt = e.insertInContainerBefore, st = e.removeChild, Ut = e.removeChildFromContainer, Mt = e.resetTextContent, wn = e.hideInstance, ae = e.hideTextInstance, De = e.unhideInstance, Je = e.unhideTextInstance, vt = e.clearContainer, Et = e.cloneInstance, rn = e.createContainerChildSet, dn = e.appendChildToContainerChildSet, or = e.finalizeContainerChildren, mn = e.replaceContainerChildren, St = e.cloneHiddenInstance, ut = e.cloneHiddenTextInstance, Nt = e.canHydrateInstance, $t = e.canHydrateTextInstance, hn = e.canHydrateSuspenseInstance, Qn = e.isSuspenseInstancePending, vn = e.isSuspenseInstanceFallback, j = e.registerSuspenseInstanceRetry, me = e.getNextHydratableSibling, ze = e.getFirstHydratableChild, ge = e.getFirstHydratableChildWithinContainer, Oe = e.getFirstHydratableChildWithinSuspenseInstance, Vt = e.hydrateInstance, Ft = e.hydrateTextInstance, Gt = e.hydrateSuspenseInstance, Yt = e.getNextHydratableInstanceAfterSuspenseInstance, Sn = e.commitHydratedContainer, tn = e.commitHydratedSuspenseInstance, Xt = e.clearSuspenseBoundary, en = e.clearSuspenseBoundaryFromContainer, Zn = e.shouldDeleteUnhydratedTailInstances, Yn = e.didNotMatchHydratedContainerTextInstance, es = e.didNotMatchHydratedTextInstance, Nn;
    function kt(u) {
        if (Nn === void 0)
            try {
                throw Error()
            } catch (v) {
                var c = v.stack.trim().match(/\n( *(at )?)/);
                Nn = c && c[1] || ""
            }
        return `
` + Nn + u
    }
    var Ur = !1;
    function Ln(u, c) {
        if (!u || Ur)
            return "";
        Ur = !0;
        var v = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        try {
            if (c)
                if (c = function() {
                    throw Error()
                }
                ,
                Object.defineProperty(c.prototype, "props", {
                    set: function() {
                        throw Error()
                    }
                }),
                typeof Reflect == "object" && Reflect.construct) {
                    try {
                        Reflect.construct(c, [])
                    } catch (wt) {
                        var E = wt
                    }
                    Reflect.construct(u, [], c)
                } else {
                    try {
                        c.call()
                    } catch (wt) {
                        E = wt
                    }
                    u.call(c.prototype)
                }
            else {
                try {
                    throw Error()
                } catch (wt) {
                    E = wt
                }
                u()
            }
        } catch (wt) {
            if (wt && E && typeof wt.stack == "string") {
                for (var D = wt.stack.split(`
`), L = E.stack.split(`
`), ie = D.length - 1, _e = L.length - 1; 1 <= ie && 0 <= _e && D[ie] !== L[_e]; )
                    _e--;
                for (; 1 <= ie && 0 <= _e; ie--,
                _e--)
                    if (D[ie] !== L[_e]) {
                        if (ie !== 1 || _e !== 1)
                            do
                                if (ie--,
                                _e--,
                                0 > _e || D[ie] !== L[_e]) {
                                    var Qe = `
` + D[ie].replace(" at new ", " at ");
                                    return u.displayName && Qe.includes("<anonymous>") && (Qe = Qe.replace("<anonymous>", u.displayName)),
                                    Qe
                                }
                            while (1 <= ie && 0 <= _e);
                        break
                    }
            }
        } finally {
            Ur = !1,
            Error.prepareStackTrace = v
        }
        return (u = u ? u.displayName || u.name : "") ? kt(u) : ""
    }
    var Bs = Object.prototype.hasOwnProperty
      , qr = []
      , Qr = -1;
    function xs(u) {
        return {
            current: u
        }
    }
    function Mn(u) {
        0 > Qr || (u.current = qr[Qr],
        qr[Qr] = null,
        Qr--)
    }
    function An(u, c) {
        Qr++,
        qr[Qr] = u.current,
        u.current = c
    }
    var ws = {}
      , ir = xs(ws)
      , Ni = xs(!1)
      , Js = ws;
    function ea(u, c) {
        var v = u.type.contextTypes;
        if (!v)
            return ws;
        var E = u.stateNode;
        if (E && E.__reactInternalMemoizedUnmaskedChildContext === c)
            return E.__reactInternalMemoizedMaskedChildContext;
        var D = {}, L;
        for (L in v)
            D[L] = c[L];
        return E && (u = u.stateNode,
        u.__reactInternalMemoizedUnmaskedChildContext = c,
        u.__reactInternalMemoizedMaskedChildContext = D),
        D
    }
    function Yi(u) {
        return u = u.childContextTypes,
        u != null
    }
    function Hr() {
        Mn(Ni),
        Mn(ir)
    }
    function _i(u, c, v) {
        if (ir.current !== ws)
            throw Error(o(168));
        An(ir, c),
        An(Ni, v)
    }
    function $l(u, c, v) {
        var E = u.stateNode;
        if (c = c.childContextTypes,
        typeof E.getChildContext != "function")
            return v;
        E = E.getChildContext();
        for (var D in E)
            if (!(D in c))
                throw Error(o(108, R(u) || "Unknown", D));
        return s({}, v, E)
    }
    function Rl(u) {
        return u = (u = u.stateNode) && u.__reactInternalMemoizedMergedChildContext || ws,
        Js = ir.current,
        An(ir, u),
        An(Ni, Ni.current),
        !0
    }
    function ts(u, c, v) {
        var E = u.stateNode;
        if (!E)
            throw Error(o(169));
        v ? (u = $l(u, c, Js),
        E.__reactInternalMemoizedMergedChildContext = u,
        Mn(Ni),
        Mn(ir),
        An(ir, u)) : Mn(Ni),
        An(Ni, v)
    }
    var zi = Math.clz32 ? Math.clz32 : ar
      , ta = Math.log
      , Iu = Math.LN2;
    function ar(u) {
        return u >>>= 0,
        u === 0 ? 32 : 31 - (ta(u) / Iu | 0) | 0
    }
    var yn = 64
      , Ta = 4194304;
    function Io(u) {
        switch (u & -u) {
        case 1:
            return 1;
        case 2:
            return 2;
        case 4:
            return 4;
        case 8:
            return 8;
        case 16:
            return 16;
        case 32:
            return 32;
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
            return u & 4194240;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
            return u & 130023424;
        case 134217728:
            return 134217728;
        case 268435456:
            return 268435456;
        case 536870912:
            return 536870912;
        case 1073741824:
            return 1073741824;
        default:
            return u
        }
    }
    function Bl(u, c) {
        var v = u.pendingLanes;
        if (v === 0)
            return 0;
        var E = 0
          , D = u.suspendedLanes
          , L = u.pingedLanes
          , ie = v & 268435455;
        if (ie !== 0) {
            var _e = ie & ~D;
            _e !== 0 ? E = Io(_e) : (L &= ie,
            L !== 0 && (E = Io(L)))
        } else
            ie = v & ~D,
            ie !== 0 ? E = Io(ie) : L !== 0 && (E = Io(L));
        if (E === 0)
            return 0;
        if (c !== 0 && c !== E && !(c & D) && (D = E & -E,
        L = c & -c,
        D >= L || D === 16 && (L & 4194240) !== 0))
            return c;
        if (E & 4 && (E |= v & 16),
        c = u.entangledLanes,
        c !== 0)
            for (u = u.entanglements,
            c &= E; 0 < c; )
                v = 31 - zi(c),
                D = 1 << v,
                E |= u[v],
                c &= ~D;
        return E
    }
    function tl(u, c) {
        switch (u) {
        case 1:
        case 2:
        case 4:
            return c + 250;
        case 8:
        case 16:
        case 32:
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
            return c + 5e3;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
            return -1;
        case 134217728:
        case 268435456:
        case 536870912:
        case 1073741824:
            return -1;
        default:
            return -1
        }
    }
    function Lo(u, c) {
        for (var v = u.suspendedLanes, E = u.pingedLanes, D = u.expirationTimes, L = u.pendingLanes; 0 < L; ) {
            var ie = 31 - zi(L)
              , _e = 1 << ie
              , Qe = D[ie];
            Qe === -1 ? (!(_e & v) || _e & E) && (D[ie] = tl(_e, c)) : Qe <= c && (u.expiredLanes |= _e),
            L &= ~_e
        }
    }
    function nl(u) {
        return u = u.pendingLanes & -1073741825,
        u !== 0 ? u : u & 1073741824 ? 1073741824 : 0
    }
    function Fo(u) {
        for (var c = [], v = 0; 31 > v; v++)
            c.push(u);
        return c
    }
    function na(u, c, v) {
        u.pendingLanes |= c,
        c !== 536870912 && (u.suspendedLanes = 0,
        u.pingedLanes = 0),
        u = u.eventTimes,
        c = 31 - zi(c),
        u[c] = v
    }
    function Ss(u, c) {
        var v = u.pendingLanes & ~c;
        u.pendingLanes = c,
        u.suspendedLanes = 0,
        u.pingedLanes = 0,
        u.expiredLanes &= c,
        u.mutableReadLanes &= c,
        u.entangledLanes &= c,
        c = u.entanglements;
        var E = u.eventTimes;
        for (u = u.expirationTimes; 0 < v; ) {
            var D = 31 - zi(v)
              , L = 1 << D;
            c[D] = 0,
            E[D] = -1,
            u[D] = -1,
            v &= ~L
        }
    }
    function Ms(u, c) {
        var v = u.entangledLanes |= c;
        for (u = u.entanglements; v; ) {
            var E = 31 - zi(v)
              , D = 1 << E;
            D & c | u[E] & c && (u[E] |= c),
            v &= ~D
        }
    }
    var Dt = 0;
    function Gc(u) {
        return u &= -u,
        1 < u ? 4 < u ? u & 268435455 ? 16 : 536870912 : 4 : 1
    }
    var eu = i.unstable_scheduleCallback
      , Uc = i.unstable_cancelCallback
      , uo = i.unstable_shouldYield
      , rl = i.unstable_requestPaint
      , yi = i.unstable_now
      , Lu = i.unstable_ImmediatePriority
      , Is = i.unstable_UserBlockingPriority
      , ko = i.unstable_NormalPriority
      , tu = i.unstable_IdlePriority
      , Oo = null
      , Ei = null;
    function Fu(u) {
        if (Ei && typeof Ei.onCommitFiberRoot == "function")
            try {
                Ei.onCommitFiberRoot(Oo, u, void 0, (u.current.flags & 128) === 128)
            } catch {}
    }
    function ra(u, c) {
        return u === c && (u !== 0 || 1 / u === 1 / c) || u !== u && c !== c
    }
    var Lr = typeof Object.is == "function" ? Object.is : ra
      , co = null
      , Il = !1
      , Da = !1;
    function Ll(u) {
        co === null ? co = [u] : co.push(u)
    }
    function Pa(u) {
        Il = !0,
        Ll(u)
    }
    function us() {
        if (!Da && co !== null) {
            Da = !0;
            var u = 0
              , c = Dt;
            try {
                var v = co;
                for (Dt = 1; u < v.length; u++) {
                    var E = v[u];
                    do
                        E = E(!0);
                    while (E !== null)
                }
                co = null,
                Il = !1
            } catch (D) {
                throw co !== null && (co = co.slice(u + 1)),
                eu(Lu, us),
                D
            } finally {
                Dt = c,
                Da = !1
            }
        }
        return null
    }
    var ku = a.ReactCurrentBatchConfig;
    function Ou(u, c) {
        if (Lr(u, c))
            return !0;
        if (typeof u != "object" || u === null || typeof c != "object" || c === null)
            return !1;
        var v = Object.keys(u)
          , E = Object.keys(c);
        if (v.length !== E.length)
            return !1;
        for (E = 0; E < v.length; E++) {
            var D = v[E];
            if (!Bs.call(c, D) || !Lr(u[D], c[D]))
                return !1
        }
        return !0
    }
    function rd(u) {
        switch (u.tag) {
        case 5:
            return kt(u.type);
        case 16:
            return kt("Lazy");
        case 13:
            return kt("Suspense");
        case 19:
            return kt("SuspenseList");
        case 0:
        case 2:
        case 15:
            return u = Ln(u.type, !1),
            u;
        case 11:
            return u = Ln(u.type.render, !1),
            u;
        case 1:
            return u = Ln(u.type, !0),
            u;
        default:
            return ""
        }
    }
    function js(u, c) {
        if (u && u.defaultProps) {
            c = s({}, c),
            u = u.defaultProps;
            for (var v in u)
                c[v] === void 0 && (c[v] = u[v]);
            return c
        }
        return c
    }
    var Cn = xs(null)
      , Fl = null
      , ia = null
      , Fr = null;
    function nu() {
        Fr = ia = Fl = null
    }
    function Nu(u, c, v) {
        He ? (An(Cn, c._currentValue),
        c._currentValue = v) : (An(Cn, c._currentValue2),
        c._currentValue2 = v)
    }
    function Hc(u) {
        var c = Cn.current;
        Mn(Cn),
        He ? u._currentValue = c : u._currentValue2 = c
    }
    function zu(u, c, v) {
        for (; u !== null; ) {
            var E = u.alternate;
            if ((u.childLanes & c) !== c ? (u.childLanes |= c,
            E !== null && (E.childLanes |= c)) : E !== null && (E.childLanes & c) !== c && (E.childLanes |= c),
            u === v)
                break;
            u = u.return
        }
    }
    function sa(u, c) {
        Fl = u,
        Fr = ia = null,
        u = u.dependencies,
        u !== null && u.firstContext !== null && (u.lanes & c && ($e = !0),
        u.firstContext = null)
    }
    function Ls(u) {
        var c = He ? u._currentValue : u._currentValue2;
        if (Fr !== u)
            if (u = {
                context: u,
                memoizedValue: c,
                next: null
            },
            ia === null) {
                if (Fl === null)
                    throw Error(o(308));
                ia = u,
                Fl.dependencies = {
                    lanes: 0,
                    firstContext: u
                }
            } else
                ia = ia.next = u;
        return c
    }
    var Te = null
      , J = !1;
    function ue(u) {
        u.updateQueue = {
            baseState: u.memoizedState,
            firstBaseUpdate: null,
            lastBaseUpdate: null,
            shared: {
                pending: null,
                interleaved: null,
                lanes: 0
            },
            effects: null
        }
    }
    function K(u, c) {
        u = u.updateQueue,
        c.updateQueue === u && (c.updateQueue = {
            baseState: u.baseState,
            firstBaseUpdate: u.firstBaseUpdate,
            lastBaseUpdate: u.lastBaseUpdate,
            shared: u.shared,
            effects: u.effects
        })
    }
    function Q(u, c) {
        return {
            eventTime: u,
            lane: c,
            tag: 0,
            payload: null,
            callback: null,
            next: null
        }
    }
    function Se(u, c) {
        var v = u.updateQueue;
        v !== null && (v = v.shared,
        rs !== null && u.mode & 1 && !(jn & 2) ? (u = v.interleaved,
        u === null ? (c.next = c,
        Te === null ? Te = [v] : Te.push(v)) : (c.next = u.next,
        u.next = c),
        v.interleaved = c) : (u = v.pending,
        u === null ? c.next = c : (c.next = u.next,
        u.next = c),
        v.pending = c))
    }
    function We(u, c, v) {
        if (c = c.updateQueue,
        c !== null && (c = c.shared,
        (v & 4194240) !== 0)) {
            var E = c.lanes;
            E &= u.pendingLanes,
            v |= E,
            c.lanes = v,
            Ms(u, v)
        }
    }
    function Be(u, c) {
        var v = u.updateQueue
          , E = u.alternate;
        if (E !== null && (E = E.updateQueue,
        v === E)) {
            var D = null
              , L = null;
            if (v = v.firstBaseUpdate,
            v !== null) {
                do {
                    var ie = {
                        eventTime: v.eventTime,
                        lane: v.lane,
                        tag: v.tag,
                        payload: v.payload,
                        callback: v.callback,
                        next: null
                    };
                    L === null ? D = L = ie : L = L.next = ie,
                    v = v.next
                } while (v !== null);
                L === null ? D = L = c : L = L.next = c
            } else
                D = L = c;
            v = {
                baseState: E.baseState,
                firstBaseUpdate: D,
                lastBaseUpdate: L,
                shared: E.shared,
                effects: E.effects
            },
            u.updateQueue = v;
            return
        }
        u = v.lastBaseUpdate,
        u === null ? v.firstBaseUpdate = c : u.next = c,
        v.lastBaseUpdate = c
    }
    function Bt(u, c, v, E) {
        var D = u.updateQueue;
        J = !1;
        var L = D.firstBaseUpdate
          , ie = D.lastBaseUpdate
          , _e = D.shared.pending;
        if (_e !== null) {
            D.shared.pending = null;
            var Qe = _e
              , wt = Qe.next;
            Qe.next = null,
            ie === null ? L = wt : ie.next = wt,
            ie = Qe;
            var qt = u.alternate;
            qt !== null && (qt = qt.updateQueue,
            _e = qt.lastBaseUpdate,
            _e !== ie && (_e === null ? qt.firstBaseUpdate = wt : _e.next = wt,
            qt.lastBaseUpdate = Qe))
        }
        if (L !== null) {
            var Rn = D.baseState;
            ie = 0,
            qt = wt = Qe = null,
            _e = L;
            do {
                var gn = _e.lane
                  , ri = _e.eventTime;
                if ((E & gn) === gn) {
                    qt !== null && (qt = qt.next = {
                        eventTime: ri,
                        lane: 0,
                        tag: _e.tag,
                        payload: _e.payload,
                        callback: _e.callback,
                        next: null
                    });
                    e: {
                        var an = u
                          , $s = _e;
                        switch (gn = c,
                        ri = v,
                        $s.tag) {
                        case 1:
                            if (an = $s.payload,
                            typeof an == "function") {
                                Rn = an.call(ri, Rn, gn);
                                break e
                            }
                            Rn = an;
                            break e;
                        case 3:
                            an.flags = an.flags & -65537 | 128;
                        case 0:
                            if (an = $s.payload,
                            gn = typeof an == "function" ? an.call(ri, Rn, gn) : an,
                            gn == null)
                                break e;
                            Rn = s({}, Rn, gn);
                            break e;
                        case 2:
                            J = !0
                        }
                    }
                    _e.callback !== null && _e.lane !== 0 && (u.flags |= 64,
                    gn = D.effects,
                    gn === null ? D.effects = [_e] : gn.push(_e))
                } else
                    ri = {
                        eventTime: ri,
                        lane: gn,
                        tag: _e.tag,
                        payload: _e.payload,
                        callback: _e.callback,
                        next: null
                    },
                    qt === null ? (wt = qt = ri,
                    Qe = Rn) : qt = qt.next = ri,
                    ie |= gn;
                if (_e = _e.next,
                _e === null) {
                    if (_e = D.shared.pending,
                    _e === null)
                        break;
                    gn = _e,
                    _e = gn.next,
                    gn.next = null,
                    D.lastBaseUpdate = gn,
                    D.shared.pending = null
                }
            } while (1);
            if (qt === null && (Qe = Rn),
            D.baseState = Qe,
            D.firstBaseUpdate = wt,
            D.lastBaseUpdate = qt,
            c = D.shared.interleaved,
            c !== null) {
                D = c;
                do
                    ie |= D.lane,
                    D = D.next;
                while (D !== c)
            } else
                L === null && (D.shared.lanes = 0);
            sd |= ie,
            u.lanes = ie,
            u.memoizedState = Rn
        }
    }
    function Fn(u, c, v) {
        if (u = c.effects,
        c.effects = null,
        u !== null)
            for (c = 0; c < u.length; c++) {
                var E = u[c]
                  , D = E.callback;
                if (D !== null) {
                    if (E.callback = null,
                    E = v,
                    typeof D != "function")
                        throw Error(o(191, D));
                    D.call(E)
                }
            }
    }
    var zn = new r.Component().refs;
    function xn(u, c, v, E) {
        c = u.memoizedState,
        v = v(E, c),
        v = v == null ? c : s({}, c, v),
        u.memoizedState = v,
        u.lanes === 0 && (u.updateQueue.baseState = v)
    }
    var Jt = {
        isMounted: function(u) {
            return (u = u._reactInternals) ? O(u) === u : !1
        },
        enqueueSetState: function(u, c, v) {
            u = u._reactInternals;
            var E = _o()
              , D = Vu(u)
              , L = Q(E, D);
            L.payload = c,
            v != null && (L.callback = v),
            Se(u, L),
            c = ka(u, D, E),
            c !== null && We(c, u, D)
        },
        enqueueReplaceState: function(u, c, v) {
            u = u._reactInternals;
            var E = _o()
              , D = Vu(u)
              , L = Q(E, D);
            L.tag = 1,
            L.payload = c,
            v != null && (L.callback = v),
            Se(u, L),
            c = ka(u, D, E),
            c !== null && We(c, u, D)
        },
        enqueueForceUpdate: function(u, c) {
            u = u._reactInternals;
            var v = _o()
              , E = Vu(u)
              , D = Q(v, E);
            D.tag = 2,
            c != null && (D.callback = c),
            Se(u, D),
            c = ka(u, E, v),
            c !== null && We(c, u, E)
        }
    };
    function At(u, c, v, E, D, L, ie) {
        return u = u.stateNode,
        typeof u.shouldComponentUpdate == "function" ? u.shouldComponentUpdate(E, L, ie) : c.prototype && c.prototype.isPureReactComponent ? !Ou(v, E) || !Ou(D, L) : !0
    }
    function Qt(u, c, v) {
        var E = !1
          , D = ws
          , L = c.contextType;
        return typeof L == "object" && L !== null ? L = Ls(L) : (D = Yi(c) ? Js : ir.current,
        E = c.contextTypes,
        L = (E = E != null) ? ea(u, D) : ws),
        c = new c(v,L),
        u.memoizedState = c.state !== null && c.state !== void 0 ? c.state : null,
        c.updater = Jt,
        u.stateNode = c,
        c._reactInternals = u,
        E && (u = u.stateNode,
        u.__reactInternalMemoizedUnmaskedChildContext = D,
        u.__reactInternalMemoizedMaskedChildContext = L),
        c
    }
    function Vr(u, c, v, E) {
        u = c.state,
        typeof c.componentWillReceiveProps == "function" && c.componentWillReceiveProps(v, E),
        typeof c.UNSAFE_componentWillReceiveProps == "function" && c.UNSAFE_componentWillReceiveProps(v, E),
        c.state !== u && Jt.enqueueReplaceState(c, c.state, null)
    }
    function lr(u, c, v, E) {
        var D = u.stateNode;
        D.props = v,
        D.state = u.memoizedState,
        D.refs = zn,
        ue(u);
        var L = c.contextType;
        typeof L == "object" && L !== null ? D.context = Ls(L) : (L = Yi(c) ? Js : ir.current,
        D.context = ea(u, L)),
        D.state = u.memoizedState,
        L = c.getDerivedStateFromProps,
        typeof L == "function" && (xn(u, c, L, v),
        D.state = u.memoizedState),
        typeof c.getDerivedStateFromProps == "function" || typeof D.getSnapshotBeforeUpdate == "function" || typeof D.UNSAFE_componentWillMount != "function" && typeof D.componentWillMount != "function" || (c = D.state,
        typeof D.componentWillMount == "function" && D.componentWillMount(),
        typeof D.UNSAFE_componentWillMount == "function" && D.UNSAFE_componentWillMount(),
        c !== D.state && Jt.enqueueReplaceState(D, D.state, null),
        Bt(u, v, D, E),
        D.state = u.memoizedState),
        typeof D.componentDidMount == "function" && (u.flags |= 4194308)
    }
    var bn = []
      , ai = 0
      , Pr = null
      , pn = 0
      , Rr = []
      , Kn = 0
      , En = null
      , di = 1
      , bi = "";
    function _n(u, c) {
        bn[ai++] = pn,
        bn[ai++] = Pr,
        Pr = u,
        pn = c
    }
    function pr(u, c, v) {
        Rr[Kn++] = di,
        Rr[Kn++] = bi,
        Rr[Kn++] = En,
        En = u;
        var E = di;
        u = bi;
        var D = 32 - zi(E) - 1;
        E &= ~(1 << D),
        v += 1;
        var L = 32 - zi(c) + D;
        if (30 < L) {
            var ie = D - D % 5;
            L = (E & (1 << ie) - 1).toString(32),
            E >>= ie,
            D -= ie,
            di = 1 << 32 - zi(c) + D | v << D | E,
            bi = L + u
        } else
            di = 1 << L | v << D | E,
            bi = u
    }
    function Wn(u) {
        u.return !== null && (_n(u, 1),
        pr(u, 1, 0))
    }
    function Ys(u) {
        for (; u === Pr; )
            Pr = bn[--ai],
            bn[ai] = null,
            pn = bn[--ai],
            bn[ai] = null;
        for (; u === En; )
            En = Rr[--Kn],
            Rr[Kn] = null,
            bi = Rr[--Kn],
            Rr[Kn] = null,
            di = Rr[--Kn],
            Rr[Kn] = null
    }
    var mr = null
      , gr = null
      , ln = !1
      , Ti = !1
      , Xn = null;
    function xi(u, c) {
        var v = Oa(5, null, null, 0);
        v.elementType = "DELETED",
        v.stateNode = c,
        v.return = u,
        c = u.deletions,
        c === null ? (u.deletions = [v],
        u.flags |= 16) : c.push(v)
    }
    function Ge(u, c) {
        switch (u.tag) {
        case 5:
            return c = Nt(c, u.type, u.pendingProps),
            c !== null ? (u.stateNode = c,
            mr = u,
            gr = ze(c),
            !0) : !1;
        case 6:
            return c = $t(c, u.pendingProps),
            c !== null ? (u.stateNode = c,
            mr = u,
            gr = null,
            !0) : !1;
        case 13:
            if (c = hn(c),
            c !== null) {
                var v = En !== null ? {
                    id: di,
                    overflow: bi
                } : null;
                return u.memoizedState = {
                    dehydrated: c,
                    treeContext: v,
                    retryLane: 1073741824
                },
                v = Oa(18, null, null, 0),
                v.stateNode = c,
                v.return = u,
                u.child = v,
                mr = u,
                gr = null,
                !0
            }
            return !1;
        default:
            return !1
        }
    }
    function As(u) {
        return (u.mode & 1) !== 0 && (u.flags & 128) === 0
    }
    function No(u) {
        if (ln) {
            var c = gr;
            if (c) {
                var v = c;
                if (!Ge(u, c)) {
                    if (As(u))
                        throw Error(o(418));
                    c = me(v);
                    var E = mr;
                    c && Ge(u, c) ? xi(E, v) : (u.flags = u.flags & -4097 | 2,
                    ln = !1,
                    mr = u)
                }
            } else {
                if (As(u))
                    throw Error(o(418));
                u.flags = u.flags & -4097 | 2,
                ln = !1,
                mr = u
            }
        }
    }
    function zo(u) {
        for (u = u.return; u !== null && u.tag !== 5 && u.tag !== 3 && u.tag !== 13; )
            u = u.return;
        mr = u
    }
    function Di(u) {
        if (!Ee || u !== mr)
            return !1;
        if (!ln)
            return zo(u),
            ln = !0,
            !1;
        if (u.tag !== 3 && (u.tag !== 5 || Zn(u.type) && !je(u.type, u.memoizedProps))) {
            var c = gr;
            if (c) {
                if (As(u)) {
                    for (u = gr; u; )
                        u = me(u);
                    throw Error(o(418))
                }
                for (; c; )
                    xi(u, c),
                    c = me(c)
            }
        }
        if (zo(u),
        u.tag === 13) {
            if (!Ee)
                throw Error(o(316));
            if (u = u.memoizedState,
            u = u !== null ? u.dehydrated : null,
            !u)
                throw Error(o(317));
            gr = Yt(u)
        } else
            gr = mr ? me(u.stateNode) : null;
        return !0
    }
    function Gi() {
        Ee && (gr = mr = null,
        Ti = ln = !1)
    }
    function vr(u) {
        Xn === null ? Xn = [u] : Xn.push(u)
    }
    function Br(u, c, v) {
        if (u = v.ref,
        u !== null && typeof u != "function" && typeof u != "object") {
            if (v._owner) {
                if (v = v._owner,
                v) {
                    if (v.tag !== 1)
                        throw Error(o(309));
                    var E = v.stateNode
                }
                if (!E)
                    throw Error(o(147, u));
                var D = E
                  , L = "" + u;
                return c !== null && c.ref !== null && typeof c.ref == "function" && c.ref._stringRef === L ? c.ref : (c = function(ie) {
                    var _e = D.refs;
                    _e === zn && (_e = D.refs = {}),
                    ie === null ? delete _e[L] : _e[L] = ie
                }
                ,
                c._stringRef = L,
                c)
            }
            if (typeof u != "string")
                throw Error(o(284));
            if (!v._owner)
                throw Error(o(290, u))
        }
        return u
    }
    function Pi(u, c) {
        throw u = Object.prototype.toString.call(c),
        Error(o(31, u === "[object Object]" ? "object with keys {" + Object.keys(c).join(", ") + "}" : u))
    }
    function Ra(u) {
        var c = u._init;
        return c(u._payload)
    }
    function Cs(u) {
        function c(ke, Me) {
            if (u) {
                var Xe = ke.deletions;
                Xe === null ? (ke.deletions = [Me],
                ke.flags |= 16) : Xe.push(Me)
            }
        }
        function v(ke, Me) {
            if (!u)
                return null;
            for (; Me !== null; )
                c(ke, Me),
                Me = Me.sibling;
            return null
        }
        function E(ke, Me) {
            for (ke = new Map; Me !== null; )
                Me.key !== null ? ke.set(Me.key, Me) : ke.set(Me.index, Me),
                Me = Me.sibling;
            return ke
        }
        function D(ke, Me) {
            return ke = Xu(ke, Me),
            ke.index = 0,
            ke.sibling = null,
            ke
        }
        function L(ke, Me, Xe) {
            return ke.index = Xe,
            u ? (Xe = ke.alternate,
            Xe !== null ? (Xe = Xe.index,
            Xe < Me ? (ke.flags |= 2,
            Me) : Xe) : (ke.flags |= 2,
            Me)) : (ke.flags |= 1048576,
            Me)
        }
        function ie(ke) {
            return u && ke.alternate === null && (ke.flags |= 2),
            ke
        }
        function _e(ke, Me, Xe, Ht) {
            return Me === null || Me.tag !== 6 ? (Me = sy(Xe, ke.mode, Ht),
            Me.return = ke,
            Me) : (Me = D(Me, Xe),
            Me.return = ke,
            Me)
        }
        function Qe(ke, Me, Xe, Ht) {
            var sn = Xe.type;
            return sn === h ? qt(ke, Me, Xe.props.children, Ht, Xe.key) : Me !== null && (Me.elementType === sn || typeof sn == "object" && sn !== null && sn.$$typeof === w && Ra(sn) === Me.type) ? (Ht = D(Me, Xe.props),
            Ht.ref = Br(ke, Me, Xe),
            Ht.return = ke,
            Ht) : (Ht = vg(Xe.type, Xe.key, Xe.props, null, ke.mode, Ht),
            Ht.ref = Br(ke, Me, Xe),
            Ht.return = ke,
            Ht)
        }
        function wt(ke, Me, Xe, Ht) {
            return Me === null || Me.tag !== 4 || Me.stateNode.containerInfo !== Xe.containerInfo || Me.stateNode.implementation !== Xe.implementation ? (Me = oy(Xe, ke.mode, Ht),
            Me.return = ke,
            Me) : (Me = D(Me, Xe.children || []),
            Me.return = ke,
            Me)
        }
        function qt(ke, Me, Xe, Ht, sn) {
            return Me === null || Me.tag !== 7 ? (Me = qc(Xe, ke.mode, Ht, sn),
            Me.return = ke,
            Me) : (Me = D(Me, Xe),
            Me.return = ke,
            Me)
        }
        function Rn(ke, Me, Xe) {
            if (typeof Me == "string" && Me !== "" || typeof Me == "number")
                return Me = sy("" + Me, ke.mode, Xe),
                Me.return = ke,
                Me;
            if (typeof Me == "object" && Me !== null) {
                switch (Me.$$typeof) {
                case l:
                    return Xe = vg(Me.type, Me.key, Me.props, null, ke.mode, Xe),
                    Xe.ref = Br(ke, null, Me),
                    Xe.return = ke,
                    Xe;
                case f:
                    return Me = oy(Me, ke.mode, Xe),
                    Me.return = ke,
                    Me;
                case w:
                    var Ht = Me._init;
                    return Rn(ke, Ht(Me._payload), Xe)
                }
                if (pe(Me) || I(Me))
                    return Me = qc(Me, ke.mode, Xe, null),
                    Me.return = ke,
                    Me;
                Pi(ke, Me)
            }
            return null
        }
        function gn(ke, Me, Xe, Ht) {
            var sn = Me !== null ? Me.key : null;
            if (typeof Xe == "string" && Xe !== "" || typeof Xe == "number")
                return sn !== null ? null : _e(ke, Me, "" + Xe, Ht);
            if (typeof Xe == "object" && Xe !== null) {
                switch (Xe.$$typeof) {
                case l:
                    return Xe.key === sn ? Qe(ke, Me, Xe, Ht) : null;
                case f:
                    return Xe.key === sn ? wt(ke, Me, Xe, Ht) : null;
                case w:
                    return sn = Xe._init,
                    gn(ke, Me, sn(Xe._payload), Ht)
                }
                if (pe(Xe) || I(Xe))
                    return sn !== null ? null : qt(ke, Me, Xe, Ht, null);
                Pi(ke, Xe)
            }
            return null
        }
        function ri(ke, Me, Xe, Ht, sn) {
            if (typeof Ht == "string" && Ht !== "" || typeof Ht == "number")
                return ke = ke.get(Xe) || null,
                _e(Me, ke, "" + Ht, sn);
            if (typeof Ht == "object" && Ht !== null) {
                switch (Ht.$$typeof) {
                case l:
                    return ke = ke.get(Ht.key === null ? Xe : Ht.key) || null,
                    Qe(Me, ke, Ht, sn);
                case f:
                    return ke = ke.get(Ht.key === null ? Xe : Ht.key) || null,
                    wt(Me, ke, Ht, sn);
                case w:
                    var Hn = Ht._init;
                    return ri(ke, Me, Xe, Hn(Ht._payload), sn)
                }
                if (pe(Ht) || I(Ht))
                    return ke = ke.get(Xe) || null,
                    qt(Me, ke, Ht, sn, null);
                Pi(Me, Ht)
            }
            return null
        }
        function an(ke, Me, Xe, Ht) {
            for (var sn = null, Hn = null, Bn = Me, Ar = Me = 0, bs = null; Bn !== null && Ar < Xe.length; Ar++) {
                Bn.index > Ar ? (bs = Bn,
                Bn = null) : bs = Bn.sibling;
                var Cr = gn(ke, Bn, Xe[Ar], Ht);
                if (Cr === null) {
                    Bn === null && (Bn = bs);
                    break
                }
                u && Bn && Cr.alternate === null && c(ke, Bn),
                Me = L(Cr, Me, Ar),
                Hn === null ? sn = Cr : Hn.sibling = Cr,
                Hn = Cr,
                Bn = bs
            }
            if (Ar === Xe.length)
                return v(ke, Bn),
                ln && _n(ke, Ar),
                sn;
            if (Bn === null) {
                for (; Ar < Xe.length; Ar++)
                    Bn = Rn(ke, Xe[Ar], Ht),
                    Bn !== null && (Me = L(Bn, Me, Ar),
                    Hn === null ? sn = Bn : Hn.sibling = Bn,
                    Hn = Bn);
                return ln && _n(ke, Ar),
                sn
            }
            for (Bn = E(ke, Bn); Ar < Xe.length; Ar++)
                bs = ri(Bn, ke, Ar, Xe[Ar], Ht),
                bs !== null && (u && bs.alternate !== null && Bn.delete(bs.key === null ? Ar : bs.key),
                Me = L(bs, Me, Ar),
                Hn === null ? sn = bs : Hn.sibling = bs,
                Hn = bs);
            return u && Bn.forEach(function(Ju) {
                return c(ke, Ju)
            }),
            ln && _n(ke, Ar),
            sn
        }
        function $s(ke, Me, Xe, Ht) {
            var sn = I(Xe);
            if (typeof sn != "function")
                throw Error(o(150));
            if (Xe = sn.call(Xe),
            Xe == null)
                throw Error(o(151));
            for (var Hn = sn = null, Bn = Me, Ar = Me = 0, bs = null, Cr = Xe.next(); Bn !== null && !Cr.done; Ar++,
            Cr = Xe.next()) {
                Bn.index > Ar ? (bs = Bn,
                Bn = null) : bs = Bn.sibling;
                var Ju = gn(ke, Bn, Cr.value, Ht);
                if (Ju === null) {
                    Bn === null && (Bn = bs);
                    break
                }
                u && Bn && Ju.alternate === null && c(ke, Bn),
                Me = L(Ju, Me, Ar),
                Hn === null ? sn = Ju : Hn.sibling = Ju,
                Hn = Ju,
                Bn = bs
            }
            if (Cr.done)
                return v(ke, Bn),
                ln && _n(ke, Ar),
                sn;
            if (Bn === null) {
                for (; !Cr.done; Ar++,
                Cr = Xe.next())
                    Cr = Rn(ke, Cr.value, Ht),
                    Cr !== null && (Me = L(Cr, Me, Ar),
                    Hn === null ? sn = Cr : Hn.sibling = Cr,
                    Hn = Cr);
                return ln && _n(ke, Ar),
                sn
            }
            for (Bn = E(ke, Bn); !Cr.done; Ar++,
            Cr = Xe.next())
                Cr = ri(Bn, ke, Ar, Cr.value, Ht),
                Cr !== null && (u && Cr.alternate !== null && Bn.delete(Cr.key === null ? Ar : Cr.key),
                Me = L(Cr, Me, Ar),
                Hn === null ? sn = Cr : Hn.sibling = Cr,
                Hn = Cr);
            return u && Bn.forEach(function(SR) {
                return c(ke, SR)
            }),
            ln && _n(ke, Ar),
            sn
        }
        function Na(ke, Me, Xe, Ht) {
            if (typeof Xe == "object" && Xe !== null && Xe.type === h && Xe.key === null && (Xe = Xe.props.children),
            typeof Xe == "object" && Xe !== null) {
                switch (Xe.$$typeof) {
                case l:
                    e: {
                        for (var sn = Xe.key, Hn = Me; Hn !== null; ) {
                            if (Hn.key === sn) {
                                if (sn = Xe.type,
                                sn === h) {
                                    if (Hn.tag === 7) {
                                        v(ke, Hn.sibling),
                                        Me = D(Hn, Xe.props.children),
                                        Me.return = ke,
                                        ke = Me;
                                        break e
                                    }
                                } else if (Hn.elementType === sn || typeof sn == "object" && sn !== null && sn.$$typeof === w && Ra(sn) === Hn.type) {
                                    v(ke, Hn.sibling),
                                    Me = D(Hn, Xe.props),
                                    Me.ref = Br(ke, Hn, Xe),
                                    Me.return = ke,
                                    ke = Me;
                                    break e
                                }
                                v(ke, Hn);
                                break
                            } else
                                c(ke, Hn);
                            Hn = Hn.sibling
                        }
                        Xe.type === h ? (Me = qc(Xe.props.children, ke.mode, Ht, Xe.key),
                        Me.return = ke,
                        ke = Me) : (Ht = vg(Xe.type, Xe.key, Xe.props, null, ke.mode, Ht),
                        Ht.ref = Br(ke, Me, Xe),
                        Ht.return = ke,
                        ke = Ht)
                    }
                    return ie(ke);
                case f:
                    e: {
                        for (Hn = Xe.key; Me !== null; ) {
                            if (Me.key === Hn)
                                if (Me.tag === 4 && Me.stateNode.containerInfo === Xe.containerInfo && Me.stateNode.implementation === Xe.implementation) {
                                    v(ke, Me.sibling),
                                    Me = D(Me, Xe.children || []),
                                    Me.return = ke,
                                    ke = Me;
                                    break e
                                } else {
                                    v(ke, Me);
                                    break
                                }
                            else
                                c(ke, Me);
                            Me = Me.sibling
                        }
                        Me = oy(Xe, ke.mode, Ht),
                        Me.return = ke,
                        ke = Me
                    }
                    return ie(ke);
                case w:
                    return Hn = Xe._init,
                    Na(ke, Me, Hn(Xe._payload), Ht)
                }
                if (pe(Xe))
                    return an(ke, Me, Xe, Ht);
                if (I(Xe))
                    return $s(ke, Me, Xe, Ht);
                Pi(ke, Xe)
            }
            return typeof Xe == "string" && Xe !== "" || typeof Xe == "number" ? (Xe = "" + Xe,
            Me !== null && Me.tag === 6 ? (v(ke, Me.sibling),
            Me = D(Me, Xe),
            Me.return = ke,
            ke = Me) : (v(ke, Me),
            Me = sy(Xe, ke.mode, Ht),
            Me.return = ke,
            ke = Me),
            ie(ke)) : v(ke, Me)
        }
        return Na
    }
    var kr = Cs(!0)
      , Pn = Cs(!1)
      , Or = {}
      , _r = xs(Or)
      , cs = xs(Or)
      , li = xs(Or);
    function Ye(u) {
        if (u === Or)
            throw Error(o(174));
        return u
    }
    function fo(u, c) {
        An(li, c),
        An(cs, u),
        An(_r, Or),
        u = xe(c),
        Mn(_r),
        An(_r, u)
    }
    function Gn() {
        Mn(_r),
        Mn(cs),
        Mn(li)
    }
    function ho(u) {
        var c = Ye(li.current)
          , v = Ye(_r.current);
        c = G(v, u.type, c),
        v !== c && (An(cs, u),
        An(_r, c))
    }
    function Go(u) {
        cs.current === u && (Mn(_r),
        Mn(cs))
    }
    var Sr = xs(0);
    function Ui(u) {
        for (var c = u; c !== null; ) {
            if (c.tag === 13) {
                var v = c.memoizedState;
                if (v !== null && (v = v.dehydrated,
                v === null || Qn(v) || vn(v)))
                    return c
            } else if (c.tag === 19 && c.memoizedProps.revealOrder !== void 0) {
                if (c.flags & 128)
                    return c
            } else if (c.child !== null) {
                c.child.return = c,
                c = c.child;
                continue
            }
            if (c === u)
                break;
            for (; c.sibling === null; ) {
                if (c.return === null || c.return === u)
                    return null;
                c = c.return
            }
            c.sibling.return = c.return,
            c = c.sibling
        }
        return null
    }
    var Ba = [];
    function po() {
        for (var u = 0; u < Ba.length; u++) {
            var c = Ba[u];
            He ? c._workInProgressVersionPrimary = null : c._workInProgressVersionSecondary = null
        }
        Ba.length = 0
    }
    var Wr = a.ReactCurrentDispatcher
      , Xr = a.ReactCurrentBatchConfig
      , wi = 0
      , Ir = null
      , ur = null
      , Er = null
      , cr = !1
      , ui = !1
      , Uo = 0
      , Ia = 0;
    function ci() {
        throw Error(o(321))
    }
    function Jn(u, c) {
        if (c === null)
            return !1;
        for (var v = 0; v < c.length && v < u.length; v++)
            if (!Lr(u[v], c[v]))
                return !1;
        return !0
    }
    function Ks(u, c, v, E, D, L) {
        if (wi = L,
        Ir = c,
        c.memoizedState = null,
        c.updateQueue = null,
        c.lanes = 0,
        Wr.current = u === null || u.memoizedState === null ? k_ : $m,
        u = v(E, D),
        ui) {
            L = 0;
            do {
                if (ui = !1,
                Uo = 0,
                25 <= L)
                    throw Error(o(301));
                L += 1,
                Er = ur = null,
                c.updateQueue = null,
                Wr.current = O_,
                u = v(E, D)
            } while (ui)
        }
        if (Wr.current = La,
        c = ur !== null && ur.next !== null,
        wi = 0,
        Er = ur = Ir = null,
        cr = !1,
        c)
            throw Error(o(300));
        return u
    }
    function fs() {
        var u = Uo !== 0;
        return Uo = 0,
        u
    }
    function Mr() {
        var u = {
            memoizedState: null,
            baseState: null,
            baseQueue: null,
            queue: null,
            next: null
        };
        return Er === null ? Ir.memoizedState = Er = u : Er = Er.next = u,
        Er
    }
    function Si() {
        if (ur === null) {
            var u = Ir.alternate;
            u = u !== null ? u.memoizedState : null
        } else
            u = ur.next;
        var c = Er === null ? Ir.memoizedState : Er.next;
        if (c !== null)
            Er = c,
            ur = u;
        else {
            if (u === null)
                throw Error(o(310));
            ur = u,
            u = {
                memoizedState: ur.memoizedState,
                baseState: ur.baseState,
                baseQueue: ur.baseQueue,
                queue: ur.queue,
                next: null
            },
            Er === null ? Ir.memoizedState = Er = u : Er = Er.next = u
        }
        return Er
    }
    function hi(u, c) {
        return typeof c == "function" ? c(u) : c
    }
    function qs(u) {
        var c = Si()
          , v = c.queue;
        if (v === null)
            throw Error(o(311));
        v.lastRenderedReducer = u;
        var E = ur
          , D = E.baseQueue
          , L = v.pending;
        if (L !== null) {
            if (D !== null) {
                var ie = D.next;
                D.next = L.next,
                L.next = ie
            }
            E.baseQueue = D = L,
            v.pending = null
        }
        if (D !== null) {
            L = D.next,
            E = E.baseState;
            var _e = ie = null
              , Qe = null
              , wt = L;
            do {
                var qt = wt.lane;
                if ((wi & qt) === qt)
                    Qe !== null && (Qe = Qe.next = {
                        lane: 0,
                        action: wt.action,
                        hasEagerState: wt.hasEagerState,
                        eagerState: wt.eagerState,
                        next: null
                    }),
                    E = wt.hasEagerState ? wt.eagerState : u(E, wt.action);
                else {
                    var Rn = {
                        lane: qt,
                        action: wt.action,
                        hasEagerState: wt.hasEagerState,
                        eagerState: wt.eagerState,
                        next: null
                    };
                    Qe === null ? (_e = Qe = Rn,
                    ie = E) : Qe = Qe.next = Rn,
                    Ir.lanes |= qt,
                    sd |= qt
                }
                wt = wt.next
            } while (wt !== null && wt !== L);
            Qe === null ? ie = E : Qe.next = _e,
            Lr(E, c.memoizedState) || ($e = !0),
            c.memoizedState = E,
            c.baseState = ie,
            c.baseQueue = Qe,
            v.lastRenderedState = E
        }
        if (u = v.interleaved,
        u !== null) {
            D = u;
            do
                L = D.lane,
                Ir.lanes |= L,
                sd |= L,
                D = D.next;
            while (D !== u)
        } else
            D === null && (v.lanes = 0);
        return [c.memoizedState, v.dispatch]
    }
    function mo(u) {
        var c = Si()
          , v = c.queue;
        if (v === null)
            throw Error(o(311));
        v.lastRenderedReducer = u;
        var E = v.dispatch
          , D = v.pending
          , L = c.memoizedState;
        if (D !== null) {
            v.pending = null;
            var ie = D = D.next;
            do
                L = u(L, ie.action),
                ie = ie.next;
            while (ie !== D);
            Lr(L, c.memoizedState) || ($e = !0),
            c.memoizedState = L,
            c.baseQueue === null && (c.baseState = L),
            v.lastRenderedState = L
        }
        return [L, E]
    }
    function go() {}
    function il(u, c) {
        var v = Ir
          , E = Si()
          , D = c()
          , L = !Lr(E.memoizedState, D);
        if (L && (E.memoizedState = D,
        $e = !0),
        E = E.queue,
        Es(ht.bind(null, v, E, u), [u]),
        E.getSnapshot !== c || L || Er !== null && Er.memoizedState.tag & 1) {
            if (v.flags |= 2048,
            on(9, Zt.bind(null, v, E, D, c), void 0, null),
            rs === null)
                throw Error(o(349));
            wi & 30 || Un(v, c, D)
        }
        return D
    }
    function Un(u, c, v) {
        u.flags |= 16384,
        u = {
            getSnapshot: c,
            value: v
        },
        c = Ir.updateQueue,
        c === null ? (c = {
            lastEffect: null,
            stores: null
        },
        Ir.updateQueue = c,
        c.stores = [u]) : (v = c.stores,
        v === null ? c.stores = [u] : v.push(u))
    }
    function Zt(u, c, v, E) {
        c.value = v,
        c.getSnapshot = E,
        un(c) && ka(u, 1, -1)
    }
    function ht(u, c, v) {
        return v(function() {
            un(c) && ka(u, 1, -1)
        })
    }
    function un(u) {
        var c = u.getSnapshot;
        u = u.value;
        try {
            var v = c();
            return !Lr(u, v)
        } catch {
            return !0
        }
    }
    function cn(u) {
        var c = Mr();
        return typeof u == "function" && (u = u()),
        c.memoizedState = c.baseState = u,
        u = {
            pending: null,
            interleaved: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: hi,
            lastRenderedState: u
        },
        c.queue = u,
        u = u.dispatch = aa.bind(null, Ir, u),
        [c.memoizedState, u]
    }
    function on(u, c, v, E) {
        return u = {
            tag: u,
            create: c,
            destroy: v,
            deps: E,
            next: null
        },
        c = Ir.updateQueue,
        c === null ? (c = {
            lastEffect: null,
            stores: null
        },
        Ir.updateQueue = c,
        c.lastEffect = u.next = u) : (v = c.lastEffect,
        v === null ? c.lastEffect = u.next = u : (E = v.next,
        v.next = u,
        u.next = E,
        c.lastEffect = u)),
        u
    }
    function br() {
        return Si().memoizedState
    }
    function Tn(u, c, v, E) {
        var D = Mr();
        Ir.flags |= u,
        D.memoizedState = on(1 | c, v, void 0, E === void 0 ? null : E)
    }
    function Jr(u, c, v, E) {
        var D = Si();
        E = E === void 0 ? null : E;
        var L = void 0;
        if (ur !== null) {
            var ie = ur.memoizedState;
            if (L = ie.destroy,
            E !== null && Jn(E, ie.deps)) {
                D.memoizedState = on(c, v, L, E);
                return
            }
        }
        Ir.flags |= u,
        D.memoizedState = on(1 | c, v, L, E)
    }
    function jr(u, c) {
        return Tn(8390656, 8, u, c)
    }
    function Es(u, c) {
        return Jr(2048, 8, u, c)
    }
    function fr(u, c) {
        return Jr(4, 2, u, c)
    }
    function Zr(u, c) {
        return Jr(4, 4, u, c)
    }
    function Fs(u, c) {
        if (typeof c == "function")
            return u = u(),
            c(u),
            function() {
                c(null)
            }
            ;
        if (c != null)
            return u = u(),
            c.current = u,
            function() {
                c.current = null
            }
    }
    function Yr(u, c, v) {
        return v = v != null ? v.concat([u]) : null,
        Jr(4, 4, Fs.bind(null, c, u), v)
    }
    function Nr() {}
    function $r(u, c) {
        var v = Si();
        c = c === void 0 ? null : c;
        var E = v.memoizedState;
        return E !== null && c !== null && Jn(c, E[1]) ? E[0] : (v.memoizedState = [u, c],
        u)
    }
    function oa(u, c) {
        var v = Si();
        c = c === void 0 ? null : c;
        var E = v.memoizedState;
        return E !== null && c !== null && Jn(c, E[1]) ? E[0] : (u = u(),
        v.memoizedState = [u, c],
        u)
    }
    function vo(u, c) {
        var v = Dt;
        Dt = v !== 0 && 4 > v ? v : 4,
        u(!0);
        var E = Xr.transition;
        Xr.transition = {};
        try {
            u(!1),
            c()
        } finally {
            Dt = v,
            Xr.transition = E
        }
    }
    function ei() {
        return Si().memoizedState
    }
    function Kr(u, c, v) {
        var E = Vu(u);
        v = {
            lane: E,
            action: v,
            hasEagerState: !1,
            eagerState: null,
            next: null
        },
        Ho(u) ? sl(c, v) : (Qs(u, c, v),
        v = _o(),
        u = ka(u, E, v),
        u !== null && Zs(u, c, E))
    }
    function aa(u, c, v) {
        var E = Vu(u)
          , D = {
            lane: E,
            action: v,
            hasEagerState: !1,
            eagerState: null,
            next: null
        };
        if (Ho(u))
            sl(c, D);
        else {
            Qs(u, c, D);
            var L = u.alternate;
            if (u.lanes === 0 && (L === null || L.lanes === 0) && (L = c.lastRenderedReducer,
            L !== null))
                try {
                    var ie = c.lastRenderedState
                      , _e = L(ie, v);
                    if (D.hasEagerState = !0,
                    D.eagerState = _e,
                    Lr(_e, ie))
                        return
                } catch {} finally {}
            v = _o(),
            u = ka(u, E, v),
            u !== null && Zs(u, c, E)
        }
    }
    function Ho(u) {
        var c = u.alternate;
        return u === Ir || c !== null && c === Ir
    }
    function sl(u, c) {
        ui = cr = !0;
        var v = u.pending;
        v === null ? c.next = c : (c.next = v.next,
        v.next = c),
        u.pending = c
    }
    function Qs(u, c, v) {
        rs !== null && u.mode & 1 && !(jn & 2) ? (u = c.interleaved,
        u === null ? (v.next = v,
        Te === null ? Te = [c] : Te.push(c)) : (v.next = u.next,
        u.next = v),
        c.interleaved = v) : (u = c.pending,
        u === null ? v.next = v : (v.next = u.next,
        u.next = v),
        c.pending = v)
    }
    function Zs(u, c, v) {
        if (v & 4194240) {
            var E = c.lanes;
            E &= u.pendingLanes,
            v |= E,
            c.lanes = v,
            Ms(u, v)
        }
    }
    var La = {
        readContext: Ls,
        useCallback: ci,
        useContext: ci,
        useEffect: ci,
        useImperativeHandle: ci,
        useInsertionEffect: ci,
        useLayoutEffect: ci,
        useMemo: ci,
        useReducer: ci,
        useRef: ci,
        useState: ci,
        useDebugValue: ci,
        useDeferredValue: ci,
        useTransition: ci,
        useMutableSource: ci,
        useSyncExternalStore: ci,
        useId: ci,
        unstable_isNewReconciler: !1
    }
      , k_ = {
        readContext: Ls,
        useCallback: function(u, c) {
            return Mr().memoizedState = [u, c === void 0 ? null : c],
            u
        },
        useContext: Ls,
        useEffect: jr,
        useImperativeHandle: function(u, c, v) {
            return v = v != null ? v.concat([u]) : null,
            Tn(4194308, 4, Fs.bind(null, c, u), v)
        },
        useLayoutEffect: function(u, c) {
            return Tn(4194308, 4, u, c)
        },
        useInsertionEffect: function(u, c) {
            return Tn(4, 2, u, c)
        },
        useMemo: function(u, c) {
            var v = Mr();
            return c = c === void 0 ? null : c,
            u = u(),
            v.memoizedState = [u, c],
            u
        },
        useReducer: function(u, c, v) {
            var E = Mr();
            return c = v !== void 0 ? v(c) : c,
            E.memoizedState = E.baseState = c,
            u = {
                pending: null,
                interleaved: null,
                lanes: 0,
                dispatch: null,
                lastRenderedReducer: u,
                lastRenderedState: c
            },
            E.queue = u,
            u = u.dispatch = Kr.bind(null, Ir, u),
            [E.memoizedState, u]
        },
        useRef: function(u) {
            var c = Mr();
            return u = {
                current: u
            },
            c.memoizedState = u
        },
        useState: cn,
        useDebugValue: Nr,
        useDeferredValue: function(u) {
            var c = cn(u)
              , v = c[0]
              , E = c[1];
            return jr(function() {
                var D = Xr.transition;
                Xr.transition = {};
                try {
                    E(u)
                } finally {
                    Xr.transition = D
                }
            }, [u]),
            v
        },
        useTransition: function() {
            var u = cn(!1)
              , c = u[0];
            return u = vo.bind(null, u[1]),
            Mr().memoizedState = u,
            [c, u]
        },
        useMutableSource: function() {},
        useSyncExternalStore: function(u, c, v) {
            var E = Ir
              , D = Mr();
            if (ln) {
                if (v === void 0)
                    throw Error(o(407));
                v = v()
            } else {
                if (v = c(),
                rs === null)
                    throw Error(o(349));
                wi & 30 || Un(E, c, v)
            }
            D.memoizedState = v;
            var L = {
                value: v,
                getSnapshot: c
            };
            return D.queue = L,
            jr(ht.bind(null, E, L, u), [u]),
            E.flags |= 2048,
            on(9, Zt.bind(null, E, L, v, c), void 0, null),
            v
        },
        useId: function() {
            var u = Mr()
              , c = rs.identifierPrefix;
            if (ln) {
                var v = bi
                  , E = di;
                v = (E & ~(1 << 32 - zi(E) - 1)).toString(32) + v,
                c = ":" + c + "R" + v,
                v = Uo++,
                0 < v && (c += "H" + v.toString(32)),
                c += ":"
            } else
                v = Ia++,
                c = ":" + c + "r" + v.toString(32) + ":";
            return u.memoizedState = c
        },
        unstable_isNewReconciler: !1
    }
      , $m = {
        readContext: Ls,
        useCallback: $r,
        useContext: Ls,
        useEffect: Es,
        useImperativeHandle: Yr,
        useInsertionEffect: fr,
        useLayoutEffect: Zr,
        useMemo: oa,
        useReducer: qs,
        useRef: br,
        useState: function() {
            return qs(hi)
        },
        useDebugValue: Nr,
        useDeferredValue: function(u) {
            var c = qs(hi)
              , v = c[0]
              , E = c[1];
            return Es(function() {
                var D = Xr.transition;
                Xr.transition = {};
                try {
                    E(u)
                } finally {
                    Xr.transition = D
                }
            }, [u]),
            v
        },
        useTransition: function() {
            var u = qs(hi)[0]
              , c = Si().memoizedState;
            return [u, c]
        },
        useMutableSource: go,
        useSyncExternalStore: il,
        useId: ei,
        unstable_isNewReconciler: !1
    }
      , O_ = {
        readContext: Ls,
        useCallback: $r,
        useContext: Ls,
        useEffect: Es,
        useImperativeHandle: Yr,
        useInsertionEffect: fr,
        useLayoutEffect: Zr,
        useMemo: oa,
        useReducer: mo,
        useRef: br,
        useState: function() {
            return mo(hi)
        },
        useDebugValue: Nr,
        useDeferredValue: function(u) {
            var c = mo(hi)
              , v = c[0]
              , E = c[1];
            return Es(function() {
                var D = Xr.transition;
                Xr.transition = {};
                try {
                    E(u)
                } finally {
                    Xr.transition = D
                }
            }, [u]),
            v
        },
        useTransition: function() {
            var u = mo(hi)[0]
              , c = Si().memoizedState;
            return [u, c]
        },
        useMutableSource: go,
        useSyncExternalStore: il,
        useId: ei,
        unstable_isNewReconciler: !1
    };
    function Vc(u, c) {
        try {
            var v = ""
              , E = c;
            do
                v += rd(E),
                E = E.return;
            while (E);
            var D = v
        } catch (L) {
            D = `
Error generating stack: ` + L.message + `
` + L.stack
        }
        return {
            value: u,
            source: c,
            stack: D
        }
    }
    function Wc(u, c) {
        try {
            console.error(c.value)
        } catch (v) {
            setTimeout(function() {
                throw v
            })
        }
    }
    var N_ = typeof WeakMap == "function" ? WeakMap : Map;
    function q(u, c, v) {
        v = Q(-1, v),
        v.tag = 3,
        v.payload = {
            element: null
        };
        var E = c.value;
        return v.callback = function() {
            cg || (cg = !0,
            Z_ = E),
            Wc(u, c)
        }
        ,
        v
    }
    function g(u, c, v) {
        v = Q(-1, v),
        v.tag = 3;
        var E = u.type.getDerivedStateFromError;
        if (typeof E == "function") {
            var D = c.value;
            v.payload = function() {
                return E(D)
            }
            ,
            v.callback = function() {
                Wc(u, c)
            }
        }
        var L = u.stateNode;
        return L !== null && typeof L.componentDidCatch == "function" && (v.callback = function() {
            Wc(u, c),
            typeof E != "function" && (Uu === null ? Uu = new Set([this]) : Uu.add(this));
            var ie = c.stack;
            this.componentDidCatch(c.value, {
                componentStack: ie !== null ? ie : ""
            })
        }
        ),
        v
    }
    function A(u, c, v) {
        var E = u.pingCache;
        if (E === null) {
            E = u.pingCache = new N_;
            var D = new Set;
            E.set(c, D)
        } else
            D = E.get(c),
            D === void 0 && (D = new Set,
            E.set(c, D));
        D.has(v) || (D.add(v),
        u = pR.bind(null, u, c, v),
        c.then(u, u))
    }
    function C(u) {
        do {
            var c;
            if ((c = u.tag === 13) && (c = u.memoizedState,
            c = c !== null ? c.dehydrated !== null : !0),
            c)
                return u;
            u = u.return
        } while (u !== null);
        return null
    }
    function b(u, c, v, E, D) {
        return u.mode & 1 ? (u.flags |= 65536,
        u.lanes = D,
        u) : (u === c ? u.flags |= 65536 : (u.flags |= 128,
        v.flags |= 131072,
        v.flags &= -52805,
        v.tag === 1 && (v.alternate === null ? v.tag = 17 : (c = Q(-1, 1),
        c.tag = 2,
        Se(v, c))),
        v.lanes |= 1),
        u)
    }
    function B(u) {
        u.flags |= 4
    }
    function F(u, c) {
        if (u !== null && u.child === c.child)
            return !0;
        if (c.flags & 16)
            return !1;
        for (u = c.child; u !== null; ) {
            if (u.flags & 12854 || u.subtreeFlags & 12854)
                return !1;
            u = u.sibling
        }
        return !0
    }
    var N, X, Y, se;
    if (gt)
        N = function(u, c) {
            for (var v = c.child; v !== null; ) {
                if (v.tag === 5 || v.tag === 6)
                    oe(u, v.stateNode);
                else if (v.tag !== 4 && v.child !== null) {
                    v.child.return = v,
                    v = v.child;
                    continue
                }
                if (v === c)
                    break;
                for (; v.sibling === null; ) {
                    if (v.return === null || v.return === c)
                        return;
                    v = v.return
                }
                v.sibling.return = v.return,
                v = v.sibling
            }
        }
        ,
        X = function() {}
        ,
        Y = function(u, c, v, E, D) {
            if (u = u.memoizedProps,
            u !== E) {
                var L = c.stateNode
                  , ie = Ye(_r.current);
                v = Ue(L, v, u, E, D, ie),
                (c.updateQueue = v) && B(c)
            }
        }
        ,
        se = function(u, c, v, E) {
            v !== E && B(c)
        }
        ;
    else if (be) {
        N = function(u, c, v, E) {
            for (var D = c.child; D !== null; ) {
                if (D.tag === 5) {
                    var L = D.stateNode;
                    v && E && (L = St(L, D.type, D.memoizedProps, D)),
                    oe(u, L)
                } else if (D.tag === 6)
                    L = D.stateNode,
                    v && E && (L = ut(L, D.memoizedProps, D)),
                    oe(u, L);
                else if (D.tag !== 4) {
                    if (D.tag === 22 && D.memoizedState !== null)
                        L = D.child,
                        L !== null && (L.return = D),
                        N(u, D, !0, !0);
                    else if (D.child !== null) {
                        D.child.return = D,
                        D = D.child;
                        continue
                    }
                }
                if (D === c)
                    break;
                for (; D.sibling === null; ) {
                    if (D.return === null || D.return === c)
                        return;
                    D = D.return
                }
                D.sibling.return = D.return,
                D = D.sibling
            }
        }
        ;
        var Re = function(u, c, v, E) {
            for (var D = c.child; D !== null; ) {
                if (D.tag === 5) {
                    var L = D.stateNode;
                    v && E && (L = St(L, D.type, D.memoizedProps, D)),
                    dn(u, L)
                } else if (D.tag === 6)
                    L = D.stateNode,
                    v && E && (L = ut(L, D.memoizedProps, D)),
                    dn(u, L);
                else if (D.tag !== 4) {
                    if (D.tag === 22 && D.memoizedState !== null)
                        L = D.child,
                        L !== null && (L.return = D),
                        Re(u, D, !0, !0);
                    else if (D.child !== null) {
                        D.child.return = D,
                        D = D.child;
                        continue
                    }
                }
                if (D === c)
                    break;
                for (; D.sibling === null; ) {
                    if (D.return === null || D.return === c)
                        return;
                    D = D.return
                }
                D.sibling.return = D.return,
                D = D.sibling
            }
        };
        X = function(u, c) {
            var v = c.stateNode;
            if (!F(u, c)) {
                u = v.containerInfo;
                var E = rn(u);
                Re(E, c, !1, !1),
                v.pendingChildren = E,
                B(c),
                or(u, E)
            }
        }
        ,
        Y = function(u, c, v, E, D) {
            var L = u.stateNode
              , ie = u.memoizedProps;
            if ((u = F(u, c)) && ie === E)
                c.stateNode = L;
            else {
                var _e = c.stateNode
                  , Qe = Ye(_r.current)
                  , wt = null;
                ie !== E && (wt = Ue(_e, v, ie, E, D, Qe)),
                u && wt === null ? c.stateNode = L : (L = Et(L, wt, v, ie, E, c, u, _e),
                Ae(L, v, E, D, Qe) && B(c),
                c.stateNode = L,
                u ? B(c) : N(L, c, !1, !1))
            }
        }
        ,
        se = function(u, c, v, E) {
            v !== E ? (u = Ye(li.current),
            v = Ye(_r.current),
            c.stateNode = de(E, u, v, c),
            B(c)) : c.stateNode = u.stateNode
        }
    } else
        X = function() {}
        ,
        Y = function() {}
        ,
        se = function() {}
        ;
    function Pe(u, c) {
        if (!ln)
            switch (u.tailMode) {
            case "hidden":
                c = u.tail;
                for (var v = null; c !== null; )
                    c.alternate !== null && (v = c),
                    c = c.sibling;
                v === null ? u.tail = null : v.sibling = null;
                break;
            case "collapsed":
                v = u.tail;
                for (var E = null; v !== null; )
                    v.alternate !== null && (E = v),
                    v = v.sibling;
                E === null ? c || u.tail === null ? u.tail = null : u.tail.sibling = null : E.sibling = null
            }
    }
    function Ie(u) {
        var c = u.alternate !== null && u.alternate.child === u.child
          , v = 0
          , E = 0;
        if (c)
            for (var D = u.child; D !== null; )
                v |= D.lanes | D.childLanes,
                E |= D.subtreeFlags & 14680064,
                E |= D.flags & 14680064,
                D.return = u,
                D = D.sibling;
        else
            for (D = u.child; D !== null; )
                v |= D.lanes | D.childLanes,
                E |= D.subtreeFlags,
                E |= D.flags,
                D.return = u,
                D = D.sibling;
        return u.subtreeFlags |= E,
        u.childLanes = v,
        c
    }
    function nt(u, c, v) {
        var E = c.pendingProps;
        switch (Ys(c),
        c.tag) {
        case 2:
        case 16:
        case 15:
        case 0:
        case 11:
        case 7:
        case 8:
        case 12:
        case 9:
        case 14:
            return Ie(c),
            null;
        case 1:
            return Yi(c.type) && Hr(),
            Ie(c),
            null;
        case 3:
            return E = c.stateNode,
            Gn(),
            Mn(Ni),
            Mn(ir),
            po(),
            E.pendingContext && (E.context = E.pendingContext,
            E.pendingContext = null),
            (u === null || u.child === null) && (Di(c) ? B(c) : u === null || u.memoizedState.isDehydrated && !(c.flags & 256) || (c.flags |= 1024,
            Xn !== null && (ty(Xn),
            Xn = null))),
            X(u, c),
            Ie(c),
            null;
        case 5:
            Go(c),
            v = Ye(li.current);
            var D = c.type;
            if (u !== null && c.stateNode != null)
                Y(u, c, D, E, v),
                u.ref !== c.ref && (c.flags |= 512,
                c.flags |= 2097152);
            else {
                if (!E) {
                    if (c.stateNode === null)
                        throw Error(o(166));
                    return Ie(c),
                    null
                }
                if (u = Ye(_r.current),
                Di(c)) {
                    if (!Ee)
                        throw Error(o(175));
                    u = Vt(c.stateNode, c.type, c.memoizedProps, v, u, c, !Ti),
                    c.updateQueue = u,
                    u !== null && B(c)
                } else {
                    var L = fe(D, E, v, u, c);
                    N(L, c, !1, !1),
                    c.stateNode = L,
                    Ae(L, D, E, v, u) && B(c)
                }
                c.ref !== null && (c.flags |= 512,
                c.flags |= 2097152)
            }
            return Ie(c),
            null;
        case 6:
            if (u && c.stateNode != null)
                se(u, c, u.memoizedProps, E);
            else {
                if (typeof E != "string" && c.stateNode === null)
                    throw Error(o(166));
                if (u = Ye(li.current),
                v = Ye(_r.current),
                Di(c)) {
                    if (!Ee)
                        throw Error(o(176));
                    if (u = c.stateNode,
                    E = c.memoizedProps,
                    (v = Ft(u, E, c, !Ti)) && (D = mr,
                    D !== null))
                        switch (L = (D.mode & 1) !== 0,
                        D.tag) {
                        case 3:
                            Yn(D.stateNode.containerInfo, u, E, L);
                            break;
                        case 5:
                            es(D.type, D.memoizedProps, D.stateNode, u, E, L)
                        }
                    v && B(c)
                } else
                    c.stateNode = de(E, u, v, c)
            }
            return Ie(c),
            null;
        case 13:
            if (Mn(Sr),
            E = c.memoizedState,
            ln && gr !== null && c.mode & 1 && !(c.flags & 128)) {
                for (u = gr; u; )
                    u = me(u);
                return Gi(),
                c.flags |= 98560,
                c
            }
            if (E !== null && E.dehydrated !== null) {
                if (E = Di(c),
                u === null) {
                    if (!E)
                        throw Error(o(318));
                    if (!Ee)
                        throw Error(o(344));
                    if (u = c.memoizedState,
                    u = u !== null ? u.dehydrated : null,
                    !u)
                        throw Error(o(317));
                    Gt(u, c)
                } else
                    Gi(),
                    !(c.flags & 128) && (c.memoizedState = null),
                    c.flags |= 4;
                return Ie(c),
                null
            }
            return Xn !== null && (ty(Xn),
            Xn = null),
            c.flags & 128 ? (c.lanes = v,
            c) : (E = E !== null,
            v = !1,
            u === null ? Di(c) : v = u.memoizedState !== null,
            E && !v && (c.child.flags |= 8192,
            c.mode & 1 && (u === null || Sr.current & 1 ? ds === 0 && (ds = 3) : ry())),
            c.updateQueue !== null && (c.flags |= 4),
            Ie(c),
            null);
        case 4:
            return Gn(),
            X(u, c),
            u === null && _t(c.stateNode.containerInfo),
            Ie(c),
            null;
        case 10:
            return Hc(c.type._context),
            Ie(c),
            null;
        case 17:
            return Yi(c.type) && Hr(),
            Ie(c),
            null;
        case 19:
            if (Mn(Sr),
            D = c.memoizedState,
            D === null)
                return Ie(c),
                null;
            if (E = (c.flags & 128) !== 0,
            L = D.rendering,
            L === null)
                if (E)
                    Pe(D, !1);
                else {
                    if (ds !== 0 || u !== null && u.flags & 128)
                        for (u = c.child; u !== null; ) {
                            if (L = Ui(u),
                            L !== null) {
                                for (c.flags |= 128,
                                Pe(D, !1),
                                u = L.updateQueue,
                                u !== null && (c.updateQueue = u,
                                c.flags |= 4),
                                c.subtreeFlags = 0,
                                u = v,
                                E = c.child; E !== null; )
                                    v = E,
                                    D = u,
                                    v.flags &= 14680066,
                                    L = v.alternate,
                                    L === null ? (v.childLanes = 0,
                                    v.lanes = D,
                                    v.child = null,
                                    v.subtreeFlags = 0,
                                    v.memoizedProps = null,
                                    v.memoizedState = null,
                                    v.updateQueue = null,
                                    v.dependencies = null,
                                    v.stateNode = null) : (v.childLanes = L.childLanes,
                                    v.lanes = L.lanes,
                                    v.child = L.child,
                                    v.subtreeFlags = 0,
                                    v.deletions = null,
                                    v.memoizedProps = L.memoizedProps,
                                    v.memoizedState = L.memoizedState,
                                    v.updateQueue = L.updateQueue,
                                    v.type = L.type,
                                    D = L.dependencies,
                                    v.dependencies = D === null ? null : {
                                        lanes: D.lanes,
                                        firstContext: D.firstContext
                                    }),
                                    E = E.sibling;
                                return An(Sr, Sr.current & 1 | 2),
                                c.child
                            }
                            u = u.sibling
                        }
                    D.tail !== null && yi() > Q_ && (c.flags |= 128,
                    E = !0,
                    Pe(D, !1),
                    c.lanes = 4194304)
                }
            else {
                if (!E)
                    if (u = Ui(L),
                    u !== null) {
                        if (c.flags |= 128,
                        E = !0,
                        u = u.updateQueue,
                        u !== null && (c.updateQueue = u,
                        c.flags |= 4),
                        Pe(D, !0),
                        D.tail === null && D.tailMode === "hidden" && !L.alternate && !ln)
                            return Ie(c),
                            null
                    } else
                        2 * yi() - D.renderingStartTime > Q_ && v !== 1073741824 && (c.flags |= 128,
                        E = !0,
                        Pe(D, !1),
                        c.lanes = 4194304);
                D.isBackwards ? (L.sibling = c.child,
                c.child = L) : (u = D.last,
                u !== null ? u.sibling = L : c.child = L,
                D.last = L)
            }
            return D.tail !== null ? (c = D.tail,
            D.rendering = c,
            D.tail = c.sibling,
            D.renderingStartTime = yi(),
            c.sibling = null,
            u = Sr.current,
            An(Sr, E ? u & 1 | 2 : u & 1),
            c) : (Ie(c),
            null);
        case 22:
        case 23:
            return ny(),
            E = c.memoizedState !== null,
            u !== null && u.memoizedState !== null !== E && (c.flags |= 8192),
            E && c.mode & 1 ? la & 1073741824 && (Ie(c),
            gt && c.subtreeFlags & 6 && (c.flags |= 8192)) : Ie(c),
            null;
        case 24:
            return null;
        case 25:
            return null
        }
        throw Error(o(156, c.tag))
    }
    var ve = a.ReactCurrentOwner
      , $e = !1;
    function lt(u, c, v, E) {
        c.child = u === null ? Pn(c, null, v, E) : kr(c, u.child, v, E)
    }
    function pt(u, c, v, E, D) {
        v = v.render;
        var L = c.ref;
        return sa(c, D),
        E = Ks(u, c, v, E, L, D),
        v = fs(),
        u !== null && !$e ? (c.updateQueue = u.updateQueue,
        c.flags &= -2053,
        u.lanes &= ~D,
        ks(u, c, D)) : (ln && v && Wn(c),
        c.flags |= 1,
        lt(u, c, E, D),
        c.child)
    }
    function xt(u, c, v, E, D) {
        if (u === null) {
            var L = v.type;
            return typeof L == "function" && !iy(L) && L.defaultProps === void 0 && v.compare === null && v.defaultProps === void 0 ? (c.tag = 15,
            c.type = L,
            Ct(u, c, L, E, D)) : (u = vg(v.type, null, E, c, c.mode, D),
            u.ref = c.ref,
            u.return = c,
            c.child = u)
        }
        if (L = u.child,
        !(u.lanes & D)) {
            var ie = L.memoizedProps;
            if (v = v.compare,
            v = v !== null ? v : Ou,
            v(ie, E) && u.ref === c.ref)
                return ks(u, c, D)
        }
        return c.flags |= 1,
        u = Xu(L, E),
        u.ref = c.ref,
        u.return = c,
        c.child = u
    }
    function Ct(u, c, v, E, D) {
        if (u !== null && Ou(u.memoizedProps, E) && u.ref === c.ref)
            if ($e = !1,
            (u.lanes & D) !== 0)
                u.flags & 131072 && ($e = !0);
            else
                return c.lanes = u.lanes,
                ks(u, c, D);
        return Wt(u, c, v, E, D)
    }
    function yt(u, c, v) {
        var E = c.pendingProps
          , D = E.children
          , L = u !== null ? u.memoizedState : null;
        if (E.mode === "hidden")
            if (!(c.mode & 1))
                c.memoizedState = {
                    baseLanes: 0,
                    cachePool: null
                },
                An(id, la),
                la |= v;
            else if (v & 1073741824)
                c.memoizedState = {
                    baseLanes: 0,
                    cachePool: null
                },
                E = L !== null ? L.baseLanes : v,
                An(id, la),
                la |= E;
            else
                return u = L !== null ? L.baseLanes | v : v,
                c.lanes = c.childLanes = 1073741824,
                c.memoizedState = {
                    baseLanes: u,
                    cachePool: null
                },
                c.updateQueue = null,
                An(id, la),
                la |= u,
                null;
        else
            L !== null ? (E = L.baseLanes | v,
            c.memoizedState = null) : E = v,
            An(id, la),
            la |= E;
        return lt(u, c, D, v),
        c.child
    }
    function jt(u, c) {
        var v = c.ref;
        (u === null && v !== null || u !== null && u.ref !== v) && (c.flags |= 512,
        c.flags |= 2097152)
    }
    function Wt(u, c, v, E, D) {
        var L = Yi(v) ? Js : ir.current;
        return L = ea(c, L),
        sa(c, D),
        v = Ks(u, c, v, E, L, D),
        E = fs(),
        u !== null && !$e ? (c.updateQueue = u.updateQueue,
        c.flags &= -2053,
        u.lanes &= ~D,
        ks(u, c, D)) : (ln && E && Wn(c),
        c.flags |= 1,
        lt(u, c, v, D),
        c.child)
    }
    function Ot(u, c, v, E, D) {
        if (Yi(v)) {
            var L = !0;
            Rl(c)
        } else
            L = !1;
        if (sa(c, D),
        c.stateNode === null)
            u !== null && (u.alternate = null,
            c.alternate = null,
            c.flags |= 2),
            Qt(c, v, E),
            lr(c, v, E, D),
            E = !0;
        else if (u === null) {
            var ie = c.stateNode
              , _e = c.memoizedProps;
            ie.props = _e;
            var Qe = ie.context
              , wt = v.contextType;
            typeof wt == "object" && wt !== null ? wt = Ls(wt) : (wt = Yi(v) ? Js : ir.current,
            wt = ea(c, wt));
            var qt = v.getDerivedStateFromProps
              , Rn = typeof qt == "function" || typeof ie.getSnapshotBeforeUpdate == "function";
            Rn || typeof ie.UNSAFE_componentWillReceiveProps != "function" && typeof ie.componentWillReceiveProps != "function" || (_e !== E || Qe !== wt) && Vr(c, ie, E, wt),
            J = !1;
            var gn = c.memoizedState;
            ie.state = gn,
            Bt(c, E, ie, D),
            Qe = c.memoizedState,
            _e !== E || gn !== Qe || Ni.current || J ? (typeof qt == "function" && (xn(c, v, qt, E),
            Qe = c.memoizedState),
            (_e = J || At(c, v, _e, E, gn, Qe, wt)) ? (Rn || typeof ie.UNSAFE_componentWillMount != "function" && typeof ie.componentWillMount != "function" || (typeof ie.componentWillMount == "function" && ie.componentWillMount(),
            typeof ie.UNSAFE_componentWillMount == "function" && ie.UNSAFE_componentWillMount()),
            typeof ie.componentDidMount == "function" && (c.flags |= 4194308)) : (typeof ie.componentDidMount == "function" && (c.flags |= 4194308),
            c.memoizedProps = E,
            c.memoizedState = Qe),
            ie.props = E,
            ie.state = Qe,
            ie.context = wt,
            E = _e) : (typeof ie.componentDidMount == "function" && (c.flags |= 4194308),
            E = !1)
        } else {
            ie = c.stateNode,
            K(u, c),
            _e = c.memoizedProps,
            wt = c.type === c.elementType ? _e : js(c.type, _e),
            ie.props = wt,
            Rn = c.pendingProps,
            gn = ie.context,
            Qe = v.contextType,
            typeof Qe == "object" && Qe !== null ? Qe = Ls(Qe) : (Qe = Yi(v) ? Js : ir.current,
            Qe = ea(c, Qe));
            var ri = v.getDerivedStateFromProps;
            (qt = typeof ri == "function" || typeof ie.getSnapshotBeforeUpdate == "function") || typeof ie.UNSAFE_componentWillReceiveProps != "function" && typeof ie.componentWillReceiveProps != "function" || (_e !== Rn || gn !== Qe) && Vr(c, ie, E, Qe),
            J = !1,
            gn = c.memoizedState,
            ie.state = gn,
            Bt(c, E, ie, D);
            var an = c.memoizedState;
            _e !== Rn || gn !== an || Ni.current || J ? (typeof ri == "function" && (xn(c, v, ri, E),
            an = c.memoizedState),
            (wt = J || At(c, v, wt, E, gn, an, Qe) || !1) ? (qt || typeof ie.UNSAFE_componentWillUpdate != "function" && typeof ie.componentWillUpdate != "function" || (typeof ie.componentWillUpdate == "function" && ie.componentWillUpdate(E, an, Qe),
            typeof ie.UNSAFE_componentWillUpdate == "function" && ie.UNSAFE_componentWillUpdate(E, an, Qe)),
            typeof ie.componentDidUpdate == "function" && (c.flags |= 4),
            typeof ie.getSnapshotBeforeUpdate == "function" && (c.flags |= 1024)) : (typeof ie.componentDidUpdate != "function" || _e === u.memoizedProps && gn === u.memoizedState || (c.flags |= 4),
            typeof ie.getSnapshotBeforeUpdate != "function" || _e === u.memoizedProps && gn === u.memoizedState || (c.flags |= 1024),
            c.memoizedProps = E,
            c.memoizedState = an),
            ie.props = E,
            ie.state = an,
            ie.context = Qe,
            E = wt) : (typeof ie.componentDidUpdate != "function" || _e === u.memoizedProps && gn === u.memoizedState || (c.flags |= 4),
            typeof ie.getSnapshotBeforeUpdate != "function" || _e === u.memoizedProps && gn === u.memoizedState || (c.flags |= 1024),
            E = !1)
        }
        return bt(u, c, v, E, L, D)
    }
    function bt(u, c, v, E, D, L) {
        jt(u, c);
        var ie = (c.flags & 128) !== 0;
        if (!E && !ie)
            return D && ts(c, v, !1),
            ks(u, c, L);
        E = c.stateNode,
        ve.current = c;
        var _e = ie && typeof v.getDerivedStateFromError != "function" ? null : E.render();
        return c.flags |= 1,
        u !== null && ie ? (c.child = kr(c, u.child, null, L),
        c.child = kr(c, null, _e, L)) : lt(u, c, _e, L),
        c.memoizedState = E.state,
        D && ts(c, v, !0),
        c.child
    }
    function dr(u) {
        var c = u.stateNode;
        c.pendingContext ? _i(u, c.pendingContext, c.pendingContext !== c.context) : c.context && _i(u, c.context, !1),
        fo(u, c.containerInfo)
    }
    function yr(u, c, v, E, D) {
        return Gi(),
        vr(D),
        c.flags |= 256,
        lt(u, c, v, E),
        c.child
    }
    var ti = {
        dehydrated: null,
        treeContext: null,
        retryLane: 0
    };
    function pi(u) {
        return {
            baseLanes: u,
            cachePool: null
        }
    }
    function Ri(u, c, v) {
        var E = c.pendingProps, D = Sr.current, L = !1, ie = (c.flags & 128) !== 0, _e;
        if ((_e = ie) || (_e = u !== null && u.memoizedState === null ? !1 : (D & 2) !== 0),
        _e ? (L = !0,
        c.flags &= -129) : (u === null || u.memoizedState !== null) && (D |= 1),
        An(Sr, D & 1),
        u === null)
            return No(c),
            u = c.memoizedState,
            u !== null && (u = u.dehydrated,
            u !== null) ? (c.mode & 1 ? vn(u) ? c.lanes = 8 : c.lanes = 1073741824 : c.lanes = 1,
            null) : (D = E.children,
            u = E.fallback,
            L ? (E = c.mode,
            L = c.child,
            D = {
                mode: "hidden",
                children: D
            },
            !(E & 1) && L !== null ? (L.childLanes = 0,
            L.pendingProps = D) : L = _g(D, E, 0, null),
            u = qc(u, E, v, null),
            L.return = c,
            u.return = c,
            L.sibling = u,
            c.child = L,
            c.child.memoizedState = pi(v),
            c.memoizedState = ti,
            u) : ni(c, D));
        if (D = u.memoizedState,
        D !== null) {
            if (_e = D.dehydrated,
            _e !== null) {
                if (ie)
                    return c.flags & 256 ? (c.flags &= -257,
                    ns(u, c, v, Error(o(422)))) : c.memoizedState !== null ? (c.child = u.child,
                    c.flags |= 128,
                    null) : (L = E.fallback,
                    D = c.mode,
                    E = _g({
                        mode: "visible",
                        children: E.children
                    }, D, 0, null),
                    L = qc(L, D, v, null),
                    L.flags |= 2,
                    E.return = c,
                    L.return = c,
                    E.sibling = L,
                    c.child = E,
                    c.mode & 1 && kr(c, u.child, null, v),
                    c.child.memoizedState = pi(v),
                    c.memoizedState = ti,
                    L);
                if (!(c.mode & 1))
                    c = ns(u, c, v, null);
                else if (vn(_e))
                    c = ns(u, c, v, Error(o(419)));
                else if (E = (v & u.childLanes) !== 0,
                $e || E) {
                    if (E = rs,
                    E !== null) {
                        switch (v & -v) {
                        case 4:
                            L = 2;
                            break;
                        case 16:
                            L = 8;
                            break;
                        case 64:
                        case 128:
                        case 256:
                        case 512:
                        case 1024:
                        case 2048:
                        case 4096:
                        case 8192:
                        case 16384:
                        case 32768:
                        case 65536:
                        case 131072:
                        case 262144:
                        case 524288:
                        case 1048576:
                        case 2097152:
                        case 4194304:
                        case 8388608:
                        case 16777216:
                        case 33554432:
                        case 67108864:
                            L = 32;
                            break;
                        case 536870912:
                            L = 268435456;
                            break;
                        default:
                            L = 0
                        }
                        E = L & (E.suspendedLanes | v) ? 0 : L,
                        E !== 0 && E !== D.retryLane && (D.retryLane = E,
                        ka(u, E, -1))
                    }
                    ry(),
                    c = ns(u, c, v, Error(o(421)))
                } else
                    Qn(_e) ? (c.flags |= 128,
                    c.child = u.child,
                    c = mR.bind(null, u),
                    j(_e, c),
                    c = null) : (v = D.treeContext,
                    Ee && (gr = Oe(_e),
                    mr = c,
                    ln = !0,
                    Xn = null,
                    Ti = !1,
                    v !== null && (Rr[Kn++] = di,
                    Rr[Kn++] = bi,
                    Rr[Kn++] = En,
                    di = v.id,
                    bi = v.overflow,
                    En = c)),
                    c = ni(c, c.pendingProps.children),
                    c.flags |= 4096);
                return c
            }
            return L ? (E = Bi(u, c, E.children, E.fallback, v),
            L = c.child,
            D = u.child.memoizedState,
            L.memoizedState = D === null ? pi(v) : {
                baseLanes: D.baseLanes | v,
                cachePool: null
            },
            L.childLanes = u.childLanes & ~v,
            c.memoizedState = ti,
            E) : (v = Hi(u, c, E.children, v),
            c.memoizedState = null,
            v)
        }
        return L ? (E = Bi(u, c, E.children, E.fallback, v),
        L = c.child,
        D = u.child.memoizedState,
        L.memoizedState = D === null ? pi(v) : {
            baseLanes: D.baseLanes | v,
            cachePool: null
        },
        L.childLanes = u.childLanes & ~v,
        c.memoizedState = ti,
        E) : (v = Hi(u, c, E.children, v),
        c.memoizedState = null,
        v)
    }
    function ni(u, c) {
        return c = _g({
            mode: "visible",
            children: c
        }, u.mode, 0, null),
        c.return = u,
        u.child = c
    }
    function Hi(u, c, v, E) {
        var D = u.child;
        return u = D.sibling,
        v = Xu(D, {
            mode: "visible",
            children: v
        }),
        !(c.mode & 1) && (v.lanes = E),
        v.return = c,
        v.sibling = null,
        u !== null && (E = c.deletions,
        E === null ? (c.deletions = [u],
        c.flags |= 16) : E.push(u)),
        c.child = v
    }
    function Bi(u, c, v, E, D) {
        var L = c.mode;
        u = u.child;
        var ie = u.sibling
          , _e = {
            mode: "hidden",
            children: v
        };
        return !(L & 1) && c.child !== u ? (v = c.child,
        v.childLanes = 0,
        v.pendingProps = _e,
        c.deletions = null) : (v = Xu(u, _e),
        v.subtreeFlags = u.subtreeFlags & 14680064),
        ie !== null ? E = Xu(ie, E) : (E = qc(E, L, D, null),
        E.flags |= 2),
        E.return = c,
        v.return = c,
        v.sibling = E,
        c.child = v,
        E
    }
    function ns(u, c, v, E) {
        return E !== null && vr(E),
        kr(c, u.child, null, v),
        u = ni(c, c.pendingProps.children),
        u.flags |= 2,
        c.memoizedState = null,
        u
    }
    function kl(u, c, v) {
        u.lanes |= c;
        var E = u.alternate;
        E !== null && (E.lanes |= c),
        zu(u.return, c, v)
    }
    function ol(u, c, v, E, D) {
        var L = u.memoizedState;
        L === null ? u.memoizedState = {
            isBackwards: c,
            rendering: null,
            renderingStartTime: 0,
            last: E,
            tail: v,
            tailMode: D
        } : (L.isBackwards = c,
        L.rendering = null,
        L.renderingStartTime = 0,
        L.last = E,
        L.tail = v,
        L.tailMode = D)
    }
    function Gu(u, c, v) {
        var E = c.pendingProps
          , D = E.revealOrder
          , L = E.tail;
        if (lt(u, c, E.children, v),
        E = Sr.current,
        E & 2)
            E = E & 1 | 2,
            c.flags |= 128;
        else {
            if (u !== null && u.flags & 128)
                e: for (u = c.child; u !== null; ) {
                    if (u.tag === 13)
                        u.memoizedState !== null && kl(u, v, c);
                    else if (u.tag === 19)
                        kl(u, v, c);
                    else if (u.child !== null) {
                        u.child.return = u,
                        u = u.child;
                        continue
                    }
                    if (u === c)
                        break e;
                    for (; u.sibling === null; ) {
                        if (u.return === null || u.return === c)
                            break e;
                        u = u.return
                    }
                    u.sibling.return = u.return,
                    u = u.sibling
                }
            E &= 1
        }
        if (An(Sr, E),
        !(c.mode & 1))
            c.memoizedState = null;
        else
            switch (D) {
            case "forwards":
                for (v = c.child,
                D = null; v !== null; )
                    u = v.alternate,
                    u !== null && Ui(u) === null && (D = v),
                    v = v.sibling;
                v = D,
                v === null ? (D = c.child,
                c.child = null) : (D = v.sibling,
                v.sibling = null),
                ol(c, !1, D, v, L);
                break;
            case "backwards":
                for (v = null,
                D = c.child,
                c.child = null; D !== null; ) {
                    if (u = D.alternate,
                    u !== null && Ui(u) === null) {
                        c.child = D;
                        break
                    }
                    u = D.sibling,
                    D.sibling = v,
                    v = D,
                    D = u
                }
                ol(c, !0, v, null, L);
                break;
            case "together":
                ol(c, !1, null, null, void 0);
                break;
            default:
                c.memoizedState = null
            }
        return c.child
    }
    function ks(u, c, v) {
        if (u !== null && (c.dependencies = u.dependencies),
        sd |= c.lanes,
        !(v & c.childLanes))
            return null;
        if (u !== null && c.child !== u.child)
            throw Error(o(153));
        if (c.child !== null) {
            for (u = c.child,
            v = Xu(u, u.pendingProps),
            c.child = v,
            v.return = c; u.sibling !== null; )
                u = u.sibling,
                v = v.sibling = Xu(u, u.pendingProps),
                v.return = c;
            v.sibling = null
        }
        return c.child
    }
    function eg(u, c, v) {
        switch (c.tag) {
        case 3:
            dr(c),
            Gi();
            break;
        case 5:
            ho(c);
            break;
        case 1:
            Yi(c.type) && Rl(c);
            break;
        case 4:
            fo(c, c.stateNode.containerInfo);
            break;
        case 10:
            Nu(c, c.type._context, c.memoizedProps.value);
            break;
        case 13:
            var E = c.memoizedState;
            if (E !== null)
                return E.dehydrated !== null ? (An(Sr, Sr.current & 1),
                c.flags |= 128,
                null) : v & c.child.childLanes ? Ri(u, c, v) : (An(Sr, Sr.current & 1),
                u = ks(u, c, v),
                u !== null ? u.sibling : null);
            An(Sr, Sr.current & 1);
            break;
        case 19:
            if (E = (v & c.childLanes) !== 0,
            u.flags & 128) {
                if (E)
                    return Gu(u, c, v);
                c.flags |= 128
            }
            var D = c.memoizedState;
            if (D !== null && (D.rendering = null,
            D.tail = null,
            D.lastEffect = null),
            An(Sr, Sr.current),
            E)
                break;
            return null;
        case 22:
        case 23:
            return c.lanes = 0,
            yt(u, c, v)
        }
        return ks(u, c, v)
    }
    function al(u, c) {
        switch (Ys(c),
        c.tag) {
        case 1:
            return Yi(c.type) && Hr(),
            u = c.flags,
            u & 65536 ? (c.flags = u & -65537 | 128,
            c) : null;
        case 3:
            return Gn(),
            Mn(Ni),
            Mn(ir),
            po(),
            u = c.flags,
            u & 65536 && !(u & 128) ? (c.flags = u & -65537 | 128,
            c) : null;
        case 5:
            return Go(c),
            null;
        case 13:
            if (Mn(Sr),
            u = c.memoizedState,
            u !== null && u.dehydrated !== null) {
                if (c.alternate === null)
                    throw Error(o(340));
                Gi()
            }
            return u = c.flags,
            u & 65536 ? (c.flags = u & -65537 | 128,
            c) : null;
        case 19:
            return Mn(Sr),
            null;
        case 4:
            return Gn(),
            null;
        case 10:
            return Hc(c.type._context),
            null;
        case 22:
        case 23:
            return ny(),
            null;
        case 24:
            return null;
        default:
            return null
        }
    }
    var Fa = !1
      , Xc = !1
      , sR = typeof WeakSet == "function" ? WeakSet : Set
      , zt = null;
    function tg(u, c) {
        var v = u.ref;
        if (v !== null)
            if (typeof v == "function")
                try {
                    v(null)
                } catch (E) {
                    Xo(u, c, E)
                }
            else
                v.current = null
    }
    function z_(u, c, v) {
        try {
            v()
        } catch (E) {
            Xo(u, c, E)
        }
    }
    var zM = !1;
    function oR(u, c) {
        for (z(u.containerInfo),
        zt = c; zt !== null; )
            if (u = zt,
            c = u.child,
            (u.subtreeFlags & 1028) !== 0 && c !== null)
                c.return = u,
                zt = c;
            else
                for (; zt !== null; ) {
                    u = zt;
                    try {
                        var v = u.alternate;
                        if (u.flags & 1024)
                            switch (u.tag) {
                            case 0:
                            case 11:
                            case 15:
                                break;
                            case 1:
                                if (v !== null) {
                                    var E = v.memoizedProps
                                      , D = v.memoizedState
                                      , L = u.stateNode
                                      , ie = L.getSnapshotBeforeUpdate(u.elementType === u.type ? E : js(u.type, E), D);
                                    L.__reactInternalSnapshotBeforeUpdate = ie
                                }
                                break;
                            case 3:
                                gt && vt(u.stateNode.containerInfo);
                                break;
                            case 5:
                            case 6:
                            case 4:
                            case 17:
                                break;
                            default:
                                throw Error(o(163))
                            }
                    } catch (_e) {
                        Xo(u, u.return, _e)
                    }
                    if (c = u.sibling,
                    c !== null) {
                        c.return = u.return,
                        zt = c;
                        break
                    }
                    zt = u.return
                }
        return v = zM,
        zM = !1,
        v
    }
    function Jc(u, c, v) {
        var E = c.updateQueue;
        if (E = E !== null ? E.lastEffect : null,
        E !== null) {
            var D = E = E.next;
            do {
                if ((D.tag & u) === u) {
                    var L = D.destroy;
                    D.destroy = void 0,
                    L !== void 0 && z_(c, v, L)
                }
                D = D.next
            } while (D !== E)
        }
    }
    function zh(u, c) {
        if (c = c.updateQueue,
        c = c !== null ? c.lastEffect : null,
        c !== null) {
            var v = c = c.next;
            do {
                if ((v.tag & u) === u) {
                    var E = v.create;
                    v.destroy = E()
                }
                v = v.next
            } while (v !== c)
        }
    }
    function G_(u) {
        var c = u.ref;
        if (c !== null) {
            var v = u.stateNode;
            switch (u.tag) {
            case 5:
                u = ce(v);
                break;
            default:
                u = v
            }
            typeof c == "function" ? c(u) : c.current = u
        }
    }
    function GM(u, c, v) {
        if (Ei && typeof Ei.onCommitFiberUnmount == "function")
            try {
                Ei.onCommitFiberUnmount(Oo, c)
            } catch {}
        switch (c.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
            if (u = c.updateQueue,
            u !== null && (u = u.lastEffect,
            u !== null)) {
                var E = u = u.next;
                do {
                    var D = E
                      , L = D.destroy;
                    D = D.tag,
                    L !== void 0 && (D & 2 || D & 4) && z_(c, v, L),
                    E = E.next
                } while (E !== u)
            }
            break;
        case 1:
            if (tg(c, v),
            u = c.stateNode,
            typeof u.componentWillUnmount == "function")
                try {
                    u.props = c.memoizedProps,
                    u.state = c.memoizedState,
                    u.componentWillUnmount()
                } catch (ie) {
                    Xo(c, v, ie)
                }
            break;
        case 5:
            tg(c, v);
            break;
        case 4:
            gt ? JM(u, c, v) : be && be && (c = c.stateNode.containerInfo,
            v = rn(c),
            mn(c, v))
        }
    }
    function UM(u, c, v) {
        for (var E = c; ; )
            if (GM(u, E, v),
            E.child === null || gt && E.tag === 4) {
                if (E === c)
                    break;
                for (; E.sibling === null; ) {
                    if (E.return === null || E.return === c)
                        return;
                    E = E.return
                }
                E.sibling.return = E.return,
                E = E.sibling
            } else
                E.child.return = E,
                E = E.child
    }
    function HM(u) {
        var c = u.alternate;
        c !== null && (u.alternate = null,
        HM(c)),
        u.child = null,
        u.deletions = null,
        u.sibling = null,
        u.tag === 5 && (c = u.stateNode,
        c !== null && ee(c)),
        u.stateNode = null,
        u.return = null,
        u.dependencies = null,
        u.memoizedProps = null,
        u.memoizedState = null,
        u.pendingProps = null,
        u.stateNode = null,
        u.updateQueue = null
    }
    function VM(u) {
        return u.tag === 5 || u.tag === 3 || u.tag === 4
    }
    function WM(u) {
        e: for (; ; ) {
            for (; u.sibling === null; ) {
                if (u.return === null || VM(u.return))
                    return null;
                u = u.return
            }
            for (u.sibling.return = u.return,
            u = u.sibling; u.tag !== 5 && u.tag !== 6 && u.tag !== 18; ) {
                if (u.flags & 2 || u.child === null || u.tag === 4)
                    continue e;
                u.child.return = u,
                u = u.child
            }
            if (!(u.flags & 2))
                return u.stateNode
        }
    }
    function XM(u) {
        if (gt) {
            e: {
                for (var c = u.return; c !== null; ) {
                    if (VM(c))
                        break e;
                    c = c.return
                }
                throw Error(o(160))
            }
            var v = c;
            switch (v.tag) {
            case 5:
                c = v.stateNode,
                v.flags & 32 && (Mt(c),
                v.flags &= -33),
                v = WM(u),
                H_(u, v, c);
                break;
            case 3:
            case 4:
                c = v.stateNode.containerInfo,
                v = WM(u),
                U_(u, v, c);
                break;
            default:
                throw Error(o(161))
            }
        }
    }
    function U_(u, c, v) {
        var E = u.tag;
        if (E === 5 || E === 6)
            u = u.stateNode,
            c ? rt(v, u, c) : ct(v, u);
        else if (E !== 4 && (u = u.child,
        u !== null))
            for (U_(u, c, v),
            u = u.sibling; u !== null; )
                U_(u, c, v),
                u = u.sibling
    }
    function H_(u, c, v) {
        var E = u.tag;
        if (E === 5 || E === 6)
            u = u.stateNode,
            c ? Le(v, u, c) : dt(v, u);
        else if (E !== 4 && (u = u.child,
        u !== null))
            for (H_(u, c, v),
            u = u.sibling; u !== null; )
                H_(u, c, v),
                u = u.sibling
    }
    function JM(u, c, v) {
        for (var E = c, D = !1, L, ie; ; ) {
            if (!D) {
                D = E.return;
                e: for (; ; ) {
                    if (D === null)
                        throw Error(o(160));
                    switch (L = D.stateNode,
                    D.tag) {
                    case 5:
                        ie = !1;
                        break e;
                    case 3:
                        L = L.containerInfo,
                        ie = !0;
                        break e;
                    case 4:
                        L = L.containerInfo,
                        ie = !0;
                        break e
                    }
                    D = D.return
                }
                D = !0
            }
            if (E.tag === 5 || E.tag === 6)
                UM(u, E, v),
                ie ? Ut(L, E.stateNode) : st(L, E.stateNode);
            else if (E.tag === 18)
                ie ? en(L, E.stateNode) : Xt(L, E.stateNode);
            else if (E.tag === 4) {
                if (E.child !== null) {
                    L = E.stateNode.containerInfo,
                    ie = !0,
                    E.child.return = E,
                    E = E.child;
                    continue
                }
            } else if (GM(u, E, v),
            E.child !== null) {
                E.child.return = E,
                E = E.child;
                continue
            }
            if (E === c)
                break;
            for (; E.sibling === null; ) {
                if (E.return === null || E.return === c)
                    return;
                E = E.return,
                E.tag === 4 && (D = !1)
            }
            E.sibling.return = E.return,
            E = E.sibling
        }
    }
    function V_(u, c) {
        if (gt) {
            switch (c.tag) {
            case 0:
            case 11:
            case 14:
            case 15:
                Jc(3, c, c.return),
                zh(3, c),
                Jc(5, c, c.return);
                return;
            case 1:
                return;
            case 5:
                var v = c.stateNode;
                if (v != null) {
                    var E = c.memoizedProps;
                    u = u !== null ? u.memoizedProps : E;
                    var D = c.type
                      , L = c.updateQueue;
                    c.updateQueue = null,
                    L !== null && le(v, L, D, u, E, c)
                }
                return;
            case 6:
                if (c.stateNode === null)
                    throw Error(o(162));
                v = c.memoizedProps,
                Fe(c.stateNode, u !== null ? u.memoizedProps : v, v);
                return;
            case 3:
                Ee && u !== null && u.memoizedState.isDehydrated && Sn(c.stateNode.containerInfo);
                return;
            case 12:
                return;
            case 13:
                ng(c);
                return;
            case 19:
                ng(c);
                return;
            case 17:
                return
            }
            throw Error(o(163))
        }
        switch (c.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
            Jc(3, c, c.return),
            zh(3, c),
            Jc(5, c, c.return);
            return;
        case 12:
            return;
        case 13:
            ng(c);
            return;
        case 19:
            ng(c);
            return;
        case 3:
            Ee && u !== null && u.memoizedState.isDehydrated && Sn(c.stateNode.containerInfo);
            break;
        case 22:
        case 23:
            return
        }
        e: if (be) {
            switch (c.tag) {
            case 1:
            case 5:
            case 6:
                break e;
            case 3:
            case 4:
                c = c.stateNode,
                mn(c.containerInfo, c.pendingChildren);
                break e
            }
            throw Error(o(163))
        }
    }
    function ng(u) {
        var c = u.updateQueue;
        if (c !== null) {
            u.updateQueue = null;
            var v = u.stateNode;
            v === null && (v = u.stateNode = new sR),
            c.forEach(function(E) {
                var D = gR.bind(null, u, E);
                v.has(E) || (v.add(E),
                E.then(D, D))
            })
        }
    }
    function aR(u, c) {
        for (zt = c; zt !== null; ) {
            c = zt;
            var v = c.deletions;
            if (v !== null)
                for (var E = 0; E < v.length; E++) {
                    var D = v[E];
                    try {
                        var L = u;
                        gt ? JM(L, D, c) : UM(L, D, c);
                        var ie = D.alternate;
                        ie !== null && (ie.return = null),
                        D.return = null
                    } catch (sn) {
                        Xo(D, c, sn)
                    }
                }
            if (v = c.child,
            c.subtreeFlags & 12854 && v !== null)
                v.return = c,
                zt = v;
            else
                for (; zt !== null; ) {
                    c = zt;
                    try {
                        var _e = c.flags;
                        if (_e & 32 && gt && Mt(c.stateNode),
                        _e & 512) {
                            var Qe = c.alternate;
                            if (Qe !== null) {
                                var wt = Qe.ref;
                                wt !== null && (typeof wt == "function" ? wt(null) : wt.current = null)
                            }
                        }
                        if (_e & 8192)
                            switch (c.tag) {
                            case 13:
                                if (c.memoizedState !== null) {
                                    var qt = c.alternate;
                                    (qt === null || qt.memoizedState === null) && (q_ = yi())
                                }
                                break;
                            case 22:
                                var Rn = c.memoizedState !== null
                                  , gn = c.alternate
                                  , ri = gn !== null && gn.memoizedState !== null;
                                if (v = c,
                                gt) {
                                    e: if (E = v,
                                    D = Rn,
                                    L = null,
                                    gt)
                                        for (var an = E; ; ) {
                                            if (an.tag === 5) {
                                                if (L === null) {
                                                    L = an;
                                                    var $s = an.stateNode;
                                                    D ? wn($s) : De(an.stateNode, an.memoizedProps)
                                                }
                                            } else if (an.tag === 6) {
                                                if (L === null) {
                                                    var Na = an.stateNode;
                                                    D ? ae(Na) : Je(Na, an.memoizedProps)
                                                }
                                            } else if ((an.tag !== 22 && an.tag !== 23 || an.memoizedState === null || an === E) && an.child !== null) {
                                                an.child.return = an,
                                                an = an.child;
                                                continue
                                            }
                                            if (an === E)
                                                break;
                                            for (; an.sibling === null; ) {
                                                if (an.return === null || an.return === E)
                                                    break e;
                                                L === an && (L = null),
                                                an = an.return
                                            }
                                            L === an && (L = null),
                                            an.sibling.return = an.return,
                                            an = an.sibling
                                        }
                                }
                                if (Rn && !ri && v.mode & 1) {
                                    zt = v;
                                    for (var ke = v.child; ke !== null; ) {
                                        for (v = zt = ke; zt !== null; ) {
                                            E = zt;
                                            var Me = E.child;
                                            switch (E.tag) {
                                            case 0:
                                            case 11:
                                            case 14:
                                            case 15:
                                                Jc(4, E, E.return);
                                                break;
                                            case 1:
                                                tg(E, E.return);
                                                var Xe = E.stateNode;
                                                if (typeof Xe.componentWillUnmount == "function") {
                                                    var Ht = E.return;
                                                    try {
                                                        Xe.props = E.memoizedProps,
                                                        Xe.state = E.memoizedState,
                                                        Xe.componentWillUnmount()
                                                    } catch (sn) {
                                                        Xo(E, Ht, sn)
                                                    }
                                                }
                                                break;
                                            case 5:
                                                tg(E, E.return);
                                                break;
                                            case 22:
                                                if (E.memoizedState !== null) {
                                                    KM(v);
                                                    continue
                                                }
                                            }
                                            Me !== null ? (Me.return = E,
                                            zt = Me) : KM(v)
                                        }
                                        ke = ke.sibling
                                    }
                                }
                            }
                        switch (_e & 4102) {
                        case 2:
                            XM(c),
                            c.flags &= -3;
                            break;
                        case 6:
                            XM(c),
                            c.flags &= -3,
                            V_(c.alternate, c);
                            break;
                        case 4096:
                            c.flags &= -4097;
                            break;
                        case 4100:
                            c.flags &= -4097,
                            V_(c.alternate, c);
                            break;
                        case 4:
                            V_(c.alternate, c)
                        }
                    } catch (sn) {
                        Xo(c, c.return, sn)
                    }
                    if (v = c.sibling,
                    v !== null) {
                        v.return = c.return,
                        zt = v;
                        break
                    }
                    zt = c.return
                }
        }
    }
    function lR(u, c, v) {
        zt = u,
        jM(u)
    }
    function jM(u, c, v) {
        for (var E = (u.mode & 1) !== 0; zt !== null; ) {
            var D = zt
              , L = D.child;
            if (D.tag === 22 && E) {
                var ie = D.memoizedState !== null || Fa;
                if (!ie) {
                    var _e = D.alternate
                      , Qe = _e !== null && _e.memoizedState !== null || Xc;
                    _e = Fa;
                    var wt = Xc;
                    if (Fa = ie,
                    (Xc = Qe) && !wt)
                        for (zt = D; zt !== null; )
                            ie = zt,
                            Qe = ie.child,
                            ie.tag === 22 && ie.memoizedState !== null ? qM(D) : Qe !== null ? (Qe.return = ie,
                            zt = Qe) : qM(D);
                    for (; L !== null; )
                        zt = L,
                        jM(L),
                        L = L.sibling;
                    zt = D,
                    Fa = _e,
                    Xc = wt
                }
                YM(u)
            } else
                D.subtreeFlags & 8772 && L !== null ? (L.return = D,
                zt = L) : YM(u)
        }
    }
    function YM(u) {
        for (; zt !== null; ) {
            var c = zt;
            if (c.flags & 8772) {
                var v = c.alternate;
                try {
                    if (c.flags & 8772)
                        switch (c.tag) {
                        case 0:
                        case 11:
                        case 15:
                            Xc || zh(5, c);
                            break;
                        case 1:
                            var E = c.stateNode;
                            if (c.flags & 4 && !Xc)
                                if (v === null)
                                    E.componentDidMount();
                                else {
                                    var D = c.elementType === c.type ? v.memoizedProps : js(c.type, v.memoizedProps);
                                    E.componentDidUpdate(D, v.memoizedState, E.__reactInternalSnapshotBeforeUpdate)
                                }
                            var L = c.updateQueue;
                            L !== null && Fn(c, L, E);
                            break;
                        case 3:
                            var ie = c.updateQueue;
                            if (ie !== null) {
                                if (v = null,
                                c.child !== null)
                                    switch (c.child.tag) {
                                    case 5:
                                        v = ce(c.child.stateNode);
                                        break;
                                    case 1:
                                        v = c.child.stateNode
                                    }
                                Fn(c, ie, v)
                            }
                            break;
                        case 5:
                            var _e = c.stateNode;
                            v === null && c.flags & 4 && Rt(_e, c.type, c.memoizedProps, c);
                            break;
                        case 6:
                            break;
                        case 4:
                            break;
                        case 12:
                            break;
                        case 13:
                            if (Ee && c.memoizedState === null) {
                                var Qe = c.alternate;
                                if (Qe !== null) {
                                    var wt = Qe.memoizedState;
                                    if (wt !== null) {
                                        var qt = wt.dehydrated;
                                        qt !== null && tn(qt)
                                    }
                                }
                            }
                            break;
                        case 19:
                        case 17:
                        case 21:
                        case 22:
                        case 23:
                            break;
                        default:
                            throw Error(o(163))
                        }
                    Xc || c.flags & 512 && G_(c)
                } catch (Rn) {
                    Xo(c, c.return, Rn)
                }
            }
            if (c === u) {
                zt = null;
                break
            }
            if (v = c.sibling,
            v !== null) {
                v.return = c.return,
                zt = v;
                break
            }
            zt = c.return
        }
    }
    function KM(u) {
        for (; zt !== null; ) {
            var c = zt;
            if (c === u) {
                zt = null;
                break
            }
            var v = c.sibling;
            if (v !== null) {
                v.return = c.return,
                zt = v;
                break
            }
            zt = c.return
        }
    }
    function qM(u) {
        for (; zt !== null; ) {
            var c = zt;
            try {
                switch (c.tag) {
                case 0:
                case 11:
                case 15:
                    var v = c.return;
                    try {
                        zh(4, c)
                    } catch (Qe) {
                        Xo(c, v, Qe)
                    }
                    break;
                case 1:
                    var E = c.stateNode;
                    if (typeof E.componentDidMount == "function") {
                        var D = c.return;
                        try {
                            E.componentDidMount()
                        } catch (Qe) {
                            Xo(c, D, Qe)
                        }
                    }
                    var L = c.return;
                    try {
                        G_(c)
                    } catch (Qe) {
                        Xo(c, L, Qe)
                    }
                    break;
                case 5:
                    var ie = c.return;
                    try {
                        G_(c)
                    } catch (Qe) {
                        Xo(c, ie, Qe)
                    }
                }
            } catch (Qe) {
                Xo(c, c.return, Qe)
            }
            if (c === u) {
                zt = null;
                break
            }
            var _e = c.sibling;
            if (_e !== null) {
                _e.return = c.return,
                zt = _e;
                break
            }
            zt = c.return
        }
    }
    var rg = 0
      , ig = 1
      , sg = 2
      , og = 3
      , ag = 4;
    if (typeof Symbol == "function" && Symbol.for) {
        var Gh = Symbol.for;
        rg = Gh("selector.component"),
        ig = Gh("selector.has_pseudo_class"),
        sg = Gh("selector.role"),
        og = Gh("selector.test_id"),
        ag = Gh("selector.text")
    }
    function W_(u) {
        var c = at(u);
        if (c != null) {
            if (typeof c.memoizedProps["data-testname"] != "string")
                throw Error(o(364));
            return c
        }
        if (u = Pt(u),
        u === null)
            throw Error(o(362));
        return u.stateNode.current
    }
    function X_(u, c) {
        switch (c.$$typeof) {
        case rg:
            if (u.type === c.value)
                return !0;
            break;
        case ig:
            e: {
                c = c.value,
                u = [u, 0];
                for (var v = 0; v < u.length; ) {
                    var E = u[v++]
                      , D = u[v++]
                      , L = c[D];
                    if (E.tag !== 5 || !ye(E)) {
                        for (; L != null && X_(E, L); )
                            D++,
                            L = c[D];
                        if (D === c.length) {
                            c = !0;
                            break e
                        } else
                            for (E = E.child; E !== null; )
                                u.push(E, D),
                                E = E.sibling
                    }
                }
                c = !1
            }
            return c;
        case sg:
            if (u.tag === 5 && tt(u.stateNode, c.value))
                return !0;
            break;
        case ag:
            if ((u.tag === 5 || u.tag === 6) && (u = V(u),
            u !== null && 0 <= u.indexOf(c.value)))
                return !0;
            break;
        case og:
            if (u.tag === 5 && (u = u.memoizedProps["data-testname"],
            typeof u == "string" && u.toLowerCase() === c.value.toLowerCase()))
                return !0;
            break;
        default:
            throw Error(o(365))
        }
        return !1
    }
    function J_(u) {
        switch (u.$$typeof) {
        case rg:
            return "<" + (k(u.value) || "Unknown") + ">";
        case ig:
            return ":has(" + (J_(u) || "") + ")";
        case sg:
            return '[role="' + u.value + '"]';
        case ag:
            return '"' + u.value + '"';
        case og:
            return '[data-testname="' + u.value + '"]';
        default:
            throw Error(o(365))
        }
    }
    function QM(u, c) {
        var v = [];
        u = [u, 0];
        for (var E = 0; E < u.length; ) {
            var D = u[E++]
              , L = u[E++]
              , ie = c[L];
            if (D.tag !== 5 || !ye(D)) {
                for (; ie != null && X_(D, ie); )
                    L++,
                    ie = c[L];
                if (L === c.length)
                    v.push(D);
                else
                    for (D = D.child; D !== null; )
                        u.push(D, L),
                        D = D.sibling
            }
        }
        return v
    }
    function j_(u, c) {
        if (!ft)
            throw Error(o(363));
        u = W_(u),
        u = QM(u, c),
        c = [],
        u = Array.from(u);
        for (var v = 0; v < u.length; ) {
            var E = u[v++];
            if (E.tag === 5)
                ye(E) || c.push(E.stateNode);
            else
                for (E = E.child; E !== null; )
                    u.push(E),
                    E = E.sibling
        }
        return c
    }
    var uR = Math.ceil
      , lg = a.ReactCurrentDispatcher
      , Y_ = a.ReactCurrentOwner
      , Ki = a.ReactCurrentBatchConfig
      , jn = 0
      , rs = null
      , is = null
      , Os = 0
      , la = 0
      , id = xs(0)
      , ds = 0
      , Uh = null
      , sd = 0
      , ug = 0
      , K_ = 0
      , Hh = null
      , Vo = null
      , q_ = 0
      , Q_ = 1 / 0;
    function od() {
        Q_ = yi() + 500
    }
    var cg = !1
      , Z_ = null
      , Uu = null
      , fg = !1
      , Hu = null
      , dg = 0
      , Vh = 0
      , $_ = null
      , hg = -1
      , pg = 0;
    function _o() {
        return jn & 6 ? yi() : hg !== -1 ? hg : hg = yi()
    }
    function Vu(u) {
        return u.mode & 1 ? jn & 2 && Os !== 0 ? Os & -Os : ku.transition !== null ? (pg === 0 && (u = yn,
        yn <<= 1,
        !(yn & 4194240) && (yn = 64),
        pg = u),
        pg) : (u = Dt,
        u !== 0 ? u : Ce()) : 1
    }
    function ka(u, c, v) {
        if (50 < Vh)
            throw Vh = 0,
            $_ = null,
            Error(o(185));
        var E = mg(u, c);
        return E === null ? null : (na(E, c, v),
        (!(jn & 2) || E !== rs) && (E === rs && (!(jn & 2) && (ug |= c),
        ds === 4 && Wu(E, Os)),
        Wo(E, v),
        c === 1 && jn === 0 && !(u.mode & 1) && (od(),
        Il && us())),
        E)
    }
    function mg(u, c) {
        u.lanes |= c;
        var v = u.alternate;
        for (v !== null && (v.lanes |= c),
        v = u,
        u = u.return; u !== null; )
            u.childLanes |= c,
            v = u.alternate,
            v !== null && (v.childLanes |= c),
            v = u,
            u = u.return;
        return v.tag === 3 ? v.stateNode : null
    }
    function Wo(u, c) {
        var v = u.callbackNode;
        Lo(u, c);
        var E = Bl(u, u === rs ? Os : 0);
        if (E === 0)
            v !== null && Uc(v),
            u.callbackNode = null,
            u.callbackPriority = 0;
        else if (c = E & -E,
        u.callbackPriority !== c) {
            if (v != null && Uc(v),
            c === 1)
                u.tag === 0 ? Pa($M.bind(null, u)) : Ll($M.bind(null, u)),
                et ? Ze(function() {
                    jn === 0 && us()
                }) : eu(Lu, us),
                v = null;
            else {
                switch (Gc(E)) {
                case 1:
                    v = Lu;
                    break;
                case 4:
                    v = Is;
                    break;
                case 16:
                    v = ko;
                    break;
                case 536870912:
                    v = tu;
                    break;
                default:
                    v = ko
                }
                v = lA(v, ZM.bind(null, u))
            }
            u.callbackPriority = c,
            u.callbackNode = v
        }
    }
    function ZM(u, c) {
        if (hg = -1,
        pg = 0,
        jn & 6)
            throw Error(o(327));
        var v = u.callbackNode;
        if (Kc() && u.callbackNode !== v)
            return null;
        var E = Bl(u, u === rs ? Os : 0);
        if (E === 0)
            return null;
        if (E & 30 || E & u.expiredLanes || c)
            c = gg(u, E);
        else {
            c = E;
            var D = jn;
            jn |= 2;
            var L = nA();
            (rs !== u || Os !== c) && (od(),
            jc(u, c));
            do
                try {
                    dR();
                    break
                } catch (_e) {
                    tA(u, _e)
                }
            while (1);
            nu(),
            lg.current = L,
            jn = D,
            is !== null ? c = 0 : (rs = null,
            Os = 0,
            c = ds)
        }
        if (c !== 0) {
            if (c === 2 && (D = nl(u),
            D !== 0 && (E = D,
            c = ey(u, D))),
            c === 1)
                throw v = Uh,
                jc(u, 0),
                Wu(u, E),
                Wo(u, yi()),
                v;
            if (c === 6)
                Wu(u, E);
            else {
                if (D = u.current.alternate,
                !(E & 30) && !cR(D) && (c = gg(u, E),
                c === 2 && (L = nl(u),
                L !== 0 && (E = L,
                c = ey(u, L))),
                c === 1))
                    throw v = Uh,
                    jc(u, 0),
                    Wu(u, E),
                    Wo(u, yi()),
                    v;
                switch (u.finishedWork = D,
                u.finishedLanes = E,
                c) {
                case 0:
                case 1:
                    throw Error(o(345));
                case 2:
                    Yc(u, Vo);
                    break;
                case 3:
                    if (Wu(u, E),
                    (E & 130023424) === E && (c = q_ + 500 - yi(),
                    10 < c)) {
                        if (Bl(u, 0) !== 0)
                            break;
                        if (D = u.suspendedLanes,
                        (D & E) !== E) {
                            _o(),
                            u.pingedLanes |= u.suspendedLanes & D;
                            break
                        }
                        u.timeoutHandle = qe(Yc.bind(null, u, Vo), c);
                        break
                    }
                    Yc(u, Vo);
                    break;
                case 4:
                    if (Wu(u, E),
                    (E & 4194240) === E)
                        break;
                    for (c = u.eventTimes,
                    D = -1; 0 < E; ) {
                        var ie = 31 - zi(E);
                        L = 1 << ie,
                        ie = c[ie],
                        ie > D && (D = ie),
                        E &= ~L
                    }
                    if (E = D,
                    E = yi() - E,
                    E = (120 > E ? 120 : 480 > E ? 480 : 1080 > E ? 1080 : 1920 > E ? 1920 : 3e3 > E ? 3e3 : 4320 > E ? 4320 : 1960 * uR(E / 1960)) - E,
                    10 < E) {
                        u.timeoutHandle = qe(Yc.bind(null, u, Vo), E);
                        break
                    }
                    Yc(u, Vo);
                    break;
                case 5:
                    Yc(u, Vo);
                    break;
                default:
                    throw Error(o(329))
                }
            }
        }
        return Wo(u, yi()),
        u.callbackNode === v ? ZM.bind(null, u) : null
    }
    function ey(u, c) {
        var v = Hh;
        return u.current.memoizedState.isDehydrated && (jc(u, c).flags |= 256),
        u = gg(u, c),
        u !== 2 && (c = Vo,
        Vo = v,
        c !== null && ty(c)),
        u
    }
    function ty(u) {
        Vo === null ? Vo = u : Vo.push.apply(Vo, u)
    }
    function cR(u) {
        for (var c = u; ; ) {
            if (c.flags & 16384) {
                var v = c.updateQueue;
                if (v !== null && (v = v.stores,
                v !== null))
                    for (var E = 0; E < v.length; E++) {
                        var D = v[E]
                          , L = D.getSnapshot;
                        D = D.value;
                        try {
                            if (!Lr(L(), D))
                                return !1
                        } catch {
                            return !1
                        }
                    }
            }
            if (v = c.child,
            c.subtreeFlags & 16384 && v !== null)
                v.return = c,
                c = v;
            else {
                if (c === u)
                    break;
                for (; c.sibling === null; ) {
                    if (c.return === null || c.return === u)
                        return !0;
                    c = c.return
                }
                c.sibling.return = c.return,
                c = c.sibling
            }
        }
        return !0
    }
    function Wu(u, c) {
        for (c &= ~K_,
        c &= ~ug,
        u.suspendedLanes |= c,
        u.pingedLanes &= ~c,
        u = u.expirationTimes; 0 < c; ) {
            var v = 31 - zi(c)
              , E = 1 << v;
            u[v] = -1,
            c &= ~E
        }
    }
    function $M(u) {
        if (jn & 6)
            throw Error(o(327));
        Kc();
        var c = Bl(u, 0);
        if (!(c & 1))
            return Wo(u, yi()),
            null;
        var v = gg(u, c);
        if (u.tag !== 0 && v === 2) {
            var E = nl(u);
            E !== 0 && (c = E,
            v = ey(u, E))
        }
        if (v === 1)
            throw v = Uh,
            jc(u, 0),
            Wu(u, c),
            Wo(u, yi()),
            v;
        if (v === 6)
            throw Error(o(345));
        return u.finishedWork = u.current.alternate,
        u.finishedLanes = c,
        Yc(u, Vo),
        Wo(u, yi()),
        null
    }
    function eA(u) {
        Hu !== null && Hu.tag === 0 && !(jn & 6) && Kc();
        var c = jn;
        jn |= 1;
        var v = Ki.transition
          , E = Dt;
        try {
            if (Ki.transition = null,
            Dt = 1,
            u)
                return u()
        } finally {
            Dt = E,
            Ki.transition = v,
            jn = c,
            !(jn & 6) && us()
        }
    }
    function ny() {
        la = id.current,
        Mn(id)
    }
    function jc(u, c) {
        u.finishedWork = null,
        u.finishedLanes = 0;
        var v = u.timeoutHandle;
        if (v !== Tt && (u.timeoutHandle = Tt,
        Ne(v)),
        is !== null)
            for (v = is.return; v !== null; ) {
                var E = v;
                switch (Ys(E),
                E.tag) {
                case 1:
                    E = E.type.childContextTypes,
                    E != null && Hr();
                    break;
                case 3:
                    Gn(),
                    Mn(Ni),
                    Mn(ir),
                    po();
                    break;
                case 5:
                    Go(E);
                    break;
                case 4:
                    Gn();
                    break;
                case 13:
                    Mn(Sr);
                    break;
                case 19:
                    Mn(Sr);
                    break;
                case 10:
                    Hc(E.type._context);
                    break;
                case 22:
                case 23:
                    ny()
                }
                v = v.return
            }
        if (rs = u,
        is = u = Xu(u.current, null),
        Os = la = c,
        ds = 0,
        Uh = null,
        K_ = ug = sd = 0,
        Vo = Hh = null,
        Te !== null) {
            for (c = 0; c < Te.length; c++)
                if (v = Te[c],
                E = v.interleaved,
                E !== null) {
                    v.interleaved = null;
                    var D = E.next
                      , L = v.pending;
                    if (L !== null) {
                        var ie = L.next;
                        L.next = D,
                        E.next = ie
                    }
                    v.pending = E
                }
            Te = null
        }
        return u
    }
    function tA(u, c) {
        do {
            var v = is;
            try {
                if (nu(),
                Wr.current = La,
                cr) {
                    for (var E = Ir.memoizedState; E !== null; ) {
                        var D = E.queue;
                        D !== null && (D.pending = null),
                        E = E.next
                    }
                    cr = !1
                }
                if (wi = 0,
                Er = ur = Ir = null,
                ui = !1,
                Uo = 0,
                Y_.current = null,
                v === null || v.return === null) {
                    ds = 1,
                    Uh = c,
                    is = null;
                    break
                }
                e: {
                    var L = u
                      , ie = v.return
                      , _e = v
                      , Qe = c;
                    if (c = Os,
                    _e.flags |= 32768,
                    Qe !== null && typeof Qe == "object" && typeof Qe.then == "function") {
                        var wt = Qe
                          , qt = _e
                          , Rn = qt.tag;
                        if (!(qt.mode & 1) && (Rn === 0 || Rn === 11 || Rn === 15)) {
                            var gn = qt.alternate;
                            gn ? (qt.updateQueue = gn.updateQueue,
                            qt.memoizedState = gn.memoizedState,
                            qt.lanes = gn.lanes) : (qt.updateQueue = null,
                            qt.memoizedState = null)
                        }
                        var ri = C(ie);
                        if (ri !== null) {
                            ri.flags &= -257,
                            b(ri, ie, _e, L, c),
                            ri.mode & 1 && A(L, wt, c),
                            c = ri,
                            Qe = wt;
                            var an = c.updateQueue;
                            if (an === null) {
                                var $s = new Set;
                                $s.add(Qe),
                                c.updateQueue = $s
                            } else
                                an.add(Qe);
                            break e
                        } else {
                            if (!(c & 1)) {
                                A(L, wt, c),
                                ry();
                                break e
                            }
                            Qe = Error(o(426))
                        }
                    } else if (ln && _e.mode & 1) {
                        var Na = C(ie);
                        if (Na !== null) {
                            !(Na.flags & 65536) && (Na.flags |= 256),
                            b(Na, ie, _e, L, c),
                            vr(Qe);
                            break e
                        }
                    }
                    L = Qe,
                    ds !== 4 && (ds = 2),
                    Hh === null ? Hh = [L] : Hh.push(L),
                    Qe = Vc(Qe, _e),
                    _e = ie;
                    do {
                        switch (_e.tag) {
                        case 3:
                            _e.flags |= 65536,
                            c &= -c,
                            _e.lanes |= c;
                            var ke = q(_e, Qe, c);
                            Be(_e, ke);
                            break e;
                        case 1:
                            L = Qe;
                            var Me = _e.type
                              , Xe = _e.stateNode;
                            if (!(_e.flags & 128) && (typeof Me.getDerivedStateFromError == "function" || Xe !== null && typeof Xe.componentDidCatch == "function" && (Uu === null || !Uu.has(Xe)))) {
                                _e.flags |= 65536,
                                c &= -c,
                                _e.lanes |= c;
                                var Ht = g(_e, L, c);
                                Be(_e, Ht);
                                break e
                            }
                        }
                        _e = _e.return
                    } while (_e !== null)
                }
                iA(v)
            } catch (sn) {
                c = sn,
                is === v && v !== null && (is = v = v.return);
                continue
            }
            break
        } while (1)
    }
    function nA() {
        var u = lg.current;
        return lg.current = La,
        u === null ? La : u
    }
    function ry() {
        (ds === 0 || ds === 3 || ds === 2) && (ds = 4),
        rs === null || !(sd & 268435455) && !(ug & 268435455) || Wu(rs, Os)
    }
    function gg(u, c) {
        var v = jn;
        jn |= 2;
        var E = nA();
        rs === u && Os === c || jc(u, c);
        do
            try {
                fR();
                break
            } catch (D) {
                tA(u, D)
            }
        while (1);
        if (nu(),
        jn = v,
        lg.current = E,
        is !== null)
            throw Error(o(261));
        return rs = null,
        Os = 0,
        ds
    }
    function fR() {
        for (; is !== null; )
            rA(is)
    }
    function dR() {
        for (; is !== null && !uo(); )
            rA(is)
    }
    function rA(u) {
        var c = aA(u.alternate, u, la);
        u.memoizedProps = u.pendingProps,
        c === null ? iA(u) : is = c,
        Y_.current = null
    }
    function iA(u) {
        var c = u;
        do {
            var v = c.alternate;
            if (u = c.return,
            c.flags & 32768) {
                if (v = al(v, c),
                v !== null) {
                    v.flags &= 32767,
                    is = v;
                    return
                }
                if (u !== null)
                    u.flags |= 32768,
                    u.subtreeFlags = 0,
                    u.deletions = null;
                else {
                    ds = 6,
                    is = null;
                    return
                }
            } else if (v = nt(v, c, la),
            v !== null) {
                is = v;
                return
            }
            if (c = c.sibling,
            c !== null) {
                is = c;
                return
            }
            is = c = u
        } while (c !== null);
        ds === 0 && (ds = 5)
    }
    function Yc(u, c) {
        var v = Dt
          , E = Ki.transition;
        try {
            Ki.transition = null,
            Dt = 1,
            hR(u, c, v)
        } finally {
            Ki.transition = E,
            Dt = v
        }
        return null
    }
    function hR(u, c, v) {
        do
            Kc();
        while (Hu !== null);
        if (jn & 6)
            throw Error(o(327));
        var E = u.finishedWork
          , D = u.finishedLanes;
        if (E === null)
            return null;
        if (u.finishedWork = null,
        u.finishedLanes = 0,
        E === u.current)
            throw Error(o(177));
        u.callbackNode = null,
        u.callbackPriority = 0;
        var L = E.lanes | E.childLanes;
        if (Ss(u, L),
        u === rs && (is = rs = null,
        Os = 0),
        !(E.subtreeFlags & 2064) && !(E.flags & 2064) || fg || (fg = !0,
        lA(ko, function() {
            return Kc(),
            null
        })),
        L = (E.flags & 15990) !== 0,
        E.subtreeFlags & 15990 || L) {
            L = Ki.transition,
            Ki.transition = null;
            var ie = Dt;
            Dt = 1;
            var _e = jn;
            jn |= 4,
            Y_.current = null,
            oR(u, E),
            aR(u, E),
            U(u.containerInfo),
            u.current = E,
            lR(E),
            rl(),
            jn = _e,
            Dt = ie,
            Ki.transition = L
        } else
            u.current = E;
        if (fg && (fg = !1,
        Hu = u,
        dg = D),
        L = u.pendingLanes,
        L === 0 && (Uu = null),
        Fu(E.stateNode),
        Wo(u, yi()),
        c !== null)
            for (v = u.onRecoverableError,
            E = 0; E < c.length; E++)
                v(c[E]);
        if (cg)
            throw cg = !1,
            u = Z_,
            Z_ = null,
            u;
        return dg & 1 && u.tag !== 0 && Kc(),
        L = u.pendingLanes,
        L & 1 ? u === $_ ? Vh++ : (Vh = 0,
        $_ = u) : Vh = 0,
        us(),
        null
    }
    function Kc() {
        if (Hu !== null) {
            var u = Gc(dg)
              , c = Ki.transition
              , v = Dt;
            try {
                if (Ki.transition = null,
                Dt = 16 > u ? 16 : u,
                Hu === null)
                    var E = !1;
                else {
                    if (u = Hu,
                    Hu = null,
                    dg = 0,
                    jn & 6)
                        throw Error(o(331));
                    var D = jn;
                    for (jn |= 4,
                    zt = u.current; zt !== null; ) {
                        var L = zt
                          , ie = L.child;
                        if (zt.flags & 16) {
                            var _e = L.deletions;
                            if (_e !== null) {
                                for (var Qe = 0; Qe < _e.length; Qe++) {
                                    var wt = _e[Qe];
                                    for (zt = wt; zt !== null; ) {
                                        var qt = zt;
                                        switch (qt.tag) {
                                        case 0:
                                        case 11:
                                        case 15:
                                            Jc(8, qt, L)
                                        }
                                        var Rn = qt.child;
                                        if (Rn !== null)
                                            Rn.return = qt,
                                            zt = Rn;
                                        else
                                            for (; zt !== null; ) {
                                                qt = zt;
                                                var gn = qt.sibling
                                                  , ri = qt.return;
                                                if (HM(qt),
                                                qt === wt) {
                                                    zt = null;
                                                    break
                                                }
                                                if (gn !== null) {
                                                    gn.return = ri,
                                                    zt = gn;
                                                    break
                                                }
                                                zt = ri
                                            }
                                    }
                                }
                                var an = L.alternate;
                                if (an !== null) {
                                    var $s = an.child;
                                    if ($s !== null) {
                                        an.child = null;
                                        do {
                                            var Na = $s.sibling;
                                            $s.sibling = null,
                                            $s = Na
                                        } while ($s !== null)
                                    }
                                }
                                zt = L
                            }
                        }
                        if (L.subtreeFlags & 2064 && ie !== null)
                            ie.return = L,
                            zt = ie;
                        else
                            e: for (; zt !== null; ) {
                                if (L = zt,
                                L.flags & 2048)
                                    switch (L.tag) {
                                    case 0:
                                    case 11:
                                    case 15:
                                        Jc(9, L, L.return)
                                    }
                                var ke = L.sibling;
                                if (ke !== null) {
                                    ke.return = L.return,
                                    zt = ke;
                                    break e
                                }
                                zt = L.return
                            }
                    }
                    var Me = u.current;
                    for (zt = Me; zt !== null; ) {
                        ie = zt;
                        var Xe = ie.child;
                        if (ie.subtreeFlags & 2064 && Xe !== null)
                            Xe.return = ie,
                            zt = Xe;
                        else
                            e: for (ie = Me; zt !== null; ) {
                                if (_e = zt,
                                _e.flags & 2048)
                                    try {
                                        switch (_e.tag) {
                                        case 0:
                                        case 11:
                                        case 15:
                                            zh(9, _e)
                                        }
                                    } catch (sn) {
                                        Xo(_e, _e.return, sn)
                                    }
                                if (_e === ie) {
                                    zt = null;
                                    break e
                                }
                                var Ht = _e.sibling;
                                if (Ht !== null) {
                                    Ht.return = _e.return,
                                    zt = Ht;
                                    break e
                                }
                                zt = _e.return
                            }
                    }
                    if (jn = D,
                    us(),
                    Ei && typeof Ei.onPostCommitFiberRoot == "function")
                        try {
                            Ei.onPostCommitFiberRoot(Oo, u)
                        } catch {}
                    E = !0
                }
                return E
            } finally {
                Dt = v,
                Ki.transition = c
            }
        }
        return !1
    }
    function sA(u, c, v) {
        c = Vc(v, c),
        c = q(u, c, 1),
        Se(u, c),
        c = _o(),
        u = mg(u, 1),
        u !== null && (na(u, 1, c),
        Wo(u, c))
    }
    function Xo(u, c, v) {
        if (u.tag === 3)
            sA(u, u, v);
        else
            for (; c !== null; ) {
                if (c.tag === 3) {
                    sA(c, u, v);
                    break
                } else if (c.tag === 1) {
                    var E = c.stateNode;
                    if (typeof c.type.getDerivedStateFromError == "function" || typeof E.componentDidCatch == "function" && (Uu === null || !Uu.has(E))) {
                        u = Vc(v, u),
                        u = g(c, u, 1),
                        Se(c, u),
                        u = _o(),
                        c = mg(c, 1),
                        c !== null && (na(c, 1, u),
                        Wo(c, u));
                        break
                    }
                }
                c = c.return
            }
    }
    function pR(u, c, v) {
        var E = u.pingCache;
        E !== null && E.delete(c),
        c = _o(),
        u.pingedLanes |= u.suspendedLanes & v,
        rs === u && (Os & v) === v && (ds === 4 || ds === 3 && (Os & 130023424) === Os && 500 > yi() - q_ ? jc(u, 0) : K_ |= v),
        Wo(u, c)
    }
    function oA(u, c) {
        c === 0 && (u.mode & 1 ? (c = Ta,
        Ta <<= 1,
        !(Ta & 130023424) && (Ta = 4194304)) : c = 1);
        var v = _o();
        u = mg(u, c),
        u !== null && (na(u, c, v),
        Wo(u, v))
    }
    function mR(u) {
        var c = u.memoizedState
          , v = 0;
        c !== null && (v = c.retryLane),
        oA(u, v)
    }
    function gR(u, c) {
        var v = 0;
        switch (u.tag) {
        case 13:
            var E = u.stateNode
              , D = u.memoizedState;
            D !== null && (v = D.retryLane);
            break;
        case 19:
            E = u.stateNode;
            break;
        default:
            throw Error(o(314))
        }
        E !== null && E.delete(c),
        oA(u, v)
    }
    var aA;
    aA = function(u, c, v) {
        if (u !== null)
            if (u.memoizedProps !== c.pendingProps || Ni.current)
                $e = !0;
            else {
                if (!(u.lanes & v) && !(c.flags & 128))
                    return $e = !1,
                    eg(u, c, v);
                $e = !!(u.flags & 131072)
            }
        else
            $e = !1,
            ln && c.flags & 1048576 && pr(c, pn, c.index);
        switch (c.lanes = 0,
        c.tag) {
        case 2:
            var E = c.type;
            u !== null && (u.alternate = null,
            c.alternate = null,
            c.flags |= 2),
            u = c.pendingProps;
            var D = ea(c, ir.current);
            sa(c, v),
            D = Ks(null, c, E, u, D, v);
            var L = fs();
            return c.flags |= 1,
            typeof D == "object" && D !== null && typeof D.render == "function" && D.$$typeof === void 0 ? (c.tag = 1,
            c.memoizedState = null,
            c.updateQueue = null,
            Yi(E) ? (L = !0,
            Rl(c)) : L = !1,
            c.memoizedState = D.state !== null && D.state !== void 0 ? D.state : null,
            ue(c),
            D.updater = Jt,
            c.stateNode = D,
            D._reactInternals = c,
            lr(c, E, u, v),
            c = bt(null, c, E, !0, L, v)) : (c.tag = 0,
            ln && L && Wn(c),
            lt(null, c, D, v),
            c = c.child),
            c;
        case 16:
            E = c.elementType;
            e: {
                switch (u !== null && (u.alternate = null,
                c.alternate = null,
                c.flags |= 2),
                u = c.pendingProps,
                D = E._init,
                E = D(E._payload),
                c.type = E,
                D = c.tag = _R(E),
                u = js(E, u),
                D) {
                case 0:
                    c = Wt(null, c, E, u, v);
                    break e;
                case 1:
                    c = Ot(null, c, E, u, v);
                    break e;
                case 11:
                    c = pt(null, c, E, u, v);
                    break e;
                case 14:
                    c = xt(null, c, E, js(E.type, u), v);
                    break e
                }
                throw Error(o(306, E, ""))
            }
            return c;
        case 0:
            return E = c.type,
            D = c.pendingProps,
            D = c.elementType === E ? D : js(E, D),
            Wt(u, c, E, D, v);
        case 1:
            return E = c.type,
            D = c.pendingProps,
            D = c.elementType === E ? D : js(E, D),
            Ot(u, c, E, D, v);
        case 3:
            e: {
                if (dr(c),
                u === null)
                    throw Error(o(387));
                E = c.pendingProps,
                L = c.memoizedState,
                D = L.element,
                K(u, c),
                Bt(c, E, null, v);
                var ie = c.memoizedState;
                if (E = ie.element,
                Ee && L.isDehydrated)
                    if (L = {
                        element: E,
                        isDehydrated: !1,
                        cache: ie.cache,
                        transitions: ie.transitions
                    },
                    c.updateQueue.baseState = L,
                    c.memoizedState = L,
                    c.flags & 256) {
                        D = Error(o(423)),
                        c = yr(u, c, E, v, D);
                        break e
                    } else if (E !== D) {
                        D = Error(o(424)),
                        c = yr(u, c, E, v, D);
                        break e
                    } else
                        for (Ee && (gr = ge(c.stateNode.containerInfo),
                        mr = c,
                        ln = !0,
                        Xn = null,
                        Ti = !1),
                        v = Pn(c, null, E, v),
                        c.child = v; v; )
                            v.flags = v.flags & -3 | 4096,
                            v = v.sibling;
                else {
                    if (Gi(),
                    E === D) {
                        c = ks(u, c, v);
                        break e
                    }
                    lt(u, c, E, v)
                }
                c = c.child
            }
            return c;
        case 5:
            return ho(c),
            u === null && No(c),
            E = c.type,
            D = c.pendingProps,
            L = u !== null ? u.memoizedProps : null,
            ie = D.children,
            je(E, D) ? ie = null : L !== null && je(E, L) && (c.flags |= 32),
            jt(u, c),
            lt(u, c, ie, v),
            c.child;
        case 6:
            return u === null && No(c),
            null;
        case 13:
            return Ri(u, c, v);
        case 4:
            return fo(c, c.stateNode.containerInfo),
            E = c.pendingProps,
            u === null ? c.child = kr(c, null, E, v) : lt(u, c, E, v),
            c.child;
        case 11:
            return E = c.type,
            D = c.pendingProps,
            D = c.elementType === E ? D : js(E, D),
            pt(u, c, E, D, v);
        case 7:
            return lt(u, c, c.pendingProps, v),
            c.child;
        case 8:
            return lt(u, c, c.pendingProps.children, v),
            c.child;
        case 12:
            return lt(u, c, c.pendingProps.children, v),
            c.child;
        case 10:
            e: {
                if (E = c.type._context,
                D = c.pendingProps,
                L = c.memoizedProps,
                ie = D.value,
                Nu(c, E, ie),
                L !== null)
                    if (Lr(L.value, ie)) {
                        if (L.children === D.children && !Ni.current) {
                            c = ks(u, c, v);
                            break e
                        }
                    } else
                        for (L = c.child,
                        L !== null && (L.return = c); L !== null; ) {
                            var _e = L.dependencies;
                            if (_e !== null) {
                                ie = L.child;
                                for (var Qe = _e.firstContext; Qe !== null; ) {
                                    if (Qe.context === E) {
                                        if (L.tag === 1) {
                                            Qe = Q(-1, v & -v),
                                            Qe.tag = 2;
                                            var wt = L.updateQueue;
                                            if (wt !== null) {
                                                wt = wt.shared;
                                                var qt = wt.pending;
                                                qt === null ? Qe.next = Qe : (Qe.next = qt.next,
                                                qt.next = Qe),
                                                wt.pending = Qe
                                            }
                                        }
                                        L.lanes |= v,
                                        Qe = L.alternate,
                                        Qe !== null && (Qe.lanes |= v),
                                        zu(L.return, v, c),
                                        _e.lanes |= v;
                                        break
                                    }
                                    Qe = Qe.next
                                }
                            } else if (L.tag === 10)
                                ie = L.type === c.type ? null : L.child;
                            else if (L.tag === 18) {
                                if (ie = L.return,
                                ie === null)
                                    throw Error(o(341));
                                ie.lanes |= v,
                                _e = ie.alternate,
                                _e !== null && (_e.lanes |= v),
                                zu(ie, v, c),
                                ie = L.sibling
                            } else
                                ie = L.child;
                            if (ie !== null)
                                ie.return = L;
                            else
                                for (ie = L; ie !== null; ) {
                                    if (ie === c) {
                                        ie = null;
                                        break
                                    }
                                    if (L = ie.sibling,
                                    L !== null) {
                                        L.return = ie.return,
                                        ie = L;
                                        break
                                    }
                                    ie = ie.return
                                }
                            L = ie
                        }
                lt(u, c, D.children, v),
                c = c.child
            }
            return c;
        case 9:
            return D = c.type,
            E = c.pendingProps.children,
            sa(c, v),
            D = Ls(D),
            E = E(D),
            c.flags |= 1,
            lt(u, c, E, v),
            c.child;
        case 14:
            return E = c.type,
            D = js(E, c.pendingProps),
            D = js(E.type, D),
            xt(u, c, E, D, v);
        case 15:
            return Ct(u, c, c.type, c.pendingProps, v);
        case 17:
            return E = c.type,
            D = c.pendingProps,
            D = c.elementType === E ? D : js(E, D),
            u !== null && (u.alternate = null,
            c.alternate = null,
            c.flags |= 2),
            c.tag = 1,
            Yi(E) ? (u = !0,
            Rl(c)) : u = !1,
            sa(c, v),
            Qt(c, E, D),
            lr(c, E, D, v),
            bt(null, c, E, !0, u, v);
        case 19:
            return Gu(u, c, v);
        case 22:
            return yt(u, c, v)
        }
        throw Error(o(156, c.tag))
    }
    ;
    function lA(u, c) {
        return eu(u, c)
    }
    function vR(u, c, v, E) {
        this.tag = u,
        this.key = v,
        this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null,
        this.index = 0,
        this.ref = null,
        this.pendingProps = c,
        this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null,
        this.mode = E,
        this.subtreeFlags = this.flags = 0,
        this.deletions = null,
        this.childLanes = this.lanes = 0,
        this.alternate = null
    }
    function Oa(u, c, v, E) {
        return new vR(u,c,v,E)
    }
    function iy(u) {
        return u = u.prototype,
        !(!u || !u.isReactComponent)
    }
    function _R(u) {
        if (typeof u == "function")
            return iy(u) ? 1 : 0;
        if (u != null) {
            if (u = u.$$typeof,
            u === y)
                return 11;
            if (u === M)
                return 14
        }
        return 2
    }
    function Xu(u, c) {
        var v = u.alternate;
        return v === null ? (v = Oa(u.tag, c, u.key, u.mode),
        v.elementType = u.elementType,
        v.type = u.type,
        v.stateNode = u.stateNode,
        v.alternate = u,
        u.alternate = v) : (v.pendingProps = c,
        v.type = u.type,
        v.flags = 0,
        v.subtreeFlags = 0,
        v.deletions = null),
        v.flags = u.flags & 14680064,
        v.childLanes = u.childLanes,
        v.lanes = u.lanes,
        v.child = u.child,
        v.memoizedProps = u.memoizedProps,
        v.memoizedState = u.memoizedState,
        v.updateQueue = u.updateQueue,
        c = u.dependencies,
        v.dependencies = c === null ? null : {
            lanes: c.lanes,
            firstContext: c.firstContext
        },
        v.sibling = u.sibling,
        v.index = u.index,
        v.ref = u.ref,
        v
    }
    function vg(u, c, v, E, D, L) {
        var ie = 2;
        if (E = u,
        typeof u == "function")
            iy(u) && (ie = 1);
        else if (typeof u == "string")
            ie = 5;
        else
            e: switch (u) {
            case h:
                return qc(v.children, D, L, c);
            case d:
                ie = 8,
                D |= 8;
                break;
            case p:
                return u = Oa(12, v, c, D | 2),
                u.elementType = p,
                u.lanes = L,
                u;
            case x:
                return u = Oa(13, v, c, D),
                u.elementType = x,
                u.lanes = L,
                u;
            case S:
                return u = Oa(19, v, c, D),
                u.elementType = S,
                u.lanes = L,
                u;
            case T:
                return _g(v, D, L, c);
            default:
                if (typeof u == "object" && u !== null)
                    switch (u.$$typeof) {
                    case m:
                        ie = 10;
                        break e;
                    case _:
                        ie = 9;
                        break e;
                    case y:
                        ie = 11;
                        break e;
                    case M:
                        ie = 14;
                        break e;
                    case w:
                        ie = 16,
                        E = null;
                        break e
                    }
                throw Error(o(130, u == null ? u : typeof u, ""))
            }
        return c = Oa(ie, v, c, D),
        c.elementType = u,
        c.type = E,
        c.lanes = L,
        c
    }
    function qc(u, c, v, E) {
        return u = Oa(7, u, E, c),
        u.lanes = v,
        u
    }
    function _g(u, c, v, E) {
        return u = Oa(22, u, E, c),
        u.elementType = T,
        u.lanes = v,
        u.stateNode = {},
        u
    }
    function sy(u, c, v) {
        return u = Oa(6, u, null, c),
        u.lanes = v,
        u
    }
    function oy(u, c, v) {
        return c = Oa(4, u.children !== null ? u.children : [], u.key, c),
        c.lanes = v,
        c.stateNode = {
            containerInfo: u.containerInfo,
            pendingChildren: null,
            implementation: u.implementation
        },
        c
    }
    function yR(u, c, v, E, D) {
        this.tag = c,
        this.containerInfo = u,
        this.finishedWork = this.pingCache = this.current = this.pendingChildren = null,
        this.timeoutHandle = Tt,
        this.callbackNode = this.pendingContext = this.context = null,
        this.callbackPriority = 0,
        this.eventTimes = Fo(0),
        this.expirationTimes = Fo(-1),
        this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0,
        this.entanglements = Fo(0),
        this.identifierPrefix = E,
        this.onRecoverableError = D,
        Ee && (this.mutableSourceEagerHydrationData = null)
    }
    function uA(u, c, v, E, D, L, ie, _e, Qe) {
        return u = new yR(u,c,v,_e,Qe),
        c === 1 ? (c = 1,
        L === !0 && (c |= 8)) : c = 0,
        L = Oa(3, null, null, c),
        u.current = L,
        L.stateNode = u,
        L.memoizedState = {
            element: E,
            isDehydrated: v,
            cache: null,
            transitions: null
        },
        ue(L),
        u
    }
    function cA(u) {
        if (!u)
            return ws;
        u = u._reactInternals;
        e: {
            if (O(u) !== u || u.tag !== 1)
                throw Error(o(170));
            var c = u;
            do {
                switch (c.tag) {
                case 3:
                    c = c.stateNode.context;
                    break e;
                case 1:
                    if (Yi(c.type)) {
                        c = c.stateNode.__reactInternalMemoizedMergedChildContext;
                        break e
                    }
                }
                c = c.return
            } while (c !== null);
            throw Error(o(171))
        }
        if (u.tag === 1) {
            var v = u.type;
            if (Yi(v))
                return $l(u, v, c)
        }
        return c
    }
    function fA(u) {
        var c = u._reactInternals;
        if (c === void 0)
            throw typeof u.render == "function" ? Error(o(188)) : (u = Object.keys(u).join(","),
            Error(o(268, u)));
        return u = te(c),
        u === null ? null : u.stateNode
    }
    function dA(u, c) {
        if (u = u.memoizedState,
        u !== null && u.dehydrated !== null) {
            var v = u.retryLane;
            u.retryLane = v !== 0 && v < c ? v : c
        }
    }
    function ay(u, c) {
        dA(u, c),
        (u = u.alternate) && dA(u, c)
    }
    function xR(u) {
        return u = te(u),
        u === null ? null : u.stateNode
    }
    function wR() {
        return null
    }
    return t.attemptContinuousHydration = function(u) {
        if (u.tag === 13) {
            var c = _o();
            ka(u, 134217728, c),
            ay(u, 134217728)
        }
    }
    ,
    t.attemptHydrationAtCurrentPriority = function(u) {
        if (u.tag === 13) {
            var c = _o()
              , v = Vu(u);
            ka(u, v, c),
            ay(u, v)
        }
    }
    ,
    t.attemptSynchronousHydration = function(u) {
        switch (u.tag) {
        case 3:
            var c = u.stateNode;
            if (c.current.memoizedState.isDehydrated) {
                var v = Io(c.pendingLanes);
                v !== 0 && (Ms(c, v | 1),
                Wo(c, yi()),
                !(jn & 6) && (od(),
                us()))
            }
            break;
        case 13:
            var E = _o();
            eA(function() {
                return ka(u, 1, E)
            }),
            ay(u, 1)
        }
    }
    ,
    t.batchedUpdates = function(u, c) {
        var v = jn;
        jn |= 1;
        try {
            return u(c)
        } finally {
            jn = v,
            jn === 0 && (od(),
            Il && us())
        }
    }
    ,
    t.createComponentSelector = function(u) {
        return {
            $$typeof: rg,
            value: u
        }
    }
    ,
    t.createContainer = function(u, c, v, E, D, L, ie) {
        return uA(u, c, !1, null, v, E, D, L, ie)
    }
    ,
    t.createHasPseudoClassSelector = function(u) {
        return {
            $$typeof: ig,
            value: u
        }
    }
    ,
    t.createHydrationContainer = function(u, c, v, E, D, L, ie, _e, Qe) {
        return u = uA(v, E, !0, u, D, L, ie, _e, Qe),
        u.context = cA(null),
        v = u.current,
        E = _o(),
        D = Vu(v),
        L = Q(E, D),
        L.callback = c ?? null,
        Se(v, L),
        u.current.lanes = D,
        na(u, D, E),
        Wo(u, E),
        u
    }
    ,
    t.createPortal = function(u, c, v) {
        var E = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
        return {
            $$typeof: f,
            key: E == null ? null : "" + E,
            children: u,
            containerInfo: c,
            implementation: v
        }
    }
    ,
    t.createRoleSelector = function(u) {
        return {
            $$typeof: sg,
            value: u
        }
    }
    ,
    t.createTestNameSelector = function(u) {
        return {
            $$typeof: og,
            value: u
        }
    }
    ,
    t.createTextSelector = function(u) {
        return {
            $$typeof: ag,
            value: u
        }
    }
    ,
    t.deferredUpdates = function(u) {
        var c = Dt
          , v = Ki.transition;
        try {
            return Ki.transition = null,
            Dt = 16,
            u()
        } finally {
            Dt = c,
            Ki.transition = v
        }
    }
    ,
    t.discreteUpdates = function(u, c, v, E, D) {
        var L = Dt
          , ie = Ki.transition;
        try {
            return Ki.transition = null,
            Dt = 1,
            u(c, v, E, D)
        } finally {
            Dt = L,
            Ki.transition = ie,
            jn === 0 && od()
        }
    }
    ,
    t.findAllNodes = j_,
    t.findBoundingRects = function(u, c) {
        if (!ft)
            throw Error(o(363));
        c = j_(u, c),
        u = [];
        for (var v = 0; v < c.length; v++)
            u.push(Z(c[v]));
        for (c = u.length - 1; 0 < c; c--) {
            v = u[c];
            for (var E = v.x, D = E + v.width, L = v.y, ie = L + v.height, _e = c - 1; 0 <= _e; _e--)
                if (c !== _e) {
                    var Qe = u[_e]
                      , wt = Qe.x
                      , qt = wt + Qe.width
                      , Rn = Qe.y
                      , gn = Rn + Qe.height;
                    if (E >= wt && L >= Rn && D <= qt && ie <= gn) {
                        u.splice(c, 1);
                        break
                    } else if (E !== wt || v.width !== Qe.width || gn < L || Rn > ie) {
                        if (!(L !== Rn || v.height !== Qe.height || qt < E || wt > D)) {
                            wt > E && (Qe.width += wt - E,
                            Qe.x = E),
                            qt < D && (Qe.width = D - wt),
                            u.splice(c, 1);
                            break
                        }
                    } else {
                        Rn > L && (Qe.height += Rn - L,
                        Qe.y = L),
                        gn < ie && (Qe.height = ie - Rn),
                        u.splice(c, 1);
                        break
                    }
                }
        }
        return u
    }
    ,
    t.findHostInstance = fA,
    t.findHostInstanceWithNoPortals = function(u) {
        return u = W(u),
        u = u !== null ? re(u) : null,
        u === null ? null : u.stateNode
    }
    ,
    t.findHostInstanceWithWarning = function(u) {
        return fA(u)
    }
    ,
    t.flushControlled = function(u) {
        var c = jn;
        jn |= 1;
        var v = Ki.transition
          , E = Dt;
        try {
            Ki.transition = null,
            Dt = 1,
            u()
        } finally {
            Dt = E,
            Ki.transition = v,
            jn = c,
            jn === 0 && (od(),
            us())
        }
    }
    ,
    t.flushPassiveEffects = Kc,
    t.flushSync = eA,
    t.focusWithin = function(u, c) {
        if (!ft)
            throw Error(o(363));
        for (u = W_(u),
        c = QM(u, c),
        c = Array.from(c),
        u = 0; u < c.length; ) {
            var v = c[u++];
            if (!ye(v)) {
                if (v.tag === 5 && Ve(v.stateNode))
                    return !0;
                for (v = v.child; v !== null; )
                    c.push(v),
                    v = v.sibling
            }
        }
        return !1
    }
    ,
    t.getCurrentUpdatePriority = function() {
        return Dt
    }
    ,
    t.getFindAllNodesFailureDescription = function(u, c) {
        if (!ft)
            throw Error(o(363));
        var v = 0
          , E = [];
        u = [W_(u), 0];
        for (var D = 0; D < u.length; ) {
            var L = u[D++]
              , ie = u[D++]
              , _e = c[ie];
            if ((L.tag !== 5 || !ye(L)) && (X_(L, _e) && (E.push(J_(_e)),
            ie++,
            ie > v && (v = ie)),
            ie < c.length))
                for (L = L.child; L !== null; )
                    u.push(L, ie),
                    L = L.sibling
        }
        if (v < c.length) {
            for (u = []; v < c.length; v++)
                u.push(J_(c[v]));
            return `findAllNodes was able to match part of the selector:
  ` + (E.join(" > ") + `

No matching component was found for:
  `) + u.join(" > ")
        }
        return null
    }
    ,
    t.getPublicRootInstance = function(u) {
        if (u = u.current,
        !u.child)
            return null;
        switch (u.child.tag) {
        case 5:
            return ce(u.child.stateNode);
        default:
            return u.child.stateNode
        }
    }
    ,
    t.injectIntoDevTools = function(u) {
        if (u = {
            bundleType: u.bundleType,
            version: u.version,
            rendererPackageName: u.rendererPackageName,
            rendererConfig: u.rendererConfig,
            overrideHookState: null,
            overrideHookStateDeletePath: null,
            overrideHookStateRenamePath: null,
            overrideProps: null,
            overridePropsDeletePath: null,
            overridePropsRenamePath: null,
            setErrorHandler: null,
            setSuspenseHandler: null,
            scheduleUpdate: null,
            currentDispatcherRef: a.ReactCurrentDispatcher,
            findHostInstanceByFiber: xR,
            findFiberByHostInstance: u.findFiberByHostInstance || wR,
            findHostInstancesForRefresh: null,
            scheduleRefresh: null,
            scheduleRoot: null,
            setRefreshHandler: null,
            getCurrentFiber: null,
            reconcilerVersion: "18.0.0-fc46dba67-20220329"
        },
        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u")
            u = !1;
        else {
            var c = __REACT_DEVTOOLS_GLOBAL_HOOK__;
            if (c.isDisabled || !c.supportsFiber)
                u = !0;
            else {
                try {
                    Oo = c.inject(u),
                    Ei = c
                } catch {}
                u = !!c.checkDCE
            }
        }
        return u
    }
    ,
    t.isAlreadyRendering = function() {
        return !1
    }
    ,
    t.observeVisibleRects = function(u, c, v, E) {
        if (!ft)
            throw Error(o(363));
        u = j_(u, c);
        var D = Ke(u, v, E).disconnect;
        return {
            disconnect: function() {
                D()
            }
        }
    }
    ,
    t.registerMutableSourceForHydration = function(u, c) {
        var v = c._getVersion;
        v = v(c._source),
        u.mutableSourceEagerHydrationData == null ? u.mutableSourceEagerHydrationData = [c, v] : u.mutableSourceEagerHydrationData.push(c, v)
    }
    ,
    t.runWithPriority = function(u, c) {
        var v = Dt;
        try {
            return Dt = u,
            c()
        } finally {
            Dt = v
        }
    }
    ,
    t.shouldError = function() {
        return null
    }
    ,
    t.shouldSuspend = function() {
        return !1
    }
    ,
    t.updateContainer = function(u, c, v, E) {
        var D = c.current
          , L = _o()
          , ie = Vu(D);
        return v = cA(v),
        c.context === null ? c.context = v : c.pendingContext = v,
        c = Q(L, ie),
        c.payload = {
            element: u
        },
        E = E === void 0 ? null : E,
        E !== null && (c.callback = E),
        Se(D, c),
        u = ka(D, ie, L),
        u !== null && We(u, D, ie),
        ie
    }
    ,
    t
};
(function(n) {
    n.exports = tU
}
)(QG);
const nU = CR(yw);
var jv = {}
  , rU = {
    get exports() {
        return jv
    },
    set exports(n) {
        jv = n
    }
}
  , K3 = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
(function(n) {
    function e(G, z) {
        var U = G.length;
        G.push(z);
        e: for (; 0 < U; ) {
            var fe = U - 1 >>> 1
              , oe = G[fe];
            if (0 < i(oe, z))
                G[fe] = z,
                G[U] = oe,
                U = fe;
            else
                break e
        }
    }
    function t(G) {
        return G.length === 0 ? null : G[0]
    }
    function r(G) {
        if (G.length === 0)
            return null;
        var z = G[0]
          , U = G.pop();
        if (U !== z) {
            G[0] = U;
            e: for (var fe = 0, oe = G.length, Ae = oe >>> 1; fe < Ae; ) {
                var Ue = 2 * (fe + 1) - 1
                  , je = G[Ue]
                  , de = Ue + 1
                  , qe = G[de];
                if (0 > i(je, U))
                    de < oe && 0 > i(qe, je) ? (G[fe] = qe,
                    G[de] = U,
                    fe = de) : (G[fe] = je,
                    G[Ue] = U,
                    fe = Ue);
                else if (de < oe && 0 > i(qe, U))
                    G[fe] = qe,
                    G[de] = U,
                    fe = de;
                else
                    break e
            }
        }
        return z
    }
    function i(G, z) {
        var U = G.sortIndex - z.sortIndex;
        return U !== 0 ? U : G.id - z.id
    }
    if (typeof performance == "object" && typeof performance.now == "function") {
        var s = performance;
        n.unstable_now = function() {
            return s.now()
        }
    } else {
        var o = Date
          , a = o.now();
        n.unstable_now = function() {
            return o.now() - a
        }
    }
    var l = []
      , f = []
      , h = 1
      , d = null
      , p = 3
      , m = !1
      , _ = !1
      , y = !1
      , x = typeof setTimeout == "function" ? setTimeout : null
      , S = typeof clearTimeout == "function" ? clearTimeout : null
      , M = typeof setImmediate < "u" ? setImmediate : null;
    typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
    function w(G) {
        for (var z = t(f); z !== null; ) {
            if (z.callback === null)
                r(f);
            else if (z.startTime <= G)
                r(f),
                z.sortIndex = z.expirationTime,
                e(l, z);
            else
                break;
            z = t(f)
        }
    }
    function T(G) {
        if (y = !1,
        w(G),
        !_)
            if (t(l) !== null)
                _ = !0,
                ce(P);
            else {
                var z = t(f);
                z !== null && xe(T, z.startTime - G)
            }
    }
    function P(G, z) {
        _ = !1,
        y && (y = !1,
        S(R),
        R = -1),
        m = !0;
        var U = p;
        try {
            for (w(z),
            d = t(l); d !== null && (!(d.expirationTime > z) || G && !W()); ) {
                var fe = d.callback;
                if (typeof fe == "function") {
                    d.callback = null,
                    p = d.priorityLevel;
                    var oe = fe(d.expirationTime <= z);
                    z = n.unstable_now(),
                    typeof oe == "function" ? d.callback = oe : d === t(l) && r(l),
                    w(z)
                } else
                    r(l);
                d = t(l)
            }
            if (d !== null)
                var Ae = !0;
            else {
                var Ue = t(f);
                Ue !== null && xe(T, Ue.startTime - z),
                Ae = !1
            }
            return Ae
        } finally {
            d = null,
            p = U,
            m = !1
        }
    }
    var I = !1
      , k = null
      , R = -1
      , O = 5
      , H = -1;
    function W() {
        return !(n.unstable_now() - H < O)
    }
    function te() {
        if (k !== null) {
            var G = n.unstable_now();
            H = G;
            var z = !0;
            try {
                z = k(!0, G)
            } finally {
                z ? ne() : (I = !1,
                k = null)
            }
        } else
            I = !1
    }
    var ne;
    if (typeof M == "function")
        ne = function() {
            M(te)
        }
        ;
    else if (typeof MessageChannel < "u") {
        var re = new MessageChannel
          , pe = re.port2;
        re.port1.onmessage = te,
        ne = function() {
            pe.postMessage(null)
        }
    } else
        ne = function() {
            x(te, 0)
        }
        ;
    function ce(G) {
        k = G,
        I || (I = !0,
        ne())
    }
    function xe(G, z) {
        R = x(function() {
            G(n.unstable_now())
        }, z)
    }
    n.unstable_IdlePriority = 5,
    n.unstable_ImmediatePriority = 1,
    n.unstable_LowPriority = 4,
    n.unstable_NormalPriority = 3,
    n.unstable_Profiling = null,
    n.unstable_UserBlockingPriority = 2,
    n.unstable_cancelCallback = function(G) {
        G.callback = null
    }
    ,
    n.unstable_continueExecution = function() {
        _ || m || (_ = !0,
        ce(P))
    }
    ,
    n.unstable_forceFrameRate = function(G) {
        0 > G || 125 < G ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : O = 0 < G ? Math.floor(1e3 / G) : 5
    }
    ,
    n.unstable_getCurrentPriorityLevel = function() {
        return p
    }
    ,
    n.unstable_getFirstCallbackNode = function() {
        return t(l)
    }
    ,
    n.unstable_next = function(G) {
        switch (p) {
        case 1:
        case 2:
        case 3:
            var z = 3;
            break;
        default:
            z = p
        }
        var U = p;
        p = z;
        try {
            return G()
        } finally {
            p = U
        }
    }
    ,
    n.unstable_pauseExecution = function() {}
    ,
    n.unstable_requestPaint = function() {}
    ,
    n.unstable_runWithPriority = function(G, z) {
        switch (G) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
            break;
        default:
            G = 3
        }
        var U = p;
        p = G;
        try {
            return z()
        } finally {
            p = U
        }
    }
    ,
    n.unstable_scheduleCallback = function(G, z, U) {
        var fe = n.unstable_now();
        switch (typeof U == "object" && U !== null ? (U = U.delay,
        U = typeof U == "number" && 0 < U ? fe + U : fe) : U = fe,
        G) {
        case 1:
            var oe = -1;
            break;
        case 2:
            oe = 250;
            break;
        case 5:
            oe = 1073741823;
            break;
        case 4:
            oe = 1e4;
            break;
        default:
            oe = 5e3
        }
        return oe = U + oe,
        G = {
            id: h++,
            callback: z,
            priorityLevel: G,
            startTime: U,
            expirationTime: oe,
            sortIndex: -1
        },
        U > fe ? (G.sortIndex = U,
        e(f, G),
        t(l) === null && G === t(f) && (y ? (S(R),
        R = -1) : y = !0,
        xe(T, U - fe))) : (G.sortIndex = oe,
        e(l, G),
        _ || m || (_ = !0,
        ce(P))),
        G
    }
    ,
    n.unstable_shouldYield = W,
    n.unstable_wrapCallback = function(G) {
        var z = p;
        return function() {
            var U = p;
            p = z;
            try {
                return G.apply(this, arguments)
            } finally {
                p = U
            }
        }
    }
}
)(K3);
(function(n) {
    n.exports = K3
}
)(rU);
function q3(n, e, t=(r,i)=>r === i) {
    if (n === e)
        return !0;
    if (!n || !e)
        return !1;
    const r = n.length;
    if (e.length !== r)
        return !1;
    for (let i = 0; i < r; i++)
        if (!t(n[i], e[i]))
            return !1;
    return !0
}
const hu = [];
function Q3(n, e, t=!1, r={}) {
    for (const s of hu)
        if (q3(e, s.keys, s.equal)) {
            if (t)
                return;
            if (Object.prototype.hasOwnProperty.call(s, "error"))
                throw s.error;
            if (Object.prototype.hasOwnProperty.call(s, "response"))
                return s.response;
            if (!t)
                throw s.promise
        }
    const i = {
        keys: e,
        equal: r.equal,
        promise: n(...e).then(s=>i.response = s).then(()=>{
            r.lifespan && r.lifespan > 0 && setTimeout(()=>{
                const s = hu.indexOf(i);
                s !== -1 && hu.splice(s, 1)
            }
            , r.lifespan)
        }
        ).catch(s=>i.error = s)
    };
    if (hu.push(i),
    !t)
        throw i.promise
}
const iU = (n,e,t)=>Q3(n, e, !1, t)
  , sU = (n,e,t)=>void Q3(n, e, !0, t)
  , oU = n=>{
    if (n === void 0 || n.length === 0)
        hu.splice(0, hu.length);
    else {
        const e = hu.find(t=>q3(n, t.keys, t.equal));
        if (e) {
            const t = hu.indexOf(e);
            t !== -1 && hu.splice(t, 1)
        }
    }
}
;
var XE, JE;
const Z3 = n=>n && n.isOrthographicCamera
  , aU = n=>n && n.hasOwnProperty("current")
  , Zm = typeof window < "u" && ((XE = window.document) != null && XE.createElement || ((JE = window.navigator) == null ? void 0 : JE.product) === "ReactNative") ? we.useLayoutEffect : we.useEffect;
function $3(n) {
    const e = we.useRef(n);
    return Zm(()=>void (e.current = n), [n]),
    e
}
function lU({set: n}) {
    return Zm(()=>(n(new Promise(()=>null)),
    ()=>n(!1)), [n]),
    null
}
class eP extends we.Component {
    constructor() {
        super(...arguments);
        ly(this, "state", {
            error: !1
        })
    }
    componentDidCatch(t) {
        this.props.set(t)
    }
    render() {
        return this.state.error ? null : this.props.children
    }
}
ly(eP, "getDerivedStateFromError", ()=>({
    error: !0
}));
const tP = "__default"
  , uU = n=>n && !!n.memoized && !!n.changes;
function nP(n) {
    const e = typeof window < "u" ? window.devicePixelRatio : 1;
    return Array.isArray(n) ? Math.min(Math.max(n[0], e), n[1]) : n
}
const cp = n=>{
    var e;
    return (e = n.__r3f) == null ? void 0 : e.root.getState()
}
  , Ii = {
    obj: n=>n === Object(n) && !Ii.arr(n) && typeof n != "function",
    fun: n=>typeof n == "function",
    str: n=>typeof n == "string",
    num: n=>typeof n == "number",
    boo: n=>typeof n == "boolean",
    und: n=>n === void 0,
    arr: n=>Array.isArray(n),
    equ(n, e, {arrays: t="shallow", objects: r="reference", strict: i=!0}={}) {
        if (typeof n != typeof e || !!n != !!e)
            return !1;
        if (Ii.str(n) || Ii.num(n))
            return n === e;
        const s = Ii.obj(n);
        if (s && r === "reference")
            return n === e;
        const o = Ii.arr(n);
        if (o && t === "reference")
            return n === e;
        if ((o || s) && n === e)
            return !0;
        let a;
        for (a in n)
            if (!(a in e))
                return !1;
        for (a in i ? e : n)
            if (n[a] !== e[a])
                return !1;
        if (Ii.und(a)) {
            if (o && n.length === 0 && e.length === 0 || s && Object.keys(n).length === 0 && Object.keys(e).length === 0)
                return !0;
            if (n !== e)
                return !1
        }
        return !0
    }
};
function cU(n) {
    const e = {
        nodes: {},
        materials: {}
    };
    return n && n.traverse(t=>{
        t.name && (e.nodes[t.name] = t),
        t.material && !e.materials[t.material.name] && (e.materials[t.material.name] = t.material)
    }
    ),
    e
}
function fU(n) {
    n.dispose && n.type !== "Scene" && n.dispose();
    for (const e in n)
        e.dispose == null || e.dispose(),
        delete n[e]
}
function Td(n, e) {
    const t = n;
    return (e != null && e.primitive || !t.__r3f) && (t.__r3f = {
        type: "",
        root: null,
        previousAttach: null,
        memoizedProps: {},
        eventCount: 0,
        handlers: {},
        objects: [],
        parent: null,
        ...e
    }),
    n
}
function xw(n, e) {
    let t = n;
    if (e.includes("-")) {
        const r = e.split("-")
          , i = r.pop();
        return t = r.reduce((s,o)=>s[o], n),
        {
            target: t,
            key: i
        }
    } else
        return {
            target: t,
            key: e
        }
}
const jE = /-\d+$/;
function gx(n, e, t) {
    if (Ii.str(t)) {
        if (jE.test(t)) {
            const s = t.replace(jE, "")
              , {target: o, key: a} = xw(n, s);
            Array.isArray(o[a]) || (o[a] = [])
        }
        const {target: r, key: i} = xw(n, t);
        e.__r3f.previousAttach = r[i],
        r[i] = e
    } else
        e.__r3f.previousAttach = t(n, e)
}
function YE(n, e, t) {
    var r, i;
    if (Ii.str(t)) {
        const {target: s, key: o} = xw(n, t)
          , a = e.__r3f.previousAttach;
        a === void 0 ? delete s[o] : s[o] = a
    } else
        (r = e.__r3f) == null || r.previousAttach == null || r.previousAttach(n, e);
    (i = e.__r3f) == null || delete i.previousAttach
}
function rP(n, {children: e, key: t, ref: r, ...i}, {children: s, key: o, ref: a, ...l}={}, f=!1) {
    var h;
    const d = (h = n == null ? void 0 : n.__r3f) != null ? h : {}
      , p = Object.entries(i)
      , m = [];
    if (f) {
        const y = Object.keys(l);
        for (let x = 0; x < y.length; x++)
            i.hasOwnProperty(y[x]) || p.unshift([y[x], tP + "remove"])
    }
    p.forEach(([y,x])=>{
        var S;
        if ((S = n.__r3f) != null && S.primitive && y === "object" || Ii.equ(x, l[y]))
            return;
        if (/^on(Pointer|Click|DoubleClick|ContextMenu|Wheel)/.test(y))
            return m.push([y, x, !0, []]);
        let M = [];
        y.includes("-") && (M = y.split("-")),
        m.push([y, x, !1, M]);
        for (const w in i) {
            const T = i[w];
            w.startsWith(`${y}-`) && m.push([w, T, !1, w.split("-")])
        }
    }
    );
    const _ = {
        ...i
    };
    return d.memoizedProps && d.memoizedProps.args && (_.args = d.memoizedProps.args),
    d.memoizedProps && d.memoizedProps.attach && (_.attach = d.memoizedProps.attach),
    {
        memoized: _,
        changes: m
    }
}
function vx(n, e) {
    var t, r, i;
    const s = (t = n.__r3f) != null ? t : {}
      , o = s.root
      , a = (r = o == null || o.getState == null ? void 0 : o.getState()) != null ? r : {}
      , {memoized: l, changes: f} = uU(e) ? e : rP(n, e)
      , h = s.eventCount;
    n.__r3f && (n.__r3f.memoizedProps = l);
    for (let p = 0; p < f.length; p++) {
        let[m,_,y,x] = f[p]
          , S = n
          , M = S[m];
        if (x.length && (M = x.reduce((w,T)=>w[T], n),
        !(M && M.set))) {
            const [w,...T] = x.reverse();
            S = T.reverse().reduce((P,I)=>P[I], n),
            m = w
        }
        if (_ === tP + "remove")
            if (S.constructor) {
                var d;
                const w = new S.constructor(...(d = S.__r3f.memoizedProps.args) != null ? d : []);
                _ = w[m],
                w.dispose && w.dispose()
            } else
                _ = 0;
        if (y)
            _ ? s.handlers[m] = _ : delete s.handlers[m],
            s.eventCount = Object.keys(s.handlers).length;
        else if (M && M.set && (M.copy || M instanceof Rf)) {
            if (Array.isArray(_))
                M.fromArray ? M.fromArray(_) : M.set(..._);
            else if (M.copy && _ && _.constructor && M.constructor.name === _.constructor.name)
                M.copy(_);
            else if (_ !== void 0) {
                const w = M instanceof It;
                !w && M.setScalar ? M.setScalar(_) : M instanceof Rf && _ instanceof Rf ? M.mask = _.mask : M.set(_),
                !("ColorManagement"in Xv) && !a.linear && w && M.convertSRGBToLinear()
            }
        } else
            S[m] = _,
            !a.linear && S[m]instanceof Ci && (S[m].encoding = nr);
        Dd(n)
    }
    if (s.parent && a.internal && n.raycast && h !== s.eventCount) {
        const p = a.internal.interaction.indexOf(n);
        p > -1 && a.internal.interaction.splice(p, 1),
        s.eventCount && a.internal.interaction.push(n)
    }
    return f.length && (i = n.__r3f) != null && i.parent && ww(n),
    n
}
function Dd(n) {
    var e, t;
    const r = (e = n.__r3f) == null || (t = e.root) == null || t.getState == null ? void 0 : t.getState();
    r && r.internal.frames === 0 && r.invalidate()
}
function ww(n) {
    n.onUpdate == null || n.onUpdate(n)
}
function iP(n, e) {
    n.manual || (Z3(n) ? (n.left = e.width / -2,
    n.right = e.width / 2,
    n.top = e.height / 2,
    n.bottom = e.height / -2) : n.aspect = e.width / e.height,
    n.updateProjectionMatrix(),
    n.updateMatrixWorld())
}
function dU(n, e, t) {
    const r = t.pop()
      , i = t.reduce((s,o)=>s[o], n);
    return i[r] = e
}
function w0(n) {
    return (n.eventObject || n.object).uuid + "/" + n.index + n.instanceId
}
function hU() {
    var n;
    const e = typeof self < "u" && self || typeof window < "u" && window;
    if (!e)
        return uc.DefaultEventPriority;
    switch ((n = e.event) == null ? void 0 : n.type) {
    case "click":
    case "contextmenu":
    case "dblclick":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
        return uc.DiscreteEventPriority;
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "pointerenter":
    case "pointerleave":
    case "wheel":
        return uc.ContinuousEventPriority;
    default:
        return uc.DefaultEventPriority
    }
}
function sP(n, e, t, r) {
    const i = t.get(e);
    i && (t.delete(e),
    t.size === 0 && (n.delete(r),
    i.target.releasePointerCapture(r)))
}
function pU(n, e) {
    const {internal: t} = n.getState();
    t.interaction = t.interaction.filter(r=>r !== e),
    t.initialHits = t.initialHits.filter(r=>r !== e),
    t.hovered.forEach((r,i)=>{
        (r.eventObject === e || r.object === e) && t.hovered.delete(i)
    }
    ),
    t.capturedMap.forEach((r,i)=>{
        sP(t.capturedMap, e, r, i)
    }
    )
}
function mU(n) {
    function e(l) {
        const {internal: f} = n.getState()
          , h = l.offsetX - f.initialClick[0]
          , d = l.offsetY - f.initialClick[1];
        return Math.round(Math.sqrt(h * h + d * d))
    }
    function t(l) {
        return l.filter(f=>["Move", "Over", "Enter", "Out", "Leave"].some(h=>{
            var d;
            return (d = f.__r3f) == null ? void 0 : d.handlers["onPointer" + h]
        }
        ))
    }
    function r(l, f) {
        const h = n.getState()
          , d = new Set
          , p = []
          , m = f ? f(h.internal.interaction) : h.internal.interaction;
        for (let S = 0; S < m.length; S++) {
            const M = cp(m[S]);
            M && (M.raycaster.camera = void 0)
        }
        h.previousRoot || h.events.compute == null || h.events.compute(l, h);
        function _(S) {
            const M = cp(S);
            if (!M || !M.events.enabled || M.raycaster.camera === null)
                return [];
            if (M.raycaster.camera === void 0) {
                var w;
                M.events.compute == null || M.events.compute(l, M, (w = M.previousRoot) == null ? void 0 : w.getState()),
                M.raycaster.camera === void 0 && (M.raycaster.camera = null)
            }
            return M.raycaster.camera ? M.raycaster.intersectObject(S, !0) : []
        }
        let y = m.flatMap(_).sort((S,M)=>{
            const w = cp(S.object)
              , T = cp(M.object);
            return !w || !T ? S.distance - M.distance : T.events.priority - w.events.priority || S.distance - M.distance
        }
        ).filter(S=>{
            const M = w0(S);
            return d.has(M) ? !1 : (d.add(M),
            !0)
        }
        );
        h.events.filter && (y = h.events.filter(y, h));
        for (const S of y) {
            let M = S.object;
            for (; M; ) {
                var x;
                (x = M.__r3f) != null && x.eventCount && p.push({
                    ...S,
                    eventObject: M
                }),
                M = M.parent
            }
        }
        if ("pointerId"in l && h.internal.capturedMap.has(l.pointerId))
            for (let S of h.internal.capturedMap.get(l.pointerId).values())
                d.has(w0(S.intersection)) || p.push(S.intersection);
        return p
    }
    function i(l, f, h, d) {
        const p = n.getState();
        if (l.length) {
            const m = {
                stopped: !1
            };
            for (const _ of l) {
                const y = cp(_.object) || p
                  , {raycaster: x, pointer: S, camera: M, internal: w} = y
                  , T = new $(S.x,S.y,0).unproject(M)
                  , P = H=>{
                    var W, te;
                    return (W = (te = w.capturedMap.get(H)) == null ? void 0 : te.has(_.eventObject)) != null ? W : !1
                }
                  , I = H=>{
                    const W = {
                        intersection: _,
                        target: f.target
                    };
                    w.capturedMap.has(H) ? w.capturedMap.get(H).set(_.eventObject, W) : w.capturedMap.set(H, new Map([[_.eventObject, W]])),
                    f.target.setPointerCapture(H)
                }
                  , k = H=>{
                    const W = w.capturedMap.get(H);
                    W && sP(w.capturedMap, _.eventObject, W, H)
                }
                ;
                let R = {};
                for (let H in f) {
                    let W = f[H];
                    typeof W != "function" && (R[H] = W)
                }
                let O = {
                    ..._,
                    ...R,
                    pointer: S,
                    intersections: l,
                    stopped: m.stopped,
                    delta: h,
                    unprojectedPoint: T,
                    ray: x.ray,
                    camera: M,
                    stopPropagation() {
                        const H = "pointerId"in f && w.capturedMap.get(f.pointerId);
                        if ((!H || H.has(_.eventObject)) && (O.stopped = m.stopped = !0,
                        w.hovered.size && Array.from(w.hovered.values()).find(W=>W.eventObject === _.eventObject))) {
                            const W = l.slice(0, l.indexOf(_));
                            s([...W, _])
                        }
                    },
                    target: {
                        hasPointerCapture: P,
                        setPointerCapture: I,
                        releasePointerCapture: k
                    },
                    currentTarget: {
                        hasPointerCapture: P,
                        setPointerCapture: I,
                        releasePointerCapture: k
                    },
                    nativeEvent: f
                };
                if (d(O),
                m.stopped === !0)
                    break
            }
        }
        return l
    }
    function s(l) {
        const {internal: f} = n.getState();
        for (const h of f.hovered.values())
            if (!l.length || !l.find(d=>d.object === h.object && d.index === h.index && d.instanceId === h.instanceId)) {
                const p = h.eventObject.__r3f
                  , m = p == null ? void 0 : p.handlers;
                if (f.hovered.delete(w0(h)),
                p != null && p.eventCount) {
                    const _ = {
                        ...h,
                        intersections: l
                    };
                    m.onPointerOut == null || m.onPointerOut(_),
                    m.onPointerLeave == null || m.onPointerLeave(_)
                }
            }
    }
    function o(l, f) {
        for (let h = 0; h < f.length; h++) {
            const d = f[h].__r3f;
            d == null || d.handlers.onPointerMissed == null || d.handlers.onPointerMissed(l)
        }
    }
    function a(l) {
        switch (l) {
        case "onPointerLeave":
        case "onPointerCancel":
            return ()=>s([]);
        case "onLostPointerCapture":
            return f=>{
                const {internal: h} = n.getState();
                "pointerId"in f && h.capturedMap.has(f.pointerId) && (h.capturedMap.delete(f.pointerId),
                s([]))
            }
        }
        return function(h) {
            const {onPointerMissed: d, internal: p} = n.getState();
            p.lastEvent.current = h;
            const m = l === "onPointerMove"
              , _ = l === "onClick" || l === "onContextMenu" || l === "onDoubleClick"
              , x = r(h, m ? t : void 0)
              , S = _ ? e(h) : 0;
            l === "onPointerDown" && (p.initialClick = [h.offsetX, h.offsetY],
            p.initialHits = x.map(w=>w.eventObject)),
            _ && !x.length && S <= 2 && (o(h, p.interaction),
            d && d(h)),
            m && s(x);
            function M(w) {
                const T = w.eventObject
                  , P = T.__r3f
                  , I = P == null ? void 0 : P.handlers;
                if (P != null && P.eventCount)
                    if (m) {
                        if (I.onPointerOver || I.onPointerEnter || I.onPointerOut || I.onPointerLeave) {
                            const k = w0(w)
                              , R = p.hovered.get(k);
                            R ? R.stopped && w.stopPropagation() : (p.hovered.set(k, w),
                            I.onPointerOver == null || I.onPointerOver(w),
                            I.onPointerEnter == null || I.onPointerEnter(w))
                        }
                        I.onPointerMove == null || I.onPointerMove(w)
                    } else {
                        const k = I[l];
                        k ? (!_ || p.initialHits.includes(T)) && (o(h, p.interaction.filter(R=>!p.initialHits.includes(R))),
                        k(w)) : _ && p.initialHits.includes(T) && o(h, p.interaction.filter(R=>!p.initialHits.includes(R)))
                    }
            }
            i(x, h, S, M)
        }
    }
    return {
        handlePointer: a
    }
}
let Sw = {}
  , AM = n=>void (Sw = {
    ...Sw,
    ...n
});
function gU(n, e) {
    function t(h, {args: d=[], attach: p, ...m}, _) {
        let y = `${h[0].toUpperCase()}${h.slice(1)}`, x;
        if (h === "primitive") {
            if (m.object === void 0)
                throw new Error("R3F: Primitives without 'object' are invalid!");
            const S = m.object;
            x = Td(S, {
                type: h,
                root: _,
                attach: p,
                primitive: !0
            })
        } else {
            const S = Sw[y];
            if (!S)
                throw new Error(`R3F: ${y} is not part of the THREE namespace! Did you forget to extend? See: https://docs.pmnd.rs/react-three-fiber/api/objects#using-3rd-party-objects-declaratively`);
            if (!Array.isArray(d))
                throw new Error("R3F: The args prop must be an array!");
            x = Td(new S(...d), {
                type: h,
                root: _,
                attach: p,
                memoizedProps: {
                    args: d
                }
            })
        }
        return x.__r3f.attach === void 0 && (x instanceof On ? x.__r3f.attach = "geometry" : x instanceof as && (x.__r3f.attach = "material")),
        y !== "inject" && vx(x, m),
        x
    }
    function r(h, d) {
        let p = !1;
        if (d) {
            var m, _;
            (m = d.__r3f) != null && m.attach ? gx(h, d, d.__r3f.attach) : d.isObject3D && h.isObject3D && (h.add(d),
            p = !0),
            p || (_ = h.__r3f) == null || _.objects.push(d),
            d.__r3f || Td(d, {}),
            d.__r3f.parent = h,
            ww(d),
            Dd(d)
        }
    }
    function i(h, d, p) {
        let m = !1;
        if (d) {
            var _, y;
            if ((_ = d.__r3f) != null && _.attach)
                gx(h, d, d.__r3f.attach);
            else if (d.isObject3D && h.isObject3D) {
                d.parent = h,
                d.dispatchEvent({
                    type: "added"
                });
                const x = h.children.filter(M=>M !== d)
                  , S = x.indexOf(p);
                h.children = [...x.slice(0, S), d, ...x.slice(S)],
                m = !0
            }
            m || (y = h.__r3f) == null || y.objects.push(d),
            d.__r3f || Td(d, {}),
            d.__r3f.parent = h,
            ww(d),
            Dd(d)
        }
    }
    function s(h, d, p=!1) {
        h && [...h].forEach(m=>o(d, m, p))
    }
    function o(h, d, p) {
        if (d) {
            var m, _, y;
            if (d.__r3f && (d.__r3f.parent = null),
            (m = h.__r3f) != null && m.objects && (h.__r3f.objects = h.__r3f.objects.filter(T=>T !== d)),
            (_ = d.__r3f) != null && _.attach)
                YE(h, d, d.__r3f.attach);
            else if (d.isObject3D && h.isObject3D) {
                var x;
                h.remove(d),
                (x = d.__r3f) != null && x.root && pU(d.__r3f.root, d)
            }
            const M = (y = d.__r3f) == null ? void 0 : y.primitive
              , w = p === void 0 ? d.dispose !== null && !M : p;
            if (!M) {
                var S;
                s((S = d.__r3f) == null ? void 0 : S.objects, d, w),
                s(d.children, d, w)
            }
            d.__r3f && (delete d.__r3f.root,
            delete d.__r3f.objects,
            delete d.__r3f.handlers,
            delete d.__r3f.memoizedProps,
            M || delete d.__r3f),
            w && d.dispose && d.type !== "Scene" && jv.unstable_scheduleCallback(jv.unstable_IdlePriority, ()=>{
                try {
                    d.dispose()
                } catch {}
            }
            ),
            Dd(h)
        }
    }
    function a(h, d, p, m) {
        var _;
        const y = (_ = h.__r3f) == null ? void 0 : _.parent;
        if (!y)
            return;
        const x = t(d, p, h.__r3f.root);
        if (h.children) {
            for (const S of h.children)
                S.__r3f && r(x, S);
            h.children = h.children.filter(S=>!S.__r3f)
        }
        h.__r3f.objects.forEach(S=>r(x, S)),
        h.__r3f.objects = [],
        h.__r3f.autoRemovedBeforeAppend || o(y, h),
        x.parent && (x.__r3f.autoRemovedBeforeAppend = !0),
        r(y, x),
        x.raycast && x.__r3f.eventCount && x.__r3f.root.getState().internal.interaction.push(x),
        [m, m.alternate].forEach(S=>{
            S !== null && (S.stateNode = x,
            S.ref && (typeof S.ref == "function" ? S.ref(x) : S.ref.current = x))
        }
        )
    }
    const l = ()=>console.warn("Text is not allowed in the R3F tree! This could be stray whitespace or characters.");
    return {
        reconciler: nU({
            createInstance: t,
            removeChild: o,
            appendChild: r,
            appendInitialChild: r,
            insertBefore: i,
            supportsMutation: !0,
            isPrimaryRenderer: !1,
            supportsPersistence: !1,
            supportsHydration: !1,
            noTimeout: -1,
            appendChildToContainer: (h,d)=>{
                if (!d)
                    return;
                const p = h.getState().scene;
                p.__r3f && (p.__r3f.root = h,
                r(p, d))
            }
            ,
            removeChildFromContainer: (h,d)=>{
                d && o(h.getState().scene, d)
            }
            ,
            insertInContainerBefore: (h,d,p)=>{
                if (!d || !p)
                    return;
                const m = h.getState().scene;
                m.__r3f && i(m, d, p)
            }
            ,
            getRootHostContext: ()=>null,
            getChildHostContext: h=>h,
            finalizeInitialChildren(h) {
                var d;
                const p = (d = h == null ? void 0 : h.__r3f) != null ? d : {};
                return Boolean(p.handlers)
            },
            prepareUpdate(h, d, p, m) {
                if (h.__r3f.primitive && m.object && m.object !== h)
                    return [!0];
                {
                    const {args: _=[], children: y, ...x} = m
                      , {args: S=[], children: M, ...w} = p;
                    if (!Array.isArray(_))
                        throw new Error("R3F: the args prop must be an array!");
                    if (_.some((P,I)=>P !== S[I]))
                        return [!0];
                    const T = rP(h, x, w, !0);
                    return T.changes.length ? [!1, T] : null
                }
            },
            commitUpdate(h, [d,p], m, _, y, x) {
                d ? a(h, m, y, x) : vx(h, p)
            },
            commitMount(h, d, p, m) {
                var _;
                const y = (_ = h.__r3f) != null ? _ : {};
                h.raycast && y.handlers && y.eventCount && h.__r3f.root.getState().internal.interaction.push(h)
            },
            getPublicInstance: h=>h,
            prepareForCommit: ()=>null,
            preparePortalMount: h=>Td(h.getState().scene),
            resetAfterCommit: ()=>{}
            ,
            shouldSetTextContent: ()=>!1,
            clearContainer: ()=>!1,
            hideInstance(h) {
                var d;
                const {attach: p, parent: m} = (d = h.__r3f) != null ? d : {};
                p && m && YE(m, h, p),
                h.isObject3D && (h.visible = !1),
                Dd(h)
            },
            unhideInstance(h, d) {
                var p;
                const {attach: m, parent: _} = (p = h.__r3f) != null ? p : {};
                m && _ && gx(_, h, m),
                (h.isObject3D && d.visible == null || d.visible) && (h.visible = !0),
                Dd(h)
            },
            createTextInstance: l,
            hideTextInstance: l,
            unhideTextInstance: l,
            getCurrentEventPriority: ()=>e ? e() : uc.DefaultEventPriority,
            beforeActiveInstanceBlur: ()=>{}
            ,
            afterActiveInstanceBlur: ()=>{}
            ,
            detachDeletedInstance: ()=>{}
            ,
            now: typeof performance < "u" && Ii.fun(performance.now) ? performance.now : Ii.fun(Date.now) ? Date.now : ()=>0,
            scheduleTimeout: Ii.fun(setTimeout) ? setTimeout : void 0,
            cancelTimeout: Ii.fun(clearTimeout) ? clearTimeout : void 0
        }),
        applyProps: vx
    }
}
const vU = ["set", "get", "setSize", "setFrameloop", "setDpr", "events", "invalidate", "advance", "size", "viewport"]
  , oP = n=>!!(n != null && n.render)
  , CM = we.createContext(null)
  , _U = (n,e)=>{
    const t = MM((a,l)=>{
        const f = new $
          , h = new $
          , d = new $;
        function p(S=l().camera, M=h, w=l().size) {
            const {width: T, height: P, top: I, left: k} = w
              , R = T / P;
            M instanceof $ ? d.copy(M) : d.set(...M);
            const O = S.getWorldPosition(f).distanceTo(d);
            if (Z3(S))
                return {
                    width: T / S.zoom,
                    height: P / S.zoom,
                    top: I,
                    left: k,
                    factor: 1,
                    distance: O,
                    aspect: R
                };
            {
                const H = S.fov * Math.PI / 180
                  , W = 2 * Math.tan(H / 2) * O
                  , te = W * (T / P);
                return {
                    width: te,
                    height: W,
                    top: I,
                    left: k,
                    factor: T / te,
                    distance: O,
                    aspect: R
                }
            }
        }
        let m;
        const _ = S=>a(M=>({
            performance: {
                ...M.performance,
                current: S
            }
        }))
          , y = new it;
        return {
            set: a,
            get: l,
            gl: null,
            camera: null,
            raycaster: null,
            events: {
                priority: 1,
                enabled: !0,
                connected: !1
            },
            xr: null,
            invalidate: (S=1)=>n(l(), S),
            advance: (S,M)=>e(S, M, l()),
            legacy: !1,
            linear: !1,
            flat: !1,
            scene: Td(new C_),
            controls: null,
            clock: new _M,
            pointer: y,
            mouse: y,
            frameloop: "always",
            onPointerMissed: void 0,
            performance: {
                current: 1,
                min: .5,
                max: 1,
                debounce: 200,
                regress: ()=>{
                    const S = l();
                    m && clearTimeout(m),
                    S.performance.current !== S.performance.min && _(S.performance.min),
                    m = setTimeout(()=>_(l().performance.max), S.performance.debounce)
                }
            },
            size: {
                width: 0,
                height: 0,
                top: 0,
                left: 0,
                updateStyle: !1
            },
            viewport: {
                initialDpr: 0,
                dpr: 0,
                width: 0,
                height: 0,
                top: 0,
                left: 0,
                aspect: 0,
                distance: 0,
                factor: 0,
                getCurrentViewport: p
            },
            setEvents: S=>a(M=>({
                ...M,
                events: {
                    ...M.events,
                    ...S
                }
            })),
            setSize: (S,M,w,T,P)=>{
                const I = l().camera
                  , k = {
                    width: S,
                    height: M,
                    top: T || 0,
                    left: P || 0,
                    updateStyle: w
                };
                a(R=>({
                    size: k,
                    viewport: {
                        ...R.viewport,
                        ...p(I, h, k)
                    }
                }))
            }
            ,
            setDpr: S=>a(M=>{
                const w = nP(S);
                return {
                    viewport: {
                        ...M.viewport,
                        dpr: w,
                        initialDpr: M.viewport.initialDpr || w
                    }
                }
            }
            ),
            setFrameloop: (S="always")=>{
                const M = l().clock;
                M.stop(),
                M.elapsedTime = 0,
                S !== "never" && (M.start(),
                M.elapsedTime = 0),
                a(()=>({
                    frameloop: S
                }))
            }
            ,
            previousRoot: void 0,
            internal: {
                active: !1,
                priority: 0,
                frames: 0,
                lastEvent: we.createRef(),
                interaction: [],
                hovered: new Map,
                subscribers: [],
                initialClick: [0, 0],
                initialHits: [],
                capturedMap: new Map,
                subscribe: (S,M,w)=>{
                    const T = l().internal;
                    return T.priority = T.priority + (M > 0 ? 1 : 0),
                    T.subscribers.push({
                        ref: S,
                        priority: M,
                        store: w
                    }),
                    T.subscribers = T.subscribers.sort((P,I)=>P.priority - I.priority),
                    ()=>{
                        const P = l().internal;
                        P != null && P.subscribers && (P.priority = P.priority - (M > 0 ? 1 : 0),
                        P.subscribers = P.subscribers.filter(I=>I.ref !== S))
                    }
                }
            }
        }
    }
    )
      , r = t.getState();
    let i = r.size
      , s = r.viewport.dpr
      , o = r.camera;
    return t.subscribe(()=>{
        const {camera: a, size: l, viewport: f, gl: h, set: d} = t.getState();
        (l !== i || f.dpr !== s) && (i = l,
        s = f.dpr,
        iP(a, l),
        h.setPixelRatio(f.dpr),
        h.setSize(l.width, l.height, l.updateStyle)),
        a !== o && (o = a,
        d(p=>({
            viewport: {
                ...p.viewport,
                ...p.viewport.getCurrentViewport(a)
            }
        })))
    }
    ),
    t.subscribe(a=>n(a)),
    t
}
;
let S0, yU = new Set, xU = new Set, wU = new Set;
function _x(n, e) {
    if (n.size)
        for (const {callback: t} of n.values())
            t(e)
}
function fp(n, e) {
    switch (n) {
    case "before":
        return _x(yU, e);
    case "after":
        return _x(xU, e);
    case "tail":
        return _x(wU, e)
    }
}
let yx, xx;
function wx(n, e, t) {
    let r = e.clock.getDelta();
    for (e.frameloop === "never" && typeof n == "number" && (r = n - e.clock.elapsedTime,
    e.clock.oldTime = e.clock.elapsedTime,
    e.clock.elapsedTime = n),
    yx = e.internal.subscribers,
    S0 = 0; S0 < yx.length; S0++)
        xx = yx[S0],
        xx.ref.current(xx.store.getState(), r, t);
    return !e.internal.priority && e.gl.render && e.gl.render(e.scene, e.camera),
    e.internal.frames = Math.max(0, e.internal.frames - 1),
    e.frameloop === "always" ? 1 : e.internal.frames
}
function SU(n) {
    let e = !1, t, r, i;
    function s(l) {
        r = requestAnimationFrame(s),
        e = !0,
        t = 0,
        fp("before", l);
        for (const h of n.values()) {
            var f;
            i = h.store.getState(),
            i.internal.active && (i.frameloop === "always" || i.internal.frames > 0) && !((f = i.gl.xr) != null && f.isPresenting) && (t += wx(l, i))
        }
        if (fp("after", l),
        t === 0)
            return fp("tail", l),
            e = !1,
            cancelAnimationFrame(r)
    }
    function o(l, f=1) {
        var h;
        if (!l)
            return n.forEach(d=>o(d.store.getState()), f);
        (h = l.gl.xr) != null && h.isPresenting || !l.internal.active || l.frameloop === "never" || (l.internal.frames = Math.min(60, l.internal.frames + f),
        e || (e = !0,
        requestAnimationFrame(s)))
    }
    function a(l, f=!0, h, d) {
        if (f && fp("before", l),
        h)
            wx(l, h, d);
        else
            for (const p of n.values())
                wx(l, p.store.getState());
        f && fp("after", l)
    }
    return {
        loop: s,
        invalidate: o,
        advance: a
    }
}
function EM() {
    const n = we.useContext(CM);
    if (!n)
        throw new Error("R3F: Hooks can only be used within the Canvas component!");
    return n
}
function pa(n=t=>t, e) {
    return EM()(n, e)
}
function I_(n, e=0) {
    const t = EM()
      , r = t.getState().internal.subscribe
      , i = $3(n);
    return Zm(()=>r(i, e, t), [e, r, t]),
    null
}
function aP(n, e) {
    return function(t, ...r) {
        const i = new t;
        return n && n(i),
        Promise.all(r.map(s=>new Promise((o,a)=>i.load(s, l=>{
            l.scene && Object.assign(l, cU(l.scene)),
            o(l)
        }
        , e, l=>a(new Error(`Could not load ${s}: ${l.message})`))))))
    }
}
function Nh(n, e, t, r) {
    const i = Array.isArray(e) ? e : [e]
      , s = iU(aP(t, r), [n, ...i], {
        equal: Ii.equ
    });
    return Array.isArray(e) ? s : s[0]
}
Nh.preload = function(n, e, t) {
    const r = Array.isArray(e) ? e : [e];
    return sU(aP(t), [n, ...r])
}
;
Nh.clear = function(n, e) {
    const t = Array.isArray(e) ? e : [e];
    return oU([n, ...t])
}
;
const Ah = new Map
  , {invalidate: KE, advance: qE} = SU(Ah)
  , {reconciler: Am, applyProps: M0} = gU(Ah, hU)
  , dp = {
    objects: "shallow",
    strict: !1
}
  , MU = (n,e)=>{
    const t = typeof n == "function" ? n(e) : n;
    return oP(t) ? t : new qS({
        powerPreference: "high-performance",
        canvas: e,
        antialias: !0,
        alpha: !0,
        ...n
    })
}
;
function AU(n) {
    return n instanceof HTMLCanvasElement
}
function CU(n, e) {
    if (e)
        return e;
    if (AU(n) && n.parentElement) {
        const {width: t, height: r, top: i, left: s} = n.parentElement.getBoundingClientRect();
        return {
            width: t,
            height: r,
            top: i,
            left: s
        }
    }
    return {
        width: 0,
        height: 0,
        top: 0,
        left: 0
    }
}
function EU(n) {
    const e = Ah.get(n)
      , t = e == null ? void 0 : e.fiber
      , r = e == null ? void 0 : e.store;
    e && console.warn("R3F.createRoot should only be called once!");
    const i = typeof reportError == "function" ? reportError : console.error
      , s = r || _U(KE, qE)
      , o = t || Am.createContainer(s, uc.ConcurrentRoot, null, !1, null, "", i, null);
    e || Ah.set(n, {
        fiber: o,
        store: s
    });
    let a, l = !1;
    return {
        configure(f={}) {
            let {gl: h, size: d, events: p, onCreated: m, shadows: _=!1, linear: y=!1, flat: x=!1, legacy: S=!1, orthographic: M=!1, frameloop: w="always", dpr: T=[1, 2], performance: P, raycaster: I, camera: k, onPointerMissed: R} = f
              , O = s.getState()
              , H = O.gl;
            O.gl || O.set({
                gl: H = MU(h, n)
            });
            let W = O.raycaster;
            W || O.set({
                raycaster: W = new SM
            });
            const {params: te, ...ne} = I || {};
            if (Ii.equ(ne, W, dp) || M0(W, {
                ...ne
            }),
            Ii.equ(te, W.params, dp) || M0(W, {
                params: {
                    ...W.params,
                    ...te
                }
            }),
            !O.camera) {
                const G = k instanceof Om
                  , z = G ? k : M ? new Mu(0,0,0,0,.1,1e3) : new gi(75,0,.1,1e3);
                G || (z.position.z = 5,
                k && M0(z, k),
                k != null && k.rotation || z.lookAt(0, 0, 0)),
                O.set({
                    camera: z
                })
            }
            if (!O.xr) {
                const G = (fe,oe)=>{
                    const Ae = s.getState();
                    Ae.frameloop !== "never" && qE(fe, !0, Ae, oe)
                }
                  , z = ()=>{
                    const fe = s.getState();
                    fe.gl.xr.enabled = fe.gl.xr.isPresenting,
                    fe.gl.xr.setAnimationLoop(fe.gl.xr.isPresenting ? G : null),
                    fe.gl.xr.isPresenting || KE(fe)
                }
                  , U = {
                    connect() {
                        const fe = s.getState().gl;
                        fe.xr.addEventListener("sessionstart", z),
                        fe.xr.addEventListener("sessionend", z)
                    },
                    disconnect() {
                        const fe = s.getState().gl;
                        fe.xr.removeEventListener("sessionstart", z),
                        fe.xr.removeEventListener("sessionend", z)
                    }
                };
                H.xr && U.connect(),
                O.set({
                    xr: U
                })
            }
            if (H.shadowMap) {
                const G = H.shadowMap.enabled
                  , z = H.shadowMap.type;
                if (H.shadowMap.enabled = !!_,
                Ii.boo(_))
                    H.shadowMap.type = Np;
                else if (Ii.str(_)) {
                    var re;
                    const U = {
                        basic: n2,
                        percentage: m_,
                        soft: Np,
                        variance: yf
                    };
                    H.shadowMap.type = (re = U[_]) != null ? re : Np
                } else
                    Ii.obj(_) && Object.assign(H.shadowMap, _);
                (G !== H.shadowMap.enabled || z !== H.shadowMap.type) && (H.shadowMap.needsUpdate = !0)
            }
            "ColorManagement"in Xv && dU(Xv, S, ["ColorManagement", "legacyMode"]);
            const pe = y ? bl : nr
              , ce = x ? Ka : FS;
            H.outputEncoding !== pe && (H.outputEncoding = pe),
            H.toneMapping !== ce && (H.toneMapping = ce),
            O.legacy !== S && O.set(()=>({
                legacy: S
            })),
            O.linear !== y && O.set(()=>({
                linear: y
            })),
            O.flat !== x && O.set(()=>({
                flat: x
            })),
            h && !Ii.fun(h) && !oP(h) && !Ii.equ(h, H, dp) && M0(H, h),
            p && !O.events.handlers && O.set({
                events: p(s)
            }),
            T && O.viewport.dpr !== nP(T) && O.setDpr(T);
            const xe = CU(n, d);
            return Ii.equ(xe, O.size, dp) || O.setSize(xe.width, xe.height, xe.updateStyle, xe.top, xe.left),
            O.frameloop !== w && O.setFrameloop(w),
            O.onPointerMissed || O.set({
                onPointerMissed: R
            }),
            P && !Ii.equ(P, O.performance, dp) && O.set(G=>({
                performance: {
                    ...G.performance,
                    ...P
                }
            })),
            a = m,
            l = !0,
            this
        },
        render(f) {
            return l || this.configure(),
            Am.updateContainer(we.createElement(bU, {
                store: s,
                children: f,
                onCreated: a,
                rootElement: n
            }), o, null, ()=>{}
            ),
            s
        },
        unmount() {
            lP(n)
        }
    }
}
function bU({store: n, children: e, onCreated: t, rootElement: r}) {
    return Zm(()=>{
        const i = n.getState();
        i.set(s=>({
            internal: {
                ...s.internal,
                active: !0
            }
        })),
        t && t(i),
        n.getState().events.connected || i.events.connect == null || i.events.connect(r)
    }
    , []),
    we.createElement(CM.Provider, {
        value: n
    }, e)
}
function lP(n, e) {
    const t = Ah.get(n)
      , r = t == null ? void 0 : t.fiber;
    if (r) {
        const i = t == null ? void 0 : t.store.getState();
        i && (i.internal.active = !1),
        Am.updateContainer(null, r, null, ()=>{
            i && setTimeout(()=>{
                try {
                    var s, o, a, l;
                    i.events.disconnect == null || i.events.disconnect(),
                    (s = i.gl) == null || (o = s.renderLists) == null || o.dispose == null || o.dispose(),
                    (a = i.gl) == null || a.forceContextLoss == null || a.forceContextLoss(),
                    (l = i.gl) != null && l.xr && i.xr.disconnect(),
                    fU(i),
                    Ah.delete(n),
                    e && e(n)
                } catch {}
            }
            , 500)
        }
        )
    }
}
function TU(n, e, t) {
    return we.createElement(DU, {
        key: e.uuid,
        children: n,
        container: e,
        state: t
    })
}
function DU({state: n={}, children: e, container: t}) {
    const {events: r, size: i, ...s} = n
      , o = EM()
      , [a] = we.useState(()=>new SM)
      , [l] = we.useState(()=>new it)
      , f = we.useCallback((d,p)=>{
        const m = {
            ...d
        };
        Object.keys(d).forEach(y=>{
            (vU.includes(y) || d[y] !== p[y]) && delete m[y]
        }
        );
        let _;
        if (p && i) {
            const y = p.camera;
            _ = d.viewport.getCurrentViewport(y, new $, i),
            y !== d.camera && iP(y, i)
        }
        return {
            ...m,
            scene: t,
            raycaster: a,
            pointer: l,
            mouse: l,
            previousRoot: o,
            events: {
                ...d.events,
                ...p == null ? void 0 : p.events,
                ...r
            },
            size: {
                ...d.size,
                ...i
            },
            viewport: {
                ...d.viewport,
                ..._
            },
            ...s
        }
    }
    , [n])
      , [h] = we.useState(()=>{
        const d = o.getState();
        return MM((m,_)=>({
            ...d,
            scene: t,
            raycaster: a,
            pointer: l,
            mouse: l,
            previousRoot: o,
            events: {
                ...d.events,
                ...r
            },
            size: {
                ...d.size,
                ...i
            },
            ...s,
            set: m,
            get: _,
            setEvents: y=>m(x=>({
                ...x,
                events: {
                    ...x.events,
                    ...y
                }
            }))
        }))
    }
    );
    return we.useEffect(()=>{
        const d = o.subscribe(p=>h.setState(m=>f(p, m)));
        return ()=>{
            d(),
            h.destroy()
        }
    }
    , []),
    we.useEffect(()=>{
        h.setState(d=>f(o.getState(), d))
    }
    , [f]),
    we.createElement(we.Fragment, null, Am.createPortal(we.createElement(CM.Provider, {
        value: h
    }, e), h, null))
}
Am.injectIntoDevTools({
    bundleType: 0,
    rendererPackageName: "@react-three/fiber",
    version: we.version
});
function Xf() {
    return Xf = Object.assign ? Object.assign.bind() : function(n) {
        for (var e = 1; e < arguments.length; e++) {
            var t = arguments[e];
            for (var r in t)
                Object.prototype.hasOwnProperty.call(t, r) && (n[r] = t[r])
        }
        return n
    }
    ,
    Xf.apply(this, arguments)
}
function Mw(n, e, t) {
    var r, i, s, o, a;
    e == null && (e = 100);
    function l() {
        var h = Date.now() - o;
        h < e && h >= 0 ? r = setTimeout(l, e - h) : (r = null,
        t || (a = n.apply(s, i),
        s = i = null))
    }
    var f = function() {
        s = this,
        i = arguments,
        o = Date.now();
        var h = t && !r;
        return r || (r = setTimeout(l, e)),
        h && (a = n.apply(s, i),
        s = i = null),
        a
    };
    return f.clear = function() {
        r && (clearTimeout(r),
        r = null)
    }
    ,
    f.flush = function() {
        r && (a = n.apply(s, i),
        s = i = null,
        clearTimeout(r),
        r = null)
    }
    ,
    f
}
Mw.debounce = Mw;
var QE = Mw;
function PU(n) {
    let {debounce: e, scroll: t, polyfill: r, offsetSize: i} = n === void 0 ? {
        debounce: 0,
        scroll: !1,
        offsetSize: !1
    } : n;
    const s = r || (typeof window > "u" ? class {
    }
    : window.ResizeObserver);
    if (!s)
        throw new Error("This browser does not support ResizeObserver out of the box. See: https://github.com/react-spring/react-use-measure/#resize-observer-polyfills");
    const [o,a] = we.useState({
        left: 0,
        top: 0,
        width: 0,
        height: 0,
        bottom: 0,
        right: 0,
        x: 0,
        y: 0
    })
      , l = we.useRef({
        element: null,
        scrollContainers: null,
        resizeObserver: null,
        lastBounds: o
    })
      , f = e ? typeof e == "number" ? e : e.scroll : null
      , h = e ? typeof e == "number" ? e : e.resize : null
      , d = we.useRef(!1);
    we.useEffect(()=>(d.current = !0,
    ()=>void (d.current = !1)));
    const [p,m,_] = we.useMemo(()=>{
        const M = ()=>{
            if (!l.current.element)
                return;
            const {left: w, top: T, width: P, height: I, bottom: k, right: R, x: O, y: H} = l.current.element.getBoundingClientRect()
              , W = {
                left: w,
                top: T,
                width: P,
                height: I,
                bottom: k,
                right: R,
                x: O,
                y: H
            };
            l.current.element instanceof HTMLElement && i && (W.height = l.current.element.offsetHeight,
            W.width = l.current.element.offsetWidth),
            Object.freeze(W),
            d.current && !LU(l.current.lastBounds, W) && a(l.current.lastBounds = W)
        }
        ;
        return [M, h ? QE(M, h) : M, f ? QE(M, f) : M]
    }
    , [a, i, f, h]);
    function y() {
        l.current.scrollContainers && (l.current.scrollContainers.forEach(M=>M.removeEventListener("scroll", _, !0)),
        l.current.scrollContainers = null),
        l.current.resizeObserver && (l.current.resizeObserver.disconnect(),
        l.current.resizeObserver = null)
    }
    function x() {
        l.current.element && (l.current.resizeObserver = new s(_),
        l.current.resizeObserver.observe(l.current.element),
        t && l.current.scrollContainers && l.current.scrollContainers.forEach(M=>M.addEventListener("scroll", _, {
            capture: !0,
            passive: !0
        })))
    }
    const S = M=>{
        !M || M === l.current.element || (y(),
        l.current.element = M,
        l.current.scrollContainers = uP(M),
        x())
    }
    ;
    return BU(_, Boolean(t)),
    RU(m),
    we.useEffect(()=>{
        y(),
        x()
    }
    , [t, _, m]),
    we.useEffect(()=>y, []),
    [S, o, p]
}
function RU(n) {
    we.useEffect(()=>{
        const e = n;
        return window.addEventListener("resize", e),
        ()=>void window.removeEventListener("resize", e)
    }
    , [n])
}
function BU(n, e) {
    we.useEffect(()=>{
        if (e) {
            const t = n;
            return window.addEventListener("scroll", t, {
                capture: !0,
                passive: !0
            }),
            ()=>void window.removeEventListener("scroll", t, !0)
        }
    }
    , [n, e])
}
function uP(n) {
    const e = [];
    if (!n || n === document.body)
        return e;
    const {overflow: t, overflowX: r, overflowY: i} = window.getComputedStyle(n);
    return [t, r, i].some(s=>s === "auto" || s === "scroll") && e.push(n),
    [...e, ...uP(n.parentElement)]
}
const IU = ["x", "y", "top", "bottom", "left", "right", "width", "height"]
  , LU = (n,e)=>IU.every(t=>n[t] === e[t]);
var FU = Object.defineProperty
  , kU = Object.defineProperties
  , OU = Object.getOwnPropertyDescriptors
  , ZE = Object.getOwnPropertySymbols
  , NU = Object.prototype.hasOwnProperty
  , zU = Object.prototype.propertyIsEnumerable
  , $E = (n,e,t)=>e in n ? FU(n, e, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: t
}) : n[e] = t
  , eb = (n,e)=>{
    for (var t in e || (e = {}))
        NU.call(e, t) && $E(n, t, e[t]);
    if (ZE)
        for (var t of ZE(e))
            zU.call(e, t) && $E(n, t, e[t]);
    return n
}
  , GU = (n,e)=>kU(n, OU(e));
function cP(n, e, t) {
    if (!n)
        return;
    if (t(n) === !0)
        return n;
    let r = e ? n.return : n.child;
    for (; r; ) {
        const i = cP(r, e, t);
        if (i)
            return i;
        r = e ? null : r.sibling
    }
}
function fP(n) {
    try {
        return Object.defineProperties(n, {
            _currentRenderer: {
                get() {
                    return null
                },
                set() {}
            },
            _currentRenderer2: {
                get() {
                    return null
                },
                set() {}
            }
        })
    } catch {
        return n
    }
}
const bM = fP(we.createContext(null));
class dP extends we.Component {
    render() {
        return we.createElement(bM.Provider, {
            value: this._reactInternals
        }, this.props.children)
    }
}
const {ReactCurrentOwner: UU, ReactCurrentDispatcher: HU} = we.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
function VU() {
    const n = we.useContext(bM);
    if (!n)
        throw new Error("its-fine: useFiber must be called within a <FiberProvider />!");
    const e = we.useId();
    return we.useMemo(()=>{
        var r;
        return (r = UU.current) != null ? r : cP(n, !1, i=>{
            let s = i.memoizedState;
            for (; s; ) {
                if (s.memoizedState === e)
                    return !0;
                s = s.next
            }
        }
        )
    }
    , [n, e])
}
function WU() {
    var n, e;
    const t = VU()
      , [r] = we.useState(()=>new Map);
    r.clear();
    let i = t;
    for (; i; ) {
        const s = (n = i.type) == null ? void 0 : n._context;
        s && s !== bM && !r.has(s) && r.set(s, (e = HU.current) == null ? void 0 : e.readContext(fP(s))),
        i = i.return
    }
    return we.useMemo(()=>Array.from(r.keys()).reduce((s,o)=>a=>we.createElement(s, null, we.createElement(o.Provider, GU(eb({}, a), {
        value: r.get(o)
    }))), s=>we.createElement(dP, eb({}, s))), [r])
}
const Sx = {
    onClick: ["click", !1],
    onContextMenu: ["contextmenu", !1],
    onDoubleClick: ["dblclick", !1],
    onWheel: ["wheel", !0],
    onPointerDown: ["pointerdown", !0],
    onPointerUp: ["pointerup", !0],
    onPointerLeave: ["pointerleave", !0],
    onPointerMove: ["pointermove", !0],
    onPointerCancel: ["pointercancel", !0],
    onLostPointerCapture: ["lostpointercapture", !0]
};
function XU(n) {
    const {handlePointer: e} = mU(n);
    return {
        priority: 1,
        enabled: !0,
        compute(t, r, i) {
            r.pointer.set(t.offsetX / r.size.width * 2 - 1, -(t.offsetY / r.size.height) * 2 + 1),
            r.raycaster.setFromCamera(r.pointer, r.camera)
        },
        connected: void 0,
        handlers: Object.keys(Sx).reduce((t,r)=>({
            ...t,
            [r]: e(r)
        }), {}),
        connect: t=>{
            var r;
            const {set: i, events: s} = n.getState();
            s.disconnect == null || s.disconnect(),
            i(o=>({
                events: {
                    ...o.events,
                    connected: t
                }
            })),
            Object.entries((r = s.handlers) != null ? r : []).forEach(([o,a])=>{
                const [l,f] = Sx[o];
                t.addEventListener(l, a, {
                    passive: f
                })
            }
            )
        }
        ,
        disconnect: ()=>{
            const {set: t, events: r} = n.getState();
            if (r.connected) {
                var i;
                Object.entries((i = r.handlers) != null ? i : []).forEach(([s,o])=>{
                    if (r && r.connected instanceof HTMLElement) {
                        const [a] = Sx[s];
                        r.connected.removeEventListener(a, o)
                    }
                }
                ),
                t(s=>({
                    events: {
                        ...s.events,
                        connected: void 0
                    }
                }))
            }
        }
    }
}
const JU = we.forwardRef(function({children: e, fallback: t, resize: r, style: i, gl: s, events: o=XU, eventSource: a, eventPrefix: l, shadows: f, linear: h, flat: d, legacy: p, orthographic: m, frameloop: _, dpr: y, performance: x, raycaster: S, camera: M, onPointerMissed: w, onCreated: T, ...P}, I) {
    we.useMemo(()=>AM(Xv), []);
    const k = WU()
      , [R,O] = PU({
        scroll: !0,
        debounce: {
            scroll: 50,
            resize: 0
        },
        ...r
    })
      , H = we.useRef(null)
      , W = we.useRef(null)
      , [te,ne] = we.useState(null);
    we.useImperativeHandle(I, ()=>H.current);
    const re = $3(w)
      , [pe,ce] = we.useState(!1)
      , [xe,G] = we.useState(!1);
    if (pe)
        throw pe;
    if (xe)
        throw xe;
    const z = we.useRef(null);
    O.width > 0 && O.height > 0 && te && (z.current || (z.current = EU(te)),
    z.current.configure({
        gl: s,
        events: o,
        shadows: f,
        linear: h,
        flat: d,
        legacy: p,
        orthographic: m,
        frameloop: _,
        dpr: y,
        performance: x,
        raycaster: S,
        camera: M,
        size: O,
        onPointerMissed: (...fe)=>re.current == null ? void 0 : re.current(...fe),
        onCreated: fe=>{
            fe.events.connect == null || fe.events.connect(a ? aU(a) ? a.current : a : W.current),
            l && fe.setEvents({
                compute: (oe,Ae)=>{
                    const Ue = oe[l + "X"]
                      , je = oe[l + "Y"];
                    Ae.pointer.set(Ue / Ae.size.width * 2 - 1, -(je / Ae.size.height) * 2 + 1),
                    Ae.raycaster.setFromCamera(Ae.pointer, Ae.camera)
                }
            }),
            T == null || T(fe)
        }
    }),
    z.current.render(we.createElement(k, null, we.createElement(eP, {
        set: G
    }, we.createElement(we.Suspense, {
        fallback: we.createElement(lU, {
            set: ce
        })
    }, e))))),
    Zm(()=>{
        ne(H.current)
    }
    , []),
    we.useEffect(()=>{
        if (te)
            return ()=>lP(te)
    }
    , [te]);
    const U = a ? "none" : "auto";
    return we.createElement("div", Xf({
        ref: W,
        style: {
            position: "relative",
            width: "100%",
            height: "100%",
            overflow: "hidden",
            pointerEvents: U,
            ...i
        }
    }, P), we.createElement("div", {
        ref: R,
        style: {
            width: "100%",
            height: "100%"
        }
    }, we.createElement("canvas", {
        ref: H,
        style: {
            display: "block"
        }
    }, t)))
})
  , hP = we.forwardRef(function(e, t) {
    return we.createElement(dP, null, we.createElement(JU, Xf({}, e, {
        ref: t
    })))
});
let hp = 0;
const pP = MM(n=>(jd.onStart = (e,t,r)=>{
    n({
        active: !0,
        item: e,
        loaded: t,
        total: r,
        progress: (t - hp) / (r - hp) * 100
    })
}
,
jd.onLoad = ()=>{
    n({
        active: !1
    })
}
,
jd.onError = e=>n(t=>({
    errors: [...t.errors, e]
})),
jd.onProgress = (e,t,r)=>{
    t === r && (hp = r),
    n({
        active: !0,
        item: e,
        loaded: t,
        total: r,
        progress: (t - hp) / (r - hp) * 100 || 100
    })
}
,
{
    errors: [],
    active: !1,
    progress: 0,
    item: "",
    loaded: 0,
    total: 0
}));
function jU(n) {
    return function(e) {
        n.forEach(function(t) {
            typeof t == "function" ? t(e) : t != null && (t.current = e)
        })
    }
}
function Cm(n) {
    return Cm = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
        return typeof e
    }
    : function(e) {
        return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
    }
    ,
    Cm(n)
}
function YU(n, e) {
    if (Cm(n) !== "object" || n === null)
        return n;
    var t = n[Symbol.toPrimitive];
    if (t !== void 0) {
        var r = t.call(n, e || "default");
        if (Cm(r) !== "object")
            return r;
        throw new TypeError("@@toPrimitive must return a primitive value.")
    }
    return (e === "string" ? String : Number)(n)
}
function KU(n) {
    var e = YU(n, "string");
    return Cm(e) === "symbol" ? e : String(e)
}
function In(n, e, t) {
    return e = KU(e),
    e in n ? Object.defineProperty(n, e, {
        value: t,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : n[e] = t,
    n
}
const qU = n=>n && n.isCubeTexture;
class QU extends vs {
    constructor(e, t) {
        var r, i;
        const s = qU(e)
          , a = ((r = s ? (i = e.image[0]) === null || i === void 0 ? void 0 : i.width : e.image.width) != null ? r : 1024) / 4
          , l = Math.floor(Math.log2(a))
          , f = Math.pow(2, l)
          , h = 3 * Math.max(f, 16 * 7)
          , d = 4 * f
          , p = [s ? "#define ENVMAP_TYPE_CUBE" : "", `#define CUBEUV_TEXEL_WIDTH ${1 / h}`, `#define CUBEUV_TEXEL_HEIGHT ${1 / d}`, `#define CUBEUV_MAX_MIP ${l}.0`]
          , m = `
        varying vec3 vWorldPosition;
        void main() 
        {
            vec4 worldPosition = ( modelMatrix * vec4( position, 1.0 ) );
            vWorldPosition = worldPosition.xyz;
            
            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
        }
        `
          , _ = p.join(`
`) + `
        #define ENVMAP_TYPE_CUBE_UV
        varying vec3 vWorldPosition;
        uniform float radius;
        uniform float height;
        uniform float angle;
        #ifdef ENVMAP_TYPE_CUBE
            uniform samplerCube map;
        #else
            uniform sampler2D map;
        #endif
        // From: https://www.shadertoy.com/view/4tsBD7
        float diskIntersectWithBackFaceCulling( vec3 ro, vec3 rd, vec3 c, vec3 n, float r ) 
        {
            float d = dot ( rd, n );
            
            if( d > 0.0 ) { return 1e6; }
            
            vec3  o = ro - c;
            float t = - dot( n, o ) / d;
            vec3  q = o + rd * t;
            
            return ( dot( q, q ) < r * r ) ? t : 1e6;
        }
        // From: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm
        float sphereIntersect( vec3 ro, vec3 rd, vec3 ce, float ra ) 
        {
            vec3 oc = ro - ce;
            float b = dot( oc, rd );
            float c = dot( oc, oc ) - ra * ra;
            float h = b * b - c;
            
            if( h < 0.0 ) { return -1.0; }
            
            h = sqrt( h );
            
            return - b + h;
        }
        vec3 project() 
        {
            vec3 p = normalize( vWorldPosition );
            vec3 camPos = cameraPosition;
            camPos.y -= height;
            float intersection = sphereIntersect( camPos, p, vec3( 0.0 ), radius );
            if( intersection > 0.0 ) {
                
                vec3 h = vec3( 0.0, - height, 0.0 );
                float intersection2 = diskIntersectWithBackFaceCulling( camPos, p, h, vec3( 0.0, 1.0, 0.0 ), radius );
                p = ( camPos + min( intersection, intersection2 ) * p ) / radius;
            } else {
                p = vec3( 0.0, 1.0, 0.0 );
            }
            return p;
        }
        #include <common>
        #include <cube_uv_reflection_fragment>
        void main() 
        {
            vec3 projectedWorldPosition = project();
            
            #ifdef ENVMAP_TYPE_CUBE
                vec3 outcolor = textureCube( map, projectedWorldPosition ).rgb;
            #else
                vec3 direction = normalize( projectedWorldPosition );
                vec2 uv = equirectUv( direction );
                vec3 outcolor = texture2D( map, uv ).rgb;
            #endif
            gl_FragColor = vec4( outcolor, 1.0 );
            #include <tonemapping_fragment>
            #include <encodings_fragment>
        }
        `
          , y = {
            map: {
                value: e
            },
            height: {
                value: (t == null ? void 0 : t.height) || 15
            },
            radius: {
                value: (t == null ? void 0 : t.radius) || 100
            }
        }
          , x = new Ih(1,16)
          , S = new el({
            uniforms: y,
            fragmentShader: _,
            vertexShader: m,
            side: Sl
        });
        super(x, S)
    }
    set radius(e) {
        this.material.uniforms.radius.value = e
    }
    get radius() {
        return this.material.uniforms.radius.value
    }
    set height(e) {
        this.material.uniforms.height.value = e
    }
    get height() {
        return this.material.uniforms.height.value
    }
}
const tb = (n,e)=>(n % e + e) % e;
let ZU = class extends ql {
    constructor(e, t) {
        super(),
        In(this, "object", void 0),
        In(this, "domElement", void 0),
        In(this, "enabled", !0),
        In(this, "target", new $),
        In(this, "minDistance", 0),
        In(this, "maxDistance", 1 / 0),
        In(this, "minZoom", 0),
        In(this, "maxZoom", 1 / 0),
        In(this, "minPolarAngle", 0),
        In(this, "maxPolarAngle", Math.PI),
        In(this, "minAzimuthAngle", -1 / 0),
        In(this, "maxAzimuthAngle", 1 / 0),
        In(this, "enableDamping", !1),
        In(this, "dampingFactor", .05),
        In(this, "enableZoom", !0),
        In(this, "zoomSpeed", 1),
        In(this, "enableRotate", !0),
        In(this, "rotateSpeed", 1),
        In(this, "enablePan", !0),
        In(this, "panSpeed", 1),
        In(this, "screenSpacePanning", !0),
        In(this, "keyPanSpeed", 7),
        In(this, "autoRotate", !1),
        In(this, "autoRotateSpeed", 2),
        In(this, "reverseOrbit", !1),
        In(this, "keys", {
            LEFT: "ArrowLeft",
            UP: "ArrowUp",
            RIGHT: "ArrowRight",
            BOTTOM: "ArrowDown"
        }),
        In(this, "mouseButtons", {
            LEFT: lf.ROTATE,
            MIDDLE: lf.DOLLY,
            RIGHT: lf.PAN
        }),
        In(this, "touches", {
            ONE: uf.ROTATE,
            TWO: uf.DOLLY_PAN
        }),
        In(this, "target0", void 0),
        In(this, "position0", void 0),
        In(this, "zoom0", void 0),
        In(this, "_domElementKeyEvents", null),
        In(this, "getPolarAngle", void 0),
        In(this, "getAzimuthalAngle", void 0),
        In(this, "setPolarAngle", void 0),
        In(this, "setAzimuthalAngle", void 0),
        In(this, "getDistance", void 0),
        In(this, "listenToKeyEvents", void 0),
        In(this, "saveState", void 0),
        In(this, "reset", void 0),
        In(this, "update", void 0),
        In(this, "connect", void 0),
        In(this, "dispose", void 0),
        this.object = e,
        this.domElement = t,
        this.target0 = this.target.clone(),
        this.position0 = this.object.position.clone(),
        this.zoom0 = this.object instanceof gi ? this.object.zoom : 1,
        this.getPolarAngle = ()=>h.phi,
        this.getAzimuthalAngle = ()=>h.theta,
        this.setPolarAngle = le=>{
            let Le = tb(le, 2 * Math.PI)
              , rt = h.phi;
            rt < 0 && (rt += 2 * Math.PI),
            Le < 0 && (Le += 2 * Math.PI);
            let st = Math.abs(Le - rt);
            2 * Math.PI - st < st && (Le < rt ? Le += 2 * Math.PI : rt += 2 * Math.PI),
            d.phi = Le - rt,
            r.update()
        }
        ,
        this.setAzimuthalAngle = le=>{
            let Le = tb(le, 2 * Math.PI)
              , rt = h.theta;
            rt < 0 && (rt += 2 * Math.PI),
            Le < 0 && (Le += 2 * Math.PI);
            let st = Math.abs(Le - rt);
            2 * Math.PI - st < st && (Le < rt ? Le += 2 * Math.PI : rt += 2 * Math.PI),
            d.theta = Le - rt,
            r.update()
        }
        ,
        this.getDistance = ()=>r.object.position.distanceTo(r.target),
        this.listenToKeyEvents = le=>{
            le.addEventListener("keydown", ye),
            this._domElementKeyEvents = le
        }
        ,
        this.saveState = ()=>{
            r.target0.copy(r.target),
            r.position0.copy(r.object.position),
            r.zoom0 = r.object instanceof gi ? r.object.zoom : 1
        }
        ,
        this.reset = ()=>{
            r.target.copy(r.target0),
            r.object.position.copy(r.position0),
            r.object instanceof gi && (r.object.zoom = r.zoom0,
            r.object.updateProjectionMatrix()),
            r.dispatchEvent(i),
            r.update(),
            l = a.NONE
        }
        ,
        this.update = (()=>{
            const le = new $
              , Le = new Ws().setFromUnitVectors(e.up, new $(0,1,0))
              , rt = Le.clone().invert()
              , st = new $
              , Ut = new Ws
              , Mt = 2 * Math.PI;
            return function() {
                const ae = r.object.position;
                le.copy(ae).sub(r.target),
                le.applyQuaternion(Le),
                h.setFromVector3(le),
                r.autoRotate && l === a.NONE && te(H()),
                r.enableDamping ? (h.theta += d.theta * r.dampingFactor,
                h.phi += d.phi * r.dampingFactor) : (h.theta += d.theta,
                h.phi += d.phi);
                let De = r.minAzimuthAngle
                  , Je = r.maxAzimuthAngle;
                return isFinite(De) && isFinite(Je) && (De < -Math.PI ? De += Mt : De > Math.PI && (De -= Mt),
                Je < -Math.PI ? Je += Mt : Je > Math.PI && (Je -= Mt),
                De <= Je ? h.theta = Math.max(De, Math.min(Je, h.theta)) : h.theta = h.theta > (De + Je) / 2 ? Math.max(De, h.theta) : Math.min(Je, h.theta)),
                h.phi = Math.max(r.minPolarAngle, Math.min(r.maxPolarAngle, h.phi)),
                h.makeSafe(),
                h.radius *= p,
                h.radius = Math.max(r.minDistance, Math.min(r.maxDistance, h.radius)),
                r.enableDamping === !0 ? r.target.addScaledVector(m, r.dampingFactor) : r.target.add(m),
                le.setFromSpherical(h),
                le.applyQuaternion(rt),
                ae.copy(r.target).add(le),
                r.object.lookAt(r.target),
                r.enableDamping === !0 ? (d.theta *= 1 - r.dampingFactor,
                d.phi *= 1 - r.dampingFactor,
                m.multiplyScalar(1 - r.dampingFactor)) : (d.set(0, 0, 0),
                m.set(0, 0, 0)),
                p = 1,
                _ || st.distanceToSquared(r.object.position) > f || 8 * (1 - Ut.dot(r.object.quaternion)) > f ? (r.dispatchEvent(i),
                st.copy(r.object.position),
                Ut.copy(r.object.quaternion),
                _ = !1,
                !0) : !1
            }
        }
        )(),
        this.connect = le=>{
            le === document && console.error('THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.'),
            r.domElement = le,
            r.domElement.style.touchAction = "none",
            r.domElement.addEventListener("contextmenu", Ke),
            r.domElement.addEventListener("pointerdown", ee),
            r.domElement.addEventListener("pointercancel", ft),
            r.domElement.addEventListener("wheel", V)
        }
        ,
        this.dispose = ()=>{
            var le, Le, rt, st, Ut, Mt;
            (le = r.domElement) === null || le === void 0 || le.removeEventListener("contextmenu", Ke),
            (Le = r.domElement) === null || Le === void 0 || Le.removeEventListener("pointerdown", ee),
            (rt = r.domElement) === null || rt === void 0 || rt.removeEventListener("pointercancel", ft),
            (st = r.domElement) === null || st === void 0 || st.removeEventListener("wheel", V),
            (Ut = r.domElement) === null || Ut === void 0 || Ut.ownerDocument.removeEventListener("pointermove", et),
            (Mt = r.domElement) === null || Mt === void 0 || Mt.ownerDocument.removeEventListener("pointerup", Ze),
            r._domElementKeyEvents !== null && r._domElementKeyEvents.removeEventListener("keydown", ye)
        }
        ;
        const r = this
          , i = {
            type: "change"
        }
          , s = {
            type: "start"
        }
          , o = {
            type: "end"
        }
          , a = {
            NONE: -1,
            ROTATE: 0,
            DOLLY: 1,
            PAN: 2,
            TOUCH_ROTATE: 3,
            TOUCH_PAN: 4,
            TOUCH_DOLLY_PAN: 5,
            TOUCH_DOLLY_ROTATE: 6
        };
        let l = a.NONE;
        const f = 1e-6
          , h = new _w
          , d = new _w;
        let p = 1;
        const m = new $;
        let _ = !1;
        const y = new it
          , x = new it
          , S = new it
          , M = new it
          , w = new it
          , T = new it
          , P = new it
          , I = new it
          , k = new it
          , R = []
          , O = {};
        function H() {
            return 2 * Math.PI / 60 / 60 * r.autoRotateSpeed
        }
        function W() {
            return Math.pow(.95, r.zoomSpeed)
        }
        function te(le) {
            r.reverseOrbit ? d.theta += le : d.theta -= le
        }
        function ne(le) {
            r.reverseOrbit ? d.phi += le : d.phi -= le
        }
        const re = (()=>{
            const le = new $;
            return function(rt, st) {
                le.setFromMatrixColumn(st, 0),
                le.multiplyScalar(-rt),
                m.add(le)
            }
        }
        )()
          , pe = (()=>{
            const le = new $;
            return function(rt, st) {
                r.screenSpacePanning === !0 ? le.setFromMatrixColumn(st, 1) : (le.setFromMatrixColumn(st, 0),
                le.crossVectors(r.object.up, le)),
                le.multiplyScalar(rt),
                m.add(le)
            }
        }
        )()
          , ce = (()=>{
            const le = new $;
            return function(rt, st) {
                const Ut = r.domElement;
                if (Ut && r.object instanceof gi && r.object.isPerspectiveCamera) {
                    const Mt = r.object.position;
                    le.copy(Mt).sub(r.target);
                    let wn = le.length();
                    wn *= Math.tan(r.object.fov / 2 * Math.PI / 180),
                    re(2 * rt * wn / Ut.clientHeight, r.object.matrix),
                    pe(2 * st * wn / Ut.clientHeight, r.object.matrix)
                } else
                    Ut && r.object instanceof Mu && r.object.isOrthographicCamera ? (re(rt * (r.object.right - r.object.left) / r.object.zoom / Ut.clientWidth, r.object.matrix),
                    pe(st * (r.object.top - r.object.bottom) / r.object.zoom / Ut.clientHeight, r.object.matrix)) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."),
                    r.enablePan = !1)
            }
        }
        )();
        function xe(le) {
            r.object instanceof gi && r.object.isPerspectiveCamera ? p /= le : r.object instanceof Mu && r.object.isOrthographicCamera ? (r.object.zoom = Math.max(r.minZoom, Math.min(r.maxZoom, r.object.zoom * le)),
            r.object.updateProjectionMatrix(),
            _ = !0) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),
            r.enableZoom = !1)
        }
        function G(le) {
            r.object instanceof gi && r.object.isPerspectiveCamera ? p *= le : r.object instanceof Mu && r.object.isOrthographicCamera ? (r.object.zoom = Math.max(r.minZoom, Math.min(r.maxZoom, r.object.zoom / le)),
            r.object.updateProjectionMatrix(),
            _ = !0) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),
            r.enableZoom = !1)
        }
        function z(le) {
            y.set(le.clientX, le.clientY)
        }
        function U(le) {
            P.set(le.clientX, le.clientY)
        }
        function fe(le) {
            M.set(le.clientX, le.clientY)
        }
        function oe(le) {
            x.set(le.clientX, le.clientY),
            S.subVectors(x, y).multiplyScalar(r.rotateSpeed);
            const Le = r.domElement;
            Le && (te(2 * Math.PI * S.x / Le.clientHeight),
            ne(2 * Math.PI * S.y / Le.clientHeight)),
            y.copy(x),
            r.update()
        }
        function Ae(le) {
            I.set(le.clientX, le.clientY),
            k.subVectors(I, P),
            k.y > 0 ? xe(W()) : k.y < 0 && G(W()),
            P.copy(I),
            r.update()
        }
        function Ue(le) {
            w.set(le.clientX, le.clientY),
            T.subVectors(w, M).multiplyScalar(r.panSpeed),
            ce(T.x, T.y),
            M.copy(w),
            r.update()
        }
        function je(le) {
            le.deltaY < 0 ? G(W()) : le.deltaY > 0 && xe(W()),
            r.update()
        }
        function de(le) {
            let Le = !1;
            switch (le.code) {
            case r.keys.UP:
                ce(0, r.keyPanSpeed),
                Le = !0;
                break;
            case r.keys.BOTTOM:
                ce(0, -r.keyPanSpeed),
                Le = !0;
                break;
            case r.keys.LEFT:
                ce(r.keyPanSpeed, 0),
                Le = !0;
                break;
            case r.keys.RIGHT:
                ce(-r.keyPanSpeed, 0),
                Le = !0;
                break
            }
            Le && (le.preventDefault(),
            r.update())
        }
        function qe() {
            if (R.length == 1)
                y.set(R[0].pageX, R[0].pageY);
            else {
                const le = .5 * (R[0].pageX + R[1].pageX)
                  , Le = .5 * (R[0].pageY + R[1].pageY);
                y.set(le, Le)
            }
        }
        function Ne() {
            if (R.length == 1)
                M.set(R[0].pageX, R[0].pageY);
            else {
                const le = .5 * (R[0].pageX + R[1].pageX)
                  , Le = .5 * (R[0].pageY + R[1].pageY);
                M.set(le, Le)
            }
        }
        function Tt() {
            const le = R[0].pageX - R[1].pageX
              , Le = R[0].pageY - R[1].pageY
              , rt = Math.sqrt(le * le + Le * Le);
            P.set(0, rt)
        }
        function He() {
            r.enableZoom && Tt(),
            r.enablePan && Ne()
        }
        function gt() {
            r.enableZoom && Tt(),
            r.enableRotate && qe()
        }
        function be(le) {
            if (R.length == 1)
                x.set(le.pageX, le.pageY);
            else {
                const rt = Rt(le)
                  , st = .5 * (le.pageX + rt.x)
                  , Ut = .5 * (le.pageY + rt.y);
                x.set(st, Ut)
            }
            S.subVectors(x, y).multiplyScalar(r.rotateSpeed);
            const Le = r.domElement;
            Le && (te(2 * Math.PI * S.x / Le.clientHeight),
            ne(2 * Math.PI * S.y / Le.clientHeight)),
            y.copy(x)
        }
        function Ee(le) {
            if (R.length == 1)
                w.set(le.pageX, le.pageY);
            else {
                const Le = Rt(le)
                  , rt = .5 * (le.pageX + Le.x)
                  , st = .5 * (le.pageY + Le.y);
                w.set(rt, st)
            }
            T.subVectors(w, M).multiplyScalar(r.panSpeed),
            ce(T.x, T.y),
            M.copy(w)
        }
        function at(le) {
            const Le = Rt(le)
              , rt = le.pageX - Le.x
              , st = le.pageY - Le.y
              , Ut = Math.sqrt(rt * rt + st * st);
            I.set(0, Ut),
            k.set(0, Math.pow(I.y / P.y, r.zoomSpeed)),
            xe(k.y),
            P.copy(I)
        }
        function _t(le) {
            r.enableZoom && at(le),
            r.enablePan && Ee(le)
        }
        function Ce(le) {
            r.enableZoom && at(le),
            r.enableRotate && be(le)
        }
        function ee(le) {
            if (r.enabled !== !1) {
                if (R.length === 0) {
                    var Le, rt;
                    (Le = r.domElement) === null || Le === void 0 || Le.ownerDocument.addEventListener("pointermove", et),
                    (rt = r.domElement) === null || rt === void 0 || rt.ownerDocument.addEventListener("pointerup", Ze)
                }
                dt(le),
                le.pointerType === "touch" ? tt(le) : Pt(le)
            }
        }
        function et(le) {
            r.enabled !== !1 && (le.pointerType === "touch" ? Ve(le) : Z(le))
        }
        function Ze(le) {
            if (ct(le),
            R.length === 0) {
                var Le, rt, st;
                (Le = r.domElement) === null || Le === void 0 || Le.releasePointerCapture(le.pointerId),
                (rt = r.domElement) === null || rt === void 0 || rt.ownerDocument.removeEventListener("pointermove", et),
                (st = r.domElement) === null || st === void 0 || st.ownerDocument.removeEventListener("pointerup", Ze)
            }
            r.dispatchEvent(o),
            l = a.NONE
        }
        function ft(le) {
            ct(le)
        }
        function Pt(le) {
            let Le;
            switch (le.button) {
            case 0:
                Le = r.mouseButtons.LEFT;
                break;
            case 1:
                Le = r.mouseButtons.MIDDLE;
                break;
            case 2:
                Le = r.mouseButtons.RIGHT;
                break;
            default:
                Le = -1
            }
            switch (Le) {
            case lf.DOLLY:
                if (r.enableZoom === !1)
                    return;
                U(le),
                l = a.DOLLY;
                break;
            case lf.ROTATE:
                if (le.ctrlKey || le.metaKey || le.shiftKey) {
                    if (r.enablePan === !1)
                        return;
                    fe(le),
                    l = a.PAN
                } else {
                    if (r.enableRotate === !1)
                        return;
                    z(le),
                    l = a.ROTATE
                }
                break;
            case lf.PAN:
                if (le.ctrlKey || le.metaKey || le.shiftKey) {
                    if (r.enableRotate === !1)
                        return;
                    z(le),
                    l = a.ROTATE
                } else {
                    if (r.enablePan === !1)
                        return;
                    fe(le),
                    l = a.PAN
                }
                break;
            default:
                l = a.NONE
            }
            l !== a.NONE && r.dispatchEvent(s)
        }
        function Z(le) {
            if (r.enabled !== !1)
                switch (l) {
                case a.ROTATE:
                    if (r.enableRotate === !1)
                        return;
                    oe(le);
                    break;
                case a.DOLLY:
                    if (r.enableZoom === !1)
                        return;
                    Ae(le);
                    break;
                case a.PAN:
                    if (r.enablePan === !1)
                        return;
                    Ue(le);
                    break
                }
        }
        function V(le) {
            r.enabled === !1 || r.enableZoom === !1 || l !== a.NONE && l !== a.ROTATE || (le.preventDefault(),
            r.dispatchEvent(s),
            je(le),
            r.dispatchEvent(o))
        }
        function ye(le) {
            r.enabled === !1 || r.enablePan === !1 || de(le)
        }
        function tt(le) {
            switch (Fe(le),
            R.length) {
            case 1:
                switch (r.touches.ONE) {
                case uf.ROTATE:
                    if (r.enableRotate === !1)
                        return;
                    qe(),
                    l = a.TOUCH_ROTATE;
                    break;
                case uf.PAN:
                    if (r.enablePan === !1)
                        return;
                    Ne(),
                    l = a.TOUCH_PAN;
                    break;
                default:
                    l = a.NONE
                }
                break;
            case 2:
                switch (r.touches.TWO) {
                case uf.DOLLY_PAN:
                    if (r.enableZoom === !1 && r.enablePan === !1)
                        return;
                    He(),
                    l = a.TOUCH_DOLLY_PAN;
                    break;
                case uf.DOLLY_ROTATE:
                    if (r.enableZoom === !1 && r.enableRotate === !1)
                        return;
                    gt(),
                    l = a.TOUCH_DOLLY_ROTATE;
                    break;
                default:
                    l = a.NONE
                }
                break;
            default:
                l = a.NONE
            }
            l !== a.NONE && r.dispatchEvent(s)
        }
        function Ve(le) {
            switch (Fe(le),
            l) {
            case a.TOUCH_ROTATE:
                if (r.enableRotate === !1)
                    return;
                be(le),
                r.update();
                break;
            case a.TOUCH_PAN:
                if (r.enablePan === !1)
                    return;
                Ee(le),
                r.update();
                break;
            case a.TOUCH_DOLLY_PAN:
                if (r.enableZoom === !1 && r.enablePan === !1)
                    return;
                _t(le),
                r.update();
                break;
            case a.TOUCH_DOLLY_ROTATE:
                if (r.enableZoom === !1 && r.enableRotate === !1)
                    return;
                Ce(le),
                r.update();
                break;
            default:
                l = a.NONE
            }
        }
        function Ke(le) {
            r.enabled !== !1 && le.preventDefault()
        }
        function dt(le) {
            R.push(le)
        }
        function ct(le) {
            delete O[le.pointerId];
            for (let Le = 0; Le < R.length; Le++)
                if (R[Le].pointerId == le.pointerId) {
                    R.splice(Le, 1);
                    return
                }
        }
        function Fe(le) {
            let Le = O[le.pointerId];
            Le === void 0 && (Le = new it,
            O[le.pointerId] = Le),
            Le.set(le.pageX, le.pageY)
        }
        function Rt(le) {
            const Le = le.pointerId === R[0].pointerId ? R[1] : R[0];
            return O[Le.pointerId]
        }
        t !== void 0 && this.connect(t),
        this.update()
    }
}
;
class TM extends Bo {
    constructor(e) {
        super(e),
        this.dracoLoader = null,
        this.ktx2Loader = null,
        this.meshoptDecoder = null,
        this.pluginCallbacks = [],
        this.register(function(t) {
            return new r5(t)
        }),
        this.register(function(t) {
            return new c5(t)
        }),
        this.register(function(t) {
            return new f5(t)
        }),
        this.register(function(t) {
            return new s5(t)
        }),
        this.register(function(t) {
            return new o5(t)
        }),
        this.register(function(t) {
            return new a5(t)
        }),
        this.register(function(t) {
            return new l5(t)
        }),
        this.register(function(t) {
            return new n5(t)
        }),
        this.register(function(t) {
            return new u5(t)
        }),
        this.register(function(t) {
            return new i5(t)
        }),
        this.register(function(t) {
            return new e5(t)
        }),
        this.register(function(t) {
            return new d5(t)
        })
    }
    load(e, t, r, i) {
        const s = this;
        let o;
        this.resourcePath !== "" ? o = this.resourcePath : this.path !== "" ? o = this.path : o = jl.extractUrlBase(e),
        this.manager.itemStart(e);
        const a = function(f) {
            i ? i(f) : console.error(f),
            s.manager.itemError(e),
            s.manager.itemEnd(e)
        }
          , l = new Aa(this.manager);
        l.setPath(this.path),
        l.setResponseType("arraybuffer"),
        l.setRequestHeader(this.requestHeader),
        l.setWithCredentials(this.withCredentials),
        l.load(e, function(f) {
            try {
                s.parse(f, o, function(h) {
                    t(h),
                    s.manager.itemEnd(e)
                }, a)
            } catch (h) {
                a(h)
            }
        }, r, a)
    }
    setDRACOLoader(e) {
        return this.dracoLoader = e,
        this
    }
    setDDSLoader() {
        throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".')
    }
    setKTX2Loader(e) {
        return this.ktx2Loader = e,
        this
    }
    setMeshoptDecoder(e) {
        return this.meshoptDecoder = e,
        this
    }
    register(e) {
        return this.pluginCallbacks.indexOf(e) === -1 && this.pluginCallbacks.push(e),
        this
    }
    unregister(e) {
        return this.pluginCallbacks.indexOf(e) !== -1 && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1),
        this
    }
    parse(e, t, r, i) {
        let s;
        const o = {}
          , a = {};
        if (typeof e == "string")
            s = e;
        else if (jl.decodeText(new Uint8Array(e,0,4)) === mP) {
            try {
                o[tr.KHR_BINARY_GLTF] = new h5(e)
            } catch (d) {
                i && i(d);
                return
            }
            s = o[tr.KHR_BINARY_GLTF].content
        } else
            s = jl.decodeText(new Uint8Array(e));
        const l = JSON.parse(s);
        if (l.asset === void 0 || l.asset.version[0] < 2) {
            i && i(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));
            return
        }
        const f = new E5(l,{
            path: t || this.resourcePath || "",
            crossOrigin: this.crossOrigin,
            requestHeader: this.requestHeader,
            manager: this.manager,
            ktx2Loader: this.ktx2Loader,
            meshoptDecoder: this.meshoptDecoder
        });
        f.fileLoader.setRequestHeader(this.requestHeader);
        for (let h = 0; h < this.pluginCallbacks.length; h++) {
            const d = this.pluginCallbacks[h](f);
            a[d.name] = d,
            o[d.name] = !0
        }
        if (l.extensionsUsed)
            for (let h = 0; h < l.extensionsUsed.length; ++h) {
                const d = l.extensionsUsed[h]
                  , p = l.extensionsRequired || [];
                switch (d) {
                case tr.KHR_MATERIALS_UNLIT:
                    o[d] = new t5;
                    break;
                case tr.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
                    o[d] = new g5;
                    break;
                case tr.KHR_DRACO_MESH_COMPRESSION:
                    o[d] = new p5(l,this.dracoLoader);
                    break;
                case tr.KHR_TEXTURE_TRANSFORM:
                    o[d] = new m5;
                    break;
                case tr.KHR_MESH_QUANTIZATION:
                    o[d] = new v5;
                    break;
                default:
                    p.indexOf(d) >= 0 && a[d] === void 0 && console.warn('THREE.GLTFLoader: Unknown extension "' + d + '".')
                }
            }
        f.setExtensions(o),
        f.setPlugins(a),
        f.parse(r, i)
    }
    parseAsync(e, t) {
        const r = this;
        return new Promise(function(i, s) {
            r.parse(e, t, i, s)
        }
        )
    }
}
function $U() {
    let n = {};
    return {
        get: function(e) {
            return n[e]
        },
        add: function(e, t) {
            n[e] = t
        },
        remove: function(e) {
            delete n[e]
        },
        removeAll: function() {
            n = {}
        }
    }
}
const tr = {
    KHR_BINARY_GLTF: "KHR_binary_glTF",
    KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
    KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
    KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
    KHR_MATERIALS_IOR: "KHR_materials_ior",
    KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: "KHR_materials_pbrSpecularGlossiness",
    KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
    KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
    KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
    KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
    KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
    KHR_MATERIALS_VOLUME: "KHR_materials_volume",
    KHR_TEXTURE_BASISU: "KHR_texture_basisu",
    KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
    KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
    KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
    EXT_TEXTURE_WEBP: "EXT_texture_webp",
    EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression"
};
class e5 {
    constructor(e) {
        this.parser = e,
        this.name = tr.KHR_LIGHTS_PUNCTUAL,
        this.cache = {
            refs: {},
            uses: {}
        }
    }
    _markDefs() {
        const e = this.parser
          , t = this.parser.json.nodes || [];
        for (let r = 0, i = t.length; r < i; r++) {
            const s = t[r];
            s.extensions && s.extensions[this.name] && s.extensions[this.name].light !== void 0 && e._addNodeRef(this.cache, s.extensions[this.name].light)
        }
    }
    _loadLight(e) {
        const t = this.parser
          , r = "light:" + e;
        let i = t.cache.get(r);
        if (i)
            return i;
        const s = t.json
          , l = ((s.extensions && s.extensions[this.name] || {}).lights || [])[e];
        let f;
        const h = new It(16777215);
        l.color !== void 0 && h.fromArray(l.color);
        const d = l.range !== void 0 ? l.range : 0;
        switch (l.type) {
        case "directional":
            f = new gM(h),
            f.target.position.set(0, 0, -1),
            f.add(f.target);
            break;
        case "point":
            f = new mM(h),
            f.distance = d;
            break;
        case "spot":
            f = new pM(h),
            f.distance = d,
            l.spot = l.spot || {},
            l.spot.innerConeAngle = l.spot.innerConeAngle !== void 0 ? l.spot.innerConeAngle : 0,
            l.spot.outerConeAngle = l.spot.outerConeAngle !== void 0 ? l.spot.outerConeAngle : Math.PI / 4,
            f.angle = l.spot.outerConeAngle,
            f.penumbra = 1 - l.spot.innerConeAngle / l.spot.outerConeAngle,
            f.target.position.set(0, 0, -1),
            f.add(f.target);
            break;
        default:
            throw new Error("THREE.GLTFLoader: Unexpected light type: " + l.type)
        }
        return f.position.set(0, 0, 0),
        f.decay = 2,
        l.intensity !== void 0 && (f.intensity = l.intensity),
        f.name = t.createUniqueName(l.name || "light_" + e),
        i = Promise.resolve(f),
        t.cache.add(r, i),
        i
    }
    createNodeAttachment(e) {
        const t = this
          , r = this.parser
          , s = r.json.nodes[e]
          , a = (s.extensions && s.extensions[this.name] || {}).light;
        return a === void 0 ? null : this._loadLight(a).then(function(l) {
            return r._getNodeRef(t.cache, a, l)
        })
    }
}
class t5 {
    constructor() {
        this.name = tr.KHR_MATERIALS_UNLIT
    }
    getMaterialType() {
        return xa
    }
    extendParams(e, t, r) {
        const i = [];
        e.color = new It(1,1,1),
        e.opacity = 1;
        const s = t.pbrMetallicRoughness;
        if (s) {
            if (Array.isArray(s.baseColorFactor)) {
                const o = s.baseColorFactor;
                e.color.fromArray(o),
                e.opacity = o[3]
            }
            s.baseColorTexture !== void 0 && i.push(r.assignTexture(e, "map", s.baseColorTexture, nr))
        }
        return Promise.all(i)
    }
}
class n5 {
    constructor(e) {
        this.parser = e,
        this.name = tr.KHR_MATERIALS_EMISSIVE_STRENGTH
    }
    extendMaterialParams(e, t) {
        const i = this.parser.json.materials[e];
        if (!i.extensions || !i.extensions[this.name])
            return Promise.resolve();
        const s = i.extensions[this.name].emissiveStrength;
        return s !== void 0 && (t.emissiveIntensity = s),
        Promise.resolve()
    }
}
class r5 {
    constructor(e) {
        this.parser = e,
        this.name = tr.KHR_MATERIALS_CLEARCOAT
    }
    getMaterialType(e) {
        const r = this.parser.json.materials[e];
        return !r.extensions || !r.extensions[this.name] ? null : Ql
    }
    extendMaterialParams(e, t) {
        const r = this.parser
          , i = r.json.materials[e];
        if (!i.extensions || !i.extensions[this.name])
            return Promise.resolve();
        const s = []
          , o = i.extensions[this.name];
        if (o.clearcoatFactor !== void 0 && (t.clearcoat = o.clearcoatFactor),
        o.clearcoatTexture !== void 0 && s.push(r.assignTexture(t, "clearcoatMap", o.clearcoatTexture)),
        o.clearcoatRoughnessFactor !== void 0 && (t.clearcoatRoughness = o.clearcoatRoughnessFactor),
        o.clearcoatRoughnessTexture !== void 0 && s.push(r.assignTexture(t, "clearcoatRoughnessMap", o.clearcoatRoughnessTexture)),
        o.clearcoatNormalTexture !== void 0 && (s.push(r.assignTexture(t, "clearcoatNormalMap", o.clearcoatNormalTexture)),
        o.clearcoatNormalTexture.scale !== void 0)) {
            const a = o.clearcoatNormalTexture.scale;
            t.clearcoatNormalScale = new it(a,a)
        }
        return Promise.all(s)
    }
}
class i5 {
    constructor(e) {
        this.parser = e,
        this.name = tr.KHR_MATERIALS_IRIDESCENCE
    }
    getMaterialType(e) {
        const r = this.parser.json.materials[e];
        return !r.extensions || !r.extensions[this.name] ? null : Ql
    }
    extendMaterialParams(e, t) {
        const r = this.parser
          , i = r.json.materials[e];
        if (!i.extensions || !i.extensions[this.name])
            return Promise.resolve();
        const s = []
          , o = i.extensions[this.name];
        return o.iridescenceFactor !== void 0 && (t.iridescence = o.iridescenceFactor),
        o.iridescenceTexture !== void 0 && s.push(r.assignTexture(t, "iridescenceMap", o.iridescenceTexture)),
        o.iridescenceIor !== void 0 && (t.iridescenceIOR = o.iridescenceIor),
        t.iridescenceThicknessRange === void 0 && (t.iridescenceThicknessRange = [100, 400]),
        o.iridescenceThicknessMinimum !== void 0 && (t.iridescenceThicknessRange[0] = o.iridescenceThicknessMinimum),
        o.iridescenceThicknessMaximum !== void 0 && (t.iridescenceThicknessRange[1] = o.iridescenceThicknessMaximum),
        o.iridescenceThicknessTexture !== void 0 && s.push(r.assignTexture(t, "iridescenceThicknessMap", o.iridescenceThicknessTexture)),
        Promise.all(s)
    }
}
class s5 {
    constructor(e) {
        this.parser = e,
        this.name = tr.KHR_MATERIALS_SHEEN
    }
    getMaterialType(e) {
        const r = this.parser.json.materials[e];
        return !r.extensions || !r.extensions[this.name] ? null : Ql
    }
    extendMaterialParams(e, t) {
        const r = this.parser
          , i = r.json.materials[e];
        if (!i.extensions || !i.extensions[this.name])
            return Promise.resolve();
        const s = [];
        t.sheenColor = new It(0,0,0),
        t.sheenRoughness = 0,
        t.sheen = 1;
        const o = i.extensions[this.name];
        return o.sheenColorFactor !== void 0 && t.sheenColor.fromArray(o.sheenColorFactor),
        o.sheenRoughnessFactor !== void 0 && (t.sheenRoughness = o.sheenRoughnessFactor),
        o.sheenColorTexture !== void 0 && s.push(r.assignTexture(t, "sheenColorMap", o.sheenColorTexture, nr)),
        o.sheenRoughnessTexture !== void 0 && s.push(r.assignTexture(t, "sheenRoughnessMap", o.sheenRoughnessTexture)),
        Promise.all(s)
    }
}
class o5 {
    constructor(e) {
        this.parser = e,
        this.name = tr.KHR_MATERIALS_TRANSMISSION
    }
    getMaterialType(e) {
        const r = this.parser.json.materials[e];
        return !r.extensions || !r.extensions[this.name] ? null : Ql
    }
    extendMaterialParams(e, t) {
        const r = this.parser
          , i = r.json.materials[e];
        if (!i.extensions || !i.extensions[this.name])
            return Promise.resolve();
        const s = []
          , o = i.extensions[this.name];
        return o.transmissionFactor !== void 0 && (t.transmission = o.transmissionFactor),
        o.transmissionTexture !== void 0 && s.push(r.assignTexture(t, "transmissionMap", o.transmissionTexture)),
        Promise.all(s)
    }
}
class a5 {
    constructor(e) {
        this.parser = e,
        this.name = tr.KHR_MATERIALS_VOLUME
    }
    getMaterialType(e) {
        const r = this.parser.json.materials[e];
        return !r.extensions || !r.extensions[this.name] ? null : Ql
    }
    extendMaterialParams(e, t) {
        const r = this.parser
          , i = r.json.materials[e];
        if (!i.extensions || !i.extensions[this.name])
            return Promise.resolve();
        const s = []
          , o = i.extensions[this.name];
        t.thickness = o.thicknessFactor !== void 0 ? o.thicknessFactor : 0,
        o.thicknessTexture !== void 0 && s.push(r.assignTexture(t, "thicknessMap", o.thicknessTexture)),
        t.attenuationDistance = o.attenuationDistance || 1 / 0;
        const a = o.attenuationColor || [1, 1, 1];
        return t.attenuationColor = new It(a[0],a[1],a[2]),
        Promise.all(s)
    }
}
class l5 {
    constructor(e) {
        this.parser = e,
        this.name = tr.KHR_MATERIALS_IOR
    }
    getMaterialType(e) {
        const r = this.parser.json.materials[e];
        return !r.extensions || !r.extensions[this.name] ? null : Ql
    }
    extendMaterialParams(e, t) {
        const i = this.parser.json.materials[e];
        if (!i.extensions || !i.extensions[this.name])
            return Promise.resolve();
        const s = i.extensions[this.name];
        return t.ior = s.ior !== void 0 ? s.ior : 1.5,
        Promise.resolve()
    }
}
class u5 {
    constructor(e) {
        this.parser = e,
        this.name = tr.KHR_MATERIALS_SPECULAR
    }
    getMaterialType(e) {
        const r = this.parser.json.materials[e];
        return !r.extensions || !r.extensions[this.name] ? null : Ql
    }
    extendMaterialParams(e, t) {
        const r = this.parser
          , i = r.json.materials[e];
        if (!i.extensions || !i.extensions[this.name])
            return Promise.resolve();
        const s = []
          , o = i.extensions[this.name];
        t.specularIntensity = o.specularFactor !== void 0 ? o.specularFactor : 1,
        o.specularTexture !== void 0 && s.push(r.assignTexture(t, "specularIntensityMap", o.specularTexture));
        const a = o.specularColorFactor || [1, 1, 1];
        return t.specularColor = new It(a[0],a[1],a[2]),
        o.specularColorTexture !== void 0 && s.push(r.assignTexture(t, "specularColorMap", o.specularColorTexture, nr)),
        Promise.all(s)
    }
}
class c5 {
    constructor(e) {
        this.parser = e,
        this.name = tr.KHR_TEXTURE_BASISU
    }
    loadTexture(e) {
        const t = this.parser
          , r = t.json
          , i = r.textures[e];
        if (!i.extensions || !i.extensions[this.name])
            return null;
        const s = i.extensions[this.name]
          , o = t.options.ktx2Loader;
        if (!o) {
            if (r.extensionsRequired && r.extensionsRequired.indexOf(this.name) >= 0)
                throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
            return null
        }
        return t.loadTextureImage(e, s.source, o)
    }
}
class f5 {
    constructor(e) {
        this.parser = e,
        this.name = tr.EXT_TEXTURE_WEBP,
        this.isSupported = null
    }
    loadTexture(e) {
        const t = this.name
          , r = this.parser
          , i = r.json
          , s = i.textures[e];
        if (!s.extensions || !s.extensions[t])
            return null;
        const o = s.extensions[t]
          , a = i.images[o.source];
        let l = r.textureLoader;
        if (a.uri) {
            const f = r.options.manager.getHandler(a.uri);
            f !== null && (l = f)
        }
        return this.detectSupport().then(function(f) {
            if (f)
                return r.loadTextureImage(e, o.source, l);
            if (i.extensionsRequired && i.extensionsRequired.indexOf(t) >= 0)
                throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
            return r.loadTexture(e)
        })
    }
    detectSupport() {
        return this.isSupported || (this.isSupported = new Promise(function(e) {
            const t = new Image;
            t.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA",
            t.onload = t.onerror = function() {
                e(t.height === 1)
            }
        }
        )),
        this.isSupported
    }
}
class d5 {
    constructor(e) {
        this.name = tr.EXT_MESHOPT_COMPRESSION,
        this.parser = e
    }
    loadBufferView(e) {
        const t = this.parser.json
          , r = t.bufferViews[e];
        if (r.extensions && r.extensions[this.name]) {
            const i = r.extensions[this.name]
              , s = this.parser.getDependency("buffer", i.buffer)
              , o = this.parser.options.meshoptDecoder;
            if (!o || !o.supported) {
                if (t.extensionsRequired && t.extensionsRequired.indexOf(this.name) >= 0)
                    throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
                return null
            }
            return s.then(function(a) {
                const l = i.byteOffset || 0
                  , f = i.byteLength || 0
                  , h = i.count
                  , d = i.byteStride
                  , p = new Uint8Array(a,l,f);
                return o.decodeGltfBufferAsync ? o.decodeGltfBufferAsync(h, d, p, i.mode, i.filter).then(function(m) {
                    return m.buffer
                }) : o.ready.then(function() {
                    const m = new ArrayBuffer(h * d);
                    return o.decodeGltfBuffer(new Uint8Array(m), h, d, p, i.mode, i.filter),
                    m
                })
            })
        } else
            return null
    }
}
const mP = "glTF"
  , pp = 12
  , nb = {
    JSON: 1313821514,
    BIN: 5130562
};
class h5 {
    constructor(e) {
        this.name = tr.KHR_BINARY_GLTF,
        this.content = null,
        this.body = null;
        const t = new DataView(e,0,pp);
        if (this.header = {
            magic: jl.decodeText(new Uint8Array(e.slice(0, 4))),
            version: t.getUint32(4, !0),
            length: t.getUint32(8, !0)
        },
        this.header.magic !== mP)
            throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
        if (this.header.version < 2)
            throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
        const r = this.header.length - pp
          , i = new DataView(e,pp);
        let s = 0;
        for (; s < r; ) {
            const o = i.getUint32(s, !0);
            s += 4;
            const a = i.getUint32(s, !0);
            if (s += 4,
            a === nb.JSON) {
                const l = new Uint8Array(e,pp + s,o);
                this.content = jl.decodeText(l)
            } else if (a === nb.BIN) {
                const l = pp + s;
                this.body = e.slice(l, l + o)
            }
            s += o
        }
        if (this.content === null)
            throw new Error("THREE.GLTFLoader: JSON content not found.")
    }
}
class p5 {
    constructor(e, t) {
        if (!t)
            throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
        this.name = tr.KHR_DRACO_MESH_COMPRESSION,
        this.json = e,
        this.dracoLoader = t,
        this.dracoLoader.preload()
    }
    decodePrimitive(e, t) {
        const r = this.json
          , i = this.dracoLoader
          , s = e.extensions[this.name].bufferView
          , o = e.extensions[this.name].attributes
          , a = {}
          , l = {}
          , f = {};
        for (const h in o) {
            const d = Cw[h] || h.toLowerCase();
            a[d] = o[h]
        }
        for (const h in e.attributes) {
            const d = Cw[h] || h.toLowerCase();
            if (o[h] !== void 0) {
                const p = r.accessors[e.attributes[h]]
                  , m = Em[p.componentType];
                f[d] = m.name,
                l[d] = p.normalized === !0
            }
        }
        return t.getDependency("bufferView", s).then(function(h) {
            return new Promise(function(d) {
                i.decodeDracoFile(h, function(p) {
                    for (const m in p.attributes) {
                        const _ = p.attributes[m]
                          , y = l[m];
                        y !== void 0 && (_.normalized = y)
                    }
                    d(p)
                }, a, f)
            }
            )
        })
    }
}
class m5 {
    constructor() {
        this.name = tr.KHR_TEXTURE_TRANSFORM
    }
    extendTexture(e, t) {
        return t.texCoord !== void 0 && console.warn('THREE.GLTFLoader: Custom UV sets in "' + this.name + '" extension not yet supported.'),
        t.offset === void 0 && t.rotation === void 0 && t.scale === void 0 || (e = e.clone(),
        t.offset !== void 0 && e.offset.fromArray(t.offset),
        t.rotation !== void 0 && (e.rotation = t.rotation),
        t.scale !== void 0 && e.repeat.fromArray(t.scale),
        e.needsUpdate = !0),
        e
    }
}
class Aw extends kh {
    constructor(e) {
        super(),
        this.isGLTFSpecularGlossinessMaterial = !0;
        const t = ["#ifdef USE_SPECULARMAP", "	uniform sampler2D specularMap;", "#endif"].join(`
`)
          , r = ["#ifdef USE_GLOSSINESSMAP", "	uniform sampler2D glossinessMap;", "#endif"].join(`
`)
          , i = ["vec3 specularFactor = specular;", "#ifdef USE_SPECULARMAP", "	vec4 texelSpecular = texture2D( specularMap, vUv );", "	// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture", "	specularFactor *= texelSpecular.rgb;", "#endif"].join(`
`)
          , s = ["float glossinessFactor = glossiness;", "#ifdef USE_GLOSSINESSMAP", "	vec4 texelGlossiness = texture2D( glossinessMap, vUv );", "	// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture", "	glossinessFactor *= texelGlossiness.a;", "#endif"].join(`
`)
          , o = ["PhysicalMaterial material;", "material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );", "vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );", "float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );", "material.roughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.", "material.roughness += geometryRoughness;", "material.roughness = min( material.roughness, 1.0 );", "material.specularColor = specularFactor;"].join(`
`)
          , a = {
            specular: {
                value: new It().setHex(16777215)
            },
            glossiness: {
                value: 1
            },
            specularMap: {
                value: null
            },
            glossinessMap: {
                value: null
            }
        };
        this._extraUniforms = a,
        this.onBeforeCompile = function(l) {
            for (const f in a)
                l.uniforms[f] = a[f];
            l.fragmentShader = l.fragmentShader.replace("uniform float roughness;", "uniform vec3 specular;").replace("uniform float metalness;", "uniform float glossiness;").replace("#include <roughnessmap_pars_fragment>", t).replace("#include <metalnessmap_pars_fragment>", r).replace("#include <roughnessmap_fragment>", i).replace("#include <metalnessmap_fragment>", s).replace("#include <lights_physical_fragment>", o)
        }
        ,
        Object.defineProperties(this, {
            specular: {
                get: function() {
                    return a.specular.value
                },
                set: function(l) {
                    a.specular.value = l
                }
            },
            specularMap: {
                get: function() {
                    return a.specularMap.value
                },
                set: function(l) {
                    a.specularMap.value = l,
                    l ? this.defines.USE_SPECULARMAP = "" : delete this.defines.USE_SPECULARMAP
                }
            },
            glossiness: {
                get: function() {
                    return a.glossiness.value
                },
                set: function(l) {
                    a.glossiness.value = l
                }
            },
            glossinessMap: {
                get: function() {
                    return a.glossinessMap.value
                },
                set: function(l) {
                    a.glossinessMap.value = l,
                    l ? (this.defines.USE_GLOSSINESSMAP = "",
                    this.defines.USE_UV = "") : (delete this.defines.USE_GLOSSINESSMAP,
                    delete this.defines.USE_UV)
                }
            }
        }),
        delete this.metalness,
        delete this.roughness,
        delete this.metalnessMap,
        delete this.roughnessMap,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.specularMap = e.specularMap,
        this.specular.copy(e.specular),
        this.glossinessMap = e.glossinessMap,
        this.glossiness = e.glossiness,
        delete this.metalness,
        delete this.roughness,
        delete this.metalnessMap,
        delete this.roughnessMap,
        this
    }
}
class g5 {
    constructor() {
        this.name = tr.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS,
        this.specularGlossinessParams = ["color", "map", "lightMap", "lightMapIntensity", "aoMap", "aoMapIntensity", "emissive", "emissiveIntensity", "emissiveMap", "bumpMap", "bumpScale", "normalMap", "normalMapType", "displacementMap", "displacementScale", "displacementBias", "specularMap", "specular", "glossinessMap", "glossiness", "alphaMap", "envMap", "envMapIntensity", "refractionRatio"]
    }
    getMaterialType() {
        return Aw
    }
    extendParams(e, t, r) {
        const i = t.extensions[this.name];
        e.color = new It(1,1,1),
        e.opacity = 1;
        const s = [];
        if (Array.isArray(i.diffuseFactor)) {
            const o = i.diffuseFactor;
            e.color.fromArray(o),
            e.opacity = o[3]
        }
        if (i.diffuseTexture !== void 0 && s.push(r.assignTexture(e, "map", i.diffuseTexture, nr)),
        e.emissive = new It(0,0,0),
        e.glossiness = i.glossinessFactor !== void 0 ? i.glossinessFactor : 1,
        e.specular = new It(1,1,1),
        Array.isArray(i.specularFactor) && e.specular.fromArray(i.specularFactor),
        i.specularGlossinessTexture !== void 0) {
            const o = i.specularGlossinessTexture;
            s.push(r.assignTexture(e, "glossinessMap", o)),
            s.push(r.assignTexture(e, "specularMap", o, nr))
        }
        return Promise.all(s)
    }
    createMaterial(e) {
        const t = new Aw(e);
        return t.fog = !0,
        t.color = e.color,
        t.map = e.map === void 0 ? null : e.map,
        t.lightMap = null,
        t.lightMapIntensity = 1,
        t.aoMap = e.aoMap === void 0 ? null : e.aoMap,
        t.aoMapIntensity = 1,
        t.emissive = e.emissive,
        t.emissiveIntensity = e.emissiveIntensity === void 0 ? 1 : e.emissiveIntensity,
        t.emissiveMap = e.emissiveMap === void 0 ? null : e.emissiveMap,
        t.bumpMap = e.bumpMap === void 0 ? null : e.bumpMap,
        t.bumpScale = 1,
        t.normalMap = e.normalMap === void 0 ? null : e.normalMap,
        t.normalMapType = Ru,
        e.normalScale && (t.normalScale = e.normalScale),
        t.displacementMap = null,
        t.displacementScale = 1,
        t.displacementBias = 0,
        t.specularMap = e.specularMap === void 0 ? null : e.specularMap,
        t.specular = e.specular,
        t.glossinessMap = e.glossinessMap === void 0 ? null : e.glossinessMap,
        t.glossiness = e.glossiness,
        t.alphaMap = null,
        t.envMap = e.envMap === void 0 ? null : e.envMap,
        t.envMapIntensity = 1,
        t.refractionRatio = .98,
        t
    }
}
class v5 {
    constructor() {
        this.name = tr.KHR_MESH_QUANTIZATION
    }
}
class gP extends Oh {
    constructor(e, t, r, i) {
        super(e, t, r, i)
    }
    copySampleValue_(e) {
        const t = this.resultBuffer
          , r = this.sampleValues
          , i = this.valueSize
          , s = e * i * 3 + i;
        for (let o = 0; o !== i; o++)
            t[o] = r[s + o];
        return t
    }
    interpolate_(e, t, r, i) {
        const s = this.resultBuffer
          , o = this.sampleValues
          , a = this.valueSize
          , l = a * 2
          , f = a * 3
          , h = i - t
          , d = (r - t) / h
          , p = d * d
          , m = p * d
          , _ = e * f
          , y = _ - f
          , x = -2 * m + 3 * p
          , S = m - p
          , M = 1 - x
          , w = S - p + d;
        for (let T = 0; T !== a; T++) {
            const P = o[y + T + a]
              , I = o[y + T + l] * h
              , k = o[_ + T + a]
              , R = o[_ + T] * h;
            s[T] = M * P + w * I + x * k + S * R
        }
        return s
    }
}
const _5 = new Ws;
class y5 extends gP {
    interpolate_(e, t, r, i) {
        const s = super.interpolate_(e, t, r, i);
        return _5.fromArray(s).normalize().toArray(s),
        s
    }
}
const uu = {
    FLOAT: 5126,
    FLOAT_MAT3: 35675,
    FLOAT_MAT4: 35676,
    FLOAT_VEC2: 35664,
    FLOAT_VEC3: 35665,
    FLOAT_VEC4: 35666,
    LINEAR: 9729,
    REPEAT: 10497,
    SAMPLER_2D: 35678,
    POINTS: 0,
    LINES: 1,
    LINE_LOOP: 2,
    LINE_STRIP: 3,
    TRIANGLES: 4,
    TRIANGLE_STRIP: 5,
    TRIANGLE_FAN: 6,
    UNSIGNED_BYTE: 5121,
    UNSIGNED_SHORT: 5123
}
  , Em = {
    5120: Int8Array,
    5121: Uint8Array,
    5122: Int16Array,
    5123: Uint16Array,
    5125: Uint32Array,
    5126: Float32Array
}
  , rb = {
    9728: Ji,
    9729: si,
    9984: pm,
    9985: v_,
    9986: ih,
    9987: Kl
}
  , ib = {
    33071: Us,
    33648: gh,
    10497: bc
}
  , sb = {
    SCALAR: 1,
    VEC2: 2,
    VEC3: 3,
    VEC4: 4,
    MAT2: 4,
    MAT3: 9,
    MAT4: 16
}
  , Cw = {
    POSITION: "position",
    NORMAL: "normal",
    TANGENT: "tangent",
    TEXCOORD_0: "uv",
    TEXCOORD_1: "uv2",
    COLOR_0: "color",
    WEIGHTS_0: "skinWeight",
    JOINTS_0: "skinIndex"
}
  , $u = {
    scale: "scale",
    translation: "position",
    rotation: "quaternion",
    weights: "morphTargetInfluences"
}
  , x5 = {
    CUBICSPLINE: void 0,
    LINEAR: Hf,
    STEP: vh
}
  , Mx = {
    OPAQUE: "OPAQUE",
    MASK: "MASK",
    BLEND: "BLEND"
};
function w5(n) {
    return n.DefaultMaterial === void 0 && (n.DefaultMaterial = new kh({
        color: 16777215,
        emissive: 0,
        metalness: 1,
        roughness: 1,
        transparent: !1,
        depthTest: !0,
        side: El
    })),
    n.DefaultMaterial
}
function mp(n, e, t) {
    for (const r in t.extensions)
        n[r] === void 0 && (e.userData.gltfExtensions = e.userData.gltfExtensions || {},
        e.userData.gltfExtensions[r] = t.extensions[r])
}
function ff(n, e) {
    e.extras !== void 0 && (typeof e.extras == "object" ? Object.assign(n.userData, e.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + e.extras))
}
function S5(n, e, t) {
    let r = !1
      , i = !1
      , s = !1;
    for (let f = 0, h = e.length; f < h; f++) {
        const d = e[f];
        if (d.POSITION !== void 0 && (r = !0),
        d.NORMAL !== void 0 && (i = !0),
        d.COLOR_0 !== void 0 && (s = !0),
        r && i && s)
            break
    }
    if (!r && !i && !s)
        return Promise.resolve(n);
    const o = []
      , a = []
      , l = [];
    for (let f = 0, h = e.length; f < h; f++) {
        const d = e[f];
        if (r) {
            const p = d.POSITION !== void 0 ? t.getDependency("accessor", d.POSITION) : n.attributes.position;
            o.push(p)
        }
        if (i) {
            const p = d.NORMAL !== void 0 ? t.getDependency("accessor", d.NORMAL) : n.attributes.normal;
            a.push(p)
        }
        if (s) {
            const p = d.COLOR_0 !== void 0 ? t.getDependency("accessor", d.COLOR_0) : n.attributes.color;
            l.push(p)
        }
    }
    return Promise.all([Promise.all(o), Promise.all(a), Promise.all(l)]).then(function(f) {
        const h = f[0]
          , d = f[1]
          , p = f[2];
        return r && (n.morphAttributes.position = h),
        i && (n.morphAttributes.normal = d),
        s && (n.morphAttributes.color = p),
        n.morphTargetsRelative = !0,
        n
    })
}
function M5(n, e) {
    if (n.updateMorphTargets(),
    e.weights !== void 0)
        for (let t = 0, r = e.weights.length; t < r; t++)
            n.morphTargetInfluences[t] = e.weights[t];
    if (e.extras && Array.isArray(e.extras.targetNames)) {
        const t = e.extras.targetNames;
        if (n.morphTargetInfluences.length === t.length) {
            n.morphTargetDictionary = {};
            for (let r = 0, i = t.length; r < i; r++)
                n.morphTargetDictionary[t[r]] = r
        } else
            console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")
    }
}
function A5(n) {
    const e = n.extensions && n.extensions[tr.KHR_DRACO_MESH_COMPRESSION];
    let t;
    return e ? t = "draco:" + e.bufferView + ":" + e.indices + ":" + ob(e.attributes) : t = n.indices + ":" + ob(n.attributes) + ":" + n.mode,
    t
}
function ob(n) {
    let e = "";
    const t = Object.keys(n).sort();
    for (let r = 0, i = t.length; r < i; r++)
        e += t[r] + ":" + n[t[r]] + ";";
    return e
}
function Ew(n) {
    switch (n) {
    case Int8Array:
        return 1 / 127;
    case Uint8Array:
        return 1 / 255;
    case Int16Array:
        return 1 / 32767;
    case Uint16Array:
        return 1 / 65535;
    default:
        throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")
    }
}
function C5(n) {
    return n.search(/\.jpe?g($|\?)/i) > 0 || n.search(/^data\:image\/jpeg/) === 0 ? "image/jpeg" : n.search(/\.webp($|\?)/i) > 0 || n.search(/^data\:image\/webp/) === 0 ? "image/webp" : "image/png"
}
class E5 {
    constructor(e={}, t={}) {
        var r, i;
        this.json = e,
        this.extensions = {},
        this.plugins = {},
        this.options = t,
        this.cache = new $U,
        this.associations = new Map,
        this.primitiveCache = {},
        this.meshCache = {
            refs: {},
            uses: {}
        },
        this.cameraCache = {
            refs: {},
            uses: {}
        },
        this.lightCache = {
            refs: {},
            uses: {}
        },
        this.sourceCache = {},
        this.textureCache = {},
        this.nodeNamesUsed = {};
        const s = typeof navigator < "u" && /^((?!chrome|android).)*safari/i.test(navigator.userAgent) === !0
          , o = typeof navigator < "u" && ((r = navigator.userAgent) === null || r === void 0 ? void 0 : r.indexOf("Firefox")) > -1
          , a = typeof navigator < "u" && o ? (i = navigator.userAgent) === null || i === void 0 ? void 0 : i.match(/Firefox\/([0-9]+)\./)[1] : -1;
        typeof createImageBitmap > "u" || s || o && a < 98 ? this.textureLoader = new N3(this.options.manager) : this.textureLoader = new X3(this.options.manager),
        this.textureLoader.setCrossOrigin(this.options.crossOrigin),
        this.textureLoader.setRequestHeader(this.options.requestHeader),
        this.fileLoader = new Aa(this.options.manager),
        this.fileLoader.setResponseType("arraybuffer"),
        this.options.crossOrigin === "use-credentials" && this.fileLoader.setWithCredentials(!0)
    }
    setExtensions(e) {
        this.extensions = e
    }
    setPlugins(e) {
        this.plugins = e
    }
    parse(e, t) {
        const r = this
          , i = this.json
          , s = this.extensions;
        this.cache.removeAll(),
        this._invokeAll(function(o) {
            return o._markDefs && o._markDefs()
        }),
        Promise.all(this._invokeAll(function(o) {
            return o.beforeRoot && o.beforeRoot()
        })).then(function() {
            return Promise.all([r.getDependencies("scene"), r.getDependencies("animation"), r.getDependencies("camera")])
        }).then(function(o) {
            const a = {
                scene: o[0][i.scene || 0],
                scenes: o[0],
                animations: o[1],
                cameras: o[2],
                asset: i.asset,
                parser: r,
                userData: {}
            };
            mp(s, a, i),
            ff(a, i),
            Promise.all(r._invokeAll(function(l) {
                return l.afterRoot && l.afterRoot(a)
            })).then(function() {
                e(a)
            })
        }).catch(t)
    }
    _markDefs() {
        const e = this.json.nodes || []
          , t = this.json.skins || []
          , r = this.json.meshes || [];
        for (let i = 0, s = t.length; i < s; i++) {
            const o = t[i].joints;
            for (let a = 0, l = o.length; a < l; a++)
                e[o[a]].isBone = !0
        }
        for (let i = 0, s = e.length; i < s; i++) {
            const o = e[i];
            o.mesh !== void 0 && (this._addNodeRef(this.meshCache, o.mesh),
            o.skin !== void 0 && (r[o.mesh].isSkinnedMesh = !0)),
            o.camera !== void 0 && this._addNodeRef(this.cameraCache, o.camera)
        }
    }
    _addNodeRef(e, t) {
        t !== void 0 && (e.refs[t] === void 0 && (e.refs[t] = e.uses[t] = 0),
        e.refs[t]++)
    }
    _getNodeRef(e, t, r) {
        if (e.refs[t] <= 1)
            return r;
        const i = r.clone()
          , s = (o,a)=>{
            const l = this.associations.get(o);
            l != null && this.associations.set(a, l);
            for (const [f,h] of o.children.entries())
                s(h, a.children[f])
        }
        ;
        return s(r, i),
        i.name += "_instance_" + e.uses[t]++,
        i
    }
    _invokeOne(e) {
        const t = Object.values(this.plugins);
        t.push(this);
        for (let r = 0; r < t.length; r++) {
            const i = e(t[r]);
            if (i)
                return i
        }
        return null
    }
    _invokeAll(e) {
        const t = Object.values(this.plugins);
        t.unshift(this);
        const r = [];
        for (let i = 0; i < t.length; i++) {
            const s = e(t[i]);
            s && r.push(s)
        }
        return r
    }
    getDependency(e, t) {
        const r = e + ":" + t;
        let i = this.cache.get(r);
        if (!i) {
            switch (e) {
            case "scene":
                i = this.loadScene(t);
                break;
            case "node":
                i = this.loadNode(t);
                break;
            case "mesh":
                i = this._invokeOne(function(s) {
                    return s.loadMesh && s.loadMesh(t)
                });
                break;
            case "accessor":
                i = this.loadAccessor(t);
                break;
            case "bufferView":
                i = this._invokeOne(function(s) {
                    return s.loadBufferView && s.loadBufferView(t)
                });
                break;
            case "buffer":
                i = this.loadBuffer(t);
                break;
            case "material":
                i = this._invokeOne(function(s) {
                    return s.loadMaterial && s.loadMaterial(t)
                });
                break;
            case "texture":
                i = this._invokeOne(function(s) {
                    return s.loadTexture && s.loadTexture(t)
                });
                break;
            case "skin":
                i = this.loadSkin(t);
                break;
            case "animation":
                i = this._invokeOne(function(s) {
                    return s.loadAnimation && s.loadAnimation(t)
                });
                break;
            case "camera":
                i = this.loadCamera(t);
                break;
            default:
                throw new Error("Unknown type: " + e)
            }
            this.cache.add(r, i)
        }
        return i
    }
    getDependencies(e) {
        let t = this.cache.get(e);
        if (!t) {
            const r = this
              , i = this.json[e + (e === "mesh" ? "es" : "s")] || [];
            t = Promise.all(i.map(function(s, o) {
                return r.getDependency(e, o)
            })),
            this.cache.add(e, t)
        }
        return t
    }
    loadBuffer(e) {
        const t = this.json.buffers[e]
          , r = this.fileLoader;
        if (t.type && t.type !== "arraybuffer")
            throw new Error("THREE.GLTFLoader: " + t.type + " buffer type is not supported.");
        if (t.uri === void 0 && e === 0)
            return Promise.resolve(this.extensions[tr.KHR_BINARY_GLTF].body);
        const i = this.options;
        return new Promise(function(s, o) {
            r.load(jl.resolveURL(t.uri, i.path), s, void 0, function() {
                o(new Error('THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".'))
            })
        }
        )
    }
    loadBufferView(e) {
        const t = this.json.bufferViews[e];
        return this.getDependency("buffer", t.buffer).then(function(r) {
            const i = t.byteLength || 0
              , s = t.byteOffset || 0;
            return r.slice(s, s + i)
        })
    }
    loadAccessor(e) {
        const t = this
          , r = this.json
          , i = this.json.accessors[e];
        if (i.bufferView === void 0 && i.sparse === void 0)
            return Promise.resolve(null);
        const s = [];
        return i.bufferView !== void 0 ? s.push(this.getDependency("bufferView", i.bufferView)) : s.push(null),
        i.sparse !== void 0 && (s.push(this.getDependency("bufferView", i.sparse.indices.bufferView)),
        s.push(this.getDependency("bufferView", i.sparse.values.bufferView))),
        Promise.all(s).then(function(o) {
            const a = o[0]
              , l = sb[i.type]
              , f = Em[i.componentType]
              , h = f.BYTES_PER_ELEMENT
              , d = h * l
              , p = i.byteOffset || 0
              , m = i.bufferView !== void 0 ? r.bufferViews[i.bufferView].byteStride : void 0
              , _ = i.normalized === !0;
            let y, x;
            if (m && m !== d) {
                const S = Math.floor(p / m)
                  , M = "InterleavedBuffer:" + i.bufferView + ":" + i.componentType + ":" + S + ":" + i.count;
                let w = t.cache.get(M);
                w || (y = new f(a,S * m,i.count * m / h),
                w = new zm(y,m / h),
                t.cache.add(M, w)),
                x = new Dc(w,l,p % m / h,_)
            } else
                a === null ? y = new f(i.count * l) : y = new f(a,p,i.count * l),
                x = new Dr(y,l,_);
            if (i.sparse !== void 0) {
                const S = sb.SCALAR
                  , M = Em[i.sparse.indices.componentType]
                  , w = i.sparse.indices.byteOffset || 0
                  , T = i.sparse.values.byteOffset || 0
                  , P = new M(o[1],w,i.sparse.count * S)
                  , I = new f(o[2],T,i.sparse.count * l);
                a !== null && (x = new Dr(x.array.slice(),x.itemSize,x.normalized));
                for (let k = 0, R = P.length; k < R; k++) {
                    const O = P[k];
                    if (x.setX(O, I[k * l]),
                    l >= 2 && x.setY(O, I[k * l + 1]),
                    l >= 3 && x.setZ(O, I[k * l + 2]),
                    l >= 4 && x.setW(O, I[k * l + 3]),
                    l >= 5)
                        throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")
                }
            }
            return x
        })
    }
    loadTexture(e) {
        const t = this.json
          , r = this.options
          , s = t.textures[e].source
          , o = t.images[s];
        let a = this.textureLoader;
        if (o.uri) {
            const l = r.manager.getHandler(o.uri);
            l !== null && (a = l)
        }
        return this.loadTextureImage(e, s, a)
    }
    loadTextureImage(e, t, r) {
        const i = this
          , s = this.json
          , o = s.textures[e]
          , a = s.images[t]
          , l = (a.uri || a.bufferView) + ":" + o.sampler;
        if (this.textureCache[l])
            return this.textureCache[l];
        const f = this.loadImageSource(t, r).then(function(h) {
            h.flipY = !1,
            o.name && (h.name = o.name);
            const p = (s.samplers || {})[o.sampler] || {};
            return h.magFilter = rb[p.magFilter] || si,
            h.minFilter = rb[p.minFilter] || Kl,
            h.wrapS = ib[p.wrapS] || bc,
            h.wrapT = ib[p.wrapT] || bc,
            i.associations.set(h, {
                textures: e
            }),
            h
        }).catch(function() {
            return null
        });
        return this.textureCache[l] = f,
        f
    }
    loadImageSource(e, t) {
        const r = this
          , i = this.json
          , s = this.options;
        if (this.sourceCache[e] !== void 0)
            return this.sourceCache[e].then(d=>d.clone());
        const o = i.images[e]
          , a = self.URL || self.webkitURL;
        let l = o.uri || ""
          , f = !1;
        if (o.bufferView !== void 0)
            l = r.getDependency("bufferView", o.bufferView).then(function(d) {
                f = !0;
                const p = new Blob([d],{
                    type: o.mimeType
                });
                return l = a.createObjectURL(p),
                l
            });
        else if (o.uri === void 0)
            throw new Error("THREE.GLTFLoader: Image " + e + " is missing URI and bufferView");
        const h = Promise.resolve(l).then(function(d) {
            return new Promise(function(p, m) {
                let _ = p;
                t.isImageBitmapLoader === !0 && (_ = function(y) {
                    const x = new Ci(y);
                    x.needsUpdate = !0,
                    p(x)
                }
                ),
                t.load(jl.resolveURL(d, s.path), _, void 0, m)
            }
            )
        }).then(function(d) {
            return f === !0 && a.revokeObjectURL(l),
            d.userData.mimeType = o.mimeType || C5(o.uri),
            d
        }).catch(function(d) {
            throw console.error("THREE.GLTFLoader: Couldn't load texture", l),
            d
        });
        return this.sourceCache[e] = h,
        h
    }
    assignTexture(e, t, r, i) {
        const s = this;
        return this.getDependency("texture", r.index).then(function(o) {
            if (r.texCoord !== void 0 && r.texCoord != 0 && !(t === "aoMap" && r.texCoord == 1) && console.warn("THREE.GLTFLoader: Custom UV set " + r.texCoord + " for texture " + t + " not yet supported."),
            s.extensions[tr.KHR_TEXTURE_TRANSFORM]) {
                const a = r.extensions !== void 0 ? r.extensions[tr.KHR_TEXTURE_TRANSFORM] : void 0;
                if (a) {
                    const l = s.associations.get(o);
                    o = s.extensions[tr.KHR_TEXTURE_TRANSFORM].extendTexture(o, a),
                    s.associations.set(o, l)
                }
            }
            return i !== void 0 && (o.encoding = i),
            e[t] = o,
            o
        })
    }
    assignFinalMaterial(e) {
        const t = e.geometry;
        let r = e.material;
        const i = t.attributes.tangent === void 0
          , s = t.attributes.color !== void 0
          , o = t.attributes.normal === void 0;
        if (e.isPoints) {
            const a = "PointsMaterial:" + r.uuid;
            let l = this.cache.get(a);
            l || (l = new b_,
            as.prototype.copy.call(l, r),
            l.color.copy(r.color),
            l.map = r.map,
            l.sizeAttenuation = !1,
            this.cache.add(a, l)),
            r = l
        } else if (e.isLine) {
            const a = "LineBasicMaterial:" + r.uuid;
            let l = this.cache.get(a);
            l || (l = new lo,
            as.prototype.copy.call(l, r),
            l.color.copy(r.color),
            this.cache.add(a, l)),
            r = l
        }
        if (i || s || o) {
            let a = "ClonedMaterial:" + r.uuid + ":";
            r.isGLTFSpecularGlossinessMaterial && (a += "specular-glossiness:"),
            i && (a += "derivative-tangents:"),
            s && (a += "vertex-colors:"),
            o && (a += "flat-shading:");
            let l = this.cache.get(a);
            l || (l = r.clone(),
            s && (l.vertexColors = !0),
            o && (l.flatShading = !0),
            i && (l.normalScale && (l.normalScale.y *= -1),
            l.clearcoatNormalScale && (l.clearcoatNormalScale.y *= -1)),
            this.cache.add(a, l),
            this.associations.set(l, this.associations.get(r))),
            r = l
        }
        r.aoMap && t.attributes.uv2 === void 0 && t.attributes.uv !== void 0 && t.setAttribute("uv2", t.attributes.uv),
        e.material = r
    }
    getMaterialType() {
        return kh
    }
    loadMaterial(e) {
        const t = this
          , r = this.json
          , i = this.extensions
          , s = r.materials[e];
        let o;
        const a = {}
          , l = s.extensions || {}
          , f = [];
        if (l[tr.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {
            const d = i[tr.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];
            o = d.getMaterialType(),
            f.push(d.extendParams(a, s, t))
        } else if (l[tr.KHR_MATERIALS_UNLIT]) {
            const d = i[tr.KHR_MATERIALS_UNLIT];
            o = d.getMaterialType(),
            f.push(d.extendParams(a, s, t))
        } else {
            const d = s.pbrMetallicRoughness || {};
            if (a.color = new It(1,1,1),
            a.opacity = 1,
            Array.isArray(d.baseColorFactor)) {
                const p = d.baseColorFactor;
                a.color.fromArray(p),
                a.opacity = p[3]
            }
            d.baseColorTexture !== void 0 && f.push(t.assignTexture(a, "map", d.baseColorTexture, nr)),
            a.metalness = d.metallicFactor !== void 0 ? d.metallicFactor : 1,
            a.roughness = d.roughnessFactor !== void 0 ? d.roughnessFactor : 1,
            d.metallicRoughnessTexture !== void 0 && (f.push(t.assignTexture(a, "metalnessMap", d.metallicRoughnessTexture)),
            f.push(t.assignTexture(a, "roughnessMap", d.metallicRoughnessTexture))),
            o = this._invokeOne(function(p) {
                return p.getMaterialType && p.getMaterialType(e)
            }),
            f.push(Promise.all(this._invokeAll(function(p) {
                return p.extendMaterialParams && p.extendMaterialParams(e, a)
            })))
        }
        s.doubleSided === !0 && (a.side = Sl);
        const h = s.alphaMode || Mx.OPAQUE;
        if (h === Mx.BLEND ? (a.transparent = !0,
        a.depthWrite = !1) : (a.transparent = !1,
        h === Mx.MASK && (a.alphaTest = s.alphaCutoff !== void 0 ? s.alphaCutoff : .5)),
        s.normalTexture !== void 0 && o !== xa && (f.push(t.assignTexture(a, "normalMap", s.normalTexture)),
        a.normalScale = new it(1,1),
        s.normalTexture.scale !== void 0)) {
            const d = s.normalTexture.scale;
            a.normalScale.set(d, d)
        }
        return s.occlusionTexture !== void 0 && o !== xa && (f.push(t.assignTexture(a, "aoMap", s.occlusionTexture)),
        s.occlusionTexture.strength !== void 0 && (a.aoMapIntensity = s.occlusionTexture.strength)),
        s.emissiveFactor !== void 0 && o !== xa && (a.emissive = new It().fromArray(s.emissiveFactor)),
        s.emissiveTexture !== void 0 && o !== xa && f.push(t.assignTexture(a, "emissiveMap", s.emissiveTexture, nr)),
        Promise.all(f).then(function() {
            let d;
            return o === Aw ? d = i[tr.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(a) : d = new o(a),
            s.name && (d.name = s.name),
            ff(d, s),
            t.associations.set(d, {
                materials: e
            }),
            s.extensions && mp(i, d, s),
            d
        })
    }
    createUniqueName(e) {
        const t = hr.sanitizeNodeName(e || "");
        let r = t;
        for (let i = 1; this.nodeNamesUsed[r]; ++i)
            r = t + "_" + i;
        return this.nodeNamesUsed[r] = !0,
        r
    }
    loadGeometries(e) {
        const t = this
          , r = this.extensions
          , i = this.primitiveCache;
        function s(a) {
            return r[tr.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(a, t).then(function(l) {
                return ab(l, a, t)
            })
        }
        const o = [];
        for (let a = 0, l = e.length; a < l; a++) {
            const f = e[a]
              , h = A5(f)
              , d = i[h];
            if (d)
                o.push(d.promise);
            else {
                let p;
                f.extensions && f.extensions[tr.KHR_DRACO_MESH_COMPRESSION] ? p = s(f) : p = ab(new On, f, t),
                i[h] = {
                    primitive: f,
                    promise: p
                },
                o.push(p)
            }
        }
        return Promise.all(o)
    }
    loadMesh(e) {
        const t = this
          , r = this.json
          , i = this.extensions
          , s = r.meshes[e]
          , o = s.primitives
          , a = [];
        for (let l = 0, f = o.length; l < f; l++) {
            const h = o[l].material === void 0 ? w5(this.cache) : this.getDependency("material", o[l].material);
            a.push(h)
        }
        return a.push(t.loadGeometries(o)),
        Promise.all(a).then(function(l) {
            const f = l.slice(0, l.length - 1)
              , h = l[l.length - 1]
              , d = [];
            for (let m = 0, _ = h.length; m < _; m++) {
                const y = h[m]
                  , x = o[m];
                let S;
                const M = f[m];
                if (x.mode === uu.TRIANGLES || x.mode === uu.TRIANGLE_STRIP || x.mode === uu.TRIANGLE_FAN || x.mode === void 0)
                    S = s.isSkinnedMesh === !0 ? new ZS(y,M) : new vs(y,M),
                    S.isSkinnedMesh === !0 && !S.geometry.attributes.skinWeight.normalized && S.normalizeSkinWeights(),
                    x.mode === uu.TRIANGLE_STRIP ? S.geometry = lb(S.geometry, J2) : x.mode === uu.TRIANGLE_FAN && (S.geometry = lb(S.geometry, NS));
                else if (x.mode === uu.LINES)
                    S = new Tl(y,M);
                else if (x.mode === uu.LINE_STRIP)
                    S = new Du(y,M);
                else if (x.mode === uu.LINE_LOOP)
                    S = new $S(y,M);
                else if (x.mode === uu.POINTS)
                    S = new eM(y,M);
                else
                    throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + x.mode);
                Object.keys(S.geometry.morphAttributes).length > 0 && M5(S, s),
                S.name = t.createUniqueName(s.name || "mesh_" + e),
                ff(S, s),
                x.extensions && mp(i, S, x),
                t.assignFinalMaterial(S),
                d.push(S)
            }
            for (let m = 0, _ = d.length; m < _; m++)
                t.associations.set(d[m], {
                    meshes: e,
                    primitives: m
                });
            if (d.length === 1)
                return d[0];
            const p = new _u;
            t.associations.set(p, {
                meshes: e
            });
            for (let m = 0, _ = d.length; m < _; m++)
                p.add(d[m]);
            return p
        })
    }
    loadCamera(e) {
        let t;
        const r = this.json.cameras[e]
          , i = r[r.type];
        if (!i) {
            console.warn("THREE.GLTFLoader: Missing camera parameters.");
            return
        }
        return r.type === "perspective" ? t = new gi(y_.radToDeg(i.yfov),i.aspectRatio || 1,i.znear || 1,i.zfar || 2e6) : r.type === "orthographic" && (t = new Mu(-i.xmag,i.xmag,i.ymag,-i.ymag,i.znear,i.zfar)),
        r.name && (t.name = this.createUniqueName(r.name)),
        ff(t, r),
        Promise.resolve(t)
    }
    loadSkin(e) {
        const t = this.json.skins[e]
          , r = {
            joints: t.joints
        };
        return t.inverseBindMatrices === void 0 ? Promise.resolve(r) : this.getDependency("accessor", t.inverseBindMatrices).then(function(i) {
            return r.inverseBindMatrices = i,
            r
        })
    }
    loadAnimation(e) {
        const r = this.json.animations[e]
          , i = []
          , s = []
          , o = []
          , a = []
          , l = [];
        for (let f = 0, h = r.channels.length; f < h; f++) {
            const d = r.channels[f]
              , p = r.samplers[d.sampler]
              , m = d.target
              , _ = m.node
              , y = r.parameters !== void 0 ? r.parameters[p.input] : p.input
              , x = r.parameters !== void 0 ? r.parameters[p.output] : p.output;
            i.push(this.getDependency("node", _)),
            s.push(this.getDependency("accessor", y)),
            o.push(this.getDependency("accessor", x)),
            a.push(p),
            l.push(m)
        }
        return Promise.all([Promise.all(i), Promise.all(s), Promise.all(o), Promise.all(a), Promise.all(l)]).then(function(f) {
            const h = f[0]
              , d = f[1]
              , p = f[2]
              , m = f[3]
              , _ = f[4]
              , y = [];
            for (let S = 0, M = h.length; S < M; S++) {
                const w = h[S]
                  , T = d[S]
                  , P = p[S]
                  , I = m[S]
                  , k = _[S];
                if (w === void 0)
                    continue;
                w.updateMatrix();
                let R;
                switch ($u[k.path]) {
                case $u.weights:
                    R = wh;
                    break;
                case $u.rotation:
                    R = Pc;
                    break;
                case $u.position:
                case $u.scale:
                default:
                    R = Sh;
                    break
                }
                const O = w.name ? w.name : w.uuid
                  , H = I.interpolation !== void 0 ? x5[I.interpolation] : Hf
                  , W = [];
                $u[k.path] === $u.weights ? w.traverse(function(ne) {
                    ne.morphTargetInfluences && W.push(ne.name ? ne.name : ne.uuid)
                }) : W.push(O);
                let te = P.array;
                if (P.normalized) {
                    const ne = Ew(te.constructor)
                      , re = new Float32Array(te.length);
                    for (let pe = 0, ce = te.length; pe < ce; pe++)
                        re[pe] = te[pe] * ne;
                    te = re
                }
                for (let ne = 0, re = W.length; ne < re; ne++) {
                    const pe = new R(W[ne] + "." + $u[k.path],T.array,te,H);
                    I.interpolation === "CUBICSPLINE" && (pe.createInterpolant = function(xe) {
                        const G = this instanceof Pc ? y5 : gP;
                        return new G(this.times,this.values,this.getValueSize() / 3,xe)
                    }
                    ,
                    pe.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0),
                    y.push(pe)
                }
            }
            const x = r.name ? r.name : "animation_" + e;
            return new Mh(x,void 0,y)
        })
    }
    createNodeMesh(e) {
        const t = this.json
          , r = this
          , i = t.nodes[e];
        return i.mesh === void 0 ? null : r.getDependency("mesh", i.mesh).then(function(s) {
            const o = r._getNodeRef(r.meshCache, i.mesh, s);
            return i.weights !== void 0 && o.traverse(function(a) {
                if (a.isMesh)
                    for (let l = 0, f = i.weights.length; l < f; l++)
                        a.morphTargetInfluences[l] = i.weights[l]
            }),
            o
        })
    }
    loadNode(e) {
        const t = this.json
          , r = this.extensions
          , i = this
          , s = t.nodes[e]
          , o = s.name ? i.createUniqueName(s.name) : "";
        return function() {
            const a = []
              , l = i._invokeOne(function(f) {
                return f.createNodeMesh && f.createNodeMesh(e)
            });
            return l && a.push(l),
            s.camera !== void 0 && a.push(i.getDependency("camera", s.camera).then(function(f) {
                return i._getNodeRef(i.cameraCache, s.camera, f)
            })),
            i._invokeAll(function(f) {
                return f.createNodeAttachment && f.createNodeAttachment(e)
            }).forEach(function(f) {
                a.push(f)
            }),
            Promise.all(a)
        }().then(function(a) {
            let l;
            if (s.isBone === !0 ? l = new E_ : a.length > 1 ? l = new _u : a.length === 1 ? l = a[0] : l = new wr,
            l !== a[0])
                for (let f = 0, h = a.length; f < h; f++)
                    l.add(a[f]);
            if (s.name && (l.userData.name = s.name,
            l.name = o),
            ff(l, s),
            s.extensions && mp(r, l, s),
            s.matrix !== void 0) {
                const f = new Dn;
                f.fromArray(s.matrix),
                l.applyMatrix4(f)
            } else
                s.translation !== void 0 && l.position.fromArray(s.translation),
                s.rotation !== void 0 && l.quaternion.fromArray(s.rotation),
                s.scale !== void 0 && l.scale.fromArray(s.scale);
            return i.associations.has(l) || i.associations.set(l, {}),
            i.associations.get(l).nodes = e,
            l
        })
    }
    loadScene(e) {
        const t = this.json
          , r = this.extensions
          , i = this.json.scenes[e]
          , s = this
          , o = new _u;
        i.name && (o.name = s.createUniqueName(i.name)),
        ff(o, i),
        i.extensions && mp(r, o, i);
        const a = i.nodes || []
          , l = [];
        for (let f = 0, h = a.length; f < h; f++)
            l.push(vP(a[f], o, t, s));
        return Promise.all(l).then(function() {
            const f = h=>{
                const d = new Map;
                for (const [p,m] of s.associations)
                    (p instanceof as || p instanceof Ci) && d.set(p, m);
                return h.traverse(p=>{
                    const m = s.associations.get(p);
                    m != null && d.set(p, m)
                }
                ),
                d
            }
            ;
            return s.associations = f(o),
            o
        })
    }
}
function vP(n, e, t, r) {
    const i = t.nodes[n];
    return r.getDependency("node", n).then(function(s) {
        if (i.skin === void 0)
            return s;
        let o;
        return r.getDependency("skin", i.skin).then(function(a) {
            o = a;
            const l = [];
            for (let f = 0, h = o.joints.length; f < h; f++)
                l.push(r.getDependency("node", o.joints[f]));
            return Promise.all(l)
        }).then(function(a) {
            return s.traverse(function(l) {
                if (!l.isMesh)
                    return;
                const f = []
                  , h = [];
                for (let d = 0, p = a.length; d < p; d++) {
                    const m = a[d];
                    if (m) {
                        f.push(m);
                        const _ = new Dn;
                        o.inverseBindMatrices !== void 0 && _.fromArray(o.inverseBindMatrices.array, d * 16),
                        h.push(_)
                    } else
                        console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', o.joints[d])
                }
                l.bind(new Gm(f,h), l.matrixWorld)
            }),
            s
        })
    }).then(function(s) {
        e.add(s);
        const o = [];
        if (i.children) {
            const a = i.children;
            for (let l = 0, f = a.length; l < f; l++) {
                const h = a[l];
                o.push(vP(h, s, t, r))
            }
        }
        return Promise.all(o)
    })
}
function b5(n, e, t) {
    const r = e.attributes
      , i = new kc;
    if (r.POSITION !== void 0) {
        const a = t.json.accessors[r.POSITION]
          , l = a.min
          , f = a.max;
        if (l !== void 0 && f !== void 0) {
            if (i.set(new $(l[0],l[1],l[2]), new $(f[0],f[1],f[2])),
            a.normalized) {
                const h = Ew(Em[a.componentType]);
                i.min.multiplyScalar(h),
                i.max.multiplyScalar(h)
            }
        } else {
            console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
            return
        }
    } else
        return;
    const s = e.targets;
    if (s !== void 0) {
        const a = new $
          , l = new $;
        for (let f = 0, h = s.length; f < h; f++) {
            const d = s[f];
            if (d.POSITION !== void 0) {
                const p = t.json.accessors[d.POSITION]
                  , m = p.min
                  , _ = p.max;
                if (m !== void 0 && _ !== void 0) {
                    if (l.setX(Math.max(Math.abs(m[0]), Math.abs(_[0]))),
                    l.setY(Math.max(Math.abs(m[1]), Math.abs(_[1]))),
                    l.setZ(Math.max(Math.abs(m[2]), Math.abs(_[2]))),
                    p.normalized) {
                        const y = Ew(Em[p.componentType]);
                        l.multiplyScalar(y)
                    }
                    a.max(l)
                } else
                    console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")
            }
        }
        i.expandByVector(a)
    }
    n.boundingBox = i;
    const o = new Oc;
    i.getCenter(o.center),
    o.radius = i.min.distanceTo(i.max) / 2,
    n.boundingSphere = o
}
function ab(n, e, t) {
    const r = e.attributes
      , i = [];
    function s(o, a) {
        return t.getDependency("accessor", o).then(function(l) {
            n.setAttribute(a, l)
        })
    }
    for (const o in r) {
        const a = Cw[o] || o.toLowerCase();
        a in n.attributes || i.push(s(r[o], a))
    }
    if (e.indices !== void 0 && !n.index) {
        const o = t.getDependency("accessor", e.indices).then(function(a) {
            n.setIndex(a)
        });
        i.push(o)
    }
    return ff(n, e),
    b5(n, e, t),
    Promise.all(i).then(function() {
        return e.targets !== void 0 ? S5(n, e.targets, t) : n
    })
}
function lb(n, e) {
    let t = n.getIndex();
    if (t === null) {
        const o = []
          , a = n.getAttribute("position");
        if (a !== void 0) {
            for (let l = 0; l < a.count; l++)
                o.push(l);
            n.setIndex(o),
            t = n.getIndex()
        } else
            return console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),
            n
    }
    const r = t.count - 2
      , i = [];
    if (e === NS)
        for (let o = 1; o <= r; o++)
            i.push(t.getX(0)),
            i.push(t.getX(o)),
            i.push(t.getX(o + 1));
    else
        for (let o = 0; o < r; o++)
            o % 2 === 0 ? (i.push(t.getX(o)),
            i.push(t.getX(o + 1)),
            i.push(t.getX(o + 2))) : (i.push(t.getX(o + 2)),
            i.push(t.getX(o + 1)),
            i.push(t.getX(o)));
    i.length / 3 !== r && console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
    const s = n.clone();
    return s.setIndex(i),
    s
}
class T5 extends O3 {
    constructor(e) {
        super(e),
        this.type = ja
    }
    parse(e) {
        const a = function(w, T) {
            switch (w) {
            case 1:
                console.error("THREE.RGBELoader Read Error: " + (T || ""));
                break;
            case 2:
                console.error("THREE.RGBELoader Write Error: " + (T || ""));
                break;
            case 3:
                console.error("THREE.RGBELoader Bad File Format: " + (T || ""));
                break;
            default:
            case 4:
                console.error("THREE.RGBELoader: Error: " + (T || ""))
            }
            return -1
        }
          , d = `
`
          , p = function(w, T, P) {
            T = T || 1024;
            let k = w.pos
              , R = -1
              , O = 0
              , H = ""
              , W = String.fromCharCode.apply(null, new Uint16Array(w.subarray(k, k + 128)));
            for (; 0 > (R = W.indexOf(d)) && O < T && k < w.byteLength; )
                H += W,
                O += W.length,
                k += 128,
                W += String.fromCharCode.apply(null, new Uint16Array(w.subarray(k, k + 128)));
            return -1 < R ? (P !== !1 && (w.pos += O + R + 1),
            H + W.slice(0, R)) : !1
        }
          , m = function(w) {
            const T = /^#\?(\S+)/
              , P = /^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/
              , I = /^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/
              , k = /^\s*FORMAT=(\S+)\s*$/
              , R = /^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/
              , O = {
                valid: 0,
                string: "",
                comments: "",
                programtype: "RGBE",
                format: "",
                gamma: 1,
                exposure: 1,
                width: 0,
                height: 0
            };
            let H, W;
            if (w.pos >= w.byteLength || !(H = p(w)))
                return a(1, "no header found");
            if (!(W = H.match(T)))
                return a(3, "bad initial token");
            for (O.valid |= 1,
            O.programtype = W[1],
            O.string += H + `
`; H = p(w),
            H !== !1; ) {
                if (O.string += H + `
`,
                H.charAt(0) === "#") {
                    O.comments += H + `
`;
                    continue
                }
                if ((W = H.match(P)) && (O.gamma = parseFloat(W[1])),
                (W = H.match(I)) && (O.exposure = parseFloat(W[1])),
                (W = H.match(k)) && (O.valid |= 2,
                O.format = W[1]),
                (W = H.match(R)) && (O.valid |= 4,
                O.height = parseInt(W[1], 10),
                O.width = parseInt(W[2], 10)),
                O.valid & 2 && O.valid & 4)
                    break
            }
            return O.valid & 2 ? O.valid & 4 ? O : a(3, "missing image size specifier") : a(3, "missing format specifier")
        }
          , _ = function(w, T, P) {
            const I = T;
            if (I < 8 || I > 32767 || w[0] !== 2 || w[1] !== 2 || w[2] & 128)
                return new Uint8Array(w);
            if (I !== (w[2] << 8 | w[3]))
                return a(3, "wrong scanline width");
            const k = new Uint8Array(4 * T * P);
            if (!k.length)
                return a(4, "unable to allocate buffer space");
            let R = 0
              , O = 0;
            const H = 4 * I
              , W = new Uint8Array(4)
              , te = new Uint8Array(H);
            let ne = P;
            for (; ne > 0 && O < w.byteLength; ) {
                if (O + 4 > w.byteLength)
                    return a(1);
                if (W[0] = w[O++],
                W[1] = w[O++],
                W[2] = w[O++],
                W[3] = w[O++],
                W[0] != 2 || W[1] != 2 || (W[2] << 8 | W[3]) != I)
                    return a(3, "bad rgbe scanline format");
                let re = 0, pe;
                for (; re < H && O < w.byteLength; ) {
                    pe = w[O++];
                    const xe = pe > 128;
                    if (xe && (pe -= 128),
                    pe === 0 || re + pe > H)
                        return a(3, "bad scanline data");
                    if (xe) {
                        const G = w[O++];
                        for (let z = 0; z < pe; z++)
                            te[re++] = G
                    } else
                        te.set(w.subarray(O, O + pe), re),
                        re += pe,
                        O += pe
                }
                const ce = I;
                for (let xe = 0; xe < ce; xe++) {
                    let G = 0;
                    k[R] = te[xe + G],
                    G += I,
                    k[R + 1] = te[xe + G],
                    G += I,
                    k[R + 2] = te[xe + G],
                    G += I,
                    k[R + 3] = te[xe + G],
                    R += 4
                }
                ne--
            }
            return k
        }
          , y = function(w, T, P, I) {
            const k = w[T + 3]
              , R = Math.pow(2, k - 128) / 255;
            P[I + 0] = w[T + 0] * R,
            P[I + 1] = w[T + 1] * R,
            P[I + 2] = w[T + 2] * R,
            P[I + 3] = 1
        }
          , x = function(w, T, P, I) {
            const k = w[T + 3]
              , R = Math.pow(2, k - 128) / 255;
            P[I + 0] = Ap.toHalfFloat(Math.min(w[T + 0] * R, 65504)),
            P[I + 1] = Ap.toHalfFloat(Math.min(w[T + 1] * R, 65504)),
            P[I + 2] = Ap.toHalfFloat(Math.min(w[T + 2] * R, 65504)),
            P[I + 3] = Ap.toHalfFloat(1)
        }
          , S = new Uint8Array(e);
        S.pos = 0;
        const M = m(S);
        if (M !== -1) {
            const w = M.width
              , T = M.height
              , P = _(S.subarray(S.pos), w, T);
            if (P !== -1) {
                let I, k, R;
                switch (this.type) {
                case ya:
                    R = P.length / 4;
                    const O = new Float32Array(R * 4);
                    for (let W = 0; W < R; W++)
                        y(P, W * 4, O, W * 4);
                    I = O,
                    k = ya;
                    break;
                case ja:
                    R = P.length / 4;
                    const H = new Uint16Array(R * 4);
                    for (let W = 0; W < R; W++)
                        x(P, W * 4, H, W * 4);
                    I = H,
                    k = ja;
                    break;
                default:
                    console.error("THREE.RGBELoader: unsupported type: ", this.type);
                    break
                }
                return {
                    width: w,
                    height: T,
                    data: I,
                    header: M.string,
                    gamma: M.gamma,
                    exposure: M.exposure,
                    type: k
                }
            }
        }
        return null
    }
    setDataType(e) {
        return this.type = e,
        this
    }
    load(e, t, r, i) {
        function s(o, a) {
            switch (o.type) {
            case ya:
            case ja:
                o.encoding = bl,
                o.minFilter = si,
                o.magFilter = si,
                o.generateMipmaps = !1,
                o.flipY = !0;
                break
            }
            t && t(o, a)
        }
        return super.load(e, s, r, i)
    }
}
const Ax = new WeakMap;
class D5 extends Bo {
    constructor(e) {
        super(e),
        this.decoderPath = "",
        this.decoderConfig = {},
        this.decoderBinary = null,
        this.decoderPending = null,
        this.workerLimit = 4,
        this.workerPool = [],
        this.workerNextTaskID = 1,
        this.workerSourceURL = "",
        this.defaultAttributeIDs = {
            position: "POSITION",
            normal: "NORMAL",
            color: "COLOR",
            uv: "TEX_COORD"
        },
        this.defaultAttributeTypes = {
            position: "Float32Array",
            normal: "Float32Array",
            color: "Float32Array",
            uv: "Float32Array"
        }
    }
    setDecoderPath(e) {
        return this.decoderPath = e,
        this
    }
    setDecoderConfig(e) {
        return this.decoderConfig = e,
        this
    }
    setWorkerLimit(e) {
        return this.workerLimit = e,
        this
    }
    load(e, t, r, i) {
        const s = new Aa(this.manager);
        s.setPath(this.path),
        s.setResponseType("arraybuffer"),
        s.setRequestHeader(this.requestHeader),
        s.setWithCredentials(this.withCredentials),
        s.load(e, o=>{
            const a = {
                attributeIDs: this.defaultAttributeIDs,
                attributeTypes: this.defaultAttributeTypes,
                useUniqueIDs: !1
            };
            this.decodeGeometry(o, a).then(t).catch(i)
        }
        , r, i)
    }
    decodeDracoFile(e, t, r, i) {
        const s = {
            attributeIDs: r || this.defaultAttributeIDs,
            attributeTypes: i || this.defaultAttributeTypes,
            useUniqueIDs: !!r
        };
        this.decodeGeometry(e, s).then(t)
    }
    decodeGeometry(e, t) {
        for (const l in t.attributeTypes) {
            const f = t.attributeTypes[l];
            f.BYTES_PER_ELEMENT !== void 0 && (t.attributeTypes[l] = f.name)
        }
        const r = JSON.stringify(t);
        if (Ax.has(e)) {
            const l = Ax.get(e);
            if (l.key === r)
                return l.promise;
            if (e.byteLength === 0)
                throw new Error("THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.")
        }
        let i;
        const s = this.workerNextTaskID++
          , o = e.byteLength
          , a = this._getWorker(s, o).then(l=>(i = l,
        new Promise((f,h)=>{
            i._callbacks[s] = {
                resolve: f,
                reject: h
            },
            i.postMessage({
                type: "decode",
                id: s,
                taskConfig: t,
                buffer: e
            }, [e])
        }
        ))).then(l=>this._createGeometry(l.geometry));
        return a.catch(()=>!0).then(()=>{
            i && s && this._releaseTask(i, s)
        }
        ),
        Ax.set(e, {
            key: r,
            promise: a
        }),
        a
    }
    _createGeometry(e) {
        const t = new On;
        e.index && t.setIndex(new Dr(e.index.array,1));
        for (let r = 0; r < e.attributes.length; r++) {
            const i = e.attributes[r]
              , s = i.name
              , o = i.array
              , a = i.itemSize;
            t.setAttribute(s, new Dr(o,a))
        }
        return t
    }
    _loadLibrary(e, t) {
        const r = new Aa(this.manager);
        return r.setPath(this.decoderPath),
        r.setResponseType(t),
        r.setWithCredentials(this.withCredentials),
        new Promise((i,s)=>{
            r.load(e, i, void 0, s)
        }
        )
    }
    preload() {
        return this._initDecoder(),
        this
    }
    _initDecoder() {
        if (this.decoderPending)
            return this.decoderPending;
        const e = typeof WebAssembly != "object" || this.decoderConfig.type === "js"
          , t = [];
        return e ? t.push(this._loadLibrary("draco_decoder.js", "text")) : (t.push(this._loadLibrary("draco_wasm_wrapper.js", "text")),
        t.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"))),
        this.decoderPending = Promise.all(t).then(r=>{
            const i = r[0];
            e || (this.decoderConfig.wasmBinary = r[1]);
            const s = P5.toString()
              , o = ["/* draco decoder */", i, "", "/* worker */", s.substring(s.indexOf("{") + 1, s.lastIndexOf("}"))].join(`
`);
            this.workerSourceURL = URL.createObjectURL(new Blob([o]))
        }
        ),
        this.decoderPending
    }
    _getWorker(e, t) {
        return this._initDecoder().then(()=>{
            if (this.workerPool.length < this.workerLimit) {
                const i = new Worker(this.workerSourceURL);
                i._callbacks = {},
                i._taskCosts = {},
                i._taskLoad = 0,
                i.postMessage({
                    type: "init",
                    decoderConfig: this.decoderConfig
                }),
                i.onmessage = function(s) {
                    const o = s.data;
                    switch (o.type) {
                    case "decode":
                        i._callbacks[o.id].resolve(o);
                        break;
                    case "error":
                        i._callbacks[o.id].reject(o);
                        break;
                    default:
                        console.error('THREE.DRACOLoader: Unexpected message, "' + o.type + '"')
                    }
                }
                ,
                this.workerPool.push(i)
            } else
                this.workerPool.sort(function(i, s) {
                    return i._taskLoad > s._taskLoad ? -1 : 1
                });
            const r = this.workerPool[this.workerPool.length - 1];
            return r._taskCosts[e] = t,
            r._taskLoad += t,
            r
        }
        )
    }
    _releaseTask(e, t) {
        e._taskLoad -= e._taskCosts[t],
        delete e._callbacks[t],
        delete e._taskCosts[t]
    }
    debug() {
        console.log("Task load: ", this.workerPool.map(e=>e._taskLoad))
    }
    dispose() {
        for (let e = 0; e < this.workerPool.length; ++e)
            this.workerPool[e].terminate();
        return this.workerPool.length = 0,
        this
    }
}
function P5() {
    let n, e;
    onmessage = function(o) {
        const a = o.data;
        switch (a.type) {
        case "init":
            n = a.decoderConfig,
            e = new Promise(function(h) {
                n.onModuleLoaded = function(d) {
                    h({
                        draco: d
                    })
                }
                ,
                DracoDecoderModule(n)
            }
            );
            break;
        case "decode":
            const l = a.buffer
              , f = a.taskConfig;
            e.then(h=>{
                const d = h.draco
                  , p = new d.Decoder
                  , m = new d.DecoderBuffer;
                m.Init(new Int8Array(l), l.byteLength);
                try {
                    const _ = t(d, p, m, f)
                      , y = _.attributes.map(x=>x.array.buffer);
                    _.index && y.push(_.index.array.buffer),
                    self.postMessage({
                        type: "decode",
                        id: a.id,
                        geometry: _
                    }, y)
                } catch (_) {
                    console.error(_),
                    self.postMessage({
                        type: "error",
                        id: a.id,
                        error: _.message
                    })
                } finally {
                    d.destroy(m),
                    d.destroy(p)
                }
            }
            );
            break
        }
    }
    ;
    function t(o, a, l, f) {
        const h = f.attributeIDs
          , d = f.attributeTypes;
        let p, m;
        const _ = a.GetEncodedGeometryType(l);
        if (_ === o.TRIANGULAR_MESH)
            p = new o.Mesh,
            m = a.DecodeBufferToMesh(l, p);
        else if (_ === o.POINT_CLOUD)
            p = new o.PointCloud,
            m = a.DecodeBufferToPointCloud(l, p);
        else
            throw new Error("THREE.DRACOLoader: Unexpected geometry type.");
        if (!m.ok() || p.ptr === 0)
            throw new Error("THREE.DRACOLoader: Decoding failed: " + m.error_msg());
        const y = {
            index: null,
            attributes: []
        };
        for (const x in h) {
            const S = self[d[x]];
            let M, w;
            if (f.useUniqueIDs)
                w = h[x],
                M = a.GetAttributeByUniqueId(p, w);
            else {
                if (w = a.GetAttributeId(p, o[h[x]]),
                w === -1)
                    continue;
                M = a.GetAttribute(p, w)
            }
            y.attributes.push(i(o, a, p, x, S, M))
        }
        return _ === o.TRIANGULAR_MESH && (y.index = r(o, a, p)),
        o.destroy(p),
        y
    }
    function r(o, a, l) {
        const h = l.num_faces() * 3
          , d = h * 4
          , p = o._malloc(d);
        a.GetTrianglesUInt32Array(l, d, p);
        const m = new Uint32Array(o.HEAPF32.buffer,p,h).slice();
        return o._free(p),
        {
            array: m,
            itemSize: 1
        }
    }
    function i(o, a, l, f, h, d) {
        const p = d.num_components()
          , _ = l.num_points() * p
          , y = _ * h.BYTES_PER_ELEMENT
          , x = s(o, h)
          , S = o._malloc(y);
        a.GetAttributeDataArrayForAllPoints(l, d, x, y, S);
        const M = new h(o.HEAPF32.buffer,S,_).slice();
        return o._free(S),
        {
            name: f,
            array: M,
            itemSize: p
        }
    }
    function s(o, a) {
        switch (a) {
        case Float32Array:
            return o.DT_FLOAT32;
        case Int8Array:
            return o.DT_INT8;
        case Int16Array:
            return o.DT_INT16;
        case Int32Array:
            return o.DT_INT32;
        case Uint8Array:
            return o.DT_UINT8;
        case Uint16Array:
            return o.DT_UINT16;
        case Uint32Array:
            return o.DT_UINT32
        }
    }
}
let A0;
const Cx = ()=>{
    if (A0)
        return A0;
    const n = "B9h9z9tFBBBF8fL9gBB9gLaaaaaFa9gEaaaB9gFaFa9gEaaaFaEMcBFFFGGGEIIILF9wFFFLEFBFKNFaFCx/IFMO/LFVK9tv9t9vq95GBt9f9f939h9z9t9f9j9h9s9s9f9jW9vq9zBBp9tv9z9o9v9wW9f9kv9j9v9kv9WvqWv94h919m9mvqBF8Z9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv94h919m9mvqBGy9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv949TvZ91v9u9jvBEn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9P9jWBIi9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9R919hWBLn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9F949wBKI9z9iqlBOc+x8ycGBM/qQFTa8jUUUUBCU/EBlHL8kUUUUBC9+RKGXAGCFJAI9LQBCaRKAE2BBC+gF9HQBALAEAIJHOAGlAGTkUUUBRNCUoBAG9uC/wgBZHKCUGAKCUG9JyRVAECFJRICBRcGXEXAcAF9PQFAVAFAclAcAVJAF9JyRMGXGXAG9FQBAMCbJHKC9wZRSAKCIrCEJCGrRQANCUGJRfCBRbAIRTEXGXAOATlAQ9PQBCBRISEMATAQJRIGXAS9FQBCBRtCBREEXGXAOAIlCi9PQBCBRISLMANCU/CBJAEJRKGXGXGXGXGXATAECKrJ2BBAtCKZrCEZfIBFGEBMAKhB83EBAKCNJhB83EBSEMAKAI2BIAI2BBHmCKrHYAYCE6HYy86BBAKCFJAICIJAYJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCGJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCEJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCIJAYAmJHY2BBAI2BFHmCKrHPAPCE6HPy86BBAKCLJAYAPJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCKJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCOJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCNJAYAmJHY2BBAI2BGHmCKrHPAPCE6HPy86BBAKCVJAYAPJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCcJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCMJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCSJAYAmJHm2BBAI2BEHICKrHYAYCE6HYy86BBAKCQJAmAYJHm2BBAICIrCEZHYAYCE6HYy86BBAKCfJAmAYJHm2BBAICGrCEZHYAYCE6HYy86BBAKCbJAmAYJHK2BBAICEZHIAICE6HIy86BBAKAIJRISGMAKAI2BNAI2BBHmCIrHYAYCb6HYy86BBAKCFJAICNJAYJHY2BBAmCbZHmAmCb6Hmy86BBAKCGJAYAmJHm2BBAI2BFHYCIrHPAPCb6HPy86BBAKCEJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCIJAmAYJHm2BBAI2BGHYCIrHPAPCb6HPy86BBAKCLJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCKJAmAYJHm2BBAI2BEHYCIrHPAPCb6HPy86BBAKCOJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCNJAmAYJHm2BBAI2BIHYCIrHPAPCb6HPy86BBAKCVJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCcJAmAYJHm2BBAI2BLHYCIrHPAPCb6HPy86BBAKCMJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCSJAmAYJHm2BBAI2BKHYCIrHPAPCb6HPy86BBAKCQJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCfJAmAYJHm2BBAI2BOHICIrHYAYCb6HYy86BBAKCbJAmAYJHK2BBAICbZHIAICb6HIy86BBAKAIJRISFMAKAI8pBB83BBAKCNJAICNJ8pBB83BBAICTJRIMAtCGJRtAECTJHEAS9JQBMMGXAIQBCBRISEMGXAM9FQBANAbJ2BBRtCBRKAfREEXAEANCU/CBJAKJ2BBHTCFrCBATCFZl9zAtJHt86BBAEAGJREAKCFJHKAM9HQBMMAfCFJRfAIRTAbCFJHbAG9HQBMMABAcAG9sJANCUGJAMAG9sTkUUUBpANANCUGJAMCaJAG9sJAGTkUUUBpMAMCBAIyAcJRcAIQBMC9+RKSFMCBC99AOAIlAGCAAGCA9Ly6yRKMALCU/EBJ8kUUUUBAKM+OmFTa8jUUUUBCoFlHL8kUUUUBC9+RKGXAFCE9uHOCtJAI9LQBCaRKAE2BBHNC/wFZC/gF9HQBANCbZHVCF9LQBALCoBJCgFCUFT+JUUUBpALC84Jha83EBALC8wJha83EBALC8oJha83EBALCAJha83EBALCiJha83EBALCTJha83EBALha83ENALha83EBAEAIJC9wJRcAECFJHNAOJRMGXAF9FQBCQCbAVCF6yRSABRECBRVCBRQCBRfCBRICBRKEXGXAMAcuQBC9+RKSEMGXGXAN2BBHOC/vF9LQBALCoBJAOCIrCa9zAKJCbZCEWJHb8oGIRTAb8oGBRtGXAOCbZHbAS9PQBALAOCa9zAIJCbZCGWJ8oGBAVAbyROAb9FRbGXGXAGCG9HQBABAt87FBABCIJAO87FBABCGJAT87FBSFMAEAtjGBAECNJAOjGBAECIJATjGBMAVAbJRVALCoBJAKCEWJHmAOjGBAmATjGIALAICGWJAOjGBALCoBJAKCFJCbZHKCEWJHTAtjGBATAOjGIAIAbJRIAKCFJRKSGMGXGXAbCb6QBAQAbJAbC989zJCFJRQSFMAM1BBHbCgFZROGXGXAbCa9MQBAMCFJRMSFMAM1BFHbCgBZCOWAOCgBZqROGXAbCa9MQBAMCGJRMSFMAM1BGHbCgBZCfWAOqROGXAbCa9MQBAMCEJRMSFMAM1BEHbCgBZCdWAOqROGXAbCa9MQBAMCIJRMSFMAM2BIC8cWAOqROAMCLJRMMAOCFrCBAOCFZl9zAQJRQMGXGXAGCG9HQBABAt87FBABCIJAQ87FBABCGJAT87FBSFMAEAtjGBAECNJAQjGBAECIJATjGBMALCoBJAKCEWJHOAQjGBAOATjGIALAICGWJAQjGBALCoBJAKCFJCbZHKCEWJHOAtjGBAOAQjGIAICFJRIAKCFJRKSFMGXAOCDF9LQBALAIAcAOCbZJ2BBHbCIrHTlCbZCGWJ8oGBAVCFJHtATyROALAIAblCbZCGWJ8oGBAtAT9FHmJHtAbCbZHTyRbAT9FRTGXGXAGCG9HQBABAV87FBABCIJAb87FBABCGJAO87FBSFMAEAVjGBAECNJAbjGBAECIJAOjGBMALAICGWJAVjGBALCoBJAKCEWJHYAOjGBAYAVjGIALAICFJHICbZCGWJAOjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAIAmJCbZHICGWJAbjGBALCoBJAKCGJCbZHKCEWJHOAVjGBAOAbjGIAKCFJRKAIATJRIAtATJRVSFMAVCBAM2BBHYyHTAOC/+F6HPJROAYCbZRtGXGXAYCIrHmQBAOCFJRbSFMAORbALAIAmlCbZCGWJ8oGBROMGXGXAtQBAbCFJRVSFMAbRVALAIAYlCbZCGWJ8oGBRbMGXGXAP9FQBAMCFJRYSFMAM1BFHYCgFZRTGXGXAYCa9MQBAMCGJRYSFMAM1BGHYCgBZCOWATCgBZqRTGXAYCa9MQBAMCEJRYSFMAM1BEHYCgBZCfWATqRTGXAYCa9MQBAMCIJRYSFMAM1BIHYCgBZCdWATqRTGXAYCa9MQBAMCLJRYSFMAMCKJRYAM2BLC8cWATqRTMATCFrCBATCFZl9zAQJHQRTMGXGXAmCb6QBAYRPSFMAY1BBHMCgFZROGXGXAMCa9MQBAYCFJRPSFMAY1BFHMCgBZCOWAOCgBZqROGXAMCa9MQBAYCGJRPSFMAY1BGHMCgBZCfWAOqROGXAMCa9MQBAYCEJRPSFMAY1BEHMCgBZCdWAOqROGXAMCa9MQBAYCIJRPSFMAYCLJRPAY2BIC8cWAOqROMAOCFrCBAOCFZl9zAQJHQROMGXGXAtCb6QBAPRMSFMAP1BBHMCgFZRbGXGXAMCa9MQBAPCFJRMSFMAP1BFHMCgBZCOWAbCgBZqRbGXAMCa9MQBAPCGJRMSFMAP1BGHMCgBZCfWAbqRbGXAMCa9MQBAPCEJRMSFMAP1BEHMCgBZCdWAbqRbGXAMCa9MQBAPCIJRMSFMAPCLJRMAP2BIC8cWAbqRbMAbCFrCBAbCFZl9zAQJHQRbMGXGXAGCG9HQBABAT87FBABCIJAb87FBABCGJAO87FBSFMAEATjGBAECNJAbjGBAECIJAOjGBMALCoBJAKCEWJHYAOjGBAYATjGIALAICGWJATjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAICFJHICbZCGWJAOjGBALCoBJAKCGJCbZCEWJHOATjGBAOAbjGIALAIAm9FAmCb6qJHICbZCGWJAbjGBAIAt9FAtCb6qJRIAKCEJRKMANCFJRNABCKJRBAECSJREAKCbZRKAICbZRIAfCEJHfAF9JQBMMCBC99AMAc6yRKMALCoFJ8kUUUUBAKM/tIFGa8jUUUUBCTlRLC9+RKGXAFCLJAI9LQBCaRKAE2BBC/+FZC/QF9HQBALhB83ENAECFJRKAEAIJC98JREGXAF9FQBGXAGCG6QBEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMALCNJAICFZCGWqHGAICGrCBAICFrCFZl9zAG8oGBJHIjGBABAIjGBABCIJRBAFCaJHFQBSGMMEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMABAICGrCBAICFrCFZl9zALCNJAICFZCGWqHI8oGBJHG87FBAIAGjGBABCGJRBAFCaJHFQBMMCBC99AKAE6yRKMAKM+lLKFaF99GaG99FaG99GXGXAGCI9HQBAF9FQFEXGXGX9DBBB8/9DBBB+/ABCGJHG1BB+yAB1BBHE+yHI+L+TABCFJHL1BBHK+yHO+L+THN9DBBBB9gHVyAN9DBB/+hANAN+U9DBBBBANAVyHcAc+MHMAECa3yAI+SHIAI+UAcAMAKCa3yAO+SHcAc+U+S+S+R+VHO+U+SHN+L9DBBB9P9d9FQBAN+oRESFMCUUUU94REMAGAE86BBGXGX9DBBB8/9DBBB+/Ac9DBBBB9gyAcAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMALAG86BBGXGX9DBBB8/9DBBB+/AI9DBBBB9gyAIAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMABAG86BBABCIJRBAFCaJHFQBSGMMAF9FQBEXGXGX9DBBB8/9DBBB+/ABCIJHG8uFB+yAB8uFBHE+yHI+L+TABCGJHL8uFBHK+yHO+L+THN9DBBBB9gHVyAN9DB/+g6ANAN+U9DBBBBANAVyHcAc+MHMAECa3yAI+SHIAI+UAcAMAKCa3yAO+SHcAc+U+S+S+R+VHO+U+SHN+L9DBBB9P9d9FQBAN+oRESFMCUUUU94REMAGAE87FBGXGX9DBBB8/9DBBB+/Ac9DBBBB9gyAcAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMALAG87FBGXGX9DBBB8/9DBBB+/AI9DBBBB9gyAIAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMABAG87FBABCNJRBAFCaJHFQBMMM/SEIEaE99EaF99GXAF9FQBCBREABRIEXGXGX9D/zI818/AICKJ8uFBHLCEq+y+VHKAI8uFB+y+UHO9DB/+g6+U9DBBB8/9DBBB+/AO9DBBBB9gy+SHN+L9DBBB9P9d9FQBAN+oRVSFMCUUUU94RVMAICIJ8uFBRcAICGJ8uFBRMABALCFJCEZAEqCFWJAV87FBGXGXAKAM+y+UHN9DB/+g6+U9DBBB8/9DBBB+/AN9DBBBB9gy+SHS+L9DBBB9P9d9FQBAS+oRMSFMCUUUU94RMMABALCGJCEZAEqCFWJAM87FBGXGXAKAc+y+UHK9DB/+g6+U9DBBB8/9DBBB+/AK9DBBBB9gy+SHS+L9DBBB9P9d9FQBAS+oRcSFMCUUUU94RcMABALCaJCEZAEqCFWJAc87FBGXGX9DBBU8/AOAO+U+TANAN+U+TAKAK+U+THO9DBBBBAO9DBBBB9gy+R9DB/+g6+U9DBBB8/+SHO+L9DBBB9P9d9FQBAO+oRcSFMCUUUU94RcMABALCEZAEqCFWJAc87FBAICNJRIAECIJREAFCaJHFQBMMM9JBGXAGCGrAF9sHF9FQBEXABAB8oGBHGCNWCN91+yAGCi91CnWCUUU/8EJ+++U84GBABCIJRBAFCaJHFQBMMM9TFEaCBCB8oGUkUUBHFABCEJC98ZJHBjGUkUUBGXGXAB8/BCTWHGuQBCaREABAGlCggEJCTrXBCa6QFMAFREMAEM/lFFFaGXGXAFABqCEZ9FQBABRESFMGXGXAGCT9PQBABRESFMABREEXAEAF8oGBjGBAECIJAFCIJ8oGBjGBAECNJAFCNJ8oGBjGBAECSJAFCSJ8oGBjGBAECTJREAFCTJRFAGC9wJHGCb9LQBMMAGCI9JQBEXAEAF8oGBjGBAFCIJRFAECIJREAGC98JHGCE9LQBMMGXAG9FQBEXAEAF2BB86BBAECFJREAFCFJRFAGCaJHGQBMMABMoFFGaGXGXABCEZ9FQBABRESFMAFCgFZC+BwsN9sRIGXGXAGCT9PQBABRESFMABREEXAEAIjGBAECSJAIjGBAECNJAIjGBAECIJAIjGBAECTJREAGC9wJHGCb9LQBMMAGCI9JQBEXAEAIjGBAECIJREAGC98JHGCE9LQBMMGXAG9FQBEXAEAF86BBAECFJREAGCaJHGQBMMABMMMFBCUNMIT9kBB"
      , e = "B9h9z9tFBBBFiI9gBB9gLaaaaaFa9gEaaaB9gFaFaEMcBBFBFFGGGEILF9wFFFLEFBFKNFaFCx/aFMO/LFVK9tv9t9vq95GBt9f9f939h9z9t9f9j9h9s9s9f9jW9vq9zBBp9tv9z9o9v9wW9f9kv9j9v9kv9WvqWv94h919m9mvqBG8Z9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv94h919m9mvqBIy9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv949TvZ91v9u9jvBLn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9P9jWBKi9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9R919hWBOn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9F949wBNI9z9iqlBVc+N9IcIBTEM9+FLa8jUUUUBCTlRBCBRFEXCBRGCBREEXABCNJAGJAECUaAFAGrCFZHIy86BBAEAIJREAGCFJHGCN9HQBMAFCx+YUUBJAE86BBAFCEWCxkUUBJAB8pEN83EBAFCFJHFCUG9HQBMMk8lLbaE97F9+FaL978jUUUUBCU/KBlHL8kUUUUBC9+RKGXAGCFJAI9LQBCaRKAE2BBC+gF9HQBALAEAIJHOAGlAG/8cBBCUoBAG9uC/wgBZHKCUGAKCUG9JyRNAECFJRKCBRVGXEXAVAF9PQFANAFAVlAVANJAF9JyRcGXGXAG9FQBAcCbJHIC9wZHMCE9sRSAMCFWRQAICIrCEJCGrRfCBRbEXAKRTCBRtGXEXGXAOATlAf9PQBCBRKSLMALCU/CBJAtAM9sJRmATAfJRKCBREGXAMCoB9JQBAOAKlC/gB9JQBCBRIEXAmAIJREGXGXGXGXGXATAICKrJ2BBHYCEZfIBFGEBMAECBDtDMIBSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAEAKDBBBDMIBAKCTJRKMGXGXGXGXGXAYCGrCEZfIBFGEBMAECBDtDMITSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMITAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMITAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAEAKDBBBDMITAKCTJRKMGXGXGXGXGXAYCIrCEZfIBFGEBMAECBDtDMIASEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIAAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIAAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAEAKDBBBDMIAAKCTJRKMGXGXGXGXGXAYCKrfIBFGEBMAECBDtDMI8wSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHYCEWCxkUUBJDBEBAYCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHYCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMI8wAKCIJAeDeBJAYCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHYCEWCxkUUBJDBEBAYCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHYCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMI8wAKCNJAeDeBJAYCx+YUUBJ2BBJRKSFMAEAKDBBBDMI8wAKCTJRKMAICoBJREAICUFJAM9LQFAERIAOAKlC/fB9LQBMMGXAEAM9PQBAECErRIEXGXAOAKlCi9PQBCBRKSOMAmAEJRYGXGXGXGXGXATAECKrJ2BBAICKZrCEZfIBFGEBMAYCBDtDMIBSEMAYAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAYAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAYAKDBBBDMIBAKCTJRKMAICGJRIAECTJHEAM9JQBMMGXAK9FQBAKRTAtCFJHtCI6QGSFMMCBRKSEMGXAM9FQBALCUGJAbJREALAbJDBGBReCBRYEXAEALCU/CBJAYJHIDBIBHdCFD9tAdCFDbHPD9OD9hD9RHdAIAMJDBIBH8ZCFD9tA8ZAPD9OD9hD9RH8ZDQBTFtGmEYIPLdKeOnHpAIAQJDBIBHyCFD9tAyAPD9OD9hD9RHyAIASJDBIBH8cCFD9tA8cAPD9OD9hD9RH8cDQBTFtGmEYIPLdKeOnH8dDQBFTtGEmYILPdKOenHPAPDQBFGEBFGEBFGEBFGEAeD9uHeDyBjGBAEAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJHIAeApA8dDQNVi8ZcMpySQ8c8dfb8e8fHPAPDQBFGEBFGEBFGEBFGED9uHeDyBjGBAIAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJHIAeAdA8ZDQNiV8ZcpMyS8cQ8df8eb8fHdAyA8cDQNiV8ZcpMyS8cQ8df8eb8fH8ZDQBFTtGEmYILPdKOenHPAPDQBFGEBFGEBFGEBFGED9uHeDyBjGBAIAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJHIAeAdA8ZDQNVi8ZcMpySQ8c8dfb8e8fHPAPDQBFGEBFGEBFGEBFGED9uHeDyBjGBAIAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJREAYCTJHYAM9JQBMMAbCIJHbAG9JQBMMABAVAG9sJALCUGJAcAG9s/8cBBALALCUGJAcCaJAG9sJAG/8cBBMAcCBAKyAVJRVAKQBMC9+RKSFMCBC99AOAKlAGCAAGCA9Ly6yRKMALCU/KBJ8kUUUUBAKMNBT+BUUUBM+KmFTa8jUUUUBCoFlHL8kUUUUBC9+RKGXAFCE9uHOCtJAI9LQBCaRKAE2BBHNC/wFZC/gF9HQBANCbZHVCF9LQBALCoBJCgFCUF/8MBALC84Jha83EBALC8wJha83EBALC8oJha83EBALCAJha83EBALCiJha83EBALCTJha83EBALha83ENALha83EBAEAIJC9wJRcAECFJHNAOJRMGXAF9FQBCQCbAVCF6yRSABRECBRVCBRQCBRfCBRICBRKEXGXAMAcuQBC9+RKSEMGXGXAN2BBHOC/vF9LQBALCoBJAOCIrCa9zAKJCbZCEWJHb8oGIRTAb8oGBRtGXAOCbZHbAS9PQBALAOCa9zAIJCbZCGWJ8oGBAVAbyROAb9FRbGXGXAGCG9HQBABAt87FBABCIJAO87FBABCGJAT87FBSFMAEAtjGBAECNJAOjGBAECIJATjGBMAVAbJRVALCoBJAKCEWJHmAOjGBAmATjGIALAICGWJAOjGBALCoBJAKCFJCbZHKCEWJHTAtjGBATAOjGIAIAbJRIAKCFJRKSGMGXGXAbCb6QBAQAbJAbC989zJCFJRQSFMAM1BBHbCgFZROGXGXAbCa9MQBAMCFJRMSFMAM1BFHbCgBZCOWAOCgBZqROGXAbCa9MQBAMCGJRMSFMAM1BGHbCgBZCfWAOqROGXAbCa9MQBAMCEJRMSFMAM1BEHbCgBZCdWAOqROGXAbCa9MQBAMCIJRMSFMAM2BIC8cWAOqROAMCLJRMMAOCFrCBAOCFZl9zAQJRQMGXGXAGCG9HQBABAt87FBABCIJAQ87FBABCGJAT87FBSFMAEAtjGBAECNJAQjGBAECIJATjGBMALCoBJAKCEWJHOAQjGBAOATjGIALAICGWJAQjGBALCoBJAKCFJCbZHKCEWJHOAtjGBAOAQjGIAICFJRIAKCFJRKSFMGXAOCDF9LQBALAIAcAOCbZJ2BBHbCIrHTlCbZCGWJ8oGBAVCFJHtATyROALAIAblCbZCGWJ8oGBAtAT9FHmJHtAbCbZHTyRbAT9FRTGXGXAGCG9HQBABAV87FBABCIJAb87FBABCGJAO87FBSFMAEAVjGBAECNJAbjGBAECIJAOjGBMALAICGWJAVjGBALCoBJAKCEWJHYAOjGBAYAVjGIALAICFJHICbZCGWJAOjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAIAmJCbZHICGWJAbjGBALCoBJAKCGJCbZHKCEWJHOAVjGBAOAbjGIAKCFJRKAIATJRIAtATJRVSFMAVCBAM2BBHYyHTAOC/+F6HPJROAYCbZRtGXGXAYCIrHmQBAOCFJRbSFMAORbALAIAmlCbZCGWJ8oGBROMGXGXAtQBAbCFJRVSFMAbRVALAIAYlCbZCGWJ8oGBRbMGXGXAP9FQBAMCFJRYSFMAM1BFHYCgFZRTGXGXAYCa9MQBAMCGJRYSFMAM1BGHYCgBZCOWATCgBZqRTGXAYCa9MQBAMCEJRYSFMAM1BEHYCgBZCfWATqRTGXAYCa9MQBAMCIJRYSFMAM1BIHYCgBZCdWATqRTGXAYCa9MQBAMCLJRYSFMAMCKJRYAM2BLC8cWATqRTMATCFrCBATCFZl9zAQJHQRTMGXGXAmCb6QBAYRPSFMAY1BBHMCgFZROGXGXAMCa9MQBAYCFJRPSFMAY1BFHMCgBZCOWAOCgBZqROGXAMCa9MQBAYCGJRPSFMAY1BGHMCgBZCfWAOqROGXAMCa9MQBAYCEJRPSFMAY1BEHMCgBZCdWAOqROGXAMCa9MQBAYCIJRPSFMAYCLJRPAY2BIC8cWAOqROMAOCFrCBAOCFZl9zAQJHQROMGXGXAtCb6QBAPRMSFMAP1BBHMCgFZRbGXGXAMCa9MQBAPCFJRMSFMAP1BFHMCgBZCOWAbCgBZqRbGXAMCa9MQBAPCGJRMSFMAP1BGHMCgBZCfWAbqRbGXAMCa9MQBAPCEJRMSFMAP1BEHMCgBZCdWAbqRbGXAMCa9MQBAPCIJRMSFMAPCLJRMAP2BIC8cWAbqRbMAbCFrCBAbCFZl9zAQJHQRbMGXGXAGCG9HQBABAT87FBABCIJAb87FBABCGJAO87FBSFMAEATjGBAECNJAbjGBAECIJAOjGBMALCoBJAKCEWJHYAOjGBAYATjGIALAICGWJATjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAICFJHICbZCGWJAOjGBALCoBJAKCGJCbZCEWJHOATjGBAOAbjGIALAIAm9FAmCb6qJHICbZCGWJAbjGBAIAt9FAtCb6qJRIAKCEJRKMANCFJRNABCKJRBAECSJREAKCbZRKAICbZRIAfCEJHfAF9JQBMMCBC99AMAc6yRKMALCoFJ8kUUUUBAKM/tIFGa8jUUUUBCTlRLC9+RKGXAFCLJAI9LQBCaRKAE2BBC/+FZC/QF9HQBALhB83ENAECFJRKAEAIJC98JREGXAF9FQBGXAGCG6QBEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMALCNJAICFZCGWqHGAICGrCBAICFrCFZl9zAG8oGBJHIjGBABAIjGBABCIJRBAFCaJHFQBSGMMEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMABAICGrCBAICFrCFZl9zALCNJAICFZCGWqHI8oGBJHG87FBAIAGjGBABCGJRBAFCaJHFQBMMCBC99AKAE6yRKMAKM/dLEK97FaF97GXGXAGCI9HQBAF9FQFCBRGEXABABDBBBHECiD+rFCiD+sFD/6FHIAECND+rFCiD+sFD/6FAID/gFAECTD+rFCiD+sFD/6FHLD/gFD/kFD/lFHKCBDtD+2FHOAICUUUU94DtHND9OD9RD/kFHI9DBB/+hDYAIAID/mFAKAKD/mFALAOALAND9OD9RD/kFHIAID/mFD/kFD/kFD/jFD/nFHLD/mF9DBBX9LDYHOD/kFCgFDtD9OAECUUU94DtD9OD9QAIALD/mFAOD/kFCND+rFCU/+EDtD9OD9QAKALD/mFAOD/kFCTD+rFCUU/8ODtD9OD9QDMBBABCTJRBAGCIJHGAF9JQBSGMMAF9FQBCBRGEXABCTJHVAVDBBBHECBDtHOCUU98D8cFCUU98D8cEHND9OABDBBBHKAEDQILKOSQfbPden8c8d8e8fCggFDtD9OD/6FAKAEDQBFGENVcMTtmYi8ZpyHECTD+sFD/6FHID/gFAECTD+rFCTD+sFD/6FHLD/gFD/kFD/lFHE9DB/+g6DYALAEAOD+2FHOALCUUUU94DtHcD9OD9RD/kFHLALD/mFAEAED/mFAIAOAIAcD9OD9RD/kFHEAED/mFD/kFD/kFD/jFD/nFHID/mF9DBBX9LDYHOD/kFCTD+rFALAID/mFAOD/kFCggEDtD9OD9QHLAEAID/mFAOD/kFCaDbCBDnGCBDnECBDnKCBDnOCBDncCBDnMCBDnfCBDnbD9OHEDQNVi8ZcMpySQ8c8dfb8e8fD9QDMBBABAKAND9OALAEDQBFTtGEmYILPdKOenD9QDMBBABCAJRBAGCIJHGAF9JQBMMM/hEIGaF97FaL978jUUUUBCTlREGXAF9FQBCBRIEXAEABDBBBHLABCTJHKDBBBHODQILKOSQfbPden8c8d8e8fHNCTD+sFHVCID+rFDMIBAB9DBBU8/DY9D/zI818/DYAVCEDtD9QD/6FD/nFHVALAODQBFGENVcMTtmYi8ZpyHLCTD+rFCTD+sFD/6FD/mFHOAOD/mFAVALCTD+sFD/6FD/mFHcAcD/mFAVANCTD+rFCTD+sFD/6FD/mFHNAND/mFD/kFD/kFD/lFCBDtD+4FD/jF9DB/+g6DYHVD/mF9DBBX9LDYHLD/kFCggEDtHMD9OAcAVD/mFALD/kFCTD+rFD9QHcANAVD/mFALD/kFCTD+rFAOAVD/mFALD/kFAMD9OD9QHVDQBFTtGEmYILPdKOenHLD8dBAEDBIBDyB+t+J83EBABCNJALD8dFAEDBIBDyF+t+J83EBAKAcAVDQNVi8ZcMpySQ8c8dfb8e8fHVD8dBAEDBIBDyG+t+J83EBABCiJAVD8dFAEDBIBDyE+t+J83EBABCAJRBAICIJHIAF9JQBMMM9jFF97GXAGCGrAF9sHG9FQBCBRFEXABABDBBBHECND+rFCND+sFD/6FAECiD+sFCnD+rFCUUU/8EDtD+uFD/mFDMBBABCTJRBAFCIJHFAG9JQBMMM9TFEaCBCB8oGUkUUBHFABCEJC98ZJHBjGUkUUBGXGXAB8/BCTWHGuQBCaREABAGlCggEJCTrXBCa6QFMAFREMAEMMMFBCUNMIT9tBB"
      , t = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 3, 2, 0, 0, 5, 3, 1, 0, 1, 12, 1, 0, 10, 22, 2, 12, 0, 65, 0, 65, 0, 65, 0, 252, 10, 0, 0, 11, 7, 0, 65, 0, 253, 15, 26, 11])
      , r = new Uint8Array([32, 0, 65, 253, 3, 1, 2, 34, 4, 106, 6, 5, 11, 8, 7, 20, 13, 33, 12, 16, 128, 9, 116, 64, 19, 113, 127, 15, 10, 21, 22, 14, 255, 66, 24, 54, 136, 107, 18, 23, 192, 26, 114, 118, 132, 17, 77, 101, 130, 144, 27, 87, 131, 44, 45, 74, 156, 154, 70, 167]);
    if (typeof WebAssembly != "object")
        return {
            supported: !1
        };
    let i = n;
    WebAssembly.validate(t) && (i = e);
    let s;
    const o = WebAssembly.instantiate(a(i), {}).then(d=>{
        s = d.instance,
        s.exports.__wasm_call_ctors()
    }
    );
    function a(d) {
        const p = new Uint8Array(d.length);
        for (let _ = 0; _ < d.length; ++_) {
            const y = d.charCodeAt(_);
            p[_] = y > 96 ? y - 71 : y > 64 ? y - 65 : y > 47 ? y + 4 : y > 46 ? 63 : 62
        }
        let m = 0;
        for (let _ = 0; _ < d.length; ++_)
            p[m++] = p[_] < 60 ? r[p[_]] : (p[_] - 60) * 64 + p[++_];
        return p.buffer.slice(0, m)
    }
    function l(d, p, m, _, y, x) {
        const S = s.exports.sbrk
          , M = m + 3 & -4
          , w = S(M * _)
          , T = S(y.length)
          , P = new Uint8Array(s.exports.memory.buffer);
        P.set(y, T);
        const I = d(w, m, _, T, y.length);
        if (I === 0 && x && x(w, M, _),
        p.set(P.subarray(w, w + m * _)),
        S(w - S(0)),
        I !== 0)
            throw new Error(`Malformed buffer data: ${I}`)
    }
    const f = {
        0: "",
        1: "meshopt_decodeFilterOct",
        2: "meshopt_decodeFilterQuat",
        3: "meshopt_decodeFilterExp",
        NONE: "",
        OCTAHEDRAL: "meshopt_decodeFilterOct",
        QUATERNION: "meshopt_decodeFilterQuat",
        EXPONENTIAL: "meshopt_decodeFilterExp"
    }
      , h = {
        0: "meshopt_decodeVertexBuffer",
        1: "meshopt_decodeIndexBuffer",
        2: "meshopt_decodeIndexSequence",
        ATTRIBUTES: "meshopt_decodeVertexBuffer",
        TRIANGLES: "meshopt_decodeIndexBuffer",
        INDICES: "meshopt_decodeIndexSequence"
    };
    return A0 = {
        ready: o,
        supported: !0,
        decodeVertexBuffer(d, p, m, _, y) {
            l(s.exports.meshopt_decodeVertexBuffer, d, p, m, _, s.exports[f[y]])
        },
        decodeIndexBuffer(d, p, m, _) {
            l(s.exports.meshopt_decodeIndexBuffer, d, p, m, _)
        },
        decodeIndexSequence(d, p, m, _) {
            l(s.exports.meshopt_decodeIndexSequence, d, p, m, _)
        },
        decodeGltfBuffer(d, p, m, _, y, x) {
            l(s.exports[h[y]], d, p, m, _, s.exports[f[x]])
        }
    },
    A0
}
;
function R5(n, e, t, r) {
    const i = class extends el {
        constructor(o={}) {
            const a = Object.entries(n);
            super({
                uniforms: a.reduce((l,[f,h])=>{
                    const d = WS.clone({
                        [f]: {
                            value: h
                        }
                    });
                    return {
                        ...l,
                        ...d
                    }
                }
                , {}),
                vertexShader: e,
                fragmentShader: t
            }),
            this.key = "",
            a.forEach(([l])=>Object.defineProperty(this, l, {
                get: ()=>this.uniforms[l].value,
                set: f=>this.uniforms[l].value = f
            })),
            Object.assign(this, o),
            r && r(this)
        }
    }
    ;
    return i.key = y_.generateUUID(),
    i
}
let C0 = null;
function _P(n, e, t) {
    return r=>{
        t && t(r),
        n && (C0 || (C0 = new D5),
        C0.setDecoderPath(typeof n == "string" ? n : "https://www.gstatic.com/draco/versioned/decoders/1.4.3/"),
        r.setDRACOLoader(C0)),
        e && r.setMeshoptDecoder(typeof Cx == "function" ? Cx() : Cx)
    }
}
function ji(n, e=!0, t=!0, r) {
    return Nh(TM, n, _P(e, t, r))
}
ji.preload = (n,e=!0,t=!0,r)=>Nh.preload(TM, n, _P(e, t, r));
ji.clear = n=>Nh.clear(TM, n);
function ub(n, e, t) {
    const {gl: r, size: i, viewport: s} = pa()
      , o = typeof n == "number" ? n : i.width * s.dpr
      , a = typeof e == "number" ? e : i.height * s.dpr
      , l = (typeof n == "number" ? t : n) || {}
      , {samples: f=0, depth: h, ...d} = l
      , p = we.useMemo(()=>{
        let m;
        return m = new $a(o,a,{
            minFilter: si,
            magFilter: si,
            encoding: r.outputEncoding,
            type: ja,
            ...d
        }),
        h && (m.depthTexture = new KS(o,a,ya)),
        m.samples = f,
        m
    }
    , []);
    return we.useLayoutEffect(()=>{
        p.setSize(o, a),
        f && (p.samples = f)
    }
    , [f, p, o, a]),
    we.useEffect(()=>()=>p.dispose(), []),
    p
}
const B5 = we.forwardRef(({makeDefault: n, events: e, camera: t, regress: r, domElement: i, enableDamping: s=!0, onChange: o, onStart: a, onEnd: l, ...f},h)=>{
    const d = pa(I=>I.invalidate)
      , p = pa(I=>I.camera)
      , m = pa(I=>I.gl)
      , _ = pa(I=>I.events)
      , y = pa(I=>I.setEvents)
      , x = pa(I=>I.set)
      , S = pa(I=>I.get)
      , M = pa(I=>I.performance)
      , w = t || p
      , T = i || _.connected || m.domElement
      , P = we.useMemo(()=>new ZU(w), [w]);
    return I_(()=>{
        P.enabled && P.update()
    }
    , -1),
    we.useEffect(()=>(P.connect(T),
    ()=>void P.dispose()), [T, r, P, d]),
    we.useEffect(()=>{
        e && y({
            enabled: !0
        });
        const I = O=>{
            d(),
            r && M.regress(),
            o && o(O)
        }
          , k = O=>{
            a && a(O),
            e || y({
                enabled: !1
            })
        }
          , R = O=>{
            l && l(O),
            e || y({
                enabled: !0
            })
        }
        ;
        return P.addEventListener("change", I),
        P.addEventListener("start", k),
        P.addEventListener("end", R),
        ()=>{
            P.removeEventListener("start", k),
            P.removeEventListener("end", R),
            P.removeEventListener("change", I)
        }
    }
    , [o, a, l, P, d, e, y]),
    we.useEffect(()=>{
        if (n) {
            const I = S().controls;
            return x({
                controls: P
            }),
            ()=>x({
                controls: I
            })
        }
    }
    , [n, P]),
    we.createElement("primitive", Xf({
        ref: h,
        object: P,
        enableDamping: s
    }, f))
}
)
  , I5 = R5({}, "void main() { }", "void main() { gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0); discard;  }");
class L5 extends Ql {
    constructor(e=6, t=!1) {
        super(),
        this.uniforms = {
            chromaticAberration: {
                value: .05
            },
            transmission: {
                value: 0
            },
            _transmission: {
                value: 1
            },
            transmissionMap: {
                value: null
            },
            roughness: {
                value: 0
            },
            thickness: {
                value: 0
            },
            thicknessMap: {
                value: null
            },
            attenuationDistance: {
                value: 1 / 0
            },
            attenuationColor: {
                value: new It("white")
            },
            anisotropy: {
                value: .1
            },
            time: {
                value: 0
            },
            distortion: {
                value: 0
            },
            distortionScale: {
                value: .5
            },
            temporalDistortion: {
                value: 0
            },
            buffer: {
                value: null
            }
        },
        this.onBeforeCompile = r=>{
            r.uniforms = {
                ...r.uniforms,
                ...this.uniforms
            },
            t ? r.defines.USE_SAMPLER = "" : r.defines.USE_TRANSMISSION = "",
            r.fragmentShader = `
      uniform float chromaticAberration;         
      uniform float anisotropy;      
      uniform float time;
      uniform float distortion;
      uniform float distortionScale;
      uniform float temporalDistortion;
      uniform sampler2D buffer;

      vec3 random3(vec3 c) {
        float j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));
        vec3 r;
        r.z = fract(512.0*j);
        j *= .125;
        r.x = fract(512.0*j);
        j *= .125;
        r.y = fract(512.0*j);
        return r-0.5;
      }

      float seed = 0.0;
      uint hash( uint x ) {
        x += ( x << 10u );
        x ^= ( x >>  6u );
        x += ( x <<  3u );
        x ^= ( x >> 11u );
        x += ( x << 15u );
        return x;
      }

      // Compound versions of the hashing algorithm I whipped together.
      uint hash( uvec2 v ) { return hash( v.x ^ hash(v.y)                         ); }
      uint hash( uvec3 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z)             ); }
      uint hash( uvec4 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z) ^ hash(v.w) ); }

      // Construct a float with half-open range [0:1] using low 23 bits.
      // All zeroes yields 0.0, all ones yields the next smallest representable value below 1.0.
      float floatConstruct( uint m ) {
        const uint ieeeMantissa = 0x007FFFFFu; // binary32 mantissa bitmask
        const uint ieeeOne      = 0x3F800000u; // 1.0 in IEEE binary32
        m &= ieeeMantissa;                     // Keep only mantissa bits (fractional part)
        m |= ieeeOne;                          // Add fractional part to 1.0
        float  f = uintBitsToFloat( m );       // Range [1:2]
        return f - 1.0;                        // Range [0:1]
      }

      // Pseudo-random value in half-open range [0:1].
      float random( float x ) { return floatConstruct(hash(floatBitsToUint(x))); }
      float random( vec2  v ) { return floatConstruct(hash(floatBitsToUint(v))); }
      float random( vec3  v ) { return floatConstruct(hash(floatBitsToUint(v))); }
      float random( vec4  v ) { return floatConstruct(hash(floatBitsToUint(v))); }

      float rand() {
        float result = random(vec3(gl_FragCoord.xy, seed));
        seed += 1.0;
        return result;
      }

      const float F3 =  0.3333333;
      const float G3 =  0.1666667;

      float snoise(vec3 p) {
        vec3 s = floor(p + dot(p, vec3(F3)));
        vec3 x = p - s + dot(s, vec3(G3));
        vec3 e = step(vec3(0.0), x - x.yzx);
        vec3 i1 = e*(1.0 - e.zxy);
        vec3 i2 = 1.0 - e.zxy*(1.0 - e);
        vec3 x1 = x - i1 + G3;
        vec3 x2 = x - i2 + 2.0*G3;
        vec3 x3 = x - 1.0 + 3.0*G3;
        vec4 w, d;
        w.x = dot(x, x);
        w.y = dot(x1, x1);
        w.z = dot(x2, x2);
        w.w = dot(x3, x3);
        w = max(0.6 - w, 0.0);
        d.x = dot(random3(s), x);
        d.y = dot(random3(s + i1), x1);
        d.z = dot(random3(s + i2), x2);
        d.w = dot(random3(s + 1.0), x3);
        w *= w;
        w *= w;
        d *= w;
        return dot(d, vec4(52.0));
      }

      float snoiseFractal(vec3 m) {
        return 0.5333333* snoise(m)
              +0.2666667* snoise(2.0*m)
              +0.1333333* snoise(4.0*m)
              +0.0666667* snoise(8.0*m);
      }
` + r.fragmentShader,
            r.fragmentShader = r.fragmentShader.replace("#include <transmission_pars_fragment>", `
        #ifdef USE_TRANSMISSION
          // Transmission code is based on glTF-Sampler-Viewer
          // https://github.com/KhronosGroup/glTF-Sample-Viewer
          uniform float _transmission;
          uniform float thickness;
          uniform float attenuationDistance;
          uniform vec3 attenuationColor;
          #ifdef USE_TRANSMISSIONMAP
            uniform sampler2D transmissionMap;
          #endif
          #ifdef USE_THICKNESSMAP
            uniform sampler2D thicknessMap;
          #endif
          uniform vec2 transmissionSamplerSize;
          uniform sampler2D transmissionSamplerMap;
          uniform mat4 modelMatrix;
          uniform mat4 projectionMatrix;
          varying vec3 vWorldPosition;
          vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
            // Direction of refracted light.
            vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
            // Compute rotation-independant scaling of the model matrix.
            vec3 modelScale;
            modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
            modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
            modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
            // The thickness is specified in local space.
            return normalize( refractionVector ) * thickness * modelScale;
          }
          float applyIorToRoughness( const in float roughness, const in float ior ) {
            // Scale roughness with IOR so that an IOR of 1.0 results in no microfacet refraction and
            // an IOR of 1.5 results in the default amount of microfacet refraction.
            return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
          }
          vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
            float framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );            
            #ifdef USE_SAMPLER
              #ifdef texture2DLodEXT
                return texture2DLodEXT(transmissionSamplerMap, fragCoord.xy, framebufferLod);
              #else
                return texture2D(transmissionSamplerMap, fragCoord.xy, framebufferLod);
              #endif
            #else
              return texture2D(buffer, fragCoord.xy);
            #endif
          }
          vec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
            if ( isinf( attenuationDistance ) ) {
              // Attenuation distance is +, i.e. the transmitted color is not attenuated at all.
              return radiance;
            } else {
              // Compute light attenuation using Beer's law.
              vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
              vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance ); // Beer's law
              return transmittance * radiance;
            }
          }
          vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
            const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
            const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,
            const in vec3 attenuationColor, const in float attenuationDistance ) {
            vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
            vec3 refractedRayExit = position + transmissionRay;
            // Project refracted vector on the framebuffer, while mapping to normalized device coordinates.
            vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
            vec2 refractionCoords = ndcPos.xy / ndcPos.w;
            refractionCoords += 1.0;
            refractionCoords /= 2.0;
            // Sample framebuffer to get pixel the refracted ray hits.
            vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
            vec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );
            // Get the specular component.
            vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
            return vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );
          }
        #endif
`),
            r.fragmentShader = r.fragmentShader.replace("#include <transmission_fragment>", `  
        // Improve the refraction to use the world pos
        material.transmission = _transmission;
        material.transmissionAlpha = 1.0;
        material.thickness = thickness;
        material.attenuationDistance = attenuationDistance;
        material.attenuationColor = attenuationColor;
        #ifdef USE_TRANSMISSIONMAP
          material.transmission *= texture2D( transmissionMap, vUv ).r;
        #endif
        #ifdef USE_THICKNESSMAP
          material.thickness *= texture2D( thicknessMap, vUv ).g;
        #endif
        
        vec3 pos = vWorldPosition;
        vec3 v = normalize( cameraPosition - pos );
        vec3 n = inverseTransformDirection( normal, viewMatrix );
        vec3 transmission = vec3(0.0);
        float transmissionR, transmissionB, transmissionG;
        float randomCoords = rand();
        float thickness_smear = thickness * max(pow(roughness, 0.33), anisotropy);
        vec3 distortionNormal = vec3(0.0);
        vec3 temporalOffset = vec3(time, -time, -time) * temporalDistortion;
        if (distortion > 0.0) {
          distortionNormal = distortion * vec3(snoiseFractal(vec3((pos * distortionScale + temporalOffset))), snoiseFractal(vec3(pos.zxy * distortionScale - temporalOffset)), snoiseFractal(vec3(pos.yxz * distortionScale + temporalOffset)));
        }
        for (float i = 0.0; i < ${e}.0; i ++) {
          vec3 sampleNorm = normalize(n + roughness * roughness * 2.0 * normalize(vec3(rand() - 0.5, rand() - 0.5, rand() - 0.5)) * pow(rand(), 0.33) + distortionNormal);
          transmissionR = getIBLVolumeRefraction(
            sampleNorm, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
            pos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness  + thickness_smear * (i + randomCoords) / float(${e}),
            material.attenuationColor, material.attenuationDistance
          ).r;
          transmissionG = getIBLVolumeRefraction(
            sampleNorm, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
            pos, modelMatrix, viewMatrix, projectionMatrix, material.ior  * (1.0 + chromaticAberration * (i + randomCoords) / float(${e})) , material.thickness + thickness_smear * (i + randomCoords) / float(${e}),
            material.attenuationColor, material.attenuationDistance
          ).g;
          transmissionB = getIBLVolumeRefraction(
            sampleNorm, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
            pos, modelMatrix, viewMatrix, projectionMatrix, material.ior * (1.0 + 2.0 * chromaticAberration * (i + randomCoords) / float(${e})), material.thickness + thickness_smear * (i + randomCoords) / float(${e}),
            material.attenuationColor, material.attenuationDistance
          ).b;
          transmission.r += transmissionR;
          transmission.g += transmissionG;
          transmission.b += transmissionB;
        }
        transmission /= ${e}.0;
        totalDiffuse = mix( totalDiffuse, transmission.rgb, material.transmission );
`)
        }
        ,
        Object.keys(this.uniforms).forEach(r=>Object.defineProperty(this, r, {
            get: ()=>this.uniforms[r].value,
            set: i=>this.uniforms[r].value = i
        }))
    }
}
const yP = we.forwardRef(({buffer: n, transmissionSampler: e=!1, backside: t=!1, side: r=El, transmission: i=1, thickness: s=0, backsideThickness: o=0, samples: a=10, resolution: l, backsideResolution: f, background: h, ...d},p)=>{
    AM({
        MeshTransmissionMaterial: L5
    });
    const m = we.useRef(null)
      , [_] = we.useState(()=>new I5)
      , y = ub(f || l)
      , x = ub(l);
    let S, M, w;
    return I_(T=>{
        m.current.time = T.clock.getElapsedTime(),
        !n && !e && (w = m.current.__r3f.parent,
        w && (M = T.gl.toneMapping,
        S = T.scene.background,
        T.gl.toneMapping = Ka,
        h && (T.scene.background = h),
        w.material = _,
        t && (T.gl.setRenderTarget(y),
        T.gl.render(T.scene, T.camera),
        w.material = m.current,
        w.material.buffer = y.texture,
        w.material.thickness = o,
        w.material.side = Do),
        T.gl.setRenderTarget(x),
        T.gl.render(T.scene, T.camera),
        w.material.thickness = s,
        w.material.side = r,
        w.material.buffer = x.texture,
        T.scene.background = S,
        T.gl.setRenderTarget(null),
        w.material = m.current,
        T.gl.toneMapping = M))
    }
    ),
    we.useImperativeHandle(p, ()=>m.current, []),
    we.createElement("meshTransmissionMaterial", Xf({
        args: [a, e],
        ref: m
    }, d, {
        buffer: n || x.texture,
        _transmission: i,
        transmission: e ? i : 0,
        thickness: s,
        side: r
    }))
}
)
  , Zl = we.forwardRef(({children: n, speed: e=1, rotationIntensity: t=1, floatIntensity: r=1, floatingRange: i=[-.1, .1], ...s},o)=>{
    const a = we.useRef(null)
      , l = we.useRef(Math.random() * 1e4);
    return I_(f=>{
        var h, d;
        const p = l.current + f.clock.getElapsedTime();
        a.current.rotation.x = Math.cos(p / 4 * e) / 8 * t,
        a.current.rotation.y = Math.sin(p / 4 * e) / 8 * t,
        a.current.rotation.z = Math.sin(p / 4 * e) / 20 * t;
        let m = Math.sin(p / 4 * e) / 10;
        m = y_.mapLinear(m, -.1, .1, (h = i == null ? void 0 : i[0]) !== null && h !== void 0 ? h : -.1, (d = i == null ? void 0 : i[1]) !== null && d !== void 0 ? d : .1),
        a.current.position.y = m * r
    }
    ),
    we.createElement("group", s, we.createElement("group", {
        ref: jU([a, o])
    }, n))
}
)
  , Ex = {
    sunset: "venice/venice_sunset_1k.hdr",
    dawn: "kiara/kiara_1_dawn_1k.hdr",
    night: "dikhololo/dikhololo_night_1k.hdr",
    warehouse: "empty-wharehouse/empty_warehouse_01_1k.hdr",
    forest: "forrest-slope/forest_slope_1k.hdr",
    apartment: "lebombo/lebombo_1k.hdr",
    studio: "studio-small-3/studio_small_03_1k.hdr",
    city: "potsdamer-platz/potsdamer_platz_1k.hdr",
    park: "rooitou/rooitou_park_1k.hdr",
    lobby: "st-fagans/st_fagans_interior_1k.hdr"
}
  , F5 = "https://market-assets.fra1.cdn.digitaloceanspaces.com/market-assets/hdris/"
  , k5 = n=>n.current && n.current.isScene
  , O5 = n=>k5(n) ? n.current : n;
function DM(n, e, t, r, i=0) {
    const s = O5(e || t)
      , o = s.background
      , a = s.environment
      , l = s.backgroundBlurriness || 0;
    return n !== "only" && (s.environment = r),
    n && (s.background = r),
    n && s.backgroundBlurriness !== void 0 && (s.backgroundBlurriness = i),
    ()=>{
        n !== "only" && (s.environment = a),
        n && (s.background = o),
        n && s.backgroundBlurriness !== void 0 && (s.backgroundBlurriness = l)
    }
}
function PM({scene: n, background: e=!1, blur: t, map: r}) {
    const i = pa(s=>s.scene);
    return we.useLayoutEffect(()=>{
        if (r)
            return DM(e, n, i, r, t)
    }
    , [i, n, r, e, t]),
    null
}
function xP({files: n=["/px.png", "/nx.png", "/py.png", "/ny.png", "/pz.png", "/nz.png"], path: e="", preset: t=void 0, encoding: r=void 0, extensions: i}) {
    if (t) {
        if (!(t in Ex))
            throw new Error("Preset must be one of: " + Object.keys(Ex).join(", "));
        n = Ex[t],
        e = F5
    }
    const s = Array.isArray(n)
      , a = Nh(s ? k3 : T5, s ? [n] : n, f=>{
        f.setPath(e),
        i && i(f)
    }
    )
      , l = s ? a[0] : a;
    return l.mapping = s ? Tu : mh,
    l.encoding = r ?? s ? nr : bl,
    l
}
function wP({background: n=!1, scene: e, blur: t, ...r}) {
    const i = xP(r)
      , s = pa(o=>o.scene);
    return we.useLayoutEffect(()=>DM(n, e, s, i, t), [i, n, e, s, t]),
    null
}
function N5({children: n, near: e=1, far: t=1e3, resolution: r=256, frames: i=1, map: s, background: o=!1, blur: a, scene: l, files: f, path: h, preset: d=void 0, extensions: p}) {
    const m = pa(w=>w.gl)
      , _ = pa(w=>w.scene)
      , y = we.useRef(null)
      , [x] = we.useState(()=>new C_)
      , S = we.useMemo(()=>{
        const w = new XS(r);
        return w.texture.type = ja,
        w
    }
    , [r]);
    we.useLayoutEffect(()=>(i === 1 && y.current.update(m, x),
    DM(o, l, _, S.texture, a)), [n, x, S.texture, l, _, o, i, m]);
    let M = 1;
    return I_(()=>{
        (i === 1 / 0 || M < i) && (y.current.update(m, x),
        M++)
    }
    ),
    we.createElement(we.Fragment, null, TU(we.createElement(we.Fragment, null, n, we.createElement("cubeCamera", {
        ref: y,
        args: [e, t, S]
    }), f || d ? we.createElement(wP, {
        background: !0,
        files: f,
        preset: d,
        path: h,
        extensions: p
    }) : s ? we.createElement(PM, {
        background: !0,
        map: s,
        extensions: p
    }) : null), x))
}
function z5(n) {
    var e, t, r, i;
    const s = xP(n)
      , o = n.map || s;
    we.useMemo(()=>AM({
        GroundProjectedEnvImpl: QU
    }), []);
    const a = we.useMemo(()=>[o], [o])
      , l = (e = n.ground) == null ? void 0 : e.height
      , f = (t = n.ground) == null ? void 0 : t.radius
      , h = (r = (i = n.ground) == null ? void 0 : i.scale) !== null && r !== void 0 ? r : 1e3;
    return we.createElement(we.Fragment, null, we.createElement(PM, Xf({}, n, {
        map: o
    })), we.createElement("groundProjectedEnvImpl", {
        args: a,
        scale: h,
        height: l,
        radius: f
    }))
}
function SP(n) {
    return n.ground ? we.createElement(z5, n) : n.map ? we.createElement(PM, n) : n.children ? we.createElement(N5, n) : we.createElement(wP, n)
}
var he = {}
  , G5 = {
    get exports() {
        return he
    },
    set exports(n) {
        he = n
    }
};
(function(n, e) {
    (function(t, r) {
        r(e)
    }
    )(Xb, function(t) {
        function r(q, g) {
            q.prototype = Object.create(g.prototype),
            q.prototype.constructor = q,
            q.__proto__ = g
        }
        function i(q) {
            if (q === void 0)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return q
        }
        /*!
 * GSAP 3.11.4
 * https://greensock.com
 *
 * @license Copyright 2008-2022, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/
        var s = {
            autoSleep: 120,
            force3D: "auto",
            nullTargetWarn: 1,
            units: {
                lineHeight: ""
            }
        }, o = {
            duration: .5,
            overwrite: !1,
            delay: 0
        }, a, l, f, h = 1e8, d = 1 / h, p = Math.PI * 2, m = p / 4, _ = 0, y = Math.sqrt, x = Math.cos, S = Math.sin, M = function(g) {
            return typeof g == "string"
        }, w = function(g) {
            return typeof g == "function"
        }, T = function(g) {
            return typeof g == "number"
        }, P = function(g) {
            return typeof g > "u"
        }, I = function(g) {
            return typeof g == "object"
        }, k = function(g) {
            return g !== !1
        }, R = function() {
            return typeof window < "u"
        }, O = function(g) {
            return w(g) || M(g)
        }, H = typeof ArrayBuffer == "function" && ArrayBuffer.isView || function() {}
        , W = Array.isArray, te = /(?:-?\.?\d|\.)+/gi, ne = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g, re = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g, pe = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi, ce = /[+-]=-?[.\d]+/, xe = /[^,'"\[\]\s]+/gi, G = /^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i, z, U, fe, oe, Ae = {}, Ue = {}, je, de = function(g) {
            return (Ue = Mt(g, Ae)) && pn
        }, qe = function(g, A) {
            return console.warn("Invalid property", g, "set to", A, "Missing plugin? gsap.registerPlugin()")
        }, Ne = function(g, A) {
            return !A && console.warn(g)
        }, Tt = function(g, A) {
            return g && (Ae[g] = A) && Ue && (Ue[g] = A) || Ae
        }, He = function() {
            return 0
        }, gt = {
            suppressEvents: !0,
            isStart: !0,
            kill: !1
        }, be = {
            suppressEvents: !0,
            kill: !1
        }, Ee = {
            suppressEvents: !0
        }, at = {}, _t = [], Ce = {}, ee, et = {}, Ze = {}, ft = 30, Pt = [], Z = "", V = function(g) {
            var A = g[0], C, b;
            if (I(A) || w(A) || (g = [g]),
            !(C = (A._gsap || {}).harness)) {
                for (b = Pt.length; b-- && !Pt[b].targetTest(A); )
                    ;
                C = Pt[b]
            }
            for (b = g.length; b--; )
                g[b] && (g[b]._gsap || (g[b]._gsap = new Fu(g[b],C))) || g.splice(b, 1);
            return g
        }, ye = function(g) {
            return g._gsap || V(Ln(g))[0]._gsap
        }, tt = function(g, A, C) {
            return (C = g[A]) && w(C) ? g[A]() : P(C) && g.getAttribute && g.getAttribute(A) || C
        }, Ve = function(g, A) {
            return (g = g.split(",")).forEach(A) || g
        }, Ke = function(g) {
            return Math.round(g * 1e5) / 1e5 || 0
        }, dt = function(g) {
            return Math.round(g * 1e7) / 1e7 || 0
        }, ct = function(g, A) {
            var C = A.charAt(0)
              , b = parseFloat(A.substr(2));
            return g = parseFloat(g),
            C === "+" ? g + b : C === "-" ? g - b : C === "*" ? g * b : g / b
        }, Fe = function(g, A) {
            for (var C = A.length, b = 0; g.indexOf(A[b]) < 0 && ++b < C; )
                ;
            return b < C
        }, Rt = function() {
            var g = _t.length, A = _t.slice(0), C, b;
            for (Ce = {},
            _t.length = 0,
            C = 0; C < g; C++)
                b = A[C],
                b && b._lazy && (b.render(b._lazy[0], b._lazy[1], !0)._lazy = 0)
        }, le = function(g, A, C, b) {
            _t.length && !l && Rt(),
            g.render(A, C, b || l && A < 0 && (g._initted || g._startAt)),
            _t.length && !l && Rt()
        }, Le = function(g) {
            var A = parseFloat(g);
            return (A || A === 0) && (g + "").match(xe).length < 2 ? A : M(g) ? g.trim() : g
        }, rt = function(g) {
            return g
        }, st = function(g, A) {
            for (var C in A)
                C in g || (g[C] = A[C]);
            return g
        }, Ut = function(g) {
            return function(A, C) {
                for (var b in C)
                    b in A || b === "duration" && g || b === "ease" || (A[b] = C[b])
            }
        }, Mt = function(g, A) {
            for (var C in A)
                g[C] = A[C];
            return g
        }, wn = function q(g, A) {
            for (var C in A)
                C !== "__proto__" && C !== "constructor" && C !== "prototype" && (g[C] = I(A[C]) ? q(g[C] || (g[C] = {}), A[C]) : A[C]);
            return g
        }, ae = function(g, A) {
            var C = {}, b;
            for (b in g)
                b in A || (C[b] = g[b]);
            return C
        }, De = function(g) {
            var A = g.parent || z
              , C = g.keyframes ? Ut(W(g.keyframes)) : st;
            if (k(g.inherit))
                for (; A; )
                    C(g, A.vars.defaults),
                    A = A.parent || A._dp;
            return g
        }, Je = function(g, A) {
            for (var C = g.length, b = C === A.length; b && C-- && g[C] === A[C]; )
                ;
            return C < 0
        }, vt = function(g, A, C, b, B) {
            C === void 0 && (C = "_first"),
            b === void 0 && (b = "_last");
            var F = g[b], N;
            if (B)
                for (N = A[B]; F && F[B] > N; )
                    F = F._prev;
            return F ? (A._next = F._next,
            F._next = A) : (A._next = g[C],
            g[C] = A),
            A._next ? A._next._prev = A : g[b] = A,
            A._prev = F,
            A.parent = A._dp = g,
            A
        }, Et = function(g, A, C, b) {
            C === void 0 && (C = "_first"),
            b === void 0 && (b = "_last");
            var B = A._prev
              , F = A._next;
            B ? B._next = F : g[C] === A && (g[C] = F),
            F ? F._prev = B : g[b] === A && (g[b] = B),
            A._next = A._prev = A.parent = null
        }, rn = function(g, A) {
            g.parent && (!A || g.parent.autoRemoveChildren) && g.parent.remove(g),
            g._act = 0
        }, dn = function(g, A) {
            if (g && (!A || A._end > g._dur || A._start < 0))
                for (var C = g; C; )
                    C._dirty = 1,
                    C = C.parent;
            return g
        }, or = function(g) {
            for (var A = g.parent; A && A.parent; )
                A._dirty = 1,
                A.totalDuration(),
                A = A.parent;
            return g
        }, mn = function(g, A, C, b) {
            return g._startAt && (l ? g._startAt.revert(be) : g.vars.immediateRender && !g.vars.autoRevert || g._startAt.render(A, !0, b))
        }, St = function q(g) {
            return !g || g._ts && q(g.parent)
        }, ut = function(g) {
            return g._repeat ? Nt(g._tTime, g = g.duration() + g._rDelay) * g : 0
        }, Nt = function(g, A) {
            var C = Math.floor(g /= A);
            return g && C === g ? C - 1 : C
        }, $t = function(g, A) {
            return (g - A._start) * A._ts + (A._ts >= 0 ? 0 : A._dirty ? A.totalDuration() : A._tDur)
        }, hn = function(g) {
            return g._end = dt(g._start + (g._tDur / Math.abs(g._ts || g._rts || d) || 0))
        }, Qn = function(g, A) {
            var C = g._dp;
            return C && C.smoothChildTiming && g._ts && (g._start = dt(C._time - (g._ts > 0 ? A / g._ts : ((g._dirty ? g.totalDuration() : g._tDur) - A) / -g._ts)),
            hn(g),
            C._dirty || dn(C, g)),
            g
        }, vn = function(g, A) {
            var C;
            if ((A._time || A._initted && !A._dur) && (C = $t(g.rawTime(), A),
            (!A._dur || Zn(0, A.totalDuration(), C) - A._tTime > d) && A.render(C, !0)),
            dn(g, A)._dp && g._initted && g._time >= g._dur && g._ts) {
                if (g._dur < g.duration())
                    for (C = g; C._dp; )
                        C.rawTime() >= 0 && C.totalTime(C._tTime),
                        C = C._dp;
                g._zTime = -d
            }
        }, j = function(g, A, C, b) {
            return A.parent && rn(A),
            A._start = dt((T(C) ? C : C || g !== z ? tn(g, C, A) : g._time) + A._delay),
            A._end = dt(A._start + (A.totalDuration() / Math.abs(A.timeScale()) || 0)),
            vt(g, A, "_first", "_last", g._sort ? "_start" : 0),
            Oe(A) || (g._recent = A),
            b || vn(g, A),
            g._ts < 0 && Qn(g, g._tTime),
            g
        }, me = function(g, A) {
            return (Ae.ScrollTrigger || qe("scrollTrigger", A)) && Ae.ScrollTrigger.create(A, g)
        }, ze = function(g, A, C, b, B) {
            if (ku(g, A, B),
            !g._initted)
                return 1;
            if (!C && g._pt && !l && (g._dur && g.vars.lazy !== !1 || !g._dur && g.vars.lazy) && ee !== Ss.frame)
                return _t.push(g),
                g._lazy = [B, b],
                1
        }, ge = function q(g) {
            var A = g.parent;
            return A && A._ts && A._initted && !A._lock && (A.rawTime() < 0 || q(A))
        }, Oe = function(g) {
            var A = g.data;
            return A === "isFromStart" || A === "isStart"
        }, Vt = function(g, A, C, b) {
            var B = g.ratio, F = A < 0 || !A && (!g._start && ge(g) && !(!g._initted && Oe(g)) || (g._ts < 0 || g._dp._ts < 0) && !Oe(g)) ? 0 : 1, N = g._rDelay, X = 0, Y, se, Re;
            if (N && g._repeat && (X = Zn(0, g._tDur, A),
            se = Nt(X, N),
            g._yoyo && se & 1 && (F = 1 - F),
            se !== Nt(g._tTime, N) && (B = 1 - F,
            g.vars.repeatRefresh && g._initted && g.invalidate())),
            F !== B || l || b || g._zTime === d || !A && g._zTime) {
                if (!g._initted && ze(g, A, b, C, X))
                    return;
                for (Re = g._zTime,
                g._zTime = A || (C ? d : 0),
                C || (C = A && !Re),
                g.ratio = F,
                g._from && (F = 1 - F),
                g._time = 0,
                g._tTime = X,
                Y = g._pt; Y; )
                    Y.r(F, Y.d),
                    Y = Y._next;
                A < 0 && mn(g, A, C, !0),
                g._onUpdate && !C && ts(g, "onUpdate"),
                X && g._repeat && !C && g.parent && ts(g, "onRepeat"),
                (A >= g._tDur || A < 0) && g.ratio === F && (F && rn(g, 1),
                !C && !l && (ts(g, F ? "onComplete" : "onReverseComplete", !0),
                g._prom && g._prom()))
            } else
                g._zTime || (g._zTime = A)
        }, Ft = function(g, A, C) {
            var b;
            if (C > A)
                for (b = g._first; b && b._start <= C; ) {
                    if (b.data === "isPause" && b._start > A)
                        return b;
                    b = b._next
                }
            else
                for (b = g._last; b && b._start >= C; ) {
                    if (b.data === "isPause" && b._start < A)
                        return b;
                    b = b._prev
                }
        }, Gt = function(g, A, C, b) {
            var B = g._repeat
              , F = dt(A) || 0
              , N = g._tTime / g._tDur;
            return N && !b && (g._time *= F / g._dur),
            g._dur = F,
            g._tDur = B ? B < 0 ? 1e10 : dt(F * (B + 1) + g._rDelay * B) : F,
            N > 0 && !b && Qn(g, g._tTime = g._tDur * N),
            g.parent && hn(g),
            C || dn(g.parent, g),
            g
        }, Yt = function(g) {
            return g instanceof Lr ? dn(g) : Gt(g, g._dur)
        }, Sn = {
            _start: 0,
            endTime: He,
            totalDuration: He
        }, tn = function q(g, A, C) {
            var b = g.labels, B = g._recent || Sn, F = g.duration() >= h ? B.endTime(!1) : g._dur, N, X, Y;
            return M(A) && (isNaN(A) || A in b) ? (X = A.charAt(0),
            Y = A.substr(-1) === "%",
            N = A.indexOf("="),
            X === "<" || X === ">" ? (N >= 0 && (A = A.replace(/=/, "")),
            (X === "<" ? B._start : B.endTime(B._repeat >= 0)) + (parseFloat(A.substr(1)) || 0) * (Y ? (N < 0 ? B : C).totalDuration() / 100 : 1)) : N < 0 ? (A in b || (b[A] = F),
            b[A]) : (X = parseFloat(A.charAt(N - 1) + A.substr(N + 1)),
            Y && C && (X = X / 100 * (W(C) ? C[0] : C).totalDuration()),
            N > 1 ? q(g, A.substr(0, N - 1), C) + X : F + X)) : A == null ? F : +A
        }, Xt = function(g, A, C) {
            var b = T(A[1]), B = (b ? 2 : 1) + (g < 2 ? 0 : 1), F = A[B], N, X;
            if (b && (F.duration = A[1]),
            F.parent = C,
            g) {
                for (N = F,
                X = C; X && !("immediateRender"in N); )
                    N = X.vars.defaults || {},
                    X = k(X.vars.inherit) && X.parent;
                F.immediateRender = k(N.immediateRender),
                g < 2 ? F.runBackwards = 1 : F.startAt = A[B - 1]
            }
            return new Fr(A[0],F,A[B + 1])
        }, en = function(g, A) {
            return g || g === 0 ? A(g) : A
        }, Zn = function(g, A, C) {
            return C < g ? g : C > A ? A : C
        }, Yn = function(g, A) {
            return !M(g) || !(A = G.exec(g)) ? "" : A[1]
        }, es = function(g, A, C) {
            return en(C, function(b) {
                return Zn(g, A, b)
            })
        }, Nn = [].slice, kt = function(g, A) {
            return g && I(g) && "length"in g && (!A && !g.length || g.length - 1 in g && I(g[0])) && !g.nodeType && g !== U
        }, Ur = function(g, A, C) {
            return C === void 0 && (C = []),
            g.forEach(function(b) {
                var B;
                return M(b) && !A || kt(b, 1) ? (B = C).push.apply(B, Ln(b)) : C.push(b)
            }) || C
        }, Ln = function(g, A, C) {
            return f && !A && f.selector ? f.selector(g) : M(g) && !C && (fe || !Ms()) ? Nn.call((A || oe).querySelectorAll(g), 0) : W(g) ? Ur(g, C) : kt(g) ? Nn.call(g, 0) : g ? [g] : []
        }, Bs = function(g) {
            return g = Ln(g)[0] || Ne("Invalid scope") || {},
            function(A) {
                var C = g.current || g.nativeElement || g;
                return Ln(A, C.querySelectorAll ? C : C === g ? Ne("Invalid scope") || oe.createElement("div") : g)
            }
        }, qr = function(g) {
            return g.sort(function() {
                return .5 - Math.random()
            })
        }, Qr = function(g) {
            if (w(g))
                return g;
            var A = I(g) ? g : {
                each: g
            }
              , C = Is(A.ease)
              , b = A.from || 0
              , B = parseFloat(A.base) || 0
              , F = {}
              , N = b > 0 && b < 1
              , X = isNaN(b) || N
              , Y = A.axis
              , se = b
              , Re = b;
            return M(b) ? se = Re = {
                center: .5,
                edges: .5,
                end: 1
            }[b] || 0 : !N && X && (se = b[0],
            Re = b[1]),
            function(Pe, Ie, nt) {
                var ve = (nt || A).length, $e = F[ve], lt, pt, xt, Ct, yt, jt, Wt, Ot, bt;
                if (!$e) {
                    if (bt = A.grid === "auto" ? 0 : (A.grid || [1, h])[1],
                    !bt) {
                        for (Wt = -h; Wt < (Wt = nt[bt++].getBoundingClientRect().left) && bt < ve; )
                            ;
                        bt--
                    }
                    for ($e = F[ve] = [],
                    lt = X ? Math.min(bt, ve) * se - .5 : b % bt,
                    pt = bt === h ? 0 : X ? ve * Re / bt - .5 : b / bt | 0,
                    Wt = 0,
                    Ot = h,
                    jt = 0; jt < ve; jt++)
                        xt = jt % bt - lt,
                        Ct = pt - (jt / bt | 0),
                        $e[jt] = yt = Y ? Math.abs(Y === "y" ? Ct : xt) : y(xt * xt + Ct * Ct),
                        yt > Wt && (Wt = yt),
                        yt < Ot && (Ot = yt);
                    b === "random" && qr($e),
                    $e.max = Wt - Ot,
                    $e.min = Ot,
                    $e.v = ve = (parseFloat(A.amount) || parseFloat(A.each) * (bt > ve ? ve - 1 : Y ? Y === "y" ? ve / bt : bt : Math.max(bt, ve / bt)) || 0) * (b === "edges" ? -1 : 1),
                    $e.b = ve < 0 ? B - ve : B,
                    $e.u = Yn(A.amount || A.each) || 0,
                    C = C && ve < 0 ? yi(C) : C
                }
                return ve = ($e[Pe] - $e.min) / $e.max || 0,
                dt($e.b + (C ? C(ve) : ve) * $e.v) + $e.u
            }
        }, xs = function(g) {
            var A = Math.pow(10, ((g + "").split(".")[1] || "").length);
            return function(C) {
                var b = dt(Math.round(parseFloat(C) / g) * g * A);
                return (b - b % 1) / A + (T(C) ? 0 : Yn(C))
            }
        }, Mn = function(g, A) {
            var C = W(g), b, B;
            return !C && I(g) && (b = C = g.radius || h,
            g.values ? (g = Ln(g.values),
            (B = !T(g[0])) && (b *= b)) : g = xs(g.increment)),
            en(A, C ? w(g) ? function(F) {
                return B = g(F),
                Math.abs(B - F) <= b ? B : F
            }
            : function(F) {
                for (var N = parseFloat(B ? F.x : F), X = parseFloat(B ? F.y : 0), Y = h, se = 0, Re = g.length, Pe, Ie; Re--; )
                    B ? (Pe = g[Re].x - N,
                    Ie = g[Re].y - X,
                    Pe = Pe * Pe + Ie * Ie) : Pe = Math.abs(g[Re] - N),
                    Pe < Y && (Y = Pe,
                    se = Re);
                return se = !b || Y <= b ? g[se] : F,
                B || se === F || T(F) ? se : se + Yn(F)
            }
            : xs(g))
        }, An = function(g, A, C, b) {
            return en(W(g) ? !A : C === !0 ? !!(C = 0) : !b, function() {
                return W(g) ? g[~~(Math.random() * g.length)] : (C = C || 1e-5) && (b = C < 1 ? Math.pow(10, (C + "").length - 2) : 1) && Math.floor(Math.round((g - C / 2 + Math.random() * (A - g + C * .99)) / C) * C * b) / b
            })
        }, ws = function() {
            for (var g = arguments.length, A = new Array(g), C = 0; C < g; C++)
                A[C] = arguments[C];
            return function(b) {
                return A.reduce(function(B, F) {
                    return F(B)
                }, b)
            }
        }, ir = function(g, A) {
            return function(C) {
                return g(parseFloat(C)) + (A || Yn(C))
            }
        }, Ni = function(g, A, C) {
            return _i(g, A, 0, 1, C)
        }, Js = function(g, A, C) {
            return en(C, function(b) {
                return g[~~A(b)]
            })
        }, ea = function q(g, A, C) {
            var b = A - g;
            return W(g) ? Js(g, q(0, g.length), A) : en(C, function(B) {
                return (b + (B - g) % b) % b + g
            })
        }, Yi = function q(g, A, C) {
            var b = A - g
              , B = b * 2;
            return W(g) ? Js(g, q(0, g.length - 1), A) : en(C, function(F) {
                return F = (B + (F - g) % B) % B || 0,
                g + (F > b ? B - F : F)
            })
        }, Hr = function(g) {
            for (var A = 0, C = "", b, B, F, N; ~(b = g.indexOf("random(", A)); )
                F = g.indexOf(")", b),
                N = g.charAt(b + 7) === "[",
                B = g.substr(b + 7, F - b - 7).match(N ? xe : te),
                C += g.substr(A, b - A) + An(N ? B : +B[0], N ? 0 : +B[1], +B[2] || 1e-5),
                A = F + 1;
            return C + g.substr(A, g.length - A)
        }, _i = function(g, A, C, b, B) {
            var F = A - g
              , N = b - C;
            return en(B, function(X) {
                return C + ((X - g) / F * N || 0)
            })
        }, $l = function q(g, A, C, b) {
            var B = isNaN(g + A) ? 0 : function(Ie) {
                return (1 - Ie) * g + Ie * A
            }
            ;
            if (!B) {
                var F = M(g), N = {}, X, Y, se, Re, Pe;
                if (C === !0 && (b = 1) && (C = null),
                F)
                    g = {
                        p: g
                    },
                    A = {
                        p: A
                    };
                else if (W(g) && !W(A)) {
                    for (se = [],
                    Re = g.length,
                    Pe = Re - 2,
                    Y = 1; Y < Re; Y++)
                        se.push(q(g[Y - 1], g[Y]));
                    Re--,
                    B = function(nt) {
                        nt *= Re;
                        var ve = Math.min(Pe, ~~nt);
                        return se[ve](nt - ve)
                    }
                    ,
                    C = A
                } else
                    b || (g = Mt(W(g) ? [] : {}, g));
                if (!se) {
                    for (X in A)
                        Il.call(N, g, X, "get", A[X]);
                    B = function(nt) {
                        return ue(nt, N) || (F ? g.p : g)
                    }
                }
            }
            return en(C, B)
        }, Rl = function(g, A, C) {
            var b = g.labels, B = h, F, N, X;
            for (F in b)
                N = b[F] - A,
                N < 0 == !!C && N && B > (N = Math.abs(N)) && (X = F,
                B = N);
            return X
        }, ts = function(g, A, C) {
            var b = g.vars, B = b[A], F = f, N = g._ctx, X, Y, se;
            if (B)
                return X = b[A + "Params"],
                Y = b.callbackScope || g,
                C && _t.length && Rt(),
                N && (f = N),
                se = X ? B.apply(Y, X) : B.call(Y),
                f = F,
                se
        }, zi = function(g) {
            return rn(g),
            g.scrollTrigger && g.scrollTrigger.kill(!!l),
            g.progress() < 1 && ts(g, "onInterrupt"),
            g
        }, ta, Iu = function(g) {
            g = !g.name && g.default || g;
            var A = g.name
              , C = w(g)
              , b = A && !C && g.init ? function() {
                this._props = []
            }
            : g
              , B = {
                init: He,
                render: ue,
                add: Il,
                kill: Q,
                modifier: K,
                rawVars: 0
            }
              , F = {
                targetTest: 0,
                get: 0,
                getSetter: sa,
                aliases: {},
                register: 0
            };
            if (Ms(),
            g !== b) {
                if (et[A])
                    return;
                st(b, st(ae(g, B), F)),
                Mt(b.prototype, Mt(B, ae(g, F))),
                et[b.prop = A] = b,
                g.targetTest && (Pt.push(b),
                at[A] = 1),
                A = (A === "css" ? "CSS" : A.charAt(0).toUpperCase() + A.substr(1)) + "Plugin"
            }
            Tt(A, b),
            g.register && g.register(pn, b, Be)
        }, ar = 255, yn = {
            aqua: [0, ar, ar],
            lime: [0, ar, 0],
            silver: [192, 192, 192],
            black: [0, 0, 0],
            maroon: [128, 0, 0],
            teal: [0, 128, 128],
            blue: [0, 0, ar],
            navy: [0, 0, 128],
            white: [ar, ar, ar],
            olive: [128, 128, 0],
            yellow: [ar, ar, 0],
            orange: [ar, 165, 0],
            gray: [128, 128, 128],
            purple: [128, 0, 128],
            green: [0, 128, 0],
            red: [ar, 0, 0],
            pink: [ar, 192, 203],
            cyan: [0, ar, ar],
            transparent: [ar, ar, ar, 0]
        }, Ta = function(g, A, C) {
            return g += g < 0 ? 1 : g > 1 ? -1 : 0,
            (g * 6 < 1 ? A + (C - A) * g * 6 : g < .5 ? C : g * 3 < 2 ? A + (C - A) * (2 / 3 - g) * 6 : A) * ar + .5 | 0
        }, Io = function(g, A, C) {
            var b = g ? T(g) ? [g >> 16, g >> 8 & ar, g & ar] : 0 : yn.black, B, F, N, X, Y, se, Re, Pe, Ie, nt;
            if (!b) {
                if (g.substr(-1) === "," && (g = g.substr(0, g.length - 1)),
                yn[g])
                    b = yn[g];
                else if (g.charAt(0) === "#") {
                    if (g.length < 6 && (B = g.charAt(1),
                    F = g.charAt(2),
                    N = g.charAt(3),
                    g = "#" + B + B + F + F + N + N + (g.length === 5 ? g.charAt(4) + g.charAt(4) : "")),
                    g.length === 9)
                        return b = parseInt(g.substr(1, 6), 16),
                        [b >> 16, b >> 8 & ar, b & ar, parseInt(g.substr(7), 16) / 255];
                    g = parseInt(g.substr(1), 16),
                    b = [g >> 16, g >> 8 & ar, g & ar]
                } else if (g.substr(0, 3) === "hsl") {
                    if (b = nt = g.match(te),
                    !A)
                        X = +b[0] % 360 / 360,
                        Y = +b[1] / 100,
                        se = +b[2] / 100,
                        F = se <= .5 ? se * (Y + 1) : se + Y - se * Y,
                        B = se * 2 - F,
                        b.length > 3 && (b[3] *= 1),
                        b[0] = Ta(X + 1 / 3, B, F),
                        b[1] = Ta(X, B, F),
                        b[2] = Ta(X - 1 / 3, B, F);
                    else if (~g.indexOf("="))
                        return b = g.match(ne),
                        C && b.length < 4 && (b[3] = 1),
                        b
                } else
                    b = g.match(te) || yn.transparent;
                b = b.map(Number)
            }
            return A && !nt && (B = b[0] / ar,
            F = b[1] / ar,
            N = b[2] / ar,
            Re = Math.max(B, F, N),
            Pe = Math.min(B, F, N),
            se = (Re + Pe) / 2,
            Re === Pe ? X = Y = 0 : (Ie = Re - Pe,
            Y = se > .5 ? Ie / (2 - Re - Pe) : Ie / (Re + Pe),
            X = Re === B ? (F - N) / Ie + (F < N ? 6 : 0) : Re === F ? (N - B) / Ie + 2 : (B - F) / Ie + 4,
            X *= 60),
            b[0] = ~~(X + .5),
            b[1] = ~~(Y * 100 + .5),
            b[2] = ~~(se * 100 + .5)),
            C && b.length < 4 && (b[3] = 1),
            b
        }, Bl = function(g) {
            var A = []
              , C = []
              , b = -1;
            return g.split(Lo).forEach(function(B) {
                var F = B.match(re) || [];
                A.push.apply(A, F),
                C.push(b += F.length + 1)
            }),
            A.c = C,
            A
        }, tl = function(g, A, C) {
            var b = "", B = (g + b).match(Lo), F = A ? "hsla(" : "rgba(", N = 0, X, Y, se, Re;
            if (!B)
                return g;
            if (B = B.map(function(Pe) {
                return (Pe = Io(Pe, A, 1)) && F + (A ? Pe[0] + "," + Pe[1] + "%," + Pe[2] + "%," + Pe[3] : Pe.join(",")) + ")"
            }),
            C && (se = Bl(g),
            X = C.c,
            X.join(b) !== se.c.join(b)))
                for (Y = g.replace(Lo, "1").split(re),
                Re = Y.length - 1; N < Re; N++)
                    b += Y[N] + (~X.indexOf(N) ? B.shift() || F + "0,0,0,0)" : (se.length ? se : B.length ? B : C).shift());
            if (!Y)
                for (Y = g.split(Lo),
                Re = Y.length - 1; N < Re; N++)
                    b += Y[N] + B[N];
            return b + Y[Re]
        }, Lo = function() {
            var q = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b", g;
            for (g in yn)
                q += "|" + g + "\\b";
            return new RegExp(q + ")","gi")
        }(), nl = /hsl[a]?\(/, Fo = function(g) {
            var A = g.join(" "), C;
            if (Lo.lastIndex = 0,
            Lo.test(A))
                return C = nl.test(A),
                g[1] = tl(g[1], C),
                g[0] = tl(g[0], C, Bl(g[1])),
                !0
        }, na, Ss = function() {
            var q = Date.now, g = 500, A = 33, C = q(), b = C, B = 1e3 / 240, F = B, N = [], X, Y, se, Re, Pe, Ie, nt = function ve($e) {
                var lt = q() - b, pt = $e === !0, xt, Ct, yt, jt;
                if (lt > g && (C += lt - A),
                b += lt,
                yt = b - C,
                xt = yt - F,
                (xt > 0 || pt) && (jt = ++Re.frame,
                Pe = yt - Re.time * 1e3,
                Re.time = yt = yt / 1e3,
                F += xt + (xt >= B ? 4 : B - xt),
                Ct = 1),
                pt || (X = Y(ve)),
                Ct)
                    for (Ie = 0; Ie < N.length; Ie++)
                        N[Ie](yt, Pe, jt, $e)
            };
            return Re = {
                time: 0,
                frame: 0,
                tick: function() {
                    nt(!0)
                },
                deltaRatio: function($e) {
                    return Pe / (1e3 / ($e || 60))
                },
                wake: function() {
                    je && (!fe && R() && (U = fe = window,
                    oe = U.document || {},
                    Ae.gsap = pn,
                    (U.gsapVersions || (U.gsapVersions = [])).push(pn.version),
                    de(Ue || U.GreenSockGlobals || !U.gsap && U || {}),
                    se = U.requestAnimationFrame),
                    X && Re.sleep(),
                    Y = se || function($e) {
                        return setTimeout($e, F - Re.time * 1e3 + 1 | 0)
                    }
                    ,
                    na = 1,
                    nt(2))
                },
                sleep: function() {
                    (se ? U.cancelAnimationFrame : clearTimeout)(X),
                    na = 0,
                    Y = He
                },
                lagSmoothing: function($e, lt) {
                    g = $e || 1 / 0,
                    A = Math.min(lt || 33, g)
                },
                fps: function($e) {
                    B = 1e3 / ($e || 240),
                    F = Re.time * 1e3 + B
                },
                add: function($e, lt, pt) {
                    var xt = lt ? function(Ct, yt, jt, Wt) {
                        $e(Ct, yt, jt, Wt),
                        Re.remove(xt)
                    }
                    : $e;
                    return Re.remove($e),
                    N[pt ? "unshift" : "push"](xt),
                    Ms(),
                    xt
                },
                remove: function($e, lt) {
                    ~(lt = N.indexOf($e)) && N.splice(lt, 1) && Ie >= lt && Ie--
                },
                _listeners: N
            },
            Re
        }(), Ms = function() {
            return !na && Ss.wake()
        }, Dt = {}, Gc = /^[\d.\-M][\d.\-,\s]/, eu = /["']/g, Uc = function(g) {
            for (var A = {}, C = g.substr(1, g.length - 3).split(":"), b = C[0], B = 1, F = C.length, N, X, Y; B < F; B++)
                X = C[B],
                N = B !== F - 1 ? X.lastIndexOf(",") : X.length,
                Y = X.substr(0, N),
                A[b] = isNaN(Y) ? Y.replace(eu, "").trim() : +Y,
                b = X.substr(N + 1).trim();
            return A
        }, uo = function(g) {
            var A = g.indexOf("(") + 1
              , C = g.indexOf(")")
              , b = g.indexOf("(", A);
            return g.substring(A, ~b && b < C ? g.indexOf(")", C + 1) : C)
        }, rl = function(g) {
            var A = (g + "").split("(")
              , C = Dt[A[0]];
            return C && A.length > 1 && C.config ? C.config.apply(null, ~g.indexOf("{") ? [Uc(A[1])] : uo(g).split(",").map(Le)) : Dt._CE && Gc.test(g) ? Dt._CE("", g) : C
        }, yi = function(g) {
            return function(A) {
                return 1 - g(1 - A)
            }
        }, Lu = function q(g, A) {
            for (var C = g._first, b; C; )
                C instanceof Lr ? q(C, A) : C.vars.yoyoEase && (!C._yoyo || !C._repeat) && C._yoyo !== A && (C.timeline ? q(C.timeline, A) : (b = C._ease,
                C._ease = C._yEase,
                C._yEase = b,
                C._yoyo = A)),
                C = C._next
        }, Is = function(g, A) {
            return g && (w(g) ? g : Dt[g] || rl(g)) || A
        }, ko = function(g, A, C, b) {
            C === void 0 && (C = function(X) {
                return 1 - A(1 - X)
            }
            ),
            b === void 0 && (b = function(X) {
                return X < .5 ? A(X * 2) / 2 : 1 - A((1 - X) * 2) / 2
            }
            );
            var B = {
                easeIn: A,
                easeOut: C,
                easeInOut: b
            }, F;
            return Ve(g, function(N) {
                Dt[N] = Ae[N] = B,
                Dt[F = N.toLowerCase()] = C;
                for (var X in B)
                    Dt[F + (X === "easeIn" ? ".in" : X === "easeOut" ? ".out" : ".inOut")] = Dt[N + "." + X] = B[X]
            }),
            B
        }, tu = function(g) {
            return function(A) {
                return A < .5 ? (1 - g(1 - A * 2)) / 2 : .5 + g((A - .5) * 2) / 2
            }
        }, Oo = function q(g, A, C) {
            var b = A >= 1 ? A : 1
              , B = (C || (g ? .3 : .45)) / (A < 1 ? A : 1)
              , F = B / p * (Math.asin(1 / b) || 0)
              , N = function(se) {
                return se === 1 ? 1 : b * Math.pow(2, -10 * se) * S((se - F) * B) + 1
            }
              , X = g === "out" ? N : g === "in" ? function(Y) {
                return 1 - N(1 - Y)
            }
            : tu(N);
            return B = p / B,
            X.config = function(Y, se) {
                return q(g, Y, se)
            }
            ,
            X
        }, Ei = function q(g, A) {
            A === void 0 && (A = 1.70158);
            var C = function(F) {
                return F ? --F * F * ((A + 1) * F + A) + 1 : 0
            }
              , b = g === "out" ? C : g === "in" ? function(B) {
                return 1 - C(1 - B)
            }
            : tu(C);
            return b.config = function(B) {
                return q(g, B)
            }
            ,
            b
        };
        Ve("Linear,Quad,Cubic,Quart,Quint,Strong", function(q, g) {
            var A = g < 5 ? g + 1 : g;
            ko(q + ",Power" + (A - 1), g ? function(C) {
                return Math.pow(C, A)
            }
            : function(C) {
                return C
            }
            , function(C) {
                return 1 - Math.pow(1 - C, A)
            }, function(C) {
                return C < .5 ? Math.pow(C * 2, A) / 2 : 1 - Math.pow((1 - C) * 2, A) / 2
            })
        }),
        Dt.Linear.easeNone = Dt.none = Dt.Linear.easeIn,
        ko("Elastic", Oo("in"), Oo("out"), Oo()),
        function(q, g) {
            var A = 1 / g
              , C = 2 * A
              , b = 2.5 * A
              , B = function(N) {
                return N < A ? q * N * N : N < C ? q * Math.pow(N - 1.5 / g, 2) + .75 : N < b ? q * (N -= 2.25 / g) * N + .9375 : q * Math.pow(N - 2.625 / g, 2) + .984375
            };
            ko("Bounce", function(F) {
                return 1 - B(1 - F)
            }, B)
        }(7.5625, 2.75),
        ko("Expo", function(q) {
            return q ? Math.pow(2, 10 * (q - 1)) : 0
        }),
        ko("Circ", function(q) {
            return -(y(1 - q * q) - 1)
        }),
        ko("Sine", function(q) {
            return q === 1 ? 1 : -x(q * m) + 1
        }),
        ko("Back", Ei("in"), Ei("out"), Ei()),
        Dt.SteppedEase = Dt.steps = Ae.SteppedEase = {
            config: function(g, A) {
                g === void 0 && (g = 1);
                var C = 1 / g
                  , b = g + (A ? 0 : 1)
                  , B = A ? 1 : 0
                  , F = 1 - d;
                return function(N) {
                    return ((b * Zn(0, F, N) | 0) + B) * C
                }
            }
        },
        o.ease = Dt["quad.out"],
        Ve("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", function(q) {
            return Z += q + "," + q + "Params,"
        });
        var Fu = function(g, A) {
            this.id = _++,
            g._gsap = this,
            this.target = g,
            this.harness = A,
            this.get = A ? A.get : tt,
            this.set = A ? A.getSetter : sa
        }
          , ra = function() {
            function q(A) {
                this.vars = A,
                this._delay = +A.delay || 0,
                (this._repeat = A.repeat === 1 / 0 ? -2 : A.repeat || 0) && (this._rDelay = A.repeatDelay || 0,
                this._yoyo = !!A.yoyo || !!A.yoyoEase),
                this._ts = 1,
                Gt(this, +A.duration, 1, 1),
                this.data = A.data,
                f && (this._ctx = f,
                f.data.push(this)),
                na || Ss.wake()
            }
            var g = q.prototype;
            return g.delay = function(C) {
                return C || C === 0 ? (this.parent && this.parent.smoothChildTiming && this.startTime(this._start + C - this._delay),
                this._delay = C,
                this) : this._delay
            }
            ,
            g.duration = function(C) {
                return arguments.length ? this.totalDuration(this._repeat > 0 ? C + (C + this._rDelay) * this._repeat : C) : this.totalDuration() && this._dur
            }
            ,
            g.totalDuration = function(C) {
                return arguments.length ? (this._dirty = 0,
                Gt(this, this._repeat < 0 ? C : (C - this._repeat * this._rDelay) / (this._repeat + 1))) : this._tDur
            }
            ,
            g.totalTime = function(C, b) {
                if (Ms(),
                !arguments.length)
                    return this._tTime;
                var B = this._dp;
                if (B && B.smoothChildTiming && this._ts) {
                    for (Qn(this, C),
                    !B._dp || B.parent || vn(B, this); B && B.parent; )
                        B.parent._time !== B._start + (B._ts >= 0 ? B._tTime / B._ts : (B.totalDuration() - B._tTime) / -B._ts) && B.totalTime(B._tTime, !0),
                        B = B.parent;
                    !this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && C < this._tDur || this._ts < 0 && C > 0 || !this._tDur && !C) && j(this._dp, this, this._start - this._delay)
                }
                return (this._tTime !== C || !this._dur && !b || this._initted && Math.abs(this._zTime) === d || !C && !this._initted && (this.add || this._ptLookup)) && (this._ts || (this._pTime = C),
                le(this, C, b)),
                this
            }
            ,
            g.time = function(C, b) {
                return arguments.length ? this.totalTime(Math.min(this.totalDuration(), C + ut(this)) % (this._dur + this._rDelay) || (C ? this._dur : 0), b) : this._time
            }
            ,
            g.totalProgress = function(C, b) {
                return arguments.length ? this.totalTime(this.totalDuration() * C, b) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.ratio
            }
            ,
            g.progress = function(C, b) {
                return arguments.length ? this.totalTime(this.duration() * (this._yoyo && !(this.iteration() & 1) ? 1 - C : C) + ut(this), b) : this.duration() ? Math.min(1, this._time / this._dur) : this.ratio
            }
            ,
            g.iteration = function(C, b) {
                var B = this.duration() + this._rDelay;
                return arguments.length ? this.totalTime(this._time + (C - 1) * B, b) : this._repeat ? Nt(this._tTime, B) + 1 : 1
            }
            ,
            g.timeScale = function(C) {
                if (!arguments.length)
                    return this._rts === -d ? 0 : this._rts;
                if (this._rts === C)
                    return this;
                var b = this.parent && this._ts ? $t(this.parent._time, this) : this._tTime;
                return this._rts = +C || 0,
                this._ts = this._ps || C === -d ? 0 : this._rts,
                this.totalTime(Zn(-this._delay, this._tDur, b), !0),
                hn(this),
                or(this)
            }
            ,
            g.paused = function(C) {
                return arguments.length ? (this._ps !== C && (this._ps = C,
                C ? (this._pTime = this._tTime || Math.max(-this._delay, this.rawTime()),
                this._ts = this._act = 0) : (Ms(),
                this._ts = this._rts,
                this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, this.progress() === 1 && Math.abs(this._zTime) !== d && (this._tTime -= d)))),
                this) : this._ps
            }
            ,
            g.startTime = function(C) {
                if (arguments.length) {
                    this._start = C;
                    var b = this.parent || this._dp;
                    return b && (b._sort || !this.parent) && j(b, this, C - this._delay),
                    this
                }
                return this._start
            }
            ,
            g.endTime = function(C) {
                return this._start + (k(C) ? this.totalDuration() : this.duration()) / Math.abs(this._ts || 1)
            }
            ,
            g.rawTime = function(C) {
                var b = this.parent || this._dp;
                return b ? C && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : this._ts ? $t(b.rawTime(C), this) : this._tTime : this._tTime
            }
            ,
            g.revert = function(C) {
                C === void 0 && (C = Ee);
                var b = l;
                return l = C,
                (this._initted || this._startAt) && (this.timeline && this.timeline.revert(C),
                this.totalTime(-.01, C.suppressEvents)),
                this.data !== "nested" && C.kill !== !1 && this.kill(),
                l = b,
                this
            }
            ,
            g.globalTime = function(C) {
                for (var b = this, B = arguments.length ? C : b.rawTime(); b; )
                    B = b._start + B / (b._ts || 1),
                    b = b._dp;
                return !this.parent && this._sat ? this._sat.vars.immediateRender ? -1 : this._sat.globalTime(C) : B
            }
            ,
            g.repeat = function(C) {
                return arguments.length ? (this._repeat = C === 1 / 0 ? -2 : C,
                Yt(this)) : this._repeat === -2 ? 1 / 0 : this._repeat
            }
            ,
            g.repeatDelay = function(C) {
                if (arguments.length) {
                    var b = this._time;
                    return this._rDelay = C,
                    Yt(this),
                    b ? this.time(b) : this
                }
                return this._rDelay
            }
            ,
            g.yoyo = function(C) {
                return arguments.length ? (this._yoyo = C,
                this) : this._yoyo
            }
            ,
            g.seek = function(C, b) {
                return this.totalTime(tn(this, C), k(b))
            }
            ,
            g.restart = function(C, b) {
                return this.play().totalTime(C ? -this._delay : 0, k(b))
            }
            ,
            g.play = function(C, b) {
                return C != null && this.seek(C, b),
                this.reversed(!1).paused(!1)
            }
            ,
            g.reverse = function(C, b) {
                return C != null && this.seek(C || this.totalDuration(), b),
                this.reversed(!0).paused(!1)
            }
            ,
            g.pause = function(C, b) {
                return C != null && this.seek(C, b),
                this.paused(!0)
            }
            ,
            g.resume = function() {
                return this.paused(!1)
            }
            ,
            g.reversed = function(C) {
                return arguments.length ? (!!C !== this.reversed() && this.timeScale(-this._rts || (C ? -d : 0)),
                this) : this._rts < 0
            }
            ,
            g.invalidate = function() {
                return this._initted = this._act = 0,
                this._zTime = -d,
                this
            }
            ,
            g.isActive = function() {
                var C = this.parent || this._dp, b = this._start, B;
                return !!(!C || this._ts && this._initted && C.isActive() && (B = C.rawTime(!0)) >= b && B < this.endTime(!0) - d)
            }
            ,
            g.eventCallback = function(C, b, B) {
                var F = this.vars;
                return arguments.length > 1 ? (b ? (F[C] = b,
                B && (F[C + "Params"] = B),
                C === "onUpdate" && (this._onUpdate = b)) : delete F[C],
                this) : F[C]
            }
            ,
            g.then = function(C) {
                var b = this;
                return new Promise(function(B) {
                    var F = w(C) ? C : rt
                      , N = function() {
                        var Y = b.then;
                        b.then = null,
                        w(F) && (F = F(b)) && (F.then || F === b) && (b.then = Y),
                        B(F),
                        b.then = Y
                    };
                    b._initted && b.totalProgress() === 1 && b._ts >= 0 || !b._tTime && b._ts < 0 ? N() : b._prom = N
                }
                )
            }
            ,
            g.kill = function() {
                zi(this)
            }
            ,
            q
        }();
        st(ra.prototype, {
            _time: 0,
            _start: 0,
            _end: 0,
            _tTime: 0,
            _tDur: 0,
            _dirty: 0,
            _repeat: 0,
            _yoyo: !1,
            parent: null,
            _initted: !1,
            _rDelay: 0,
            _ts: 1,
            _dp: 0,
            ratio: 0,
            _zTime: -d,
            _prom: 0,
            _ps: !1,
            _rts: 1
        });
        var Lr = function(q) {
            r(g, q);
            function g(C, b) {
                var B;
                return C === void 0 && (C = {}),
                B = q.call(this, C) || this,
                B.labels = {},
                B.smoothChildTiming = !!C.smoothChildTiming,
                B.autoRemoveChildren = !!C.autoRemoveChildren,
                B._sort = k(C.sortChildren),
                z && j(C.parent || z, i(B), b),
                C.reversed && B.reverse(),
                C.paused && B.paused(!0),
                C.scrollTrigger && me(i(B), C.scrollTrigger),
                B
            }
            var A = g.prototype;
            return A.to = function(b, B, F) {
                return Xt(0, arguments, this),
                this
            }
            ,
            A.from = function(b, B, F) {
                return Xt(1, arguments, this),
                this
            }
            ,
            A.fromTo = function(b, B, F, N) {
                return Xt(2, arguments, this),
                this
            }
            ,
            A.set = function(b, B, F) {
                return B.duration = 0,
                B.parent = this,
                De(B).repeatDelay || (B.repeat = 0),
                B.immediateRender = !!B.immediateRender,
                new Fr(b,B,tn(this, F),1),
                this
            }
            ,
            A.call = function(b, B, F) {
                return j(this, Fr.delayedCall(0, b, B), F)
            }
            ,
            A.staggerTo = function(b, B, F, N, X, Y, se) {
                return F.duration = B,
                F.stagger = F.stagger || N,
                F.onComplete = Y,
                F.onCompleteParams = se,
                F.parent = this,
                new Fr(b,F,tn(this, X)),
                this
            }
            ,
            A.staggerFrom = function(b, B, F, N, X, Y, se) {
                return F.runBackwards = 1,
                De(F).immediateRender = k(F.immediateRender),
                this.staggerTo(b, B, F, N, X, Y, se)
            }
            ,
            A.staggerFromTo = function(b, B, F, N, X, Y, se, Re) {
                return N.startAt = F,
                De(N).immediateRender = k(N.immediateRender),
                this.staggerTo(b, B, N, X, Y, se, Re)
            }
            ,
            A.render = function(b, B, F) {
                var N = this._time, X = this._dirty ? this.totalDuration() : this._tDur, Y = this._dur, se = b <= 0 ? 0 : dt(b), Re = this._zTime < 0 != b < 0 && (this._initted || !Y), Pe, Ie, nt, ve, $e, lt, pt, xt, Ct, yt, jt, Wt;
                if (this !== z && se > X && b >= 0 && (se = X),
                se !== this._tTime || F || Re) {
                    if (N !== this._time && Y && (se += this._time - N,
                    b += this._time - N),
                    Pe = se,
                    Ct = this._start,
                    xt = this._ts,
                    lt = !xt,
                    Re && (Y || (N = this._zTime),
                    (b || !B) && (this._zTime = b)),
                    this._repeat) {
                        if (jt = this._yoyo,
                        $e = Y + this._rDelay,
                        this._repeat < -1 && b < 0)
                            return this.totalTime($e * 100 + b, B, F);
                        if (Pe = dt(se % $e),
                        se === X ? (ve = this._repeat,
                        Pe = Y) : (ve = ~~(se / $e),
                        ve && ve === se / $e && (Pe = Y,
                        ve--),
                        Pe > Y && (Pe = Y)),
                        yt = Nt(this._tTime, $e),
                        !N && this._tTime && yt !== ve && (yt = ve),
                        jt && ve & 1 && (Pe = Y - Pe,
                        Wt = 1),
                        ve !== yt && !this._lock) {
                            var Ot = jt && yt & 1
                              , bt = Ot === (jt && ve & 1);
                            if (ve < yt && (Ot = !Ot),
                            N = Ot ? 0 : Y,
                            this._lock = 1,
                            this.render(N || (Wt ? 0 : dt(ve * $e)), B, !Y)._lock = 0,
                            this._tTime = se,
                            !B && this.parent && ts(this, "onRepeat"),
                            this.vars.repeatRefresh && !Wt && (this.invalidate()._lock = 1),
                            N && N !== this._time || lt !== !this._ts || this.vars.onRepeat && !this.parent && !this._act)
                                return this;
                            if (Y = this._dur,
                            X = this._tDur,
                            bt && (this._lock = 2,
                            N = Ot ? Y : -1e-4,
                            this.render(N, !0),
                            this.vars.repeatRefresh && !Wt && this.invalidate()),
                            this._lock = 0,
                            !this._ts && !lt)
                                return this;
                            Lu(this, Wt)
                        }
                    }
                    if (this._hasPause && !this._forcing && this._lock < 2 && (pt = Ft(this, dt(N), dt(Pe)),
                    pt && (se -= Pe - (Pe = pt._start))),
                    this._tTime = se,
                    this._time = Pe,
                    this._act = !xt,
                    this._initted || (this._onUpdate = this.vars.onUpdate,
                    this._initted = 1,
                    this._zTime = b,
                    N = 0),
                    !N && Pe && !B && (ts(this, "onStart"),
                    this._tTime !== se))
                        return this;
                    if (Pe >= N && b >= 0)
                        for (Ie = this._first; Ie; ) {
                            if (nt = Ie._next,
                            (Ie._act || Pe >= Ie._start) && Ie._ts && pt !== Ie) {
                                if (Ie.parent !== this)
                                    return this.render(b, B, F);
                                if (Ie.render(Ie._ts > 0 ? (Pe - Ie._start) * Ie._ts : (Ie._dirty ? Ie.totalDuration() : Ie._tDur) + (Pe - Ie._start) * Ie._ts, B, F),
                                Pe !== this._time || !this._ts && !lt) {
                                    pt = 0,
                                    nt && (se += this._zTime = -d);
                                    break
                                }
                            }
                            Ie = nt
                        }
                    else {
                        Ie = this._last;
                        for (var dr = b < 0 ? b : Pe; Ie; ) {
                            if (nt = Ie._prev,
                            (Ie._act || dr <= Ie._end) && Ie._ts && pt !== Ie) {
                                if (Ie.parent !== this)
                                    return this.render(b, B, F);
                                if (Ie.render(Ie._ts > 0 ? (dr - Ie._start) * Ie._ts : (Ie._dirty ? Ie.totalDuration() : Ie._tDur) + (dr - Ie._start) * Ie._ts, B, F || l && (Ie._initted || Ie._startAt)),
                                Pe !== this._time || !this._ts && !lt) {
                                    pt = 0,
                                    nt && (se += this._zTime = dr ? -d : d);
                                    break
                                }
                            }
                            Ie = nt
                        }
                    }
                    if (pt && !B && (this.pause(),
                    pt.render(Pe >= N ? 0 : -d)._zTime = Pe >= N ? 1 : -1,
                    this._ts))
                        return this._start = Ct,
                        hn(this),
                        this.render(b, B, F);
                    this._onUpdate && !B && ts(this, "onUpdate", !0),
                    (se === X && this._tTime >= this.totalDuration() || !se && N) && (Ct === this._start || Math.abs(xt) !== Math.abs(this._ts)) && (this._lock || ((b || !Y) && (se === X && this._ts > 0 || !se && this._ts < 0) && rn(this, 1),
                    !B && !(b < 0 && !N) && (se || N || !X) && (ts(this, se === X && b >= 0 ? "onComplete" : "onReverseComplete", !0),
                    this._prom && !(se < X && this.timeScale() > 0) && this._prom())))
                }
                return this
            }
            ,
            A.add = function(b, B) {
                var F = this;
                if (T(B) || (B = tn(this, B, b)),
                !(b instanceof ra)) {
                    if (W(b))
                        return b.forEach(function(N) {
                            return F.add(N, B)
                        }),
                        this;
                    if (M(b))
                        return this.addLabel(b, B);
                    if (w(b))
                        b = Fr.delayedCall(0, b);
                    else
                        return this
                }
                return this !== b ? j(this, b, B) : this
            }
            ,
            A.getChildren = function(b, B, F, N) {
                b === void 0 && (b = !0),
                B === void 0 && (B = !0),
                F === void 0 && (F = !0),
                N === void 0 && (N = -h);
                for (var X = [], Y = this._first; Y; )
                    Y._start >= N && (Y instanceof Fr ? B && X.push(Y) : (F && X.push(Y),
                    b && X.push.apply(X, Y.getChildren(!0, B, F)))),
                    Y = Y._next;
                return X
            }
            ,
            A.getById = function(b) {
                for (var B = this.getChildren(1, 1, 1), F = B.length; F--; )
                    if (B[F].vars.id === b)
                        return B[F]
            }
            ,
            A.remove = function(b) {
                return M(b) ? this.removeLabel(b) : w(b) ? this.killTweensOf(b) : (Et(this, b),
                b === this._recent && (this._recent = this._last),
                dn(this))
            }
            ,
            A.totalTime = function(b, B) {
                return arguments.length ? (this._forcing = 1,
                !this._dp && this._ts && (this._start = dt(Ss.time - (this._ts > 0 ? b / this._ts : (this.totalDuration() - b) / -this._ts))),
                q.prototype.totalTime.call(this, b, B),
                this._forcing = 0,
                this) : this._tTime
            }
            ,
            A.addLabel = function(b, B) {
                return this.labels[b] = tn(this, B),
                this
            }
            ,
            A.removeLabel = function(b) {
                return delete this.labels[b],
                this
            }
            ,
            A.addPause = function(b, B, F) {
                var N = Fr.delayedCall(0, B || He, F);
                return N.data = "isPause",
                this._hasPause = 1,
                j(this, N, tn(this, b))
            }
            ,
            A.removePause = function(b) {
                var B = this._first;
                for (b = tn(this, b); B; )
                    B._start === b && B.data === "isPause" && rn(B),
                    B = B._next
            }
            ,
            A.killTweensOf = function(b, B, F) {
                for (var N = this.getTweensOf(b, F), X = N.length; X--; )
                    Pa !== N[X] && N[X].kill(b, B);
                return this
            }
            ,
            A.getTweensOf = function(b, B) {
                for (var F = [], N = Ln(b), X = this._first, Y = T(B), se; X; )
                    X instanceof Fr ? Fe(X._targets, N) && (Y ? (!Pa || X._initted && X._ts) && X.globalTime(0) <= B && X.globalTime(X.totalDuration()) > B : !B || X.isActive()) && F.push(X) : (se = X.getTweensOf(N, B)).length && F.push.apply(F, se),
                    X = X._next;
                return F
            }
            ,
            A.tweenTo = function(b, B) {
                B = B || {};
                var F = this, N = tn(F, b), X = B, Y = X.startAt, se = X.onStart, Re = X.onStartParams, Pe = X.immediateRender, Ie, nt = Fr.to(F, st({
                    ease: B.ease || "none",
                    lazy: !1,
                    immediateRender: !1,
                    time: N,
                    overwrite: "auto",
                    duration: B.duration || Math.abs((N - (Y && "time"in Y ? Y.time : F._time)) / F.timeScale()) || d,
                    onStart: function() {
                        if (F.pause(),
                        !Ie) {
                            var $e = B.duration || Math.abs((N - (Y && "time"in Y ? Y.time : F._time)) / F.timeScale());
                            nt._dur !== $e && Gt(nt, $e, 0, 1).render(nt._time, !0, !0),
                            Ie = 1
                        }
                        se && se.apply(nt, Re || [])
                    }
                }, B));
                return Pe ? nt.render(0) : nt
            }
            ,
            A.tweenFromTo = function(b, B, F) {
                return this.tweenTo(B, st({
                    startAt: {
                        time: tn(this, b)
                    }
                }, F))
            }
            ,
            A.recent = function() {
                return this._recent
            }
            ,
            A.nextLabel = function(b) {
                return b === void 0 && (b = this._time),
                Rl(this, tn(this, b))
            }
            ,
            A.previousLabel = function(b) {
                return b === void 0 && (b = this._time),
                Rl(this, tn(this, b), 1)
            }
            ,
            A.currentLabel = function(b) {
                return arguments.length ? this.seek(b, !0) : this.previousLabel(this._time + d)
            }
            ,
            A.shiftChildren = function(b, B, F) {
                F === void 0 && (F = 0);
                for (var N = this._first, X = this.labels, Y; N; )
                    N._start >= F && (N._start += b,
                    N._end += b),
                    N = N._next;
                if (B)
                    for (Y in X)
                        X[Y] >= F && (X[Y] += b);
                return dn(this)
            }
            ,
            A.invalidate = function(b) {
                var B = this._first;
                for (this._lock = 0; B; )
                    B.invalidate(b),
                    B = B._next;
                return q.prototype.invalidate.call(this, b)
            }
            ,
            A.clear = function(b) {
                b === void 0 && (b = !0);
                for (var B = this._first, F; B; )
                    F = B._next,
                    this.remove(B),
                    B = F;
                return this._dp && (this._time = this._tTime = this._pTime = 0),
                b && (this.labels = {}),
                dn(this)
            }
            ,
            A.totalDuration = function(b) {
                var B = 0, F = this, N = F._last, X = h, Y, se, Re;
                if (arguments.length)
                    return F.timeScale((F._repeat < 0 ? F.duration() : F.totalDuration()) / (F.reversed() ? -b : b));
                if (F._dirty) {
                    for (Re = F.parent; N; )
                        Y = N._prev,
                        N._dirty && N.totalDuration(),
                        se = N._start,
                        se > X && F._sort && N._ts && !F._lock ? (F._lock = 1,
                        j(F, N, se - N._delay, 1)._lock = 0) : X = se,
                        se < 0 && N._ts && (B -= se,
                        (!Re && !F._dp || Re && Re.smoothChildTiming) && (F._start += se / F._ts,
                        F._time -= se,
                        F._tTime -= se),
                        F.shiftChildren(-se, !1, -1 / 0),
                        X = 0),
                        N._end > B && N._ts && (B = N._end),
                        N = Y;
                    Gt(F, F === z && F._time > B ? F._time : B, 1, 1),
                    F._dirty = 0
                }
                return F._tDur
            }
            ,
            g.updateRoot = function(b) {
                if (z._ts && (le(z, $t(b, z)),
                ee = Ss.frame),
                Ss.frame >= ft) {
                    ft += s.autoSleep || 120;
                    var B = z._first;
                    if ((!B || !B._ts) && s.autoSleep && Ss._listeners.length < 2) {
                        for (; B && !B._ts; )
                            B = B._next;
                        B || Ss.sleep()
                    }
                }
            }
            ,
            g
        }(ra);
        st(Lr.prototype, {
            _lock: 0,
            _hasPause: 0,
            _forcing: 0
        });
        var co = function(g, A, C, b, B, F, N) {
            var X = new Be(this._pt,g,A,0,1,J,null,B), Y = 0, se = 0, Re, Pe, Ie, nt, ve, $e, lt, pt;
            for (X.b = C,
            X.e = b,
            C += "",
            b += "",
            (lt = ~b.indexOf("random(")) && (b = Hr(b)),
            F && (pt = [C, b],
            F(pt, g, A),
            C = pt[0],
            b = pt[1]),
            Pe = C.match(pe) || []; Re = pe.exec(b); )
                nt = Re[0],
                ve = b.substring(Y, Re.index),
                Ie ? Ie = (Ie + 1) % 5 : ve.substr(-5) === "rgba(" && (Ie = 1),
                nt !== Pe[se++] && ($e = parseFloat(Pe[se - 1]) || 0,
                X._pt = {
                    _next: X._pt,
                    p: ve || se === 1 ? ve : ",",
                    s: $e,
                    c: nt.charAt(1) === "=" ? ct($e, nt) - $e : parseFloat(nt) - $e,
                    m: Ie && Ie < 4 ? Math.round : 0
                },
                Y = pe.lastIndex);
            return X.c = Y < b.length ? b.substring(Y, b.length) : "",
            X.fp = N,
            (ce.test(b) || lt) && (X.e = 0),
            this._pt = X,
            X
        }, Il = function(g, A, C, b, B, F, N, X, Y, se) {
            w(b) && (b = b(B || 0, g, F));
            var Re = g[A], Pe = C !== "get" ? C : w(Re) ? Y ? g[A.indexOf("set") || !w(g["get" + A.substr(3)]) ? A : "get" + A.substr(3)](Y) : g[A]() : Re, Ie = w(Re) ? Y ? Hc : Nu : nu, nt;
            if (M(b) && (~b.indexOf("random(") && (b = Hr(b)),
            b.charAt(1) === "=" && (nt = ct(Pe, b) + (Yn(Pe) || 0),
            (nt || nt === 0) && (b = nt))),
            !se || Pe !== b || us)
                return !isNaN(Pe * b) && b !== "" ? (nt = new Be(this._pt,g,A,+Pe || 0,b - (Pe || 0),typeof Re == "boolean" ? Te : Ls,0,Ie),
                Y && (nt.fp = Y),
                N && nt.modifier(N, this, g),
                this._pt = nt) : (!Re && !(A in g) && qe(A, b),
                co.call(this, g, A, Pe, b, Ie, X || s.stringFilter, Y))
        }, Da = function(g, A, C, b, B) {
            if (w(g) && (g = Cn(g, B, A, C, b)),
            !I(g) || g.style && g.nodeType || W(g) || H(g))
                return M(g) ? Cn(g, B, A, C, b) : g;
            var F = {}, N;
            for (N in g)
                F[N] = Cn(g[N], B, A, C, b);
            return F
        }, Ll = function(g, A, C, b, B, F) {
            var N, X, Y, se;
            if (et[g] && (N = new et[g]).init(B, N.rawVars ? A[g] : Da(A[g], b, B, F, C), C, b, F) !== !1 && (C._pt = X = new Be(C._pt,B,g,0,1,N.render,N,0,N.priority),
            C !== ta))
                for (Y = C._ptLookup[C._targets.indexOf(B)],
                se = N._props.length; se--; )
                    Y[N._props[se]] = X;
            return N
        }, Pa, us, ku = function q(g, A, C) {
            var b = g.vars, B = b.ease, F = b.startAt, N = b.immediateRender, X = b.lazy, Y = b.onUpdate, se = b.onUpdateParams, Re = b.callbackScope, Pe = b.runBackwards, Ie = b.yoyoEase, nt = b.keyframes, ve = b.autoRevert, $e = g._dur, lt = g._startAt, pt = g._targets, xt = g.parent, Ct = xt && xt.data === "nested" ? xt.vars.targets : pt, yt = g._overwrite === "auto" && !a, jt = g.timeline, Wt, Ot, bt, dr, yr, ti, pi, Ri, ni, Hi, Bi, ns, kl;
            if (jt && (!nt || !B) && (B = "none"),
            g._ease = Is(B, o.ease),
            g._yEase = Ie ? yi(Is(Ie === !0 ? B : Ie, o.ease)) : 0,
            Ie && g._yoyo && !g._repeat && (Ie = g._yEase,
            g._yEase = g._ease,
            g._ease = Ie),
            g._from = !jt && !!b.runBackwards,
            !jt || nt && !b.stagger) {
                if (Ri = pt[0] ? ye(pt[0]).harness : 0,
                ns = Ri && b[Ri.prop],
                Wt = ae(b, at),
                lt && (lt._zTime < 0 && lt.progress(1),
                A < 0 && Pe && N && !ve ? lt.render(-1, !0) : lt.revert(Pe && $e ? be : gt),
                lt._lazy = 0),
                F) {
                    if (rn(g._startAt = Fr.set(pt, st({
                        data: "isStart",
                        overwrite: !1,
                        parent: xt,
                        immediateRender: !0,
                        lazy: !lt && k(X),
                        startAt: null,
                        delay: 0,
                        onUpdate: Y,
                        onUpdateParams: se,
                        callbackScope: Re,
                        stagger: 0
                    }, F))),
                    g._startAt._dp = 0,
                    g._startAt._sat = g,
                    A < 0 && (l || !N && !ve) && g._startAt.revert(be),
                    N && $e && A <= 0 && C <= 0) {
                        A && (g._zTime = A);
                        return
                    }
                } else if (Pe && $e && !lt) {
                    if (A && (N = !1),
                    bt = st({
                        overwrite: !1,
                        data: "isFromStart",
                        lazy: N && !lt && k(X),
                        immediateRender: N,
                        stagger: 0,
                        parent: xt
                    }, Wt),
                    ns && (bt[Ri.prop] = ns),
                    rn(g._startAt = Fr.set(pt, bt)),
                    g._startAt._dp = 0,
                    g._startAt._sat = g,
                    A < 0 && (l ? g._startAt.revert(be) : g._startAt.render(-1, !0)),
                    g._zTime = A,
                    !N)
                        q(g._startAt, d, d);
                    else if (!A)
                        return
                }
                for (g._pt = g._ptCache = 0,
                X = $e && k(X) || X && !$e,
                Ot = 0; Ot < pt.length; Ot++) {
                    if (yr = pt[Ot],
                    pi = yr._gsap || V(pt)[Ot]._gsap,
                    g._ptLookup[Ot] = Hi = {},
                    Ce[pi.id] && _t.length && Rt(),
                    Bi = Ct === pt ? Ot : Ct.indexOf(yr),
                    Ri && (ni = new Ri).init(yr, ns || Wt, g, Bi, Ct) !== !1 && (g._pt = dr = new Be(g._pt,yr,ni.name,0,1,ni.render,ni,0,ni.priority),
                    ni._props.forEach(function(ol) {
                        Hi[ol] = dr
                    }),
                    ni.priority && (ti = 1)),
                    !Ri || ns)
                        for (bt in Wt)
                            et[bt] && (ni = Ll(bt, Wt, g, Bi, yr, Ct)) ? ni.priority && (ti = 1) : Hi[bt] = dr = Il.call(g, yr, bt, "get", Wt[bt], Bi, Ct, 0, b.stringFilter);
                    g._op && g._op[Ot] && g.kill(yr, g._op[Ot]),
                    yt && g._pt && (Pa = g,
                    z.killTweensOf(yr, Hi, g.globalTime(A)),
                    kl = !g.parent,
                    Pa = 0),
                    g._pt && X && (Ce[pi.id] = 1)
                }
                ti && We(g),
                g._onInit && g._onInit(g)
            }
            g._onUpdate = Y,
            g._initted = (!g._op || g._pt) && !kl,
            nt && A <= 0 && jt.render(h, !0, !0)
        }, Ou = function(g, A, C, b, B, F, N) {
            var X = (g._pt && g._ptCache || (g._ptCache = {}))[A], Y, se, Re, Pe;
            if (!X)
                for (X = g._ptCache[A] = [],
                Re = g._ptLookup,
                Pe = g._targets.length; Pe--; ) {
                    if (Y = Re[Pe][A],
                    Y && Y.d && Y.d._pt)
                        for (Y = Y.d._pt; Y && Y.p !== A && Y.fp !== A; )
                            Y = Y._next;
                    if (!Y)
                        return us = 1,
                        g.vars[A] = "+=0",
                        ku(g, N),
                        us = 0,
                        1;
                    X.push(Y)
                }
            for (Pe = X.length; Pe--; )
                se = X[Pe],
                Y = se._pt || se,
                Y.s = (b || b === 0) && !B ? b : Y.s + (b || 0) + F * Y.c,
                Y.c = C - Y.s,
                se.e && (se.e = Ke(C) + Yn(se.e)),
                se.b && (se.b = Y.s + Yn(se.b))
        }, rd = function(g, A) {
            var C = g[0] ? ye(g[0]).harness : 0, b = C && C.aliases, B, F, N, X;
            if (!b)
                return A;
            B = Mt({}, A);
            for (F in b)
                if (F in B)
                    for (X = b[F].split(","),
                    N = X.length; N--; )
                        B[X[N]] = B[F];
            return B
        }, js = function(g, A, C, b) {
            var B = A.ease || b || "power1.inOut", F, N;
            if (W(A))
                N = C[g] || (C[g] = []),
                A.forEach(function(X, Y) {
                    return N.push({
                        t: Y / (A.length - 1) * 100,
                        v: X,
                        e: B
                    })
                });
            else
                for (F in A)
                    N = C[F] || (C[F] = []),
                    F === "ease" || N.push({
                        t: parseFloat(g),
                        v: A[F],
                        e: B
                    })
        }, Cn = function(g, A, C, b, B) {
            return w(g) ? g.call(A, C, b, B) : M(g) && ~g.indexOf("random(") ? Hr(g) : g
        }, Fl = Z + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert", ia = {};
        Ve(Fl + ",id,stagger,delay,duration,paused,scrollTrigger", function(q) {
            return ia[q] = 1
        });
        var Fr = function(q) {
            r(g, q);
            function g(C, b, B, F) {
                var N;
                typeof b == "number" && (B.duration = b,
                b = B,
                B = null),
                N = q.call(this, F ? b : De(b)) || this;
                var X = N.vars, Y = X.duration, se = X.delay, Re = X.immediateRender, Pe = X.stagger, Ie = X.overwrite, nt = X.keyframes, ve = X.defaults, $e = X.scrollTrigger, lt = X.yoyoEase, pt = b.parent || z, xt = (W(C) || H(C) ? T(C[0]) : "length"in b) ? [C] : Ln(C), Ct, yt, jt, Wt, Ot, bt, dr, yr;
                if (N._targets = xt.length ? V(xt) : Ne("GSAP target " + C + " not found. https://greensock.com", !s.nullTargetWarn) || [],
                N._ptLookup = [],
                N._overwrite = Ie,
                nt || Pe || O(Y) || O(se)) {
                    if (b = N.vars,
                    Ct = N.timeline = new Lr({
                        data: "nested",
                        defaults: ve || {},
                        targets: pt && pt.data === "nested" ? pt.vars.targets : xt
                    }),
                    Ct.kill(),
                    Ct.parent = Ct._dp = i(N),
                    Ct._start = 0,
                    Pe || O(Y) || O(se)) {
                        if (Wt = xt.length,
                        dr = Pe && Qr(Pe),
                        I(Pe))
                            for (Ot in Pe)
                                ~Fl.indexOf(Ot) && (yr || (yr = {}),
                                yr[Ot] = Pe[Ot]);
                        for (yt = 0; yt < Wt; yt++)
                            jt = ae(b, ia),
                            jt.stagger = 0,
                            lt && (jt.yoyoEase = lt),
                            yr && Mt(jt, yr),
                            bt = xt[yt],
                            jt.duration = +Cn(Y, i(N), yt, bt, xt),
                            jt.delay = (+Cn(se, i(N), yt, bt, xt) || 0) - N._delay,
                            !Pe && Wt === 1 && jt.delay && (N._delay = se = jt.delay,
                            N._start += se,
                            jt.delay = 0),
                            Ct.to(bt, jt, dr ? dr(yt, bt, xt) : 0),
                            Ct._ease = Dt.none;
                        Ct.duration() ? Y = se = 0 : N.timeline = 0
                    } else if (nt) {
                        De(st(Ct.vars.defaults, {
                            ease: "none"
                        })),
                        Ct._ease = Is(nt.ease || b.ease || "none");
                        var ti = 0, pi, Ri, ni;
                        if (W(nt))
                            nt.forEach(function(Hi) {
                                return Ct.to(xt, Hi, ">")
                            }),
                            Ct.duration();
                        else {
                            jt = {};
                            for (Ot in nt)
                                Ot === "ease" || Ot === "easeEach" || js(Ot, nt[Ot], jt, nt.easeEach);
                            for (Ot in jt)
                                for (pi = jt[Ot].sort(function(Hi, Bi) {
                                    return Hi.t - Bi.t
                                }),
                                ti = 0,
                                yt = 0; yt < pi.length; yt++)
                                    Ri = pi[yt],
                                    ni = {
                                        ease: Ri.e,
                                        duration: (Ri.t - (yt ? pi[yt - 1].t : 0)) / 100 * Y
                                    },
                                    ni[Ot] = Ri.v,
                                    Ct.to(xt, ni, ti),
                                    ti += ni.duration;
                            Ct.duration() < Y && Ct.to({}, {
                                duration: Y - Ct.duration()
                            })
                        }
                    }
                    Y || N.duration(Y = Ct.duration())
                } else
                    N.timeline = 0;
                return Ie === !0 && !a && (Pa = i(N),
                z.killTweensOf(xt),
                Pa = 0),
                j(pt, i(N), B),
                b.reversed && N.reverse(),
                b.paused && N.paused(!0),
                (Re || !Y && !nt && N._start === dt(pt._time) && k(Re) && St(i(N)) && pt.data !== "nested") && (N._tTime = -d,
                N.render(Math.max(0, -se) || 0)),
                $e && me(i(N), $e),
                N
            }
            var A = g.prototype;
            return A.render = function(b, B, F) {
                var N = this._time, X = this._tDur, Y = this._dur, se = b < 0, Re = b > X - d && !se ? X : b < d ? 0 : b, Pe, Ie, nt, ve, $e, lt, pt, xt, Ct;
                if (!Y)
                    Vt(this, b, B, F);
                else if (Re !== this._tTime || !b || F || !this._initted && this._tTime || this._startAt && this._zTime < 0 !== se) {
                    if (Pe = Re,
                    xt = this.timeline,
                    this._repeat) {
                        if (ve = Y + this._rDelay,
                        this._repeat < -1 && se)
                            return this.totalTime(ve * 100 + b, B, F);
                        if (Pe = dt(Re % ve),
                        Re === X ? (nt = this._repeat,
                        Pe = Y) : (nt = ~~(Re / ve),
                        nt && nt === Re / ve && (Pe = Y,
                        nt--),
                        Pe > Y && (Pe = Y)),
                        lt = this._yoyo && nt & 1,
                        lt && (Ct = this._yEase,
                        Pe = Y - Pe),
                        $e = Nt(this._tTime, ve),
                        Pe === N && !F && this._initted)
                            return this._tTime = Re,
                            this;
                        nt !== $e && (xt && this._yEase && Lu(xt, lt),
                        this.vars.repeatRefresh && !lt && !this._lock && (this._lock = F = 1,
                        this.render(dt(ve * nt), !0).invalidate()._lock = 0))
                    }
                    if (!this._initted) {
                        if (ze(this, se ? b : Pe, F, B, Re))
                            return this._tTime = 0,
                            this;
                        if (N !== this._time)
                            return this;
                        if (Y !== this._dur)
                            return this.render(b, B, F)
                    }
                    if (this._tTime = Re,
                    this._time = Pe,
                    !this._act && this._ts && (this._act = 1,
                    this._lazy = 0),
                    this.ratio = pt = (Ct || this._ease)(Pe / Y),
                    this._from && (this.ratio = pt = 1 - pt),
                    Pe && !N && !B && (ts(this, "onStart"),
                    this._tTime !== Re))
                        return this;
                    for (Ie = this._pt; Ie; )
                        Ie.r(pt, Ie.d),
                        Ie = Ie._next;
                    xt && xt.render(b < 0 ? b : !Pe && lt ? -d : xt._dur * xt._ease(Pe / this._dur), B, F) || this._startAt && (this._zTime = b),
                    this._onUpdate && !B && (se && mn(this, b, B, F),
                    ts(this, "onUpdate")),
                    this._repeat && nt !== $e && this.vars.onRepeat && !B && this.parent && ts(this, "onRepeat"),
                    (Re === this._tDur || !Re) && this._tTime === Re && (se && !this._onUpdate && mn(this, b, !0, !0),
                    (b || !Y) && (Re === this._tDur && this._ts > 0 || !Re && this._ts < 0) && rn(this, 1),
                    !B && !(se && !N) && (Re || N || lt) && (ts(this, Re === X ? "onComplete" : "onReverseComplete", !0),
                    this._prom && !(Re < X && this.timeScale() > 0) && this._prom()))
                }
                return this
            }
            ,
            A.targets = function() {
                return this._targets
            }
            ,
            A.invalidate = function(b) {
                return (!b || !this.vars.runBackwards) && (this._startAt = 0),
                this._pt = this._op = this._onUpdate = this._lazy = this.ratio = 0,
                this._ptLookup = [],
                this.timeline && this.timeline.invalidate(b),
                q.prototype.invalidate.call(this, b)
            }
            ,
            A.resetTo = function(b, B, F, N) {
                na || Ss.wake(),
                this._ts || this.play();
                var X = Math.min(this._dur, (this._dp._time - this._start) * this._ts), Y;
                return this._initted || ku(this, X),
                Y = this._ease(X / this._dur),
                Ou(this, b, B, F, N, Y, X) ? this.resetTo(b, B, F, N) : (Qn(this, 0),
                this.parent || vt(this._dp, this, "_first", "_last", this._dp._sort ? "_start" : 0),
                this.render(0))
            }
            ,
            A.kill = function(b, B) {
                if (B === void 0 && (B = "all"),
                !b && (!B || B === "all"))
                    return this._lazy = this._pt = 0,
                    this.parent ? zi(this) : this;
                if (this.timeline) {
                    var F = this.timeline.totalDuration();
                    return this.timeline.killTweensOf(b, B, Pa && Pa.vars.overwrite !== !0)._first || zi(this),
                    this.parent && F !== this.timeline.totalDuration() && Gt(this, this._dur * this.timeline._tDur / F, 0, 1),
                    this
                }
                var N = this._targets, X = b ? Ln(b) : N, Y = this._ptLookup, se = this._pt, Re, Pe, Ie, nt, ve, $e, lt;
                if ((!B || B === "all") && Je(N, X))
                    return B === "all" && (this._pt = 0),
                    zi(this);
                for (Re = this._op = this._op || [],
                B !== "all" && (M(B) && (ve = {},
                Ve(B, function(pt) {
                    return ve[pt] = 1
                }),
                B = ve),
                B = rd(N, B)),
                lt = N.length; lt--; )
                    if (~X.indexOf(N[lt])) {
                        Pe = Y[lt],
                        B === "all" ? (Re[lt] = B,
                        nt = Pe,
                        Ie = {}) : (Ie = Re[lt] = Re[lt] || {},
                        nt = B);
                        for (ve in nt)
                            $e = Pe && Pe[ve],
                            $e && ((!("kill"in $e.d) || $e.d.kill(ve) === !0) && Et(this, $e, "_pt"),
                            delete Pe[ve]),
                            Ie !== "all" && (Ie[ve] = 1)
                    }
                return this._initted && !this._pt && se && zi(this),
                this
            }
            ,
            g.to = function(b, B) {
                return new g(b,B,arguments[2])
            }
            ,
            g.from = function(b, B) {
                return Xt(1, arguments)
            }
            ,
            g.delayedCall = function(b, B, F, N) {
                return new g(B,0,{
                    immediateRender: !1,
                    lazy: !1,
                    overwrite: !1,
                    delay: b,
                    onComplete: B,
                    onReverseComplete: B,
                    onCompleteParams: F,
                    onReverseCompleteParams: F,
                    callbackScope: N
                })
            }
            ,
            g.fromTo = function(b, B, F) {
                return Xt(2, arguments)
            }
            ,
            g.set = function(b, B) {
                return B.duration = 0,
                B.repeatDelay || (B.repeat = 0),
                new g(b,B)
            }
            ,
            g.killTweensOf = function(b, B, F) {
                return z.killTweensOf(b, B, F)
            }
            ,
            g
        }(ra);
        st(Fr.prototype, {
            _targets: [],
            _lazy: 0,
            _startAt: 0,
            _op: 0,
            _onInit: 0
        }),
        Ve("staggerTo,staggerFrom,staggerFromTo", function(q) {
            Fr[q] = function() {
                var g = new Lr
                  , A = Nn.call(arguments, 0);
                return A.splice(q === "staggerFromTo" ? 5 : 4, 0, 0),
                g[q].apply(g, A)
            }
        });
        var nu = function(g, A, C) {
            return g[A] = C
        }
          , Nu = function(g, A, C) {
            return g[A](C)
        }
          , Hc = function(g, A, C, b) {
            return g[A](b.fp, C)
        }
          , zu = function(g, A, C) {
            return g.setAttribute(A, C)
        }
          , sa = function(g, A) {
            return w(g[A]) ? Nu : P(g[A]) && g.setAttribute ? zu : nu
        }
          , Ls = function(g, A) {
            return A.set(A.t, A.p, Math.round((A.s + A.c * g) * 1e6) / 1e6, A)
        }
          , Te = function(g, A) {
            return A.set(A.t, A.p, !!(A.s + A.c * g), A)
        }
          , J = function(g, A) {
            var C = A._pt
              , b = "";
            if (!g && A.b)
                b = A.b;
            else if (g === 1 && A.e)
                b = A.e;
            else {
                for (; C; )
                    b = C.p + (C.m ? C.m(C.s + C.c * g) : Math.round((C.s + C.c * g) * 1e4) / 1e4) + b,
                    C = C._next;
                b += A.c
            }
            A.set(A.t, A.p, b, A)
        }
          , ue = function(g, A) {
            for (var C = A._pt; C; )
                C.r(g, C.d),
                C = C._next
        }
          , K = function(g, A, C, b) {
            for (var B = this._pt, F; B; )
                F = B._next,
                B.p === b && B.modifier(g, A, C),
                B = F
        }
          , Q = function(g) {
            for (var A = this._pt, C, b; A; )
                b = A._next,
                A.p === g && !A.op || A.op === g ? Et(this, A, "_pt") : A.dep || (C = 1),
                A = b;
            return !C
        }
          , Se = function(g, A, C, b) {
            b.mSet(g, A, b.m.call(b.tween, C, b.mt), b)
        }
          , We = function(g) {
            for (var A = g._pt, C, b, B, F; A; ) {
                for (C = A._next,
                b = B; b && b.pr > A.pr; )
                    b = b._next;
                (A._prev = b ? b._prev : F) ? A._prev._next = A : B = A,
                (A._next = b) ? b._prev = A : F = A,
                A = C
            }
            g._pt = B
        }
          , Be = function() {
            function q(A, C, b, B, F, N, X, Y, se) {
                this.t = C,
                this.s = B,
                this.c = F,
                this.p = b,
                this.r = N || Ls,
                this.d = X || this,
                this.set = Y || nu,
                this.pr = se || 0,
                this._next = A,
                A && (A._prev = this)
            }
            var g = q.prototype;
            return g.modifier = function(C, b, B) {
                this.mSet = this.mSet || this.set,
                this.set = Se,
                this.m = C,
                this.mt = B,
                this.tween = b
            }
            ,
            q
        }();
        Ve(Z + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", function(q) {
            return at[q] = 1
        }),
        Ae.TweenMax = Ae.TweenLite = Fr,
        Ae.TimelineLite = Ae.TimelineMax = Lr,
        z = new Lr({
            sortChildren: !1,
            defaults: o,
            autoRemoveChildren: !0,
            id: "root",
            smoothChildTiming: !0
        }),
        s.stringFilter = Fo;
        var Bt = []
          , Fn = {}
          , zn = []
          , xn = 0
          , Jt = function(g) {
            return (Fn[g] || zn).map(function(A) {
                return A()
            })
        }
          , At = function() {
            var g = Date.now()
              , A = [];
            g - xn > 2 && (Jt("matchMediaInit"),
            Bt.forEach(function(C) {
                var b = C.queries, B = C.conditions, F, N, X, Y;
                for (N in b)
                    F = U.matchMedia(b[N]).matches,
                    F && (X = 1),
                    F !== B[N] && (B[N] = F,
                    Y = 1);
                Y && (C.revert(),
                X && A.push(C))
            }),
            Jt("matchMediaRevert"),
            A.forEach(function(C) {
                return C.onMatch(C)
            }),
            xn = g,
            Jt("matchMedia"))
        }
          , Qt = function() {
            function q(A, C) {
                this.selector = C && Bs(C),
                this.data = [],
                this._r = [],
                this.isReverted = !1,
                A && this.add(A)
            }
            var g = q.prototype;
            return g.add = function(C, b, B) {
                w(C) && (B = b,
                b = C,
                C = w);
                var F = this
                  , N = function() {
                    var Y = f, se = F.selector, Re;
                    return Y && Y !== F && Y.data.push(F),
                    B && (F.selector = Bs(B)),
                    f = F,
                    Re = b.apply(F, arguments),
                    w(Re) && F._r.push(Re),
                    f = Y,
                    F.selector = se,
                    F.isReverted = !1,
                    Re
                };
                return F.last = N,
                C === w ? N(F) : C ? F[C] = N : N
            }
            ,
            g.ignore = function(C) {
                var b = f;
                f = null,
                C(this),
                f = b
            }
            ,
            g.getTweens = function() {
                var C = [];
                return this.data.forEach(function(b) {
                    return b instanceof q ? C.push.apply(C, b.getTweens()) : b instanceof Fr && !(b.parent && b.parent.data === "nested") && C.push(b)
                }),
                C
            }
            ,
            g.clear = function() {
                this._r.length = this.data.length = 0
            }
            ,
            g.kill = function(C, b) {
                var B = this;
                if (C) {
                    var F = this.getTweens();
                    this.data.forEach(function(X) {
                        X.data === "isFlip" && (X.revert(),
                        X.getChildren(!0, !0, !1).forEach(function(Y) {
                            return F.splice(F.indexOf(Y), 1)
                        }))
                    }),
                    F.map(function(X) {
                        return {
                            g: X.globalTime(0),
                            t: X
                        }
                    }).sort(function(X, Y) {
                        return Y.g - X.g || -1
                    }).forEach(function(X) {
                        return X.t.revert(C)
                    }),
                    this.data.forEach(function(X) {
                        return !(X instanceof ra) && X.revert && X.revert(C)
                    }),
                    this._r.forEach(function(X) {
                        return X(C, B)
                    }),
                    this.isReverted = !0
                } else
                    this.data.forEach(function(X) {
                        return X.kill && X.kill()
                    });
                if (this.clear(),
                b) {
                    var N = Bt.indexOf(this);
                    ~N && Bt.splice(N, 1)
                }
            }
            ,
            g.revert = function(C) {
                this.kill(C || {})
            }
            ,
            q
        }()
          , Vr = function() {
            function q(A) {
                this.contexts = [],
                this.scope = A
            }
            var g = q.prototype;
            return g.add = function(C, b, B) {
                I(C) || (C = {
                    matches: C
                });
                var F = new Qt(0,B || this.scope), N = F.conditions = {}, X, Y, se;
                this.contexts.push(F),
                b = F.add("onMatch", b),
                F.queries = C;
                for (Y in C)
                    Y === "all" ? se = 1 : (X = U.matchMedia(C[Y]),
                    X && (Bt.indexOf(F) < 0 && Bt.push(F),
                    (N[Y] = X.matches) && (se = 1),
                    X.addListener ? X.addListener(At) : X.addEventListener("change", At)));
                return se && b(F),
                this
            }
            ,
            g.revert = function(C) {
                this.kill(C || {})
            }
            ,
            g.kill = function(C) {
                this.contexts.forEach(function(b) {
                    return b.kill(C, !0)
                })
            }
            ,
            q
        }()
          , lr = {
            registerPlugin: function() {
                for (var g = arguments.length, A = new Array(g), C = 0; C < g; C++)
                    A[C] = arguments[C];
                A.forEach(function(b) {
                    return Iu(b)
                })
            },
            timeline: function(g) {
                return new Lr(g)
            },
            getTweensOf: function(g, A) {
                return z.getTweensOf(g, A)
            },
            getProperty: function(g, A, C, b) {
                M(g) && (g = Ln(g)[0]);
                var B = ye(g || {}).get
                  , F = C ? rt : Le;
                return C === "native" && (C = ""),
                g && (A ? F((et[A] && et[A].get || B)(g, A, C, b)) : function(N, X, Y) {
                    return F((et[N] && et[N].get || B)(g, N, X, Y))
                }
                )
            },
            quickSetter: function(g, A, C) {
                if (g = Ln(g),
                g.length > 1) {
                    var b = g.map(function(se) {
                        return pn.quickSetter(se, A, C)
                    })
                      , B = b.length;
                    return function(se) {
                        for (var Re = B; Re--; )
                            b[Re](se)
                    }
                }
                g = g[0] || {};
                var F = et[A]
                  , N = ye(g)
                  , X = N.harness && (N.harness.aliases || {})[A] || A
                  , Y = F ? function(se) {
                    var Re = new F;
                    ta._pt = 0,
                    Re.init(g, C ? se + C : se, ta, 0, [g]),
                    Re.render(1, Re),
                    ta._pt && ue(1, ta)
                }
                : N.set(g, X);
                return F ? Y : function(se) {
                    return Y(g, X, C ? se + C : se, N, 1)
                }
            },
            quickTo: function(g, A, C) {
                var b, B = pn.to(g, Mt((b = {},
                b[A] = "+=0.1",
                b.paused = !0,
                b), C || {})), F = function(X, Y, se) {
                    return B.resetTo(A, X, Y, se)
                };
                return F.tween = B,
                F
            },
            isTweening: function(g) {
                return z.getTweensOf(g, !0).length > 0
            },
            defaults: function(g) {
                return g && g.ease && (g.ease = Is(g.ease, o.ease)),
                wn(o, g || {})
            },
            config: function(g) {
                return wn(s, g || {})
            },
            registerEffect: function(g) {
                var A = g.name
                  , C = g.effect
                  , b = g.plugins
                  , B = g.defaults
                  , F = g.extendTimeline;
                (b || "").split(",").forEach(function(N) {
                    return N && !et[N] && !Ae[N] && Ne(A + " effect requires " + N + " plugin.")
                }),
                Ze[A] = function(N, X, Y) {
                    return C(Ln(N), st(X || {}, B), Y)
                }
                ,
                F && (Lr.prototype[A] = function(N, X, Y) {
                    return this.add(Ze[A](N, I(X) ? X : (Y = X) && {}, this), Y)
                }
                )
            },
            registerEase: function(g, A) {
                Dt[g] = Is(A)
            },
            parseEase: function(g, A) {
                return arguments.length ? Is(g, A) : Dt
            },
            getById: function(g) {
                return z.getById(g)
            },
            exportRoot: function(g, A) {
                g === void 0 && (g = {});
                var C = new Lr(g), b, B;
                for (C.smoothChildTiming = k(g.smoothChildTiming),
                z.remove(C),
                C._dp = 0,
                C._time = C._tTime = z._time,
                b = z._first; b; )
                    B = b._next,
                    (A || !(!b._dur && b instanceof Fr && b.vars.onComplete === b._targets[0])) && j(C, b, b._start - b._delay),
                    b = B;
                return j(z, C, 0),
                C
            },
            context: function(g, A) {
                return g ? new Qt(g,A) : f
            },
            matchMedia: function(g) {
                return new Vr(g)
            },
            matchMediaRefresh: function() {
                return Bt.forEach(function(g) {
                    var A = g.conditions, C, b;
                    for (b in A)
                        A[b] && (A[b] = !1,
                        C = 1);
                    C && g.revert()
                }) || At()
            },
            addEventListener: function(g, A) {
                var C = Fn[g] || (Fn[g] = []);
                ~C.indexOf(A) || C.push(A)
            },
            removeEventListener: function(g, A) {
                var C = Fn[g]
                  , b = C && C.indexOf(A);
                b >= 0 && C.splice(b, 1)
            },
            utils: {
                wrap: ea,
                wrapYoyo: Yi,
                distribute: Qr,
                random: An,
                snap: Mn,
                normalize: Ni,
                getUnit: Yn,
                clamp: es,
                splitColor: Io,
                toArray: Ln,
                selector: Bs,
                mapRange: _i,
                pipe: ws,
                unitize: ir,
                interpolate: $l,
                shuffle: qr
            },
            install: de,
            effects: Ze,
            ticker: Ss,
            updateRoot: Lr.updateRoot,
            plugins: et,
            globalTimeline: z,
            core: {
                PropTween: Be,
                globals: Tt,
                Tween: Fr,
                Timeline: Lr,
                Animation: ra,
                getCache: ye,
                _removeLinkedListItem: Et,
                reverting: function() {
                    return l
                },
                context: function(g) {
                    return g && f && (f.data.push(g),
                    g._ctx = f),
                    f
                },
                suppressOverwrites: function(g) {
                    return a = g
                }
            }
        };
        Ve("to,from,fromTo,delayedCall,set,killTweensOf", function(q) {
            return lr[q] = Fr[q]
        }),
        Ss.add(Lr.updateRoot),
        ta = lr.to({}, {
            duration: 0
        });
        var bn = function(g, A) {
            for (var C = g._pt; C && C.p !== A && C.op !== A && C.fp !== A; )
                C = C._next;
            return C
        }
          , ai = function(g, A) {
            var C = g._targets, b, B, F;
            for (b in A)
                for (B = C.length; B--; )
                    F = g._ptLookup[B][b],
                    F && (F = F.d) && (F._pt && (F = bn(F, b)),
                    F && F.modifier && F.modifier(A[b], g, C[B], b))
        }
          , Pr = function(g, A) {
            return {
                name: g,
                rawVars: 1,
                init: function(b, B, F) {
                    F._onInit = function(N) {
                        var X, Y;
                        if (M(B) && (X = {},
                        Ve(B, function(se) {
                            return X[se] = 1
                        }),
                        B = X),
                        A) {
                            X = {};
                            for (Y in B)
                                X[Y] = A(B[Y]);
                            B = X
                        }
                        ai(N, B)
                    }
                }
            }
        }
          , pn = lr.registerPlugin({
            name: "attr",
            init: function(g, A, C, b, B) {
                var F, N, X;
                this.tween = C;
                for (F in A)
                    X = g.getAttribute(F) || "",
                    N = this.add(g, "setAttribute", (X || 0) + "", A[F], b, B, 0, 0, F),
                    N.op = F,
                    N.b = X,
                    this._props.push(F)
            },
            render: function(g, A) {
                for (var C = A._pt; C; )
                    l ? C.set(C.t, C.p, C.b, C) : C.r(g, C.d),
                    C = C._next
            }
        }, {
            name: "endArray",
            init: function(g, A) {
                for (var C = A.length; C--; )
                    this.add(g, C, g[C] || 0, A[C], 0, 0, 0, 0, 0, 1)
            }
        }, Pr("roundProps", xs), Pr("modifiers"), Pr("snap", Mn)) || lr;
        Fr.version = Lr.version = pn.version = "3.11.4",
        je = 1,
        R() && Ms();
        var Rr = Dt.Power0, Kn = Dt.Power1, En = Dt.Power2, di = Dt.Power3, bi = Dt.Power4, _n = Dt.Linear, pr = Dt.Quad, Wn = Dt.Cubic, Ys = Dt.Quart, mr = Dt.Quint, gr = Dt.Strong, ln = Dt.Elastic, Ti = Dt.Back, Xn = Dt.SteppedEase, xi = Dt.Bounce, Ge = Dt.Sine, As = Dt.Expo, No = Dt.Circ, zo, Di, Gi, vr, Br, Pi, Ra, Cs = function() {
            return typeof window < "u"
        }, kr = {}, Pn = 180 / Math.PI, Or = Math.PI / 180, _r = Math.atan2, cs = 1e8, li = /([A-Z])/g, Ye = /(left|right|width|margin|padding|x)/i, fo = /[\s,\(]\S/, Gn = {
            autoAlpha: "opacity,visibility",
            scale: "scaleX,scaleY",
            alpha: "opacity"
        }, ho = function(g, A) {
            return A.set(A.t, A.p, Math.round((A.s + A.c * g) * 1e4) / 1e4 + A.u, A)
        }, Go = function(g, A) {
            return A.set(A.t, A.p, g === 1 ? A.e : Math.round((A.s + A.c * g) * 1e4) / 1e4 + A.u, A)
        }, Sr = function(g, A) {
            return A.set(A.t, A.p, g ? Math.round((A.s + A.c * g) * 1e4) / 1e4 + A.u : A.b, A)
        }, Ui = function(g, A) {
            var C = A.s + A.c * g;
            A.set(A.t, A.p, ~~(C + (C < 0 ? -.5 : .5)) + A.u, A)
        }, Ba = function(g, A) {
            return A.set(A.t, A.p, g ? A.e : A.b, A)
        }, po = function(g, A) {
            return A.set(A.t, A.p, g !== 1 ? A.b : A.e, A)
        }, Wr = function(g, A, C) {
            return g.style[A] = C
        }, Xr = function(g, A, C) {
            return g.style.setProperty(A, C)
        }, wi = function(g, A, C) {
            return g._gsap[A] = C
        }, Ir = function(g, A, C) {
            return g._gsap.scaleX = g._gsap.scaleY = C
        }, ur = function(g, A, C, b, B) {
            var F = g._gsap;
            F.scaleX = F.scaleY = C,
            F.renderTransform(B, F)
        }, Er = function(g, A, C, b, B) {
            var F = g._gsap;
            F[A] = C,
            F.renderTransform(B, F)
        }, cr = "transform", ui = cr + "Origin", Uo = function(g, A) {
            var C = this
              , b = this.target
              , B = b.style;
            if (g in kr) {
                if (this.tfm = this.tfm || {},
                g !== "transform" && (g = Gn[g] || g,
                ~g.indexOf(",") ? g.split(",").forEach(function(F) {
                    return C.tfm[F] = br(b, F)
                }) : this.tfm[g] = b._gsap.x ? b._gsap[g] : br(b, g)),
                this.props.indexOf(cr) >= 0)
                    return;
                b._gsap.svg && (this.svgo = b.getAttribute("data-svg-origin"),
                this.props.push(ui, A, "")),
                g = cr
            }
            (B || A) && this.props.push(g, A, B[g])
        }, Ia = function(g) {
            g.translate && (g.removeProperty("translate"),
            g.removeProperty("scale"),
            g.removeProperty("rotate"))
        }, ci = function() {
            var g = this.props, A = this.target, C = A.style, b = A._gsap, B, F;
            for (B = 0; B < g.length; B += 3)
                g[B + 1] ? A[g[B]] = g[B + 2] : g[B + 2] ? C[g[B]] = g[B + 2] : C.removeProperty(g[B].replace(li, "-$1").toLowerCase());
            if (this.tfm) {
                for (F in this.tfm)
                    b[F] = this.tfm[F];
                b.svg && (b.renderTransform(),
                A.setAttribute("data-svg-origin", this.svgo || "")),
                B = Ra(),
                B && !B.isStart && !C[cr] && (Ia(C),
                b.uncache = 1)
            }
        }, Jn = function(g, A) {
            var C = {
                target: g,
                props: [],
                revert: ci,
                save: Uo
            };
            return A && A.split(",").forEach(function(b) {
                return C.save(b)
            }),
            C
        }, Ks, fs = function(g, A) {
            var C = Di.createElementNS ? Di.createElementNS((A || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), g) : Di.createElement(g);
            return C.style ? C : Di.createElement(g)
        }, Mr = function q(g, A, C) {
            var b = getComputedStyle(g);
            return b[A] || b.getPropertyValue(A.replace(li, "-$1").toLowerCase()) || b.getPropertyValue(A) || !C && q(g, hi(A) || A, 1) || ""
        }, Si = "O,Moz,ms,Ms,Webkit".split(","), hi = function(g, A, C) {
            var b = A || Br
              , B = b.style
              , F = 5;
            if (g in B && !C)
                return g;
            for (g = g.charAt(0).toUpperCase() + g.substr(1); F-- && !(Si[F] + g in B); )
                ;
            return F < 0 ? null : (F === 3 ? "ms" : F >= 0 ? Si[F] : "") + g
        }, qs = function() {
            Cs() && window.document && (zo = window,
            Di = zo.document,
            Gi = Di.documentElement,
            Br = fs("div") || {
                style: {}
            },
            fs("div"),
            cr = hi(cr),
            ui = cr + "Origin",
            Br.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0",
            Ks = !!hi("perspective"),
            Ra = pn.core.reverting,
            vr = 1)
        }, mo = function q(g) {
            var A = fs("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"), C = this.parentNode, b = this.nextSibling, B = this.style.cssText, F;
            if (Gi.appendChild(A),
            A.appendChild(this),
            this.style.display = "block",
            g)
                try {
                    F = this.getBBox(),
                    this._gsapBBox = this.getBBox,
                    this.getBBox = q
                } catch {}
            else
                this._gsapBBox && (F = this._gsapBBox());
            return C && (b ? C.insertBefore(this, b) : C.appendChild(this)),
            Gi.removeChild(A),
            this.style.cssText = B,
            F
        }, go = function(g, A) {
            for (var C = A.length; C--; )
                if (g.hasAttribute(A[C]))
                    return g.getAttribute(A[C])
        }, il = function(g) {
            var A;
            try {
                A = g.getBBox()
            } catch {
                A = mo.call(g, !0)
            }
            return A && (A.width || A.height) || g.getBBox === mo || (A = mo.call(g, !0)),
            A && !A.width && !A.x && !A.y ? {
                x: +go(g, ["x", "cx", "x1"]) || 0,
                y: +go(g, ["y", "cy", "y1"]) || 0,
                width: 0,
                height: 0
            } : A
        }, Un = function(g) {
            return !!(g.getCTM && (!g.parentNode || g.ownerSVGElement) && il(g))
        }, Zt = function(g, A) {
            if (A) {
                var C = g.style;
                A in kr && A !== ui && (A = cr),
                C.removeProperty ? ((A.substr(0, 2) === "ms" || A.substr(0, 6) === "webkit") && (A = "-" + A),
                C.removeProperty(A.replace(li, "-$1").toLowerCase())) : C.removeAttribute(A)
            }
        }, ht = function(g, A, C, b, B, F) {
            var N = new Be(g._pt,A,C,0,1,F ? po : Ba);
            return g._pt = N,
            N.b = b,
            N.e = B,
            g._props.push(C),
            N
        }, un = {
            deg: 1,
            rad: 1,
            turn: 1
        }, cn = {
            grid: 1,
            flex: 1
        }, on = function q(g, A, C, b) {
            var B = parseFloat(C) || 0, F = (C + "").trim().substr((B + "").length) || "px", N = Br.style, X = Ye.test(A), Y = g.tagName.toLowerCase() === "svg", se = (Y ? "client" : "offset") + (X ? "Width" : "Height"), Re = 100, Pe = b === "px", Ie = b === "%", nt, ve, $e, lt;
            return b === F || !B || un[b] || un[F] ? B : (F !== "px" && !Pe && (B = q(g, A, C, "px")),
            lt = g.getCTM && Un(g),
            (Ie || F === "%") && (kr[A] || ~A.indexOf("adius")) ? (nt = lt ? g.getBBox()[X ? "width" : "height"] : g[se],
            Ke(Ie ? B / nt * Re : B / 100 * nt)) : (N[X ? "width" : "height"] = Re + (Pe ? F : b),
            ve = ~A.indexOf("adius") || b === "em" && g.appendChild && !Y ? g : g.parentNode,
            lt && (ve = (g.ownerSVGElement || {}).parentNode),
            (!ve || ve === Di || !ve.appendChild) && (ve = Di.body),
            $e = ve._gsap,
            $e && Ie && $e.width && X && $e.time === Ss.time && !$e.uncache ? Ke(B / $e.width * Re) : ((Ie || F === "%") && !cn[Mr(ve, "display")] && (N.position = Mr(g, "position")),
            ve === g && (N.position = "static"),
            ve.appendChild(Br),
            nt = Br[se],
            ve.removeChild(Br),
            N.position = "absolute",
            X && Ie && ($e = ye(ve),
            $e.time = Ss.time,
            $e.width = ve[se]),
            Ke(Pe ? nt * B / Re : nt && B ? Re / nt * B : 0))))
        }, br = function(g, A, C, b) {
            var B;
            return vr || qs(),
            A in Gn && A !== "transform" && (A = Gn[A],
            ~A.indexOf(",") && (A = A.split(",")[0])),
            kr[A] && A !== "transform" ? (B = vo(g, b),
            B = A !== "transformOrigin" ? B[A] : B.svg ? B.origin : ei(Mr(g, ui)) + " " + B.zOrigin + "px") : (B = g.style[A],
            (!B || B === "auto" || b || ~(B + "").indexOf("calc(")) && (B = fr[A] && fr[A](g, A, C) || Mr(g, A) || tt(g, A) || (A === "opacity" ? 1 : 0))),
            C && !~(B + "").trim().indexOf(" ") ? on(g, A, B, C) + C : B
        }, Tn = function(g, A, C, b) {
            if (!C || C === "none") {
                var B = hi(A, g, 1)
                  , F = B && Mr(g, B, 1);
                F && F !== C ? (A = B,
                C = F) : A === "borderColor" && (C = Mr(g, "borderTopColor"))
            }
            var N = new Be(this._pt,g.style,A,0,1,J), X = 0, Y = 0, se, Re, Pe, Ie, nt, ve, $e, lt, pt, xt, Ct, yt;
            if (N.b = C,
            N.e = b,
            C += "",
            b += "",
            b === "auto" && (g.style[A] = b,
            b = Mr(g, A) || b,
            g.style[A] = C),
            se = [C, b],
            Fo(se),
            C = se[0],
            b = se[1],
            Pe = C.match(re) || [],
            yt = b.match(re) || [],
            yt.length) {
                for (; Re = re.exec(b); )
                    $e = Re[0],
                    pt = b.substring(X, Re.index),
                    nt ? nt = (nt + 1) % 5 : (pt.substr(-5) === "rgba(" || pt.substr(-5) === "hsla(") && (nt = 1),
                    $e !== (ve = Pe[Y++] || "") && (Ie = parseFloat(ve) || 0,
                    Ct = ve.substr((Ie + "").length),
                    $e.charAt(1) === "=" && ($e = ct(Ie, $e) + Ct),
                    lt = parseFloat($e),
                    xt = $e.substr((lt + "").length),
                    X = re.lastIndex - xt.length,
                    xt || (xt = xt || s.units[A] || Ct,
                    X === b.length && (b += xt,
                    N.e += xt)),
                    Ct !== xt && (Ie = on(g, A, ve, xt) || 0),
                    N._pt = {
                        _next: N._pt,
                        p: pt || Y === 1 ? pt : ",",
                        s: Ie,
                        c: lt - Ie,
                        m: nt && nt < 4 || A === "zIndex" ? Math.round : 0
                    });
                N.c = X < b.length ? b.substring(X, b.length) : ""
            } else
                N.r = A === "display" && b === "none" ? po : Ba;
            return ce.test(b) && (N.e = 0),
            this._pt = N,
            N
        }, Jr = {
            top: "0%",
            bottom: "100%",
            left: "0%",
            right: "100%",
            center: "50%"
        }, jr = function(g) {
            var A = g.split(" ")
              , C = A[0]
              , b = A[1] || "50%";
            return (C === "top" || C === "bottom" || b === "left" || b === "right") && (g = C,
            C = b,
            b = g),
            A[0] = Jr[C] || C,
            A[1] = Jr[b] || b,
            A.join(" ")
        }, Es = function(g, A) {
            if (A.tween && A.tween._time === A.tween._dur) {
                var C = A.t, b = C.style, B = A.u, F = C._gsap, N, X, Y;
                if (B === "all" || B === !0)
                    b.cssText = "",
                    X = 1;
                else
                    for (B = B.split(","),
                    Y = B.length; --Y > -1; )
                        N = B[Y],
                        kr[N] && (X = 1,
                        N = N === "transformOrigin" ? ui : cr),
                        Zt(C, N);
                X && (Zt(C, cr),
                F && (F.svg && C.removeAttribute("transform"),
                vo(C, 1),
                F.uncache = 1,
                Ia(b)))
            }
        }, fr = {
            clearProps: function(g, A, C, b, B) {
                if (B.data !== "isFromStart") {
                    var F = g._pt = new Be(g._pt,A,C,0,0,Es);
                    return F.u = b,
                    F.pr = -10,
                    F.tween = B,
                    g._props.push(C),
                    1
                }
            }
        }, Zr = [1, 0, 0, 1, 0, 0], Fs = {}, Yr = function(g) {
            return g === "matrix(1, 0, 0, 1, 0, 0)" || g === "none" || !g
        }, Nr = function(g) {
            var A = Mr(g, cr);
            return Yr(A) ? Zr : A.substr(7).match(ne).map(Ke)
        }, $r = function(g, A) {
            var C = g._gsap || ye(g), b = g.style, B = Nr(g), F, N, X, Y;
            return C.svg && g.getAttribute("transform") ? (X = g.transform.baseVal.consolidate().matrix,
            B = [X.a, X.b, X.c, X.d, X.e, X.f],
            B.join(",") === "1,0,0,1,0,0" ? Zr : B) : (B === Zr && !g.offsetParent && g !== Gi && !C.svg && (X = b.display,
            b.display = "block",
            F = g.parentNode,
            (!F || !g.offsetParent) && (Y = 1,
            N = g.nextElementSibling,
            Gi.appendChild(g)),
            B = Nr(g),
            X ? b.display = X : Zt(g, "display"),
            Y && (N ? F.insertBefore(g, N) : F ? F.appendChild(g) : Gi.removeChild(g))),
            A && B.length > 6 ? [B[0], B[1], B[4], B[5], B[12], B[13]] : B)
        }, oa = function(g, A, C, b, B, F) {
            var N = g._gsap, X = B || $r(g, !0), Y = N.xOrigin || 0, se = N.yOrigin || 0, Re = N.xOffset || 0, Pe = N.yOffset || 0, Ie = X[0], nt = X[1], ve = X[2], $e = X[3], lt = X[4], pt = X[5], xt = A.split(" "), Ct = parseFloat(xt[0]) || 0, yt = parseFloat(xt[1]) || 0, jt, Wt, Ot, bt;
            C ? X !== Zr && (Wt = Ie * $e - nt * ve) && (Ot = Ct * ($e / Wt) + yt * (-ve / Wt) + (ve * pt - $e * lt) / Wt,
            bt = Ct * (-nt / Wt) + yt * (Ie / Wt) - (Ie * pt - nt * lt) / Wt,
            Ct = Ot,
            yt = bt) : (jt = il(g),
            Ct = jt.x + (~xt[0].indexOf("%") ? Ct / 100 * jt.width : Ct),
            yt = jt.y + (~(xt[1] || xt[0]).indexOf("%") ? yt / 100 * jt.height : yt)),
            b || b !== !1 && N.smooth ? (lt = Ct - Y,
            pt = yt - se,
            N.xOffset = Re + (lt * Ie + pt * ve) - lt,
            N.yOffset = Pe + (lt * nt + pt * $e) - pt) : N.xOffset = N.yOffset = 0,
            N.xOrigin = Ct,
            N.yOrigin = yt,
            N.smooth = !!b,
            N.origin = A,
            N.originIsAbsolute = !!C,
            g.style[ui] = "0px 0px",
            F && (ht(F, N, "xOrigin", Y, Ct),
            ht(F, N, "yOrigin", se, yt),
            ht(F, N, "xOffset", Re, N.xOffset),
            ht(F, N, "yOffset", Pe, N.yOffset)),
            g.setAttribute("data-svg-origin", Ct + " " + yt)
        }, vo = function(g, A) {
            var C = g._gsap || new Fu(g);
            if ("x"in C && !A && !C.uncache)
                return C;
            var b = g.style, B = C.scaleX < 0, F = "px", N = "deg", X = getComputedStyle(g), Y = Mr(g, ui) || "0", se, Re, Pe, Ie, nt, ve, $e, lt, pt, xt, Ct, yt, jt, Wt, Ot, bt, dr, yr, ti, pi, Ri, ni, Hi, Bi, ns, kl, ol, Gu, ks, eg, al, Fa;
            return se = Re = Pe = ve = $e = lt = pt = xt = Ct = 0,
            Ie = nt = 1,
            C.svg = !!(g.getCTM && Un(g)),
            X.translate && ((X.translate !== "none" || X.scale !== "none" || X.rotate !== "none") && (b[cr] = (X.translate !== "none" ? "translate3d(" + (X.translate + " 0 0").split(" ").slice(0, 3).join(", ") + ") " : "") + (X.rotate !== "none" ? "rotate(" + X.rotate + ") " : "") + (X.scale !== "none" ? "scale(" + X.scale.split(" ").join(",") + ") " : "") + (X[cr] !== "none" ? X[cr] : "")),
            b.scale = b.rotate = b.translate = "none"),
            Wt = $r(g, C.svg),
            C.svg && (C.uncache ? (ns = g.getBBox(),
            Y = C.xOrigin - ns.x + "px " + (C.yOrigin - ns.y) + "px",
            Bi = "") : Bi = !A && g.getAttribute("data-svg-origin"),
            oa(g, Bi || Y, !!Bi || C.originIsAbsolute, C.smooth !== !1, Wt)),
            yt = C.xOrigin || 0,
            jt = C.yOrigin || 0,
            Wt !== Zr && (yr = Wt[0],
            ti = Wt[1],
            pi = Wt[2],
            Ri = Wt[3],
            se = ni = Wt[4],
            Re = Hi = Wt[5],
            Wt.length === 6 ? (Ie = Math.sqrt(yr * yr + ti * ti),
            nt = Math.sqrt(Ri * Ri + pi * pi),
            ve = yr || ti ? _r(ti, yr) * Pn : 0,
            pt = pi || Ri ? _r(pi, Ri) * Pn + ve : 0,
            pt && (nt *= Math.abs(Math.cos(pt * Or))),
            C.svg && (se -= yt - (yt * yr + jt * pi),
            Re -= jt - (yt * ti + jt * Ri))) : (Fa = Wt[6],
            eg = Wt[7],
            ol = Wt[8],
            Gu = Wt[9],
            ks = Wt[10],
            al = Wt[11],
            se = Wt[12],
            Re = Wt[13],
            Pe = Wt[14],
            Ot = _r(Fa, ks),
            $e = Ot * Pn,
            Ot && (bt = Math.cos(-Ot),
            dr = Math.sin(-Ot),
            Bi = ni * bt + ol * dr,
            ns = Hi * bt + Gu * dr,
            kl = Fa * bt + ks * dr,
            ol = ni * -dr + ol * bt,
            Gu = Hi * -dr + Gu * bt,
            ks = Fa * -dr + ks * bt,
            al = eg * -dr + al * bt,
            ni = Bi,
            Hi = ns,
            Fa = kl),
            Ot = _r(-pi, ks),
            lt = Ot * Pn,
            Ot && (bt = Math.cos(-Ot),
            dr = Math.sin(-Ot),
            Bi = yr * bt - ol * dr,
            ns = ti * bt - Gu * dr,
            kl = pi * bt - ks * dr,
            al = Ri * dr + al * bt,
            yr = Bi,
            ti = ns,
            pi = kl),
            Ot = _r(ti, yr),
            ve = Ot * Pn,
            Ot && (bt = Math.cos(Ot),
            dr = Math.sin(Ot),
            Bi = yr * bt + ti * dr,
            ns = ni * bt + Hi * dr,
            ti = ti * bt - yr * dr,
            Hi = Hi * bt - ni * dr,
            yr = Bi,
            ni = ns),
            $e && Math.abs($e) + Math.abs(ve) > 359.9 && ($e = ve = 0,
            lt = 180 - lt),
            Ie = Ke(Math.sqrt(yr * yr + ti * ti + pi * pi)),
            nt = Ke(Math.sqrt(Hi * Hi + Fa * Fa)),
            Ot = _r(ni, Hi),
            pt = Math.abs(Ot) > 2e-4 ? Ot * Pn : 0,
            Ct = al ? 1 / (al < 0 ? -al : al) : 0),
            C.svg && (Bi = g.getAttribute("transform"),
            C.forceCSS = g.setAttribute("transform", "") || !Yr(Mr(g, cr)),
            Bi && g.setAttribute("transform", Bi))),
            Math.abs(pt) > 90 && Math.abs(pt) < 270 && (B ? (Ie *= -1,
            pt += ve <= 0 ? 180 : -180,
            ve += ve <= 0 ? 180 : -180) : (nt *= -1,
            pt += pt <= 0 ? 180 : -180)),
            A = A || C.uncache,
            C.x = se - ((C.xPercent = se && (!A && C.xPercent || (Math.round(g.offsetWidth / 2) === Math.round(-se) ? -50 : 0))) ? g.offsetWidth * C.xPercent / 100 : 0) + F,
            C.y = Re - ((C.yPercent = Re && (!A && C.yPercent || (Math.round(g.offsetHeight / 2) === Math.round(-Re) ? -50 : 0))) ? g.offsetHeight * C.yPercent / 100 : 0) + F,
            C.z = Pe + F,
            C.scaleX = Ke(Ie),
            C.scaleY = Ke(nt),
            C.rotation = Ke(ve) + N,
            C.rotationX = Ke($e) + N,
            C.rotationY = Ke(lt) + N,
            C.skewX = pt + N,
            C.skewY = xt + N,
            C.transformPerspective = Ct + F,
            (C.zOrigin = parseFloat(Y.split(" ")[2]) || 0) && (b[ui] = ei(Y)),
            C.xOffset = C.yOffset = 0,
            C.force3D = s.force3D,
            C.renderTransform = C.svg ? La : Ks ? Zs : aa,
            C.uncache = 0,
            C
        }, ei = function(g) {
            return (g = g.split(" "))[0] + " " + g[1]
        }, Kr = function(g, A, C) {
            var b = Yn(A);
            return Ke(parseFloat(A) + parseFloat(on(g, "x", C + "px", b))) + b
        }, aa = function(g, A) {
            A.z = "0px",
            A.rotationY = A.rotationX = "0deg",
            A.force3D = 0,
            Zs(g, A)
        }, Ho = "0deg", sl = "0px", Qs = ") ", Zs = function(g, A) {
            var C = A || this
              , b = C.xPercent
              , B = C.yPercent
              , F = C.x
              , N = C.y
              , X = C.z
              , Y = C.rotation
              , se = C.rotationY
              , Re = C.rotationX
              , Pe = C.skewX
              , Ie = C.skewY
              , nt = C.scaleX
              , ve = C.scaleY
              , $e = C.transformPerspective
              , lt = C.force3D
              , pt = C.target
              , xt = C.zOrigin
              , Ct = ""
              , yt = lt === "auto" && g && g !== 1 || lt === !0;
            if (xt && (Re !== Ho || se !== Ho)) {
                var jt = parseFloat(se) * Or, Wt = Math.sin(jt), Ot = Math.cos(jt), bt;
                jt = parseFloat(Re) * Or,
                bt = Math.cos(jt),
                F = Kr(pt, F, Wt * bt * -xt),
                N = Kr(pt, N, -Math.sin(jt) * -xt),
                X = Kr(pt, X, Ot * bt * -xt + xt)
            }
            $e !== sl && (Ct += "perspective(" + $e + Qs),
            (b || B) && (Ct += "translate(" + b + "%, " + B + "%) "),
            (yt || F !== sl || N !== sl || X !== sl) && (Ct += X !== sl || yt ? "translate3d(" + F + ", " + N + ", " + X + ") " : "translate(" + F + ", " + N + Qs),
            Y !== Ho && (Ct += "rotate(" + Y + Qs),
            se !== Ho && (Ct += "rotateY(" + se + Qs),
            Re !== Ho && (Ct += "rotateX(" + Re + Qs),
            (Pe !== Ho || Ie !== Ho) && (Ct += "skew(" + Pe + ", " + Ie + Qs),
            (nt !== 1 || ve !== 1) && (Ct += "scale(" + nt + ", " + ve + Qs),
            pt.style[cr] = Ct || "translate(0, 0)"
        }, La = function(g, A) {
            var C = A || this, b = C.xPercent, B = C.yPercent, F = C.x, N = C.y, X = C.rotation, Y = C.skewX, se = C.skewY, Re = C.scaleX, Pe = C.scaleY, Ie = C.target, nt = C.xOrigin, ve = C.yOrigin, $e = C.xOffset, lt = C.yOffset, pt = C.forceCSS, xt = parseFloat(F), Ct = parseFloat(N), yt, jt, Wt, Ot, bt;
            X = parseFloat(X),
            Y = parseFloat(Y),
            se = parseFloat(se),
            se && (se = parseFloat(se),
            Y += se,
            X += se),
            X || Y ? (X *= Or,
            Y *= Or,
            yt = Math.cos(X) * Re,
            jt = Math.sin(X) * Re,
            Wt = Math.sin(X - Y) * -Pe,
            Ot = Math.cos(X - Y) * Pe,
            Y && (se *= Or,
            bt = Math.tan(Y - se),
            bt = Math.sqrt(1 + bt * bt),
            Wt *= bt,
            Ot *= bt,
            se && (bt = Math.tan(se),
            bt = Math.sqrt(1 + bt * bt),
            yt *= bt,
            jt *= bt)),
            yt = Ke(yt),
            jt = Ke(jt),
            Wt = Ke(Wt),
            Ot = Ke(Ot)) : (yt = Re,
            Ot = Pe,
            jt = Wt = 0),
            (xt && !~(F + "").indexOf("px") || Ct && !~(N + "").indexOf("px")) && (xt = on(Ie, "x", F, "px"),
            Ct = on(Ie, "y", N, "px")),
            (nt || ve || $e || lt) && (xt = Ke(xt + nt - (nt * yt + ve * Wt) + $e),
            Ct = Ke(Ct + ve - (nt * jt + ve * Ot) + lt)),
            (b || B) && (bt = Ie.getBBox(),
            xt = Ke(xt + b / 100 * bt.width),
            Ct = Ke(Ct + B / 100 * bt.height)),
            bt = "matrix(" + yt + "," + jt + "," + Wt + "," + Ot + "," + xt + "," + Ct + ")",
            Ie.setAttribute("transform", bt),
            pt && (Ie.style[cr] = bt)
        }, k_ = function(g, A, C, b, B) {
            var F = 360, N = M(B), X = parseFloat(B) * (N && ~B.indexOf("rad") ? Pn : 1), Y = X - b, se = b + Y + "deg", Re, Pe;
            return N && (Re = B.split("_")[1],
            Re === "short" && (Y %= F,
            Y !== Y % (F / 2) && (Y += Y < 0 ? F : -F)),
            Re === "cw" && Y < 0 ? Y = (Y + F * cs) % F - ~~(Y / F) * F : Re === "ccw" && Y > 0 && (Y = (Y - F * cs) % F - ~~(Y / F) * F)),
            g._pt = Pe = new Be(g._pt,A,C,b,Y,Go),
            Pe.e = se,
            Pe.u = "deg",
            g._props.push(C),
            Pe
        }, $m = function(g, A) {
            for (var C in A)
                g[C] = A[C];
            return g
        }, O_ = function(g, A, C) {
            var b = $m({}, C._gsap), B = "perspective,force3D,transformOrigin,svgOrigin", F = C.style, N, X, Y, se, Re, Pe, Ie, nt;
            b.svg ? (Y = C.getAttribute("transform"),
            C.setAttribute("transform", ""),
            F[cr] = A,
            N = vo(C, 1),
            Zt(C, cr),
            C.setAttribute("transform", Y)) : (Y = getComputedStyle(C)[cr],
            F[cr] = A,
            N = vo(C, 1),
            F[cr] = Y);
            for (X in kr)
                Y = b[X],
                se = N[X],
                Y !== se && B.indexOf(X) < 0 && (Ie = Yn(Y),
                nt = Yn(se),
                Re = Ie !== nt ? on(C, X, Y, nt) : parseFloat(Y),
                Pe = parseFloat(se),
                g._pt = new Be(g._pt,N,X,Re,Pe - Re,ho),
                g._pt.u = nt || 0,
                g._props.push(X));
            $m(N, b)
        };
        Ve("padding,margin,Width,Radius", function(q, g) {
            var A = "Top"
              , C = "Right"
              , b = "Bottom"
              , B = "Left"
              , F = (g < 3 ? [A, C, b, B] : [A + B, A + C, b + C, b + B]).map(function(N) {
                return g < 2 ? q + N : "border" + N + q
            });
            fr[g > 1 ? "border" + q : q] = function(N, X, Y, se, Re) {
                var Pe, Ie;
                if (arguments.length < 4)
                    return Pe = F.map(function(nt) {
                        return br(N, nt, Y)
                    }),
                    Ie = Pe.join(" "),
                    Ie.split(Pe[0]).length === 5 ? Pe[0] : Ie;
                Pe = (se + "").split(" "),
                Ie = {},
                F.forEach(function(nt, ve) {
                    return Ie[nt] = Pe[ve] = Pe[ve] || Pe[(ve - 1) / 2 | 0]
                }),
                N.init(X, Ie, Re)
            }
        });
        var Vc = {
            name: "css",
            register: qs,
            targetTest: function(g) {
                return g.style && g.nodeType
            },
            init: function(g, A, C, b, B) {
                var F = this._props, N = g.style, X = C.vars.startAt, Y, se, Re, Pe, Ie, nt, ve, $e, lt, pt, xt, Ct, yt, jt, Wt, Ot;
                vr || qs(),
                this.styles = this.styles || Jn(g),
                Ot = this.styles.props,
                this.tween = C;
                for (ve in A)
                    if (ve !== "autoRound" && (se = A[ve],
                    !(et[ve] && Ll(ve, A, C, b, g, B)))) {
                        if (Ie = typeof se,
                        nt = fr[ve],
                        Ie === "function" && (se = se.call(C, b, g, B),
                        Ie = typeof se),
                        Ie === "string" && ~se.indexOf("random(") && (se = Hr(se)),
                        nt)
                            nt(this, g, ve, se, C) && (Wt = 1);
                        else if (ve.substr(0, 2) === "--")
                            Y = (getComputedStyle(g).getPropertyValue(ve) + "").trim(),
                            se += "",
                            Lo.lastIndex = 0,
                            Lo.test(Y) || ($e = Yn(Y),
                            lt = Yn(se)),
                            lt ? $e !== lt && (Y = on(g, ve, Y, lt) + lt) : $e && (se += $e),
                            this.add(N, "setProperty", Y, se, b, B, 0, 0, ve),
                            F.push(ve),
                            Ot.push(ve, 0, N[ve]);
                        else if (Ie !== "undefined") {
                            if (X && ve in X ? (Y = typeof X[ve] == "function" ? X[ve].call(C, b, g, B) : X[ve],
                            M(Y) && ~Y.indexOf("random(") && (Y = Hr(Y)),
                            Yn(Y + "") || (Y += s.units[ve] || Yn(br(g, ve)) || ""),
                            (Y + "").charAt(1) === "=" && (Y = br(g, ve))) : Y = br(g, ve),
                            Pe = parseFloat(Y),
                            pt = Ie === "string" && se.charAt(1) === "=" && se.substr(0, 2),
                            pt && (se = se.substr(2)),
                            Re = parseFloat(se),
                            ve in Gn && (ve === "autoAlpha" && (Pe === 1 && br(g, "visibility") === "hidden" && Re && (Pe = 0),
                            Ot.push("visibility", 0, N.visibility),
                            ht(this, N, "visibility", Pe ? "inherit" : "hidden", Re ? "inherit" : "hidden", !Re)),
                            ve !== "scale" && ve !== "transform" && (ve = Gn[ve],
                            ~ve.indexOf(",") && (ve = ve.split(",")[0]))),
                            xt = ve in kr,
                            xt) {
                                if (this.styles.save(ve),
                                Ct || (yt = g._gsap,
                                yt.renderTransform && !A.parseTransform || vo(g, A.parseTransform),
                                jt = A.smoothOrigin !== !1 && yt.smooth,
                                Ct = this._pt = new Be(this._pt,N,cr,0,1,yt.renderTransform,yt,0,-1),
                                Ct.dep = 1),
                                ve === "scale")
                                    this._pt = new Be(this._pt,yt,"scaleY",yt.scaleY,(pt ? ct(yt.scaleY, pt + Re) : Re) - yt.scaleY || 0,ho),
                                    this._pt.u = 0,
                                    F.push("scaleY", ve),
                                    ve += "X";
                                else if (ve === "transformOrigin") {
                                    Ot.push(ui, 0, N[ui]),
                                    se = jr(se),
                                    yt.svg ? oa(g, se, 0, jt, 0, this) : (lt = parseFloat(se.split(" ")[2]) || 0,
                                    lt !== yt.zOrigin && ht(this, yt, "zOrigin", yt.zOrigin, lt),
                                    ht(this, N, ve, ei(Y), ei(se)));
                                    continue
                                } else if (ve === "svgOrigin") {
                                    oa(g, se, 1, jt, 0, this);
                                    continue
                                } else if (ve in Fs) {
                                    k_(this, yt, ve, Pe, pt ? ct(Pe, pt + se) : se);
                                    continue
                                } else if (ve === "smoothOrigin") {
                                    ht(this, yt, "smooth", yt.smooth, se);
                                    continue
                                } else if (ve === "force3D") {
                                    yt[ve] = se;
                                    continue
                                } else if (ve === "transform") {
                                    O_(this, se, g);
                                    continue
                                }
                            } else
                                ve in N || (ve = hi(ve) || ve);
                            if (xt || (Re || Re === 0) && (Pe || Pe === 0) && !fo.test(se) && ve in N)
                                $e = (Y + "").substr((Pe + "").length),
                                Re || (Re = 0),
                                lt = Yn(se) || (ve in s.units ? s.units[ve] : $e),
                                $e !== lt && (Pe = on(g, ve, Y, lt)),
                                this._pt = new Be(this._pt,xt ? yt : N,ve,Pe,(pt ? ct(Pe, pt + Re) : Re) - Pe,!xt && (lt === "px" || ve === "zIndex") && A.autoRound !== !1 ? Ui : ho),
                                this._pt.u = lt || 0,
                                $e !== lt && lt !== "%" && (this._pt.b = Y,
                                this._pt.r = Sr);
                            else if (ve in N)
                                Tn.call(this, g, ve, Y, pt ? pt + se : se);
                            else if (ve in g)
                                this.add(g, ve, Y || g[ve], pt ? pt + se : se, b, B);
                            else if (ve !== "parseTransform") {
                                qe(ve, se);
                                continue
                            }
                            xt || (ve in N ? Ot.push(ve, 0, N[ve]) : Ot.push(ve, 1, Y || g[ve])),
                            F.push(ve)
                        }
                    }
                Wt && We(this)
            },
            render: function(g, A) {
                if (A.tween._time || !Ra())
                    for (var C = A._pt; C; )
                        C.r(g, C.d),
                        C = C._next;
                else
                    A.styles.revert()
            },
            get: br,
            aliases: Gn,
            getSetter: function(g, A, C) {
                var b = Gn[A];
                return b && b.indexOf(",") < 0 && (A = b),
                A in kr && A !== ui && (g._gsap.x || br(g, "x")) ? C && Pi === C ? A === "scale" ? Ir : wi : (Pi = C || {}) && (A === "scale" ? ur : Er) : g.style && !P(g.style[A]) ? Wr : ~A.indexOf("-") ? Xr : sa(g, A)
            },
            core: {
                _removeProperty: Zt,
                _getMatrix: $r
            }
        };
        pn.utils.checkPrefix = hi,
        pn.core.getStyleSaver = Jn,
        function(q, g, A, C) {
            var b = Ve(q + "," + g + "," + A, function(B) {
                kr[B] = 1
            });
            Ve(g, function(B) {
                s.units[B] = "deg",
                Fs[B] = 1
            }),
            Gn[b[13]] = q + "," + g,
            Ve(C, function(B) {
                var F = B.split(":");
                Gn[F[1]] = b[F[0]]
            })
        }("x,y,z,scale,scaleX,scaleY,xPercent,yPercent", "rotation,rotationX,rotationY,skewX,skewY", "transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", "0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY"),
        Ve("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", function(q) {
            s.units[q] = "px"
        }),
        pn.registerPlugin(Vc);
        var Wc = pn.registerPlugin(Vc) || pn
          , N_ = Wc.core.Tween;
        t.Back = Ti,
        t.Bounce = xi,
        t.CSSPlugin = Vc,
        t.Circ = No,
        t.Cubic = Wn,
        t.Elastic = ln,
        t.Expo = As,
        t.Linear = _n,
        t.Power0 = Rr,
        t.Power1 = Kn,
        t.Power2 = En,
        t.Power3 = di,
        t.Power4 = bi,
        t.Quad = pr,
        t.Quart = Ys,
        t.Quint = mr,
        t.Sine = Ge,
        t.SteppedEase = Xn,
        t.Strong = gr,
        t.TimelineLite = Lr,
        t.TimelineMax = Lr,
        t.TweenLite = Fr,
        t.TweenMax = N_,
        t.default = Wc,
        t.gsap = Wc,
        typeof window > "u" || window !== t ? Object.defineProperty(t, "__esModule", {
            value: !0
        }) : delete window.default
    })
}
)(G5, he);
var oi = {}
  , U5 = {
    get exports() {
        return oi
    },
    set exports(n) {
        oi = n
    }
};
(function(n, e) {
    (function(t, r) {
        r(e)
    }
    )(Xb, function(t) {
        function r(Te, J) {
            for (var ue = 0; ue < J.length; ue++) {
                var K = J[ue];
                K.enumerable = K.enumerable || !1,
                K.configurable = !0,
                "value"in K && (K.writable = !0),
                Object.defineProperty(Te, K.key, K)
            }
        }
        function i(Te, J, ue) {
            return J && r(Te.prototype, J),
            ue && r(Te, ue),
            Te
        }
        /*!
 * Observer 3.11.4
 * https://greensock.com
 *
 * @license Copyright 2008-2022, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/
        var s, o, a, l, f, h, d, p, m, _, y, x, S, M = function() {
            return s || typeof window < "u" && (s = window.gsap) && s.registerPlugin && s
        }, w = 1, T = [], P = [], I = [], k = Date.now, R = function(J, ue) {
            return ue
        }, O = function() {
            var J = m.core
              , ue = J.bridge || {}
              , K = J._scrollers
              , Q = J._proxies;
            K.push.apply(K, P),
            Q.push.apply(Q, I),
            P = K,
            I = Q,
            R = function(We, Be) {
                return ue[We](Be)
            }
        }, H = function(J, ue) {
            return ~I.indexOf(J) && I[I.indexOf(J) + 1][ue]
        }, W = function(J) {
            return !!~_.indexOf(J)
        }, te = function(J, ue, K, Q, Se) {
            return J.addEventListener(ue, K, {
                passive: !Q,
                capture: !!Se
            })
        }, ne = function(J, ue, K, Q) {
            return J.removeEventListener(ue, K, !!Q)
        }, re = "scrollLeft", pe = "scrollTop", ce = function() {
            return y && y.isPressed || P.cache++
        }, xe = function(J, ue) {
            var K = function Q(Se) {
                if (Se || Se === 0) {
                    w && (a.history.scrollRestoration = "manual");
                    var We = y && y.isPressed;
                    Se = Q.v = Math.round(Se) || (y && y.iOS ? 1 : 0),
                    J(Se),
                    Q.cacheID = P.cache,
                    We && R("ss", Se)
                } else
                    (ue || P.cache !== Q.cacheID || R("ref")) && (Q.cacheID = P.cache,
                    Q.v = J());
                return Q.v + Q.offset
            };
            return K.offset = 0,
            J && K
        }, G = {
            s: re,
            p: "left",
            p2: "Left",
            os: "right",
            os2: "Right",
            d: "width",
            d2: "Width",
            a: "x",
            sc: xe(function(Te) {
                return arguments.length ? a.scrollTo(Te, z.sc()) : a.pageXOffset || l[re] || f[re] || h[re] || 0
            })
        }, z = {
            s: pe,
            p: "top",
            p2: "Top",
            os: "bottom",
            os2: "Bottom",
            d: "height",
            d2: "Height",
            a: "y",
            op: G,
            sc: xe(function(Te) {
                return arguments.length ? a.scrollTo(G.sc(), Te) : a.pageYOffset || l[pe] || f[pe] || h[pe] || 0
            })
        }, U = function(J) {
            return s.utils.toArray(J)[0] || (typeof J == "string" && s.config().nullTargetWarn !== !1 ? console.warn("Element not found:", J) : null)
        }, fe = function(J, ue) {
            var K = ue.s
              , Q = ue.sc;
            W(J) && (J = l.scrollingElement || f);
            var Se = P.indexOf(J)
              , We = Q === z.sc ? 1 : 2;
            !~Se && (Se = P.push(J) - 1),
            P[Se + We] || J.addEventListener("scroll", ce);
            var Be = P[Se + We]
              , Bt = Be || (P[Se + We] = xe(H(J, K), !0) || (W(J) ? Q : xe(function(Fn) {
                return arguments.length ? J[K] = Fn : J[K]
            })));
            return Bt.target = J,
            Be || (Bt.smooth = s.getProperty(J, "scrollBehavior") === "smooth"),
            Bt
        }, oe = function(J, ue, K) {
            var Q = J
              , Se = J
              , We = k()
              , Be = We
              , Bt = ue || 50
              , Fn = Math.max(500, Bt * 3)
              , zn = function(Qt, Vr) {
                var lr = k();
                Vr || lr - We > Bt ? (Se = Q,
                Q = Qt,
                Be = We,
                We = lr) : K ? Q += Qt : Q = Se + (Qt - Se) / (lr - Be) * (We - Be)
            }
              , xn = function() {
                Se = Q = K ? 0 : Q,
                Be = We = 0
            }
              , Jt = function(Qt) {
                var Vr = Be
                  , lr = Se
                  , bn = k();
                return (Qt || Qt === 0) && Qt !== Q && zn(Qt),
                We === Be || bn - Be > Fn ? 0 : (Q + (K ? lr : -lr)) / ((K ? bn : We) - Vr) * 1e3
            };
            return {
                update: zn,
                reset: xn,
                getVelocity: Jt
            }
        }, Ae = function(J, ue) {
            return ue && !J._gsapAllow && J.preventDefault(),
            J.changedTouches ? J.changedTouches[0] : J
        }, Ue = function(J) {
            var ue = Math.max.apply(Math, J)
              , K = Math.min.apply(Math, J);
            return Math.abs(ue) >= Math.abs(K) ? ue : K
        }, je = function() {
            m = s.core.globals().ScrollTrigger,
            m && m.core && O()
        }, de = function(J) {
            return s = J || M(),
            s && typeof document < "u" && document.body && (a = window,
            l = document,
            f = l.documentElement,
            h = l.body,
            _ = [a, l, f, h],
            s.utils.clamp,
            S = s.core.context || function() {}
            ,
            p = "onpointerenter"in h ? "pointer" : "mouse",
            d = qe.isTouch = a.matchMedia && a.matchMedia("(hover: none), (pointer: coarse)").matches ? 1 : "ontouchstart"in a || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0 ? 2 : 0,
            x = qe.eventTypes = ("ontouchstart"in f ? "touchstart,touchmove,touchcancel,touchend" : "onpointerdown"in f ? "pointerdown,pointermove,pointercancel,pointerup" : "mousedown,mousemove,mouseup,mouseup").split(","),
            setTimeout(function() {
                return w = 0
            }, 500),
            je(),
            o = 1),
            o
        };
        G.op = z,
        P.cache = 0;
        var qe = function() {
            function Te(ue) {
                this.init(ue)
            }
            var J = Te.prototype;
            return J.init = function(K) {
                o || de(s) || console.warn("Please gsap.registerPlugin(Observer)"),
                m || je();
                var Q = K.tolerance
                  , Se = K.dragMinimum
                  , We = K.type
                  , Be = K.target
                  , Bt = K.lineHeight
                  , Fn = K.debounce
                  , zn = K.preventDefault
                  , xn = K.onStop
                  , Jt = K.onStopDelay
                  , At = K.ignore
                  , Qt = K.wheelSpeed
                  , Vr = K.event
                  , lr = K.onDragStart
                  , bn = K.onDragEnd
                  , ai = K.onDrag
                  , Pr = K.onPress
                  , pn = K.onRelease
                  , Rr = K.onRight
                  , Kn = K.onLeft
                  , En = K.onUp
                  , di = K.onDown
                  , bi = K.onChangeX
                  , _n = K.onChangeY
                  , pr = K.onChange
                  , Wn = K.onToggleX
                  , Ys = K.onToggleY
                  , mr = K.onHover
                  , gr = K.onHoverEnd
                  , ln = K.onMove
                  , Ti = K.ignoreCheck
                  , Xn = K.isNormalizer
                  , xi = K.onGestureStart
                  , Ge = K.onGestureEnd
                  , As = K.onWheel
                  , No = K.onEnable
                  , zo = K.onDisable
                  , Di = K.onClick
                  , Gi = K.scrollSpeed
                  , vr = K.capture
                  , Br = K.allowClicks
                  , Pi = K.lockAxis
                  , Ra = K.onLockAxis;
                this.target = Be = U(Be) || f,
                this.vars = K,
                At && (At = s.utils.toArray(At)),
                Q = Q || 1e-9,
                Se = Se || 0,
                Qt = Qt || 1,
                Gi = Gi || 1,
                We = We || "wheel,touch,pointer",
                Fn = Fn !== !1,
                Bt || (Bt = parseFloat(a.getComputedStyle(h).lineHeight) || 22);
                var Cs, kr, Pn, Or, _r, cs, li, Ye = this, fo = 0, Gn = 0, ho = fe(Be, G), Go = fe(Be, z), Sr = ho(), Ui = Go(), Ba = ~We.indexOf("touch") && !~We.indexOf("pointer") && x[0] === "pointerdown", po = W(Be), Wr = Be.ownerDocument || l, Xr = [0, 0, 0], wi = [0, 0, 0], Ir = 0, ur = function() {
                    return Ir = k()
                }, Er = function(Zt, ht) {
                    return (Ye.event = Zt) && At && ~At.indexOf(Zt.target) || ht && Ba && Zt.pointerType !== "touch" || Ti && Ti(Zt, ht)
                }, cr = function() {
                    Ye._vx.reset(),
                    Ye._vy.reset(),
                    kr.pause(),
                    xn && xn(Ye)
                }, ui = function() {
                    var Zt = Ye.deltaX = Ue(Xr)
                      , ht = Ye.deltaY = Ue(wi)
                      , un = Math.abs(Zt) >= Q
                      , cn = Math.abs(ht) >= Q;
                    pr && (un || cn) && pr(Ye, Zt, ht, Xr, wi),
                    un && (Rr && Ye.deltaX > 0 && Rr(Ye),
                    Kn && Ye.deltaX < 0 && Kn(Ye),
                    bi && bi(Ye),
                    Wn && Ye.deltaX < 0 != fo < 0 && Wn(Ye),
                    fo = Ye.deltaX,
                    Xr[0] = Xr[1] = Xr[2] = 0),
                    cn && (di && Ye.deltaY > 0 && di(Ye),
                    En && Ye.deltaY < 0 && En(Ye),
                    _n && _n(Ye),
                    Ys && Ye.deltaY < 0 != Gn < 0 && Ys(Ye),
                    Gn = Ye.deltaY,
                    wi[0] = wi[1] = wi[2] = 0),
                    (Or || Pn) && (ln && ln(Ye),
                    Pn && (ai(Ye),
                    Pn = !1),
                    Or = !1),
                    cs && !(cs = !1) && Ra && Ra(Ye),
                    _r && (As(Ye),
                    _r = !1),
                    Cs = 0
                }, Uo = function(Zt, ht, un) {
                    Xr[un] += Zt,
                    wi[un] += ht,
                    Ye._vx.update(Zt),
                    Ye._vy.update(ht),
                    Fn ? Cs || (Cs = requestAnimationFrame(ui)) : ui()
                }, Ia = function(Zt, ht) {
                    Pi && !li && (Ye.axis = li = Math.abs(Zt) > Math.abs(ht) ? "x" : "y",
                    cs = !0),
                    li !== "y" && (Xr[2] += Zt,
                    Ye._vx.update(Zt, !0)),
                    li !== "x" && (wi[2] += ht,
                    Ye._vy.update(ht, !0)),
                    Fn ? Cs || (Cs = requestAnimationFrame(ui)) : ui()
                }, ci = function(Zt) {
                    if (!Er(Zt, 1)) {
                        Zt = Ae(Zt, zn);
                        var ht = Zt.clientX
                          , un = Zt.clientY
                          , cn = ht - Ye.x
                          , on = un - Ye.y
                          , br = Ye.isDragging;
                        Ye.x = ht,
                        Ye.y = un,
                        (br || Math.abs(Ye.startX - ht) >= Se || Math.abs(Ye.startY - un) >= Se) && (ai && (Pn = !0),
                        br || (Ye.isDragging = !0),
                        Ia(cn, on),
                        br || lr && lr(Ye))
                    }
                }, Jn = Ye.onPress = function(Un) {
                    Er(Un, 1) || (Ye.axis = li = null,
                    kr.pause(),
                    Ye.isPressed = !0,
                    Un = Ae(Un),
                    fo = Gn = 0,
                    Ye.startX = Ye.x = Un.clientX,
                    Ye.startY = Ye.y = Un.clientY,
                    Ye._vx.reset(),
                    Ye._vy.reset(),
                    te(Xn ? Be : Wr, x[1], ci, zn, !0),
                    Ye.deltaX = Ye.deltaY = 0,
                    Pr && Pr(Ye))
                }
                , Ks = function(Zt) {
                    if (!Er(Zt, 1)) {
                        ne(Xn ? Be : Wr, x[1], ci, !0);
                        var ht = !isNaN(Ye.y - Ye.startY)
                          , un = Ye.isDragging && (Math.abs(Ye.x - Ye.startX) > 3 || Math.abs(Ye.y - Ye.startY) > 3)
                          , cn = Ae(Zt);
                        !un && ht && (Ye._vx.reset(),
                        Ye._vy.reset(),
                        zn && Br && s.delayedCall(.08, function() {
                            if (k() - Ir > 300 && !Zt.defaultPrevented) {
                                if (Zt.target.click)
                                    Zt.target.click();
                                else if (Wr.createEvent) {
                                    var on = Wr.createEvent("MouseEvents");
                                    on.initMouseEvent("click", !0, !0, a, 1, cn.screenX, cn.screenY, cn.clientX, cn.clientY, !1, !1, !1, !1, 0, null),
                                    Zt.target.dispatchEvent(on)
                                }
                            }
                        })),
                        Ye.isDragging = Ye.isGesturing = Ye.isPressed = !1,
                        xn && !Xn && kr.restart(!0),
                        bn && un && bn(Ye),
                        pn && pn(Ye, un)
                    }
                }, fs = function(Zt) {
                    return Zt.touches && Zt.touches.length > 1 && (Ye.isGesturing = !0) && xi(Zt, Ye.isDragging)
                }, Mr = function() {
                    return (Ye.isGesturing = !1) || Ge(Ye)
                }, Si = function(Zt) {
                    if (!Er(Zt)) {
                        var ht = ho()
                          , un = Go();
                        Uo((ht - Sr) * Gi, (un - Ui) * Gi, 1),
                        Sr = ht,
                        Ui = un,
                        xn && kr.restart(!0)
                    }
                }, hi = function(Zt) {
                    if (!Er(Zt)) {
                        Zt = Ae(Zt, zn),
                        As && (_r = !0);
                        var ht = (Zt.deltaMode === 1 ? Bt : Zt.deltaMode === 2 ? a.innerHeight : 1) * Qt;
                        Uo(Zt.deltaX * ht, Zt.deltaY * ht, 0),
                        xn && !Xn && kr.restart(!0)
                    }
                }, qs = function(Zt) {
                    if (!Er(Zt)) {
                        var ht = Zt.clientX
                          , un = Zt.clientY
                          , cn = ht - Ye.x
                          , on = un - Ye.y;
                        Ye.x = ht,
                        Ye.y = un,
                        Or = !0,
                        (cn || on) && Ia(cn, on)
                    }
                }, mo = function(Zt) {
                    Ye.event = Zt,
                    mr(Ye)
                }, go = function(Zt) {
                    Ye.event = Zt,
                    gr(Ye)
                }, il = function(Zt) {
                    return Er(Zt) || Ae(Zt, zn) && Di(Ye)
                };
                kr = Ye._dc = s.delayedCall(Jt || .25, cr).pause(),
                Ye.deltaX = Ye.deltaY = 0,
                Ye._vx = oe(0, 50, !0),
                Ye._vy = oe(0, 50, !0),
                Ye.scrollX = ho,
                Ye.scrollY = Go,
                Ye.isDragging = Ye.isGesturing = Ye.isPressed = !1,
                S(this),
                Ye.enable = function(Un) {
                    return Ye.isEnabled || (te(po ? Wr : Be, "scroll", ce),
                    We.indexOf("scroll") >= 0 && te(po ? Wr : Be, "scroll", Si, zn, vr),
                    We.indexOf("wheel") >= 0 && te(Be, "wheel", hi, zn, vr),
                    (We.indexOf("touch") >= 0 && d || We.indexOf("pointer") >= 0) && (te(Be, x[0], Jn, zn, vr),
                    te(Wr, x[2], Ks),
                    te(Wr, x[3], Ks),
                    Br && te(Be, "click", ur, !1, !0),
                    Di && te(Be, "click", il),
                    xi && te(Wr, "gesturestart", fs),
                    Ge && te(Wr, "gestureend", Mr),
                    mr && te(Be, p + "enter", mo),
                    gr && te(Be, p + "leave", go),
                    ln && te(Be, p + "move", qs)),
                    Ye.isEnabled = !0,
                    Un && Un.type && Jn(Un),
                    No && No(Ye)),
                    Ye
                }
                ,
                Ye.disable = function() {
                    Ye.isEnabled && (T.filter(function(Un) {
                        return Un !== Ye && W(Un.target)
                    }).length || ne(po ? Wr : Be, "scroll", ce),
                    Ye.isPressed && (Ye._vx.reset(),
                    Ye._vy.reset(),
                    ne(Xn ? Be : Wr, x[1], ci, !0)),
                    ne(po ? Wr : Be, "scroll", Si, vr),
                    ne(Be, "wheel", hi, vr),
                    ne(Be, x[0], Jn, vr),
                    ne(Wr, x[2], Ks),
                    ne(Wr, x[3], Ks),
                    ne(Be, "click", ur, !0),
                    ne(Be, "click", il),
                    ne(Wr, "gesturestart", fs),
                    ne(Wr, "gestureend", Mr),
                    ne(Be, p + "enter", mo),
                    ne(Be, p + "leave", go),
                    ne(Be, p + "move", qs),
                    Ye.isEnabled = Ye.isPressed = Ye.isDragging = !1,
                    zo && zo(Ye))
                }
                ,
                Ye.kill = Ye.revert = function() {
                    Ye.disable();
                    var Un = T.indexOf(Ye);
                    Un >= 0 && T.splice(Un, 1),
                    y === Ye && (y = 0)
                }
                ,
                T.push(Ye),
                Xn && W(Be) && (y = Ye),
                Ye.enable(Vr)
            }
            ,
            i(Te, [{
                key: "velocityX",
                get: function() {
                    return this._vx.getVelocity()
                }
            }, {
                key: "velocityY",
                get: function() {
                    return this._vy.getVelocity()
                }
            }]),
            Te
        }();
        qe.version = "3.11.4",
        qe.create = function(Te) {
            return new qe(Te)
        }
        ,
        qe.register = de,
        qe.getAll = function() {
            return T.slice()
        }
        ,
        qe.getById = function(Te) {
            return T.filter(function(J) {
                return J.vars.id === Te
            })[0]
        }
        ,
        M() && s.registerPlugin(qe);
        /*!
 * ScrollTrigger 3.11.4
 * https://greensock.com
 *
 * @license Copyright 2008-2022, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/
        var Ne, Tt, He, gt, be, Ee, at, _t, Ce, ee, et, Ze, ft, Pt, Z, V, ye, tt, Ve, Ke, dt, ct, Fe, Rt, le, Le, rt, st, Ut, Mt, wn = 1, ae = Date.now, De = ae(), Je = 0, vt = 0, Et = function() {
            return Pt = 1
        }, rn = function() {
            return Pt = 0
        }, dn = function(J) {
            return J
        }, or = function(J) {
            return Math.round(J * 1e5) / 1e5 || 0
        }, mn = function() {
            return typeof window < "u"
        }, St = function() {
            return Ne || mn() && (Ne = window.gsap) && Ne.registerPlugin && Ne
        }, ut = function(J) {
            return !!~at.indexOf(J)
        }, Nt = function(J) {
            return H(J, "getBoundingClientRect") || (ut(J) ? function() {
                return us.width = He.innerWidth,
                us.height = He.innerHeight,
                us
            }
            : function() {
                return An(J)
            }
            )
        }, $t = function(J, ue, K) {
            var Q = K.d
              , Se = K.d2
              , We = K.a;
            return (We = H(J, "getBoundingClientRect")) ? function() {
                return We()[Q]
            }
            : function() {
                return (ue ? He["inner" + Se] : J["client" + Se]) || 0
            }
        }, hn = function(J, ue) {
            return !ue || ~I.indexOf(J) ? Nt(J) : function() {
                return us
            }
        }, Qn = function(J, ue) {
            var K = ue.s
              , Q = ue.d2
              , Se = ue.d
              , We = ue.a;
            return (K = "scroll" + Q) && (We = H(J, K)) ? We() - Nt(J)()[Se] : ut(J) ? (be[K] || Ee[K]) - (He["inner" + Q] || be["client" + Q] || Ee["client" + Q]) : J[K] - J["offset" + Q]
        }, vn = function(J, ue) {
            for (var K = 0; K < Ve.length; K += 3)
                (!ue || ~ue.indexOf(Ve[K + 1])) && J(Ve[K], Ve[K + 1], Ve[K + 2])
        }, j = function(J) {
            return typeof J == "string"
        }, me = function(J) {
            return typeof J == "function"
        }, ze = function(J) {
            return typeof J == "number"
        }, ge = function(J) {
            return typeof J == "object"
        }, Oe = function(J, ue, K) {
            return J && J.progress(ue ? 0 : 1) && K && J.pause()
        }, Vt = function(J, ue) {
            if (J.enabled) {
                var K = ue(J);
                K && K.totalTime && (J.callbackAnimation = K)
            }
        }, Ft = Math.abs, Gt = "left", Yt = "top", Sn = "right", tn = "bottom", Xt = "width", en = "height", Zn = "Right", Yn = "Left", es = "Top", Nn = "Bottom", kt = "padding", Ur = "margin", Ln = "Width", Bs = "Height", qr = "px", Qr = function(J) {
            return He.getComputedStyle(J)
        }, xs = function(J) {
            var ue = Qr(J).position;
            J.style.position = ue === "absolute" || ue === "fixed" ? ue : "relative"
        }, Mn = function(J, ue) {
            for (var K in ue)
                K in J || (J[K] = ue[K]);
            return J
        }, An = function(J, ue) {
            var K = ue && Qr(J)[Z] !== "matrix(1, 0, 0, 1, 0, 0)" && Ne.to(J, {
                x: 0,
                y: 0,
                xPercent: 0,
                yPercent: 0,
                rotation: 0,
                rotationX: 0,
                rotationY: 0,
                scale: 1,
                skewX: 0,
                skewY: 0
            }).progress(1)
              , Q = J.getBoundingClientRect();
            return K && K.progress(0).kill(),
            Q
        }, ws = function(J, ue) {
            var K = ue.d2;
            return J["offset" + K] || J["client" + K] || 0
        }, ir = function(J) {
            var ue = [], K = J.labels, Q = J.duration(), Se;
            for (Se in K)
                ue.push(K[Se] / Q);
            return ue
        }, Ni = function(J) {
            return function(ue) {
                return Ne.utils.snap(ir(J), ue)
            }
        }, Js = function(J) {
            var ue = Ne.utils.snap(J)
              , K = Array.isArray(J) && J.slice(0).sort(function(Q, Se) {
                return Q - Se
            });
            return K ? function(Q, Se, We) {
                We === void 0 && (We = .001);
                var Be;
                if (!Se)
                    return ue(Q);
                if (Se > 0) {
                    for (Q -= We,
                    Be = 0; Be < K.length; Be++)
                        if (K[Be] >= Q)
                            return K[Be];
                    return K[Be - 1]
                } else
                    for (Be = K.length,
                    Q += We; Be--; )
                        if (K[Be] <= Q)
                            return K[Be];
                return K[0]
            }
            : function(Q, Se, We) {
                We === void 0 && (We = .001);
                var Be = ue(Q);
                return !Se || Math.abs(Be - Q) < We || Be - Q < 0 == Se < 0 ? Be : ue(Se < 0 ? Q - J : Q + J)
            }
        }, ea = function(J) {
            return function(ue, K) {
                return Js(ir(J))(ue, K.direction)
            }
        }, Yi = function(J, ue, K, Q) {
            return K.split(",").forEach(function(Se) {
                return J(ue, Se, Q)
            })
        }, Hr = function(J, ue, K, Q, Se) {
            return J.addEventListener(ue, K, {
                passive: !Q,
                capture: !!Se
            })
        }, _i = function(J, ue, K, Q) {
            return J.removeEventListener(ue, K, !!Q)
        }, $l = function(J, ue, K) {
            return K && K.wheelHandler && J(ue, "wheel", K)
        }, Rl = {
            startColor: "green",
            endColor: "red",
            indent: 0,
            fontSize: "16px",
            fontWeight: "normal"
        }, ts = {
            toggleActions: "play",
            anticipatePin: 0
        }, zi = {
            top: 0,
            left: 0,
            center: .5,
            bottom: 1,
            right: 1
        }, ta = function(J, ue) {
            if (j(J)) {
                var K = J.indexOf("=")
                  , Q = ~K ? +(J.charAt(K - 1) + 1) * parseFloat(J.substr(K + 1)) : 0;
                ~K && (J.indexOf("%") > K && (Q *= ue / 100),
                J = J.substr(0, K - 1)),
                J = Q + (J in zi ? zi[J] * ue : ~J.indexOf("%") ? parseFloat(J) * ue / 100 : parseFloat(J) || 0)
            }
            return J
        }, Iu = function(J, ue, K, Q, Se, We, Be, Bt) {
            var Fn = Se.startColor
              , zn = Se.endColor
              , xn = Se.fontSize
              , Jt = Se.indent
              , At = Se.fontWeight
              , Qt = gt.createElement("div")
              , Vr = ut(K) || H(K, "pinType") === "fixed"
              , lr = J.indexOf("scroller") !== -1
              , bn = Vr ? Ee : K
              , ai = J.indexOf("start") !== -1
              , Pr = ai ? Fn : zn
              , pn = "border-color:" + Pr + ";font-size:" + xn + ";color:" + Pr + ";font-weight:" + At + ";pointer-events:none;white-space:nowrap;font-family:sans-serif,Arial;z-index:1000;padding:4px 8px;border-width:0;border-style:solid;";
            return pn += "position:" + ((lr || Bt) && Vr ? "fixed;" : "absolute;"),
            (lr || Bt || !Vr) && (pn += (Q === z ? Sn : tn) + ":" + (We + parseFloat(Jt)) + "px;"),
            Be && (pn += "box-sizing:border-box;text-align:left;width:" + Be.offsetWidth + "px;"),
            Qt._isStart = ai,
            Qt.setAttribute("class", "gsap-marker-" + J + (ue ? " marker-" + ue : "")),
            Qt.style.cssText = pn,
            Qt.innerText = ue || ue === 0 ? J + "-" + ue : J,
            bn.children[0] ? bn.insertBefore(Qt, bn.children[0]) : bn.appendChild(Qt),
            Qt._offset = Qt["offset" + Q.op.d2],
            ar(Qt, 0, Q, ai),
            Qt
        }, ar = function(J, ue, K, Q) {
            var Se = {
                display: "block"
            }
              , We = K[Q ? "os2" : "p2"]
              , Be = K[Q ? "p2" : "os2"];
            J._isFlipped = Q,
            Se[K.a + "Percent"] = Q ? -100 : 0,
            Se[K.a] = Q ? "1px" : 0,
            Se["border" + We + Ln] = 1,
            Se["border" + Be + Ln] = 0,
            Se[K.p] = ue + "px",
            Ne.set(J, Se)
        }, yn = [], Ta = {}, Io, Bl = function() {
            return ae() - Je > 34 && (Io || (Io = requestAnimationFrame(Ei)))
        }, tl = function() {
            (!Fe || !Fe.isPressed || Fe.startX > Ee.clientWidth) && (P.cache++,
            Fe ? Io || (Io = requestAnimationFrame(Ei)) : Ei(),
            Je || Ms("scrollStart"),
            Je = ae())
        }, Lo = function() {
            Le = He.innerWidth,
            le = He.innerHeight
        }, nl = function() {
            P.cache++,
            !ft && !ct && !gt.fullscreenElement && !gt.webkitFullscreenElement && (!Rt || Le !== He.innerWidth || Math.abs(He.innerHeight - le) > He.innerHeight * .25) && _t.restart(!0)
        }, Fo = {}, na = [], Ss = function Te() {
            return _i(Cn, "scrollEnd", Te) || Is(!0)
        }, Ms = function(J) {
            return Fo[J] && Fo[J].map(function(ue) {
                return ue()
            }) || na
        }, Dt = [], Gc = function(J) {
            for (var ue = 0; ue < Dt.length; ue += 5)
                (!J || Dt[ue + 4] && Dt[ue + 4].query === J) && (Dt[ue].style.cssText = Dt[ue + 1],
                Dt[ue].getBBox && Dt[ue].setAttribute("transform", Dt[ue + 2] || ""),
                Dt[ue + 3].uncache = 1)
        }, eu = function(J, ue) {
            var K;
            for (V = 0; V < yn.length; V++)
                K = yn[V],
                K && (!ue || K._ctx === ue) && (J ? K.kill(1) : K.revert(!0, !0));
            ue && Gc(ue),
            ue || Ms("revert")
        }, Uc = function(J, ue) {
            P.cache++,
            (ue || !uo) && P.forEach(function(K) {
                return me(K) && K.cacheID++ && (K.rec = 0)
            }),
            j(J) && (He.history.scrollRestoration = Ut = J)
        }, uo, rl = 0, yi, Lu = function() {
            if (yi !== rl) {
                var J = yi = rl;
                requestAnimationFrame(function() {
                    return J === rl && Is(!0)
                })
            }
        }, Is = function(J, ue) {
            if (Je && !J) {
                Hr(Cn, "scrollEnd", Ss);
                return
            }
            uo = Cn.isRefreshing = !0,
            P.forEach(function(Q) {
                return me(Q) && Q.cacheID++ && (Q.rec = Q())
            });
            var K = Ms("refreshInit");
            Ke && Cn.sort(),
            ue || eu(),
            P.forEach(function(Q) {
                me(Q) && (Q.smooth && (Q.target.style.scrollBehavior = "auto"),
                Q(0))
            }),
            yn.slice(0).forEach(function(Q) {
                return Q.refresh()
            }),
            yn.forEach(function(Q, Se) {
                if (Q._subPinOffset && Q.pin) {
                    var We = Q.vars.horizontal ? "offsetWidth" : "offsetHeight"
                      , Be = Q.pin[We];
                    Q.revert(!0, 1),
                    Q.adjustPinSpacing(Q.pin[We] - Be),
                    Q.revert(!1, 1)
                }
            }),
            yn.forEach(function(Q) {
                return Q.vars.end === "max" && Q.setPositions(Q.start, Math.max(Q.start + 1, Qn(Q.scroller, Q._dir)))
            }),
            K.forEach(function(Q) {
                return Q && Q.render && Q.render(-1)
            }),
            P.forEach(function(Q) {
                me(Q) && (Q.smooth && requestAnimationFrame(function() {
                    return Q.target.style.scrollBehavior = "smooth"
                }),
                Q.rec && Q(Q.rec))
            }),
            Uc(Ut, 1),
            _t.pause(),
            rl++,
            Ei(2),
            yn.forEach(function(Q) {
                return me(Q.vars.onRefresh) && Q.vars.onRefresh(Q)
            }),
            uo = Cn.isRefreshing = !1,
            Ms("refresh")
        }, ko = 0, tu = 1, Oo, Ei = function(J) {
            if (!uo || J === 2) {
                Cn.isUpdating = !0,
                Oo && Oo.update(0);
                var ue = yn.length
                  , K = ae()
                  , Q = K - De >= 50
                  , Se = ue && yn[0].scroll();
                if (tu = ko > Se ? -1 : 1,
                ko = Se,
                Q && (Je && !Pt && K - Je > 200 && (Je = 0,
                Ms("scrollEnd")),
                et = De,
                De = K),
                tu < 0) {
                    for (V = ue; V-- > 0; )
                        yn[V] && yn[V].update(0, Q);
                    tu = 1
                } else
                    for (V = 0; V < ue; V++)
                        yn[V] && yn[V].update(0, Q);
                Cn.isUpdating = !1
            }
            Io = 0
        }, Fu = [Gt, Yt, tn, Sn, Ur + Nn, Ur + Zn, Ur + es, Ur + Yn, "display", "flexShrink", "float", "zIndex", "gridColumnStart", "gridColumnEnd", "gridRowStart", "gridRowEnd", "gridArea", "justifySelf", "alignSelf", "placeSelf", "order"], ra = Fu.concat([Xt, en, "boxSizing", "max" + Ln, "max" + Bs, "position", Ur, kt, kt + es, kt + Zn, kt + Nn, kt + Yn]), Lr = function(J, ue, K) {
            Da(K);
            var Q = J._gsap;
            if (Q.spacerIsNative)
                Da(Q.spacerState);
            else if (J._gsap.swappedIn) {
                var Se = ue.parentNode;
                Se && (Se.insertBefore(J, ue),
                Se.removeChild(ue))
            }
            J._gsap.swappedIn = !1
        }, co = function(J, ue, K, Q) {
            if (!J._gsap.swappedIn) {
                for (var Se = Fu.length, We = ue.style, Be = J.style, Bt; Se--; )
                    Bt = Fu[Se],
                    We[Bt] = K[Bt];
                We.position = K.position === "absolute" ? "absolute" : "relative",
                K.display === "inline" && (We.display = "inline-block"),
                Be[tn] = Be[Sn] = "auto",
                We.flexBasis = K.flexBasis || "auto",
                We.overflow = "visible",
                We.boxSizing = "border-box",
                We[Xt] = ws(J, G) + qr,
                We[en] = ws(J, z) + qr,
                We[kt] = Be[Ur] = Be[Yt] = Be[Gt] = "0",
                Da(Q),
                Be[Xt] = Be["max" + Ln] = K[Xt],
                Be[en] = Be["max" + Bs] = K[en],
                Be[kt] = K[kt],
                J.parentNode !== ue && (J.parentNode.insertBefore(ue, J),
                ue.appendChild(J)),
                J._gsap.swappedIn = !0
            }
        }, Il = /([A-Z])/g, Da = function(J) {
            if (J) {
                var ue = J.t.style, K = J.length, Q = 0, Se, We;
                for ((J.t._gsap || Ne.core.getCache(J.t)).uncache = 1; Q < K; Q += 2)
                    We = J[Q + 1],
                    Se = J[Q],
                    We ? ue[Se] = We : ue[Se] && ue.removeProperty(Se.replace(Il, "-$1").toLowerCase())
            }
        }, Ll = function(J) {
            for (var ue = ra.length, K = J.style, Q = [], Se = 0; Se < ue; Se++)
                Q.push(ra[Se], K[ra[Se]]);
            return Q.t = J,
            Q
        }, Pa = function(J, ue, K) {
            for (var Q = [], Se = J.length, We = K ? 8 : 0, Be; We < Se; We += 2)
                Be = J[We],
                Q.push(Be, Be in ue ? ue[Be] : J[We + 1]);
            return Q.t = J.t,
            Q
        }, us = {
            left: 0,
            top: 0
        }, ku = function(J, ue, K, Q, Se, We, Be, Bt, Fn, zn, xn, Jt, At) {
            me(J) && (J = J(Bt)),
            j(J) && J.substr(0, 3) === "max" && (J = Jt + (J.charAt(4) === "=" ? ta("0" + J.substr(3), K) : 0));
            var Qt = At ? At.time() : 0, Vr, lr, bn;
            if (At && At.seek(0),
            ze(J))
                Be && ar(Be, K, Q, !0);
            else {
                me(ue) && (ue = ue(Bt));
                var ai = (J || "0").split(" "), Pr, pn, Rr, Kn;
                bn = U(ue) || Ee,
                Pr = An(bn) || {},
                (!Pr || !Pr.left && !Pr.top) && Qr(bn).display === "none" && (Kn = bn.style.display,
                bn.style.display = "block",
                Pr = An(bn),
                Kn ? bn.style.display = Kn : bn.style.removeProperty("display")),
                pn = ta(ai[0], Pr[Q.d]),
                Rr = ta(ai[1] || "0", K),
                J = Pr[Q.p] - Fn[Q.p] - zn + pn + Se - Rr,
                Be && ar(Be, Rr, Q, K - Rr < 20 || Be._isStart && Rr > 20),
                K -= K - Rr
            }
            if (We) {
                var En = J + K
                  , di = We._isStart;
                Vr = "scroll" + Q.d2,
                ar(We, En, Q, di && En > 20 || !di && (xn ? Math.max(Ee[Vr], be[Vr]) : We.parentNode[Vr]) <= En + 1),
                xn && (Fn = An(Be),
                xn && (We.style[Q.op.p] = Fn[Q.op.p] - Q.op.m - We._offset + qr))
            }
            return At && bn && (Vr = An(bn),
            At.seek(Jt),
            lr = An(bn),
            At._caScrollDist = Vr[Q.p] - lr[Q.p],
            J = J / At._caScrollDist * Jt),
            At && At.seek(Qt),
            At ? J : Math.round(J)
        }, Ou = /(webkit|moz|length|cssText|inset)/i, rd = function(J, ue, K, Q) {
            if (J.parentNode !== ue) {
                var Se = J.style, We, Be;
                if (ue === Ee) {
                    J._stOrig = Se.cssText,
                    Be = Qr(J);
                    for (We in Be)
                        !+We && !Ou.test(We) && Be[We] && typeof Se[We] == "string" && We !== "0" && (Se[We] = Be[We]);
                    Se.top = K,
                    Se.left = Q
                } else
                    Se.cssText = J._stOrig;
                Ne.core.getCache(J).uncache = 1,
                ue.appendChild(J)
            }
        }, js = function(J, ue) {
            var K = fe(J, ue), Q = "_scroll" + ue.p2, Se, We, Be = function Bt(Fn, zn, xn, Jt, At) {
                var Qt = Bt.tween
                  , Vr = zn.onComplete
                  , lr = {};
                return xn = xn || K(),
                At = Jt && At || 0,
                Jt = Jt || Fn - xn,
                Qt && Qt.kill(),
                Se = Math.round(xn),
                zn[Q] = Fn,
                zn.modifiers = lr,
                lr[Q] = function(bn) {
                    return bn = Math.round(K()),
                    bn !== Se && bn !== We && Math.abs(bn - Se) > 3 && Math.abs(bn - We) > 3 ? (Qt.kill(),
                    Bt.tween = 0) : bn = xn + Jt * Qt.ratio + At * Qt.ratio * Qt.ratio,
                    We = Se,
                    Se = Math.round(bn)
                }
                ,
                zn.onUpdate = function() {
                    P.cache++,
                    Ei()
                }
                ,
                zn.onComplete = function() {
                    Bt.tween = 0,
                    Vr && Vr.call(Qt)
                }
                ,
                Qt = Bt.tween = Ne.to(J, zn),
                Qt
            };
            return J[Q] = K,
            K.wheelHandler = function() {
                return Be.tween && Be.tween.kill() && (Be.tween = 0)
            }
            ,
            Hr(J, "wheel", K.wheelHandler),
            Be
        }, Cn = function() {
            function Te(ue, K) {
                Tt || Te.register(Ne) || console.warn("Please gsap.registerPlugin(ScrollTrigger)"),
                this.init(ue, K)
            }
            var J = Te.prototype;
            return J.init = function(K, Q) {
                if (this.progress = this.start = 0,
                this.vars && this.kill(!0, !0),
                !vt) {
                    this.update = this.refresh = this.kill = dn;
                    return
                }
                K = Mn(j(K) || ze(K) || K.nodeType ? {
                    trigger: K
                } : K, ts);
                var Se = K, We = Se.onUpdate, Be = Se.toggleClass, Bt = Se.id, Fn = Se.onToggle, zn = Se.onRefresh, xn = Se.scrub, Jt = Se.trigger, At = Se.pin, Qt = Se.pinSpacing, Vr = Se.invalidateOnRefresh, lr = Se.anticipatePin, bn = Se.onScrubComplete, ai = Se.onSnapComplete, Pr = Se.once, pn = Se.snap, Rr = Se.pinReparent, Kn = Se.pinSpacer, En = Se.containerAnimation, di = Se.fastScrollEnd, bi = Se.preventOverlaps, _n = K.horizontal || K.containerAnimation && K.horizontal !== !1 ? G : z, pr = !xn && xn !== 0, Wn = U(K.scroller || He), Ys = Ne.core.getCache(Wn), mr = ut(Wn), gr = ("pinType"in K ? K.pinType : H(Wn, "pinType") || mr && "fixed") === "fixed", ln = [K.onEnter, K.onLeave, K.onEnterBack, K.onLeaveBack], Ti = pr && K.toggleActions.split(" "), Xn = "markers"in K ? K.markers : ts.markers, xi = mr ? 0 : parseFloat(Qr(Wn)["border" + _n.p2 + Ln]) || 0, Ge = this, As = K.onRefreshInit && function() {
                    return K.onRefreshInit(Ge)
                }
                , No = $t(Wn, mr, _n), zo = hn(Wn, mr), Di = 0, Gi = 0, vr = fe(Wn, _n), Br, Pi, Ra, Cs, kr, Pn, Or, _r, cs, li, Ye, fo, Gn, ho, Go, Sr, Ui, Ba, po, Wr, Xr, wi, Ir, ur, Er, cr, ui, Uo, Ia, ci, Jn, Ks, fs, Mr, Si, hi, qs, mo, go;
                if (st(Ge),
                Ge._dir = _n,
                lr *= 45,
                Ge.scroller = Wn,
                Ge.scroll = En ? En.time.bind(En) : vr,
                Cs = vr(),
                Ge.vars = K,
                Q = Q || K.animation,
                "refreshPriority"in K && (Ke = 1,
                K.refreshPriority === -9999 && (Oo = Ge)),
                Ys.tweenScroll = Ys.tweenScroll || {
                    top: js(Wn, z),
                    left: js(Wn, G)
                },
                Ge.tweenTo = Br = Ys.tweenScroll[_n.p],
                Ge.scrubDuration = function(ht) {
                    Ks = ze(ht) && ht,
                    Ks ? Jn ? Jn.duration(ht) : Jn = Ne.to(Q, {
                        ease: "expo",
                        totalProgress: "+=0.001",
                        duration: Ks,
                        paused: !0,
                        onComplete: function() {
                            return bn && bn(Ge)
                        }
                    }) : (Jn && Jn.progress(1).kill(),
                    Jn = 0)
                }
                ,
                Q && (Q.vars.lazy = !1,
                Q._initted || Q.vars.immediateRender !== !1 && K.immediateRender !== !1 && Q.duration() && Q.render(0, !0, !0),
                Ge.animation = Q.pause(),
                Q.scrollTrigger = Ge,
                Ge.scrubDuration(xn),
                Ia = 0,
                Bt || (Bt = Q.vars.id)),
                yn.push(Ge),
                pn && ((!ge(pn) || pn.push) && (pn = {
                    snapTo: pn
                }),
                "scrollBehavior"in Ee.style && Ne.set(mr ? [Ee, be] : Wn, {
                    scrollBehavior: "auto"
                }),
                P.forEach(function(ht) {
                    return me(ht) && ht.target === (mr ? gt.scrollingElement || be : Wn) && (ht.smooth = !1)
                }),
                Ra = me(pn.snapTo) ? pn.snapTo : pn.snapTo === "labels" ? Ni(Q) : pn.snapTo === "labelsDirectional" ? ea(Q) : pn.directional !== !1 ? function(ht, un) {
                    return Js(pn.snapTo)(ht, ae() - Gi < 500 ? 0 : un.direction)
                }
                : Ne.utils.snap(pn.snapTo),
                fs = pn.duration || {
                    min: .1,
                    max: 2
                },
                fs = ge(fs) ? ee(fs.min, fs.max) : ee(fs, fs),
                Mr = Ne.delayedCall(pn.delay || Ks / 2 || .1, function() {
                    var ht = vr()
                      , un = ae() - Gi < 500
                      , cn = Br.tween;
                    if ((un || Math.abs(Ge.getVelocity()) < 10) && !cn && !Pt && Di !== ht) {
                        var on = (ht - Pn) / Gn
                          , br = Q && !pr ? Q.totalProgress() : on
                          , Tn = un ? 0 : (br - ci) / (ae() - et) * 1e3 || 0
                          , Jr = Ne.utils.clamp(-on, 1 - on, Ft(Tn / 2) * Tn / .185)
                          , jr = on + (pn.inertia === !1 ? 0 : Jr)
                          , Es = ee(0, 1, Ra(jr, Ge))
                          , fr = Math.round(Pn + Es * Gn)
                          , Zr = pn
                          , Fs = Zr.onStart
                          , Yr = Zr.onInterrupt
                          , Nr = Zr.onComplete;
                        if (ht <= Or && ht >= Pn && fr !== ht) {
                            if (cn && !cn._initted && cn.data <= Ft(fr - ht))
                                return;
                            pn.inertia === !1 && (Jr = Es - on),
                            Br(fr, {
                                duration: fs(Ft(Math.max(Ft(jr - br), Ft(Es - br)) * .185 / Tn / .05 || 0)),
                                ease: pn.ease || "power3",
                                data: Ft(fr - ht),
                                onInterrupt: function() {
                                    return Mr.restart(!0) && Yr && Yr(Ge)
                                },
                                onComplete: function() {
                                    Ge.update(),
                                    Di = vr(),
                                    Ia = ci = Q && !pr ? Q.totalProgress() : Ge.progress,
                                    ai && ai(Ge),
                                    Nr && Nr(Ge)
                                }
                            }, ht, Jr * Gn, fr - ht - Jr * Gn),
                            Fs && Fs(Ge, Br.tween)
                        }
                    } else
                        Ge.isActive && Di !== ht && Mr.restart(!0)
                }).pause()),
                Bt && (Ta[Bt] = Ge),
                Jt = Ge.trigger = U(Jt || At),
                go = Jt && Jt._gsap && Jt._gsap.stRevert,
                go && (go = go(Ge)),
                At = At === !0 ? Jt : U(At),
                j(Be) && (Be = {
                    targets: Jt,
                    className: Be
                }),
                At && (Qt === !1 || Qt === Ur || (Qt = !Qt && At.parentNode && At.parentNode.style && Qr(At.parentNode).display === "flex" ? !1 : kt),
                Ge.pin = At,
                Pi = Ne.core.getCache(At),
                Pi.spacer ? ho = Pi.pinState : (Kn && (Kn = U(Kn),
                Kn && !Kn.nodeType && (Kn = Kn.current || Kn.nativeElement),
                Pi.spacerIsNative = !!Kn,
                Kn && (Pi.spacerState = Ll(Kn))),
                Pi.spacer = Ui = Kn || gt.createElement("div"),
                Ui.classList.add("pin-spacer"),
                Bt && Ui.classList.add("pin-spacer-" + Bt),
                Pi.pinState = ho = Ll(At)),
                K.force3D !== !1 && Ne.set(At, {
                    force3D: !0
                }),
                Ge.spacer = Ui = Pi.spacer,
                Uo = Qr(At),
                Ir = Uo[Qt + _n.os2],
                po = Ne.getProperty(At),
                Wr = Ne.quickSetter(At, _n.a, qr),
                co(At, Ui, Uo),
                Sr = Ll(At)),
                Xn) {
                    fo = ge(Xn) ? Mn(Xn, Rl) : Rl,
                    li = Iu("scroller-start", Bt, Wn, _n, fo, 0),
                    Ye = Iu("scroller-end", Bt, Wn, _n, fo, 0, li),
                    Ba = li["offset" + _n.op.d2];
                    var il = U(H(Wn, "content") || Wn);
                    _r = this.markerStart = Iu("start", Bt, il, _n, fo, Ba, 0, En),
                    cs = this.markerEnd = Iu("end", Bt, il, _n, fo, Ba, 0, En),
                    En && (mo = Ne.quickSetter([_r, cs], _n.a, qr)),
                    !gr && !(I.length && H(Wn, "fixedMarkers") === !0) && (xs(mr ? Ee : Wn),
                    Ne.set([li, Ye], {
                        force3D: !0
                    }),
                    Er = Ne.quickSetter(li, _n.a, qr),
                    ui = Ne.quickSetter(Ye, _n.a, qr))
                }
                if (En) {
                    var Un = En.vars.onUpdate
                      , Zt = En.vars.onUpdateParams;
                    En.eventCallback("onUpdate", function() {
                        Ge.update(0, 0, 1),
                        Un && Un.apply(Zt || [])
                    })
                }
                Ge.previous = function() {
                    return yn[yn.indexOf(Ge) - 1]
                }
                ,
                Ge.next = function() {
                    return yn[yn.indexOf(Ge) + 1]
                }
                ,
                Ge.revert = function(ht, un) {
                    if (!un)
                        return Ge.kill(!0);
                    var cn = ht !== !1 || !Ge.enabled
                      , on = ft;
                    cn !== Ge.isReverted && (cn && (hi = Math.max(vr(), Ge.scroll.rec || 0),
                    Si = Ge.progress,
                    qs = Q && Q.progress()),
                    _r && [_r, cs, li, Ye].forEach(function(br) {
                        return br.style.display = cn ? "none" : "block"
                    }),
                    cn && (ft = 1,
                    Ge.update(cn)),
                    At && (!Rr || !Ge.isActive) && (cn ? Lr(At, Ui, ho) : co(At, Ui, Qr(At), ur)),
                    cn || Ge.update(cn),
                    ft = on,
                    Ge.isReverted = cn)
                }
                ,
                Ge.refresh = function(ht, un) {
                    if (!((ft || !Ge.enabled) && !un)) {
                        if (At && ht && Je) {
                            Hr(Te, "scrollEnd", Ss);
                            return
                        }
                        !uo && As && As(Ge),
                        ft = 1,
                        Gi = ae(),
                        Br.tween && (Br.tween.kill(),
                        Br.tween = 0),
                        Jn && Jn.pause(),
                        Vr && Q && Q.revert({
                            kill: !1
                        }).invalidate(),
                        Ge.isReverted || Ge.revert(!0, !0),
                        Ge._subPinOffset = !1;
                        for (var cn = No(), on = zo(), br = En ? En.duration() : Qn(Wn, _n), Tn = 0, Jr = 0, jr = K.end, Es = K.endTrigger || Jt, fr = K.start || (K.start === 0 || !Jt ? 0 : At ? "0 0" : "0 100%"), Zr = Ge.pinnedContainer = K.pinnedContainer && U(K.pinnedContainer), Fs = Jt && Math.max(0, yn.indexOf(Ge)) || 0, Yr = Fs, Nr, $r, oa, vo, ei, Kr, aa, Ho, sl, Qs, Zs; Yr--; )
                            Kr = yn[Yr],
                            Kr.end || Kr.refresh(0, 1) || (ft = 1),
                            aa = Kr.pin,
                            aa && (aa === Jt || aa === At) && !Kr.isReverted && (Qs || (Qs = []),
                            Qs.unshift(Kr),
                            Kr.revert(!0, !0)),
                            Kr !== yn[Yr] && (Fs--,
                            Yr--);
                        for (me(fr) && (fr = fr(Ge)),
                        Pn = ku(fr, Jt, cn, _n, vr(), _r, li, Ge, on, xi, gr, br, En) || (At ? -.001 : 0),
                        me(jr) && (jr = jr(Ge)),
                        j(jr) && !jr.indexOf("+=") && (~jr.indexOf(" ") ? jr = (j(fr) ? fr.split(" ")[0] : "") + jr : (Tn = ta(jr.substr(2), cn),
                        jr = j(fr) ? fr : Pn + Tn,
                        Es = Jt)),
                        Or = Math.max(Pn, ku(jr || (Es ? "100% 0" : br), Es, cn, _n, vr() + Tn, cs, Ye, Ge, on, xi, gr, br, En)) || -.001,
                        Gn = Or - Pn || (Pn -= .01) && .001,
                        Tn = 0,
                        Yr = Fs; Yr--; )
                            Kr = yn[Yr],
                            aa = Kr.pin,
                            aa && Kr.start - Kr._pinPush <= Pn && !En && Kr.end > 0 && (Nr = Kr.end - Kr.start,
                            (aa === Jt && Kr.start - Kr._pinPush < Pn || aa === Zr) && !ze(fr) && (Tn += Nr * (1 - Kr.progress)),
                            aa === At && (Jr += Nr));
                        if (Pn += Tn,
                        Or += Tn,
                        Ge._pinPush = Jr,
                        _r && Tn && (Nr = {},
                        Nr[_n.a] = "+=" + Tn,
                        Zr && (Nr[_n.p] = "-=" + vr()),
                        Ne.set([_r, cs], Nr)),
                        At)
                            Nr = Qr(At),
                            vo = _n === z,
                            oa = vr(),
                            Xr = parseFloat(po(_n.a)) + Jr,
                            !br && Or > 1 && (Zs = (mr ? gt.scrollingElement || be : Wn).style,
                            Zs = {
                                style: Zs,
                                value: Zs["overflow" + _n.a.toUpperCase()]
                            },
                            Zs["overflow" + _n.a.toUpperCase()] = "scroll"),
                            co(At, Ui, Nr),
                            Sr = Ll(At),
                            $r = An(At, !0),
                            Ho = gr && fe(Wn, vo ? G : z)(),
                            Qt && (ur = [Qt + _n.os2, Gn + Jr + qr],
                            ur.t = Ui,
                            Yr = Qt === kt ? ws(At, _n) + Gn + Jr : 0,
                            Yr && ur.push(_n.d, Yr + qr),
                            Da(ur),
                            Zr && yn.forEach(function(La) {
                                La.pin === Zr && La.vars.pinSpacing !== !1 && (La._subPinOffset = !0)
                            }),
                            gr && vr(hi)),
                            gr && (ei = {
                                top: $r.top + (vo ? oa - Pn : Ho) + qr,
                                left: $r.left + (vo ? Ho : oa - Pn) + qr,
                                boxSizing: "border-box",
                                position: "fixed"
                            },
                            ei[Xt] = ei["max" + Ln] = Math.ceil($r.width) + qr,
                            ei[en] = ei["max" + Bs] = Math.ceil($r.height) + qr,
                            ei[Ur] = ei[Ur + es] = ei[Ur + Zn] = ei[Ur + Nn] = ei[Ur + Yn] = "0",
                            ei[kt] = Nr[kt],
                            ei[kt + es] = Nr[kt + es],
                            ei[kt + Zn] = Nr[kt + Zn],
                            ei[kt + Nn] = Nr[kt + Nn],
                            ei[kt + Yn] = Nr[kt + Yn],
                            Go = Pa(ho, ei, Rr),
                            uo && vr(0)),
                            Q ? (sl = Q._initted,
                            dt(1),
                            Q.render(Q.duration(), !0, !0),
                            wi = po(_n.a) - Xr + Gn + Jr,
                            cr = Math.abs(Gn - wi) > 1,
                            gr && cr && Go.splice(Go.length - 2, 2),
                            Q.render(0, !0, !0),
                            sl || Q.invalidate(!0),
                            Q.parent || Q.totalTime(Q.totalTime()),
                            dt(0)) : wi = Gn,
                            Zs && (Zs.value ? Zs.style["overflow" + _n.a.toUpperCase()] = Zs.value : Zs.style.removeProperty("overflow-" + _n.a));
                        else if (Jt && vr() && !En)
                            for ($r = Jt.parentNode; $r && $r !== Ee; )
                                $r._pinOffset && (Pn -= $r._pinOffset,
                                Or -= $r._pinOffset),
                                $r = $r.parentNode;
                        Qs && Qs.forEach(function(La) {
                            return La.revert(!1, !0)
                        }),
                        Ge.start = Pn,
                        Ge.end = Or,
                        Cs = kr = uo ? hi : vr(),
                        !En && !uo && (Cs < hi && vr(hi),
                        Ge.scroll.rec = 0),
                        Ge.revert(!1, !0),
                        Mr && (Di = -1,
                        Ge.isActive && vr(Pn + Gn * Si),
                        Mr.restart(!0)),
                        ft = 0,
                        Q && pr && (Q._initted || qs) && Q.progress() !== qs && Q.progress(qs, !0).render(Q.time(), !0, !0),
                        (Si !== Ge.progress || En) && (Q && !pr && Q.totalProgress(Si, !0),
                        Ge.progress = (Cs - Pn) / Gn === Si ? 0 : Si),
                        At && Qt && (Ui._pinOffset = Math.round(Ge.progress * wi)),
                        zn && !uo && zn(Ge)
                    }
                }
                ,
                Ge.getVelocity = function() {
                    return (vr() - kr) / (ae() - et) * 1e3 || 0
                }
                ,
                Ge.endAnimation = function() {
                    Oe(Ge.callbackAnimation),
                    Q && (Jn ? Jn.progress(1) : Q.paused() ? pr || Oe(Q, Ge.direction < 0, 1) : Oe(Q, Q.reversed()))
                }
                ,
                Ge.labelToScroll = function(ht) {
                    return Q && Q.labels && (Pn || Ge.refresh() || Pn) + Q.labels[ht] / Q.duration() * Gn || 0
                }
                ,
                Ge.getTrailing = function(ht) {
                    var un = yn.indexOf(Ge)
                      , cn = Ge.direction > 0 ? yn.slice(0, un).reverse() : yn.slice(un + 1);
                    return (j(ht) ? cn.filter(function(on) {
                        return on.vars.preventOverlaps === ht
                    }) : cn).filter(function(on) {
                        return Ge.direction > 0 ? on.end <= Pn : on.start >= Or
                    })
                }
                ,
                Ge.update = function(ht, un, cn) {
                    if (!(En && !cn && !ht)) {
                        var on = uo ? hi : Ge.scroll(), br = ht ? 0 : (on - Pn) / Gn, Tn = br < 0 ? 0 : br > 1 ? 1 : br || 0, Jr = Ge.progress, jr, Es, fr, Zr, Fs, Yr, Nr, $r;
                        if (un && (kr = Cs,
                        Cs = En ? vr() : on,
                        pn && (ci = Ia,
                        Ia = Q && !pr ? Q.totalProgress() : Tn)),
                        lr && !Tn && At && !ft && !wn && Je && Pn < on + (on - kr) / (ae() - et) * lr && (Tn = 1e-4),
                        Tn !== Jr && Ge.enabled) {
                            if (jr = Ge.isActive = !!Tn && Tn < 1,
                            Es = !!Jr && Jr < 1,
                            Yr = jr !== Es,
                            Fs = Yr || !!Tn != !!Jr,
                            Ge.direction = Tn > Jr ? 1 : -1,
                            Ge.progress = Tn,
                            Fs && !ft && (fr = Tn && !Jr ? 0 : Tn === 1 ? 1 : Jr === 1 ? 2 : 3,
                            pr && (Zr = !Yr && Ti[fr + 1] !== "none" && Ti[fr + 1] || Ti[fr],
                            $r = Q && (Zr === "complete" || Zr === "reset" || Zr in Q))),
                            bi && (Yr || $r) && ($r || xn || !Q) && (me(bi) ? bi(Ge) : Ge.getTrailing(bi).forEach(function(Kr) {
                                return Kr.endAnimation()
                            })),
                            pr || (Jn && !ft && !wn ? (Jn._dp._time - Jn._start !== Jn._time && Jn.render(Jn._dp._time - Jn._start),
                            Jn.resetTo ? Jn.resetTo("totalProgress", Tn, Q._tTime / Q._tDur) : (Jn.vars.totalProgress = Tn,
                            Jn.invalidate().restart())) : Q && Q.totalProgress(Tn, !!ft)),
                            At) {
                                if (ht && Qt && (Ui.style[Qt + _n.os2] = Ir),
                                !gr)
                                    Wr(or(Xr + wi * Tn));
                                else if (Fs) {
                                    if (Nr = !ht && Tn > Jr && Or + 1 > on && on + 1 >= Qn(Wn, _n),
                                    Rr)
                                        if (!ht && (jr || Nr)) {
                                            var oa = An(At, !0)
                                              , vo = on - Pn;
                                            rd(At, Ee, oa.top + (_n === z ? vo : 0) + qr, oa.left + (_n === z ? 0 : vo) + qr)
                                        } else
                                            rd(At, Ui);
                                    Da(jr || Nr ? Go : Sr),
                                    cr && Tn < 1 && jr || Wr(Xr + (Tn === 1 && !Nr ? wi : 0))
                                }
                            }
                            pn && !Br.tween && !ft && !wn && Mr.restart(!0),
                            Be && (Yr || Pr && Tn && (Tn < 1 || !Mt)) && Ce(Be.targets).forEach(function(Kr) {
                                return Kr.classList[jr || Pr ? "add" : "remove"](Be.className)
                            }),
                            We && !pr && !ht && We(Ge),
                            Fs && !ft ? (pr && ($r && (Zr === "complete" ? Q.pause().totalProgress(1) : Zr === "reset" ? Q.restart(!0).pause() : Zr === "restart" ? Q.restart(!0) : Q[Zr]()),
                            We && We(Ge)),
                            (Yr || !Mt) && (Fn && Yr && Vt(Ge, Fn),
                            ln[fr] && Vt(Ge, ln[fr]),
                            Pr && (Tn === 1 ? Ge.kill(!1, 1) : ln[fr] = 0),
                            Yr || (fr = Tn === 1 ? 1 : 3,
                            ln[fr] && Vt(Ge, ln[fr]))),
                            di && !jr && Math.abs(Ge.getVelocity()) > (ze(di) ? di : 2500) && (Oe(Ge.callbackAnimation),
                            Jn ? Jn.progress(1) : Oe(Q, Zr === "reverse" ? 1 : !Tn, 1))) : pr && We && !ft && We(Ge)
                        }
                        if (ui) {
                            var ei = En ? on / En.duration() * (En._caScrollDist || 0) : on;
                            Er(ei + (li._isFlipped ? 1 : 0)),
                            ui(ei)
                        }
                        mo && mo(-on / En.duration() * (En._caScrollDist || 0))
                    }
                }
                ,
                Ge.enable = function(ht, un) {
                    Ge.enabled || (Ge.enabled = !0,
                    Hr(Wn, "resize", nl),
                    Hr(mr ? gt : Wn, "scroll", tl),
                    As && Hr(Te, "refreshInit", As),
                    ht !== !1 && (Ge.progress = Si = 0,
                    Cs = kr = Di = vr()),
                    un !== !1 && Ge.refresh())
                }
                ,
                Ge.getTween = function(ht) {
                    return ht && Br ? Br.tween : Jn
                }
                ,
                Ge.setPositions = function(ht, un) {
                    At && (Xr += ht - Pn,
                    wi += un - ht - Gn,
                    Qt === kt && Ge.adjustPinSpacing(un - ht - Gn)),
                    Ge.start = Pn = ht,
                    Ge.end = Or = un,
                    Gn = un - ht,
                    Ge.update()
                }
                ,
                Ge.adjustPinSpacing = function(ht) {
                    if (ur) {
                        var un = ur.indexOf(_n.d) + 1;
                        ur[un] = parseFloat(ur[un]) + ht + qr,
                        ur[1] = parseFloat(ur[1]) + ht + qr,
                        Da(ur)
                    }
                }
                ,
                Ge.disable = function(ht, un) {
                    if (Ge.enabled && (ht !== !1 && Ge.revert(!0, !0),
                    Ge.enabled = Ge.isActive = !1,
                    un || Jn && Jn.pause(),
                    hi = 0,
                    Pi && (Pi.uncache = 1),
                    As && _i(Te, "refreshInit", As),
                    Mr && (Mr.pause(),
                    Br.tween && Br.tween.kill() && (Br.tween = 0)),
                    !mr)) {
                        for (var cn = yn.length; cn--; )
                            if (yn[cn].scroller === Wn && yn[cn] !== Ge)
                                return;
                        _i(Wn, "resize", nl),
                        _i(Wn, "scroll", tl)
                    }
                }
                ,
                Ge.kill = function(ht, un) {
                    Ge.disable(ht, un),
                    Jn && !un && Jn.kill(),
                    Bt && delete Ta[Bt];
                    var cn = yn.indexOf(Ge);
                    cn >= 0 && yn.splice(cn, 1),
                    cn === V && tu > 0 && V--,
                    cn = 0,
                    yn.forEach(function(on) {
                        return on.scroller === Ge.scroller && (cn = 1)
                    }),
                    cn || uo || (Ge.scroll.rec = 0),
                    Q && (Q.scrollTrigger = null,
                    ht && Q.revert({
                        kill: !1
                    }),
                    un || Q.kill()),
                    _r && [_r, cs, li, Ye].forEach(function(on) {
                        return on.parentNode && on.parentNode.removeChild(on)
                    }),
                    Oo === Ge && (Oo = 0),
                    At && (Pi && (Pi.uncache = 1),
                    cn = 0,
                    yn.forEach(function(on) {
                        return on.pin === At && cn++
                    }),
                    cn || (Pi.spacer = 0)),
                    K.onKill && K.onKill(Ge)
                }
                ,
                Ge.enable(!1, !1),
                go && go(Ge),
                !Q || !Q.add || Gn ? Ge.refresh() : Ne.delayedCall(.01, function() {
                    return Pn || Or || Ge.refresh()
                }) && (Gn = .01) && (Pn = Or = 0),
                At && Lu()
            }
            ,
            Te.register = function(K) {
                return Tt || (Ne = K || St(),
                mn() && window.document && Te.enable(),
                Tt = vt),
                Tt
            }
            ,
            Te.defaults = function(K) {
                if (K)
                    for (var Q in K)
                        ts[Q] = K[Q];
                return ts
            }
            ,
            Te.disable = function(K, Q) {
                vt = 0,
                yn.forEach(function(We) {
                    return We[Q ? "kill" : "disable"](K)
                }),
                _i(He, "wheel", tl),
                _i(gt, "scroll", tl),
                clearInterval(Ze),
                _i(gt, "touchcancel", dn),
                _i(Ee, "touchstart", dn),
                Yi(_i, gt, "pointerdown,touchstart,mousedown", Et),
                Yi(_i, gt, "pointerup,touchend,mouseup", rn),
                _t.kill(),
                vn(_i);
                for (var Se = 0; Se < P.length; Se += 3)
                    $l(_i, P[Se], P[Se + 1]),
                    $l(_i, P[Se], P[Se + 2])
            }
            ,
            Te.enable = function() {
                if (He = window,
                gt = document,
                be = gt.documentElement,
                Ee = gt.body,
                Ne && (Ce = Ne.utils.toArray,
                ee = Ne.utils.clamp,
                st = Ne.core.context || dn,
                dt = Ne.core.suppressOverwrites || dn,
                Ut = He.history.scrollRestoration || "auto",
                Ne.core.globals("ScrollTrigger", Te),
                Ee)) {
                    vt = 1,
                    qe.register(Ne),
                    Te.isTouch = qe.isTouch,
                    rt = qe.isTouch && /(iPad|iPhone|iPod|Mac)/g.test(navigator.userAgent),
                    Hr(He, "wheel", tl),
                    at = [He, gt, be, Ee],
                    Ne.matchMedia ? (Te.matchMedia = function(Bt) {
                        var Fn = Ne.matchMedia(), zn;
                        for (zn in Bt)
                            Fn.add(zn, Bt[zn]);
                        return Fn
                    }
                    ,
                    Ne.addEventListener("matchMediaInit", function() {
                        return eu()
                    }),
                    Ne.addEventListener("matchMediaRevert", function() {
                        return Gc()
                    }),
                    Ne.addEventListener("matchMedia", function() {
                        Is(0, 1),
                        Ms("matchMedia")
                    }),
                    Ne.matchMedia("(orientation: portrait)", function() {
                        return Lo(),
                        Lo
                    })) : console.warn("Requires GSAP 3.11.0 or later"),
                    Lo(),
                    Hr(gt, "scroll", tl);
                    var K = Ee.style, Q = K.borderTopStyle, Se = Ne.core.Animation.prototype, We, Be;
                    for (Se.revert || Object.defineProperty(Se, "revert", {
                        value: function() {
                            return this.time(-.01, !0)
                        }
                    }),
                    K.borderTopStyle = "solid",
                    We = An(Ee),
                    z.m = Math.round(We.top + z.sc()) || 0,
                    G.m = Math.round(We.left + G.sc()) || 0,
                    Q ? K.borderTopStyle = Q : K.removeProperty("border-top-style"),
                    Ze = setInterval(Bl, 250),
                    Ne.delayedCall(.5, function() {
                        return wn = 0
                    }),
                    Hr(gt, "touchcancel", dn),
                    Hr(Ee, "touchstart", dn),
                    Yi(Hr, gt, "pointerdown,touchstart,mousedown", Et),
                    Yi(Hr, gt, "pointerup,touchend,mouseup", rn),
                    Z = Ne.utils.checkPrefix("transform"),
                    ra.push(Z),
                    Tt = ae(),
                    _t = Ne.delayedCall(.2, Is).pause(),
                    Ve = [gt, "visibilitychange", function() {
                        var Bt = He.innerWidth
                          , Fn = He.innerHeight;
                        gt.hidden ? (ye = Bt,
                        tt = Fn) : (ye !== Bt || tt !== Fn) && nl()
                    }
                    , gt, "DOMContentLoaded", Is, He, "load", Is, He, "resize", nl],
                    vn(Hr),
                    yn.forEach(function(Bt) {
                        return Bt.enable(0, 1)
                    }),
                    Be = 0; Be < P.length; Be += 3)
                        $l(_i, P[Be], P[Be + 1]),
                        $l(_i, P[Be], P[Be + 2])
                }
            }
            ,
            Te.config = function(K) {
                "limitCallbacks"in K && (Mt = !!K.limitCallbacks);
                var Q = K.syncInterval;
                Q && clearInterval(Ze) || (Ze = Q) && setInterval(Bl, Q),
                "ignoreMobileResize"in K && (Rt = Te.isTouch === 1 && K.ignoreMobileResize),
                "autoRefreshEvents"in K && (vn(_i) || vn(Hr, K.autoRefreshEvents || "none"),
                ct = (K.autoRefreshEvents + "").indexOf("resize") === -1)
            }
            ,
            Te.scrollerProxy = function(K, Q) {
                var Se = U(K)
                  , We = P.indexOf(Se)
                  , Be = ut(Se);
                ~We && P.splice(We, Be ? 6 : 2),
                Q && (Be ? I.unshift(He, Q, Ee, Q, be, Q) : I.unshift(Se, Q))
            }
            ,
            Te.clearMatchMedia = function(K) {
                yn.forEach(function(Q) {
                    return Q._ctx && Q._ctx.query === K && Q._ctx.kill(!0, !0)
                })
            }
            ,
            Te.isInViewport = function(K, Q, Se) {
                var We = (j(K) ? U(K) : K).getBoundingClientRect()
                  , Be = We[Se ? Xt : en] * Q || 0;
                return Se ? We.right - Be > 0 && We.left + Be < He.innerWidth : We.bottom - Be > 0 && We.top + Be < He.innerHeight
            }
            ,
            Te.positionInViewport = function(K, Q, Se) {
                j(K) && (K = U(K));
                var We = K.getBoundingClientRect()
                  , Be = We[Se ? Xt : en]
                  , Bt = Q == null ? Be / 2 : Q in zi ? zi[Q] * Be : ~Q.indexOf("%") ? parseFloat(Q) * Be / 100 : parseFloat(Q) || 0;
                return Se ? (We.left + Bt) / He.innerWidth : (We.top + Bt) / He.innerHeight
            }
            ,
            Te.killAll = function(K) {
                if (yn.slice(0).forEach(function(Se) {
                    return Se.vars.id !== "ScrollSmoother" && Se.kill()
                }),
                K !== !0) {
                    var Q = Fo.killAll || [];
                    Fo = {},
                    Q.forEach(function(Se) {
                        return Se()
                    })
                }
            }
            ,
            Te
        }();
        Cn.version = "3.11.4",
        Cn.saveStyles = function(Te) {
            return Te ? Ce(Te).forEach(function(J) {
                if (J && J.style) {
                    var ue = Dt.indexOf(J);
                    ue >= 0 && Dt.splice(ue, 5),
                    Dt.push(J, J.style.cssText, J.getBBox && J.getAttribute("transform"), Ne.core.getCache(J), st())
                }
            }) : Dt
        }
        ,
        Cn.revert = function(Te, J) {
            return eu(!Te, J)
        }
        ,
        Cn.create = function(Te, J) {
            return new Cn(Te,J)
        }
        ,
        Cn.refresh = function(Te) {
            return Te ? nl() : (Tt || Cn.register()) && Is(!0)
        }
        ,
        Cn.update = function(Te) {
            return ++P.cache && Ei(Te === !0 ? 2 : 0)
        }
        ,
        Cn.clearScrollMemory = Uc,
        Cn.maxScroll = function(Te, J) {
            return Qn(Te, J ? G : z)
        }
        ,
        Cn.getScrollFunc = function(Te, J) {
            return fe(U(Te), J ? G : z)
        }
        ,
        Cn.getById = function(Te) {
            return Ta[Te]
        }
        ,
        Cn.getAll = function() {
            return yn.filter(function(Te) {
                return Te.vars.id !== "ScrollSmoother"
            })
        }
        ,
        Cn.isScrolling = function() {
            return !!Je
        }
        ,
        Cn.snapDirectional = Js,
        Cn.addEventListener = function(Te, J) {
            var ue = Fo[Te] || (Fo[Te] = []);
            ~ue.indexOf(J) || ue.push(J)
        }
        ,
        Cn.removeEventListener = function(Te, J) {
            var ue = Fo[Te]
              , K = ue && ue.indexOf(J);
            K >= 0 && ue.splice(K, 1)
        }
        ,
        Cn.batch = function(Te, J) {
            var ue = [], K = {}, Q = J.interval || .016, Se = J.batchMax || 1e9, We = function(Fn, zn) {
                var xn = []
                  , Jt = []
                  , At = Ne.delayedCall(Q, function() {
                    zn(xn, Jt),
                    xn = [],
                    Jt = []
                }).pause();
                return function(Qt) {
                    xn.length || At.restart(!0),
                    xn.push(Qt.trigger),
                    Jt.push(Qt),
                    Se <= xn.length && At.progress(1)
                }
            }, Be;
            for (Be in J)
                K[Be] = Be.substr(0, 2) === "on" && me(J[Be]) && Be !== "onRefreshInit" ? We(Be, J[Be]) : J[Be];
            return me(Se) && (Se = Se(),
            Hr(Cn, "refresh", function() {
                return Se = J.batchMax()
            })),
            Ce(Te).forEach(function(Bt) {
                var Fn = {};
                for (Be in K)
                    Fn[Be] = K[Be];
                Fn.trigger = Bt,
                ue.push(Cn.create(Fn))
            }),
            ue
        }
        ;
        var Fl = function(J, ue, K, Q) {
            return ue > Q ? J(Q) : ue < 0 && J(0),
            K > Q ? (Q - ue) / (K - ue) : K < 0 ? ue / (ue - K) : 1
        }, ia = function Te(J, ue) {
            ue === !0 ? J.style.removeProperty("touch-action") : J.style.touchAction = ue === !0 ? "auto" : ue ? "pan-" + ue + (qe.isTouch ? " pinch-zoom" : "") : "none",
            J === be && Te(Ee, ue)
        }, Fr = {
            auto: 1,
            scroll: 1
        }, nu = function(J) {
            var ue = J.event, K = J.target, Q = J.axis, Se = (ue.changedTouches ? ue.changedTouches[0] : ue).target, We = Se._gsap || Ne.core.getCache(Se), Be = ae(), Bt;
            if (!We._isScrollT || Be - We._isScrollT > 2e3) {
                for (; Se && Se !== Ee && (Se.scrollHeight <= Se.clientHeight && Se.scrollWidth <= Se.clientWidth || !(Fr[(Bt = Qr(Se)).overflowY] || Fr[Bt.overflowX])); )
                    Se = Se.parentNode;
                We._isScroll = Se && Se !== K && !ut(Se) && (Fr[(Bt = Qr(Se)).overflowY] || Fr[Bt.overflowX]),
                We._isScrollT = Be
            }
            (We._isScroll || Q === "x") && (ue.stopPropagation(),
            ue._gsapAllow = !0)
        }, Nu = function(J, ue, K, Q) {
            return qe.create({
                target: J,
                capture: !0,
                debounce: !1,
                lockAxis: !0,
                type: ue,
                onWheel: Q = Q && nu,
                onPress: Q,
                onDrag: Q,
                onScroll: Q,
                onEnable: function() {
                    return K && Hr(gt, qe.eventTypes[0], sa, !1, !0)
                },
                onDisable: function() {
                    return _i(gt, qe.eventTypes[0], sa, !0)
                }
            })
        }, Hc = /(input|label|select|textarea)/i, zu, sa = function(J) {
            var ue = Hc.test(J.target.tagName);
            (ue || zu) && (J._gsapAllow = !0,
            zu = ue)
        }, Ls = function(J) {
            ge(J) || (J = {}),
            J.preventDefault = J.isNormalizer = J.allowClicks = !0,
            J.type || (J.type = "wheel,touch"),
            J.debounce = !!J.debounce,
            J.id = J.id || "normalizer";
            var ue = J, K = ue.normalizeScrollX, Q = ue.momentum, Se = ue.allowNestedScroll, We, Be, Bt = U(J.target) || be, Fn = Ne.core.globals().ScrollSmoother, zn = Fn && Fn.get(), xn = rt && (J.content && U(J.content) || zn && J.content !== !1 && !zn.smooth() && zn.content()), Jt = fe(Bt, z), At = fe(Bt, G), Qt = 1, Vr = (qe.isTouch && He.visualViewport ? He.visualViewport.scale * He.visualViewport.width : He.outerWidth) / He.innerWidth, lr = 0, bn = me(Q) ? function() {
                return Q(We)
            }
            : function() {
                return Q || 2.8
            }
            , ai, Pr, pn = Nu(Bt, J.type, !0, Se), Rr = function() {
                return Pr = !1
            }, Kn = dn, En = dn, di = function() {
                Be = Qn(Bt, z),
                En = ee(rt ? 1 : 0, Be),
                K && (Kn = ee(0, Qn(Bt, G))),
                ai = rl
            }, bi = function() {
                xn._gsap.y = or(parseFloat(xn._gsap.y) + Jt.offset) + "px",
                xn.style.transform = "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " + parseFloat(xn._gsap.y) + ", 0, 1)",
                Jt.offset = Jt.cacheID = 0
            }, _n = function() {
                if (Pr) {
                    requestAnimationFrame(Rr);
                    var Ti = or(We.deltaY / 2)
                      , Xn = En(Jt.v - Ti);
                    if (xn && Xn !== Jt.v + Jt.offset) {
                        Jt.offset = Xn - Jt.v;
                        var xi = or((parseFloat(xn && xn._gsap.y) || 0) - Jt.offset);
                        xn.style.transform = "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " + xi + ", 0, 1)",
                        xn._gsap.y = xi + "px",
                        Jt.cacheID = P.cache,
                        Ei()
                    }
                    return !0
                }
                Jt.offset && bi(),
                Pr = !0
            }, pr, Wn, Ys, mr, gr = function() {
                di(),
                pr.isActive() && pr.vars.scrollY > Be && (Jt() > Be ? pr.progress(1) && Jt(Be) : pr.resetTo("scrollY", Be))
            };
            return xn && Ne.set(xn, {
                y: "+=0"
            }),
            J.ignoreCheck = function(ln) {
                return rt && ln.type === "touchmove" && _n() || Qt > 1.05 && ln.type !== "touchstart" || We.isGesturing || ln.touches && ln.touches.length > 1
            }
            ,
            J.onPress = function() {
                var ln = Qt;
                Qt = or((He.visualViewport && He.visualViewport.scale || 1) / Vr),
                pr.pause(),
                ln !== Qt && ia(Bt, Qt > 1.01 ? !0 : K ? !1 : "x"),
                Wn = At(),
                Ys = Jt(),
                di(),
                ai = rl
            }
            ,
            J.onRelease = J.onGestureStart = function(ln, Ti) {
                if (Jt.offset && bi(),
                !Ti)
                    mr.restart(!0);
                else {
                    P.cache++;
                    var Xn = bn(), xi, Ge;
                    K && (xi = At(),
                    Ge = xi + Xn * .05 * -ln.velocityX / .227,
                    Xn *= Fl(At, xi, Ge, Qn(Bt, G)),
                    pr.vars.scrollX = Kn(Ge)),
                    xi = Jt(),
                    Ge = xi + Xn * .05 * -ln.velocityY / .227,
                    Xn *= Fl(Jt, xi, Ge, Qn(Bt, z)),
                    pr.vars.scrollY = En(Ge),
                    pr.invalidate().duration(Xn).play(.01),
                    (rt && pr.vars.scrollY >= Be || xi >= Be - 1) && Ne.to({}, {
                        onUpdate: gr,
                        duration: Xn
                    })
                }
            }
            ,
            J.onWheel = function() {
                pr._ts && pr.pause(),
                ae() - lr > 1e3 && (ai = 0,
                lr = ae())
            }
            ,
            J.onChange = function(ln, Ti, Xn, xi, Ge) {
                if (rl !== ai && di(),
                Ti && K && At(Kn(xi[2] === Ti ? Wn + (ln.startX - ln.x) : At() + Ti - xi[1])),
                Xn) {
                    Jt.offset && bi();
                    var As = Ge[2] === Xn
                      , No = As ? Ys + ln.startY - ln.y : Jt() + Xn - Ge[1]
                      , zo = En(No);
                    As && No !== zo && (Ys += zo - No),
                    Jt(zo)
                }
                (Xn || Ti) && Ei()
            }
            ,
            J.onEnable = function() {
                ia(Bt, K ? !1 : "x"),
                Cn.addEventListener("refresh", gr),
                Hr(He, "resize", gr),
                Jt.smooth && (Jt.target.style.scrollBehavior = "auto",
                Jt.smooth = At.smooth = !1),
                pn.enable()
            }
            ,
            J.onDisable = function() {
                ia(Bt, !0),
                _i(He, "resize", gr),
                Cn.removeEventListener("refresh", gr),
                pn.kill()
            }
            ,
            J.lockAxis = J.lockAxis !== !1,
            We = new qe(J),
            We.iOS = rt,
            rt && !Jt() && Jt(1),
            rt && Ne.ticker.add(dn),
            mr = We._dc,
            pr = Ne.to(We, {
                ease: "power4",
                paused: !0,
                scrollX: K ? "+=0.1" : "+=0",
                scrollY: "+=0.1",
                onComplete: mr.vars.onComplete
            }),
            We
        };
        Cn.sort = function(Te) {
            return yn.sort(Te || function(J, ue) {
                return (J.vars.refreshPriority || 0) * -1e6 + J.start - (ue.start + (ue.vars.refreshPriority || 0) * -1e6)
            }
            )
        }
        ,
        Cn.observe = function(Te) {
            return new qe(Te)
        }
        ,
        Cn.normalizeScroll = function(Te) {
            if (typeof Te > "u")
                return Fe;
            if (Te === !0 && Fe)
                return Fe.enable();
            if (Te === !1)
                return Fe && Fe.kill();
            var J = Te instanceof qe ? Te : Ls(Te);
            return Fe && Fe.target === J.target && Fe.kill(),
            ut(J.target) && (Fe = J),
            J
        }
        ,
        Cn.core = {
            _getVelocityProp: oe,
            _inputObserver: Nu,
            _scrollers: P,
            _proxies: I,
            bridge: {
                ss: function() {
                    Je || Ms("scrollStart"),
                    Je = ae()
                },
                ref: function() {
                    return ft
                }
            }
        },
        St() && Ne.registerPlugin(Cn),
        t.ScrollTrigger = Cn,
        t.default = Cn,
        typeof window > "u" || window !== t ? Object.defineProperty(t, "__esModule", {
            value: !0
        }) : delete window.default
    })
}
)(U5, oi);
he.gsap.registerPlugin(oi.ScrollTrigger);
function H5(n) {
    const {nodes: e, materials: t} = ji("/zumo_silencio_c.glb")
      , r = we.useRef()
      , i = we.useRef()
      , s = we.useRef()
      , o = we.useRef();
    var a = new Audio("./beep.mp3")
      , l = new Audio("/print1.2.mp3")
      , f = document.querySelector("#ticket")
      , h = document.querySelector("#marco3 .progressbar")
      , d = document.querySelector("#marco3 .purchased")
      , p = document.querySelector("#marco3 .lightbeep");
    return we.useEffect(()=>{
        s.current.material.metalness = 0,
        s.current.material.roughness = 0,
        o.current.material.metalness = 0,
        o.current.material.roughness = .5;
        const m = ()=>{
            p.classList.add("on"),
            i.current.intensity = 2,
            a.play(),
            h.classList.add("off"),
            d.classList.add("on"),
            setTimeout(function() {
                f.classList.add("prod3"),
                p.classList.remove("on"),
                i.current.intensity = 0,
                l.play(),
                he.gsap.to(r.current.scale, {
                    duration: .15,
                    y: 0,
                    x: 0,
                    z: 0,
                    ease: "power4.easeInOut",
                    immediateRender: !1
                })
            }, 500)
        }
        ;
        he.gsap.to(r.current.position, {
            scrollTrigger: {
                trigger: "#landing",
                scrub: .2,
                start: "top top",
                end: "bottom -100%"
            },
            y: 7,
            ease: "power4.easeInOut",
            immediateRender: !1
        }),
        he.gsap.to("#marco3 .progressbar", {
            scrollTrigger: {
                trigger: "#motion",
                scrub: .2,
                start: "bottom 0",
                end: "bottom -50%"
            },
            width: innerWidth * .063,
            ease: "power4.easeInOut",
            immediateRender: !1
        }),
        he.gsap.from("#marco3 .numero", {
            scrollTrigger: {
                trigger: ".etiqueta.tres",
                scrub: .2,
                start: "top 100%",
                end: "top 25%"
            },
            x: -innerHeight * .2,
            ease: "power4.easeInOut",
            immediateRender: !1
        }),
        he.gsap.from("#marco3 .lat2", {
            scrollTrigger: {
                trigger: "#marco3",
                scrub: .2,
                start: "top 100%",
                end: "top 25%"
            },
            x: innerHeight * .2,
            ease: "power4.easeInOut",
            immediateRender: !1
        }),
        he.gsap.from("#marco3 .abajoizq", {
            scrollTrigger: {
                trigger: "#marco3",
                scrub: .2,
                start: "top 80%",
                end: "top 25%"
            },
            x: -innerHeight * .2,
            ease: "power4.easeInOut",
            immediateRender: !1
        }),
        he.gsap.from("#marco3 .abajodch", {
            scrollTrigger: {
                trigger: "#marco3",
                scrub: .2,
                start: "top 80%",
                end: "top 25%"
            },
            x: innerHeight * .2,
            ease: "power4.easeInOut",
            immediateRender: !1
        }),
        he.gsap.to(r.current.position, {
            scrollTrigger: {
                trigger: "#motion",
                scrub: .2,
                start: "top 110%",
                end: "top bottom"
            },
            x: 0,
            ease: "power4.easeInOut",
            immediateRender: !1
        }),
        he.gsap.to(r.current.rotation, {
            scrollTrigger: {
                trigger: "#motion",
                scrub: .2,
                start: "top 110%",
                end: "top bottom"
            },
            y: 1,
            z: 2,
            ease: "power4.easeInOut",
            immediateRender: !1
        }),
        he.gsap.to(r.current.rotation, {
            scrollTrigger: {
                trigger: "#motion",
                scrub: .2,
                start: "top bottom",
                end: "bottom 0"
            },
            y: Math.PI * 2,
            z: Math.PI * 2 + .5,
            ease: "power4.easeInOut",
            immediateRender: !1
        }),
        he.gsap.to(r.current.position, {
            scrollTrigger: {
                trigger: "#motion",
                scrub: .2,
                start: "top bottom",
                end: "bottom 0"
            },
            y: .3,
            ease: "power4.easeInOut",
            immediateRender: !1
        }),
        oi.ScrollTrigger.create({
            trigger: "#motion",
            start: "bottom -50%",
            onEnter: m,
            onLeaveBack: _=>_.disable()
        }),
        he.gsap.to(r.current.scale, {
            scrollTrigger: {
                trigger: "#clients",
                scrub: .2,
                start: "bottom 140%",
                end: "bottom 130%"
            },
            x: .012,
            y: .012,
            z: .012,
            ease: "linear",
            immediateRender: !1
        }),
        he.gsap.to(r.current.position, {
            scrollTrigger: {
                trigger: "#clients",
                scrub: .2,
                start: "bottom 120%",
                end: "bottom 110%"
            },
            x: -.5,
            y: 5,
            z: 2.5,
            ease: "linear",
            immediateRender: !1
        }),
        he.gsap.to(r.current.rotation, {
            scrollTrigger: {
                trigger: "#clients",
                scrub: .2,
                start: "bottom 120%",
                end: "bottom 110%"
            },
            x: 3,
            y: 0,
            z: 1,
            ease: "linear",
            immediateRender: !1
        }),
        he.gsap.to(r.current.position, {
            scrollTrigger: {
                trigger: "#clients",
                scrub: .2,
                start: "bottom 50%",
                end: "bottom 0"
            },
            x: -1.5,
            y: 0,
            z: .8,
            ease: "linear",
            immediateRender: !1
        }),
        he.gsap.to(r.current.rotation, {
            scrollTrigger: {
                trigger: "#clients",
                scrub: .2,
                start: "bottom 50%",
                end: "bottom 0"
            },
            x: 0,
            y: 0,
            z: .5,
            ease: "linear",
            immediateRender: !1
        })
    }
    , []),
    ot.jsx(ot.Fragment, {
        children: ot.jsxs(Zl, {
            speed: 5,
            rotationIntensity: 1,
            floatIntensity: 1,
            floatingRange: [-.05, .05],
            children: [ot.jsxs("group", {
                ...n,
                dispose: null,
                ref: r,
                rotation: [0, -.3, -.6],
                children: [ot.jsx("group", {
                    position: [0, -56.29, 0],
                    children: ot.jsx("mesh", {
                        geometry: e.Wrapper.geometry,
                        position: [-.76, 61.13, 18.16],
                        rotation: [0, 0, 2.88],
                        scale: [1, -1, 1],
                        children: ot.jsx(yP, {
                            background: new It(16777215),
                            backside: !0,
                            samples: 10,
                            resolution: 2048,
                            transmission: 1,
                            roughness: 0,
                            thickness: .1,
                            ior: 2.1,
                            anisotropy: .1,
                            attenuationDistance: 1,
                            attenuationColor: "#ffffff",
                            color: "#ffffff"
                        })
                    })
                }), ot.jsx("group", {
                    position: [0, -56.29, 0],
                    children: ot.jsx("mesh", {
                        ref: s,
                        geometry: e.Straw.geometry,
                        material: t["Straw.001"],
                        position: [32.15, 159.14, 19.83],
                        rotation: [Math.PI / 2, -.26, Math.PI],
                        scale: [1, -1, 1]
                    })
                }), ot.jsx("group", {
                    position: [0, -56.29, 0],
                    children: ot.jsxs("group", {
                        position: [2.8, .85, -2.27],
                        rotation: [-Math.PI / 2, 0, 0],
                        children: [ot.jsx("mesh", {
                            geometry: e["Packaging-Foil"].geometry,
                            material: t["Foil.001"]
                        }), ot.jsx("mesh", {
                            ref: o,
                            geometry: e["Packaging-Box"].geometry,
                            material: t["Box.001"]
                        })]
                    })
                })]
            }), ot.jsx("pointLight", {
                ref: i,
                color: "red",
                intensity: 0,
                position: [-5, -30, 5]
            })]
        })
    })
}
ji.preload("/zumo_silencio_c.glb");
he.gsap.registerPlugin(oi.ScrollTrigger);
function V5(n) {
    const {nodes: e, materials: t} = ji("/can_silencio_c.glb")
      , r = we.useRef();
    we.useRef();
    const i = we.useRef()
      , s = we.useRef()
      , o = we.useRef()
      , a = we.useRef()
      , l = we.useRef();
    var f = document.querySelector("#marco1 .lightbeep")
      , h = new Audio("./beep.mp3")
      , d = new Audio("/print1.2.mp3")
      , p = document.querySelector("#ticket")
      , m = document.querySelector("#marco1 .progressbar")
      , _ = document.querySelector("#marco1 .purchased");
    const y = ()=>{
        f.classList.add("on"),
        i.current.intensity = 2,
        h.play(),
        m.classList.add("off"),
        _.classList.add("on"),
        setTimeout(function() {
            p.classList.add("prod1"),
            f.classList.remove("on"),
            i.current.intensity = 0,
            d.play(),
            he.gsap.to(r.current.scale, {
                duration: .15,
                y: 0,
                x: 0,
                z: 0,
                ease: "power4.easeInOut",
                immediateRender: !1
            })
        }, 500)
    }
    ;
    return we.useEffect(()=>{
        s.current.material.metalness = 0,
        s.current.material.roughness = .2,
        o.current.material.roughness = .3,
        a.current.material.roughness = .3,
        he.gsap.to(r.current.position, {
            scrollTrigger: {
                trigger: "#landing",
                scrub: .2,
                start: "top top",
                end: "bottom -100%"
            },
            x: 0,
            z: 0,
            ease: "power4.easeInOut",
            immediateRender: !1
        }),
        he.gsap.to(r.current.rotation, {
            scrollTrigger: {
                trigger: "#landing",
                scrub: .2,
                start: "top top",
                end: "bottom -200%"
            },
            x: 0,
            y: -2,
            z: 3.14 * 2,
            ease: "power4.easeInOut",
            immediateRender: !1
        }),
        he.gsap.to(r.current.position, {
            scrollTrigger: {
                trigger: "#landing",
                scrub: .2,
                start: "top top",
                end: "bottom -150%"
            },
            y: .2,
            ease: "power4.easeInOut",
            immediateRender: !1
        }),
        he.gsap.to("#marco1 .progressbar", {
            scrollTrigger: {
                trigger: "#tercera",
                scrub: .2,
                start: "bottom 0",
                end: "bottom -50%"
            },
            width: innerWidth * .063,
            ease: "power4.easeInOut",
            immediateRender: !1
        }),
        he.gsap.from("#marco1 .numero", {
            scrollTrigger: {
                trigger: ".etiqueta.uno",
                scrub: .2,
                start: "top 100%",
                end: "top 25%"
            },
            x: -innerHeight * .2,
            ease: "power4.easeInOut",
            immediateRender: !1
        }),
        he.gsap.from("#marco1 .lat2", {
            scrollTrigger: {
                trigger: "#marco1",
                scrub: .2,
                start: "top 100%",
                end: "top 25%"
            },
            x: innerHeight * .2,
            ease: "power4.easeInOut",
            immediateRender: !1
        }),
        he.gsap.from("#marco1 .abajoizq", {
            scrollTrigger: {
                trigger: "#marco1",
                scrub: .2,
                start: "top 80%",
                end: "top 25%"
            },
            x: -innerHeight * .2,
            ease: "power4.easeInOut",
            immediateRender: !1
        }),
        he.gsap.from("#marco1 .abajodch", {
            scrollTrigger: {
                trigger: "#marco1",
                scrub: .2,
                start: "top 80%",
                end: "top 25%"
            },
            x: innerHeight * .2,
            ease: "power4.easeInOut",
            immediateRender: !1
        }),
        he.gsap.to(l.current.rotation, {
            scrollTrigger: {
                trigger: "#tercera",
                scrub: .2,
                start: "bottom 0",
                end: "bottom -50%"
            },
            y: Math.PI * 2,
            ease: "power4.easeInOut",
            immediateRender: !1
        }),
        oi.ScrollTrigger.create({
            trigger: "#tercera",
            start: "bottom -50%",
            onEnter: y,
            onLeaveBack: x=>x.disable()
        }),
        he.gsap.to(r.current.scale, {
            scrollTrigger: {
                trigger: "#clients",
                scrub: .2,
                start: "bottom 140%",
                end: "bottom 130%"
            },
            x: .012,
            y: .012,
            z: .012,
            ease: "linear",
            immediateRender: !1
        }),
        he.gsap.to(r.current.position, {
            scrollTrigger: {
                trigger: "#clients",
                scrub: .2,
                start: "bottom 120%",
                end: "bottom 110%"
            },
            x: 3.3,
            y: 3,
            z: 3.8,
            ease: "linear",
            immediateRender: !1
        }),
        he.gsap.to(r.current.rotation, {
            scrollTrigger: {
                trigger: "#clients",
                scrub: .2,
                start: "bottom 120%",
                end: "bottom 110%"
            },
            x: 0,
            y: 2,
            z: 1.5,
            ease: "linear",
            immediateRender: !1
        }),
        he.gsap.to(r.current.position, {
            scrollTrigger: {
                trigger: "#clients",
                scrub: .2,
                start: "bottom 50%",
                end: "bottom 0"
            },
            x: .8,
            y: -.5,
            z: .3,
            ease: "linear",
            immediateRender: !1
        }),
        he.gsap.to(r.current.rotation, {
            scrollTrigger: {
                trigger: "#clients",
                scrub: .2,
                start: "bottom 50%",
                end: "bottom 0"
            },
            x: Math.PI / 2,
            y: .8,
            z: Math.PI / 2 + .1,
            ease: "linear",
            immediateRender: !1
        }),
        oi.ScrollTrigger.refresh()
    }
    , []),
    ot.jsx(ot.Fragment, {
        children: ot.jsxs(Zl, {
            speed: 5,
            rotationIntensity: .5,
            floatIntensity: .5,
            floatingRange: [-.01, .01],
            children: [ot.jsx("group", {
                ref: l,
                children: ot.jsxs("group", {
                    ...n,
                    dispose: null,
                    ref: r,
                    rotation: [.3, -2, -.2],
                    children: [ot.jsx("mesh", {
                        ref: o,
                        geometry: e.Aluminum_Standard_Can_330ml_v_22.geometry,
                        material: t["Mat.002"],
                        position: [0, 4.19, 0],
                        rotation: [-Math.PI / 2, 0, 0]
                    }), ot.jsx("mesh", {
                        ref: a,
                        geometry: e.Aluminum_Standard_Can_330ml_v_21.geometry,
                        material: t["Mat.002"],
                        position: [0, 4.19, 0],
                        rotation: [-Math.PI / 2, 0, 1.57]
                    }), ot.jsx("mesh", {
                        ref: s,
                        geometry: e.Aluminum_Standard_Can_330ml_v_2.geometry,
                        material: t["Mat.003"],
                        position: [0, 4.19, 0],
                        rotation: [-Math.PI / 2, 0, .37]
                    })]
                })
            }), ot.jsx("pointLight", {
                ref: i,
                color: "red",
                intensity: 0,
                position: [-5, -20, 5]
            })]
        })
    })
}
ji.preload("/can_silencio_c.glb");
he.gsap.registerPlugin(oi.ScrollTrigger);
function W5(n) {
    const {nodes: e, materials: t} = ji("/bolsa_silencio_c.glb")
      , r = we.useRef();
    we.useRef(),
    we.useRef();
    const i = we.useRef();
    var s = document.querySelector("#marco2 .lightbeep")
      , o = new Audio("./beep.mp3")
      , a = new Audio("/print1.2.mp3")
      , l = document.querySelector("#ticket")
      , f = document.querySelector("#marco2 .progressbar")
      , h = document.querySelector("#marco2 .purchased");
    return we.useEffect(()=>{
        r.current.material.metalness = 0,
        r.current.material.roughness = .15;
        const d = ()=>{
            s.classList.add("on"),
            i.current.intensity = 2,
            o.play(),
            f.classList.add("off"),
            h.classList.add("on"),
            setTimeout(function() {
                l.classList.add("prod2"),
                s.classList.remove("on"),
                i.current.intensity = 0,
                a.play(),
                he.gsap.to(r.current.scale, {
                    duration: .15,
                    x: 0,
                    z: 0,
                    ease: "power4.easeInOut",
                    immediateRender: !1
                })
            }, 500)
        }
        ;
        he.gsap.to(r.current.position, {
            scrollTrigger: {
                trigger: "#landing",
                scrub: .2,
                start: "top top",
                end: "bottom -100%"
            },
            y: 280,
            ease: "power4.easeInOut",
            immediateRender: !1
        }),
        he.gsap.to(r.current.position, {
            scrollTrigger: {
                trigger: "#aesthetics",
                scrub: .2,
                start: "top 120%",
                end: "top bottom"
            },
            x: 200,
            ease: "power4.easeInOut",
            immediateRender: !1
        }),
        he.gsap.to(r.current.rotation, {
            scrollTrigger: {
                trigger: "#aesthetics",
                scrub: .2,
                start: "top bottom",
                end: "bottom top"
            },
            z: 3 * 2,
            y: .1 + 3.1416 * 2,
            x: -1.5,
            ease: "power4.easeInOut",
            immediateRender: !1
        }),
        he.gsap.to(r.current.position, {
            scrollTrigger: {
                trigger: "#aesthetics",
                scrub: .2,
                start: "top bottom",
                end: "bottom top"
            },
            y: 0,
            z: 0,
            ease: "power4.easeInOut",
            immediateRender: !1
        }),
        he.gsap.from("#marco2 .numero", {
            scrollTrigger: {
                trigger: ".etiqueta.dos",
                scrub: .2,
                start: "top 100%",
                end: "top 25%"
            },
            x: -innerHeight * .2,
            ease: "power4.easeInOut",
            immediateRender: !1
        }),
        he.gsap.from("#marco2 .abajoizq", {
            scrollTrigger: {
                trigger: "#marco2",
                scrub: .2,
                start: "top 80%",
                end: "top 25%"
            },
            x: -innerHeight * .2,
            ease: "power4.easeInOut",
            immediateRender: !1
        }),
        he.gsap.to("#marco2 .progressbar", {
            scrollTrigger: {
                trigger: "#aesthetics",
                scrub: .2,
                start: "bottom 0",
                end: "bottom -50%"
            },
            width: innerWidth * .063,
            ease: "power4.easeInOut",
            immediateRender: !1
        }),
        oi.ScrollTrigger.create({
            trigger: "#aesthetics",
            start: "bottom -50%",
            onEnter: d,
            onLeaveBack: p=>p.disable()
        }),
        he.gsap.to(r.current.scale, {
            scrollTrigger: {
                trigger: "#clients",
                scrub: .2,
                start: "bottom 140%",
                end: "bottom 130%"
            },
            x: 51,
            y: 51,
            z: 51,
            ease: "linear",
            immediateRender: !1
        }),
        he.gsap.to(r.current.position, {
            scrollTrigger: {
                trigger: "#clients",
                scrub: .2,
                start: "bottom 120%",
                end: "bottom 110%"
            },
            x: 120,
            y: 300,
            z: 120,
            ease: "linear",
            immediateRender: !1
        }),
        he.gsap.to(r.current.rotation, {
            scrollTrigger: {
                trigger: "#clients",
                scrub: .2,
                start: "bottom 120%",
                end: "bottom 110%"
            },
            x: 0,
            y: 2,
            z: 0,
            ease: "linear",
            immediateRender: !1
        }),
        he.gsap.to(r.current.position, {
            scrollTrigger: {
                trigger: "#clients",
                scrub: .2,
                start: "bottom 50%",
                end: "bottom 0"
            },
            x: 120,
            y: 0,
            z: 0,
            ease: "linear",
            immediateRender: !1
        }),
        he.gsap.to(r.current.rotation, {
            scrollTrigger: {
                trigger: "#clients",
                scrub: .2,
                start: "bottom 50%",
                end: "bottom 0"
            },
            x: -Math.PI / 2,
            y: 0,
            z: 0,
            ease: "linear",
            immediateRender: !1
        })
    }
    , []),
    ot.jsxs(Zl, {
        speed: 5,
        rotationIntensity: 1,
        floatIntensity: 1,
        floatingRange: [-.05, .05],
        children: [ot.jsx("group", {
            children: ot.jsx("group", {
                ...n,
                dispose: null,
                children: ot.jsx("mesh", {
                    ref: r,
                    geometry: e.package_01.geometry,
                    material: t["Mat.004"],
                    rotation: [-Math.PI / 2, -.2, .1],
                    scale: 100
                })
            })
        }), ot.jsx("pointLight", {
            ref: i,
            color: "red",
            intensity: 0,
            position: [-5, -30, 5]
        })]
    })
}
ji.preload("/bolsa_silencio_c.glb");
he.gsap.registerPlugin(oi.ScrollTrigger);
function X5(n) {
    const {nodes: e, materials: t} = ji("/chocolatina_silencio_c.glb")
      , r = we.useRef();
    we.useRef();
    const i = we.useRef();
    var s = new Audio("./beep.mp3")
      , o = new Audio("/print1.2.mp3")
      , a = document.querySelector("#ticket")
      , l = document.querySelector("#marco4 .progressbar")
      , f = document.querySelector("#marco4 .purchased")
      , h = document.querySelector("#marco4 .lightbeep");
    return we.useEffect(()=>{
        r.current.material.metalness = 0;
        const d = ()=>{
            h.classList.add("on"),
            i.current.intensity = 2,
            s.play(),
            l.classList.add("off"),
            f.classList.add("on"),
            setTimeout(function() {
                a.classList.add("prod4"),
                h.classList.remove("on"),
                i.current.intensity = 0,
                o.play(),
                he.gsap.to(r.current.scale, {
                    duration: .15,
                    y: 0,
                    x: 0,
                    z: 0,
                    ease: "power4.easeInOut",
                    immediateRender: !1
                })
            }, 500)
        }
        ;
        he.gsap.to(r.current.position, {
            scrollTrigger: {
                trigger: "#landing",
                scrub: .2,
                start: "top top",
                end: "bottom -100%"
            },
            y: 180,
            ease: "power4.easeInOut",
            immediateRender: !1
        }),
        he.gsap.to(r.current.position, {
            scrollTrigger: {
                trigger: "#disruptive",
                scrub: .2,
                start: "top 110%",
                end: "top bottom"
            },
            x: -70,
            ease: "power4.easeInOut",
            immediateRender: !1
        }),
        he.gsap.to(r.current.position, {
            scrollTrigger: {
                trigger: "#disruptive",
                scrub: .2,
                start: "top bottom",
                end: "bottom 0"
            },
            y: -30,
            ease: "power4.easeInOut",
            immediateRender: !1
        }),
        he.gsap.to(r.current.rotation, {
            scrollTrigger: {
                trigger: "#disruptive",
                scrub: .2,
                start: "top bottom",
                end: "bottom 0"
            },
            x: .2 + Math.PI * 2,
            y: .3 + Math.PI * 2,
            z: 1,
            ease: "power4.easeInOut",
            immediateRender: !1
        }),
        he.gsap.from("#marco4 .numero", {
            scrollTrigger: {
                trigger: ".etiqueta.cuatro",
                scrub: .2,
                start: "top 100%",
                end: "top 25%"
            },
            x: -innerHeight * .2,
            ease: "power4.easeInOut",
            immediateRender: !1
        }),
        he.gsap.from("#marco4 .lat2", {
            scrollTrigger: {
                trigger: "#marco4",
                scrub: .2,
                start: "top 100%",
                end: "top 25%"
            },
            x: innerHeight * .2,
            ease: "power4.easeInOut",
            immediateRender: !1
        }),
        he.gsap.from("#marco4 .abajoizq", {
            scrollTrigger: {
                trigger: "#marco4",
                scrub: .2,
                start: "top 80%",
                end: "top 25%"
            },
            x: -innerHeight * .2,
            ease: "power4.easeInOut",
            immediateRender: !1
        }),
        he.gsap.from("#marco4 .abajodch", {
            scrollTrigger: {
                trigger: "#marco4",
                scrub: .2,
                start: "top 80%",
                end: "top 25%"
            },
            x: innerHeight * .2,
            ease: "power4.easeInOut",
            immediateRender: !1
        }),
        he.gsap.to("#marco4 .progressbar", {
            scrollTrigger: {
                trigger: "#disruptive",
                scrub: .2,
                start: "bottom 0",
                end: "bottom -50%"
            },
            width: innerWidth * .063,
            ease: "power4.easeInOut",
            immediateRender: !1
        }),
        oi.ScrollTrigger.create({
            trigger: "#disruptive",
            start: "bottom -50%",
            onEnter: d,
            onLeaveBack: p=>p.disable()
        }),
        he.gsap.to(r.current.scale, {
            scrollTrigger: {
                trigger: "#clients",
                scrub: .2,
                start: "bottom 140%",
                end: "bottom 130%"
            },
            x: .37,
            y: .37,
            z: .37,
            ease: "linear",
            immediateRender: !1
        }),
        he.gsap.to(r.current.position, {
            scrollTrigger: {
                trigger: "#clients",
                scrub: .2,
                start: "bottom 120%",
                end: "bottom 110%"
            },
            x: 0,
            y: 100,
            z: 90,
            ease: "linear",
            immediateRender: !1
        }),
        he.gsap.to(r.current.rotation, {
            scrollTrigger: {
                trigger: "#clients",
                scrub: .2,
                start: "bottom 120%",
                end: "bottom 110%"
            },
            x: 1,
            y: .5,
            z: 4,
            ease: "linear",
            immediateRender: !1
        }),
        he.gsap.to(r.current.position, {
            scrollTrigger: {
                trigger: "#clients",
                scrub: .2,
                start: "bottom 50%",
                end: "bottom 0"
            },
            x: -30,
            y: -80,
            z: 60,
            ease: "linear",
            immediateRender: !1
        }),
        he.gsap.to(r.current.rotation, {
            scrollTrigger: {
                trigger: "#clients",
                scrub: .2,
                start: "bottom 50%",
                end: "bottom 0"
            },
            x: 0,
            y: 0,
            z: .5,
            ease: "linear",
            immediateRender: !1
        })
    }
    , []),
    ot.jsx(ot.Fragment, {
        children: ot.jsxs(Zl, {
            speed: 5,
            rotationIntensity: 1,
            floatIntensity: 1,
            floatingRange: [-.05, .05],
            children: [ot.jsx("group", {
                ...n,
                dispose: null,
                children: ot.jsx("mesh", {
                    ref: r,
                    castShadow: !0,
                    receiveShadow: !0,
                    geometry: e.Candy_wrapper_v_8.geometry,
                    material: t.Candy_wrapper_v_8,
                    position: [0, 12, 0],
                    rotation: [.1, .4, .4]
                })
            }), ot.jsx("pointLight", {
                ref: i,
                color: "red",
                intensity: 0,
                position: [-5, -20, 5]
            })]
        })
    })
}
ji.preload("/chocolatina_silencio_c.glb");
he.gsap.registerPlugin(oi.ScrollTrigger);
function J5(n) {
    const {nodes: e, materials: t} = ji("/basket_c.glb")
      , r = we.useRef()
      , i = we.useRef()
      , s = we.useRef()
      , o = we.useRef();
    var a = new Audio("/print2.1.mp3")
      , l = document.querySelector("#ticket");
    return we.useEffect(()=>{
        r.current.material.metalness = 1,
        r.current.material.roughness = .2,
        i.current.material.metalness = 1,
        i.current.material.roughness = .2,
        s.current.material.metalness = 1,
        s.current.material.roughness = .2,
        he.gsap.to(o.current.position, {
            scrollTrigger: {
                trigger: "#clients",
                scrub: .2,
                start: "top 0%",
                end: "top -1%"
            },
            y: 0,
            ease: "linear",
            immediateRender: !1
        }),
        he.gsap.to(o.current.position, {
            scrollTrigger: {
                trigger: "#clients",
                scrub: .2,
                start: "bottom 100%",
                end: "bottom 0%"
            },
            x: 0,
            y: -1.6,
            z: 0,
            ease: "linear",
            immediateRender: !1
        }),
        he.gsap.to(o.current.rotation, {
            scrollTrigger: {
                trigger: "#clients",
                scrub: .2,
                start: "bottom 100%",
                end: "bottom 0%"
            },
            y: .8,
            x: .3,
            z: 0,
            ease: "linear",
            immediateRender: !1
        }),
        he.gsap.to(s.current.rotation, {
            scrollTrigger: {
                trigger: "#clients",
                scrub: .2,
                start: "bottom 50%",
                end: "bottom 0%"
            },
            z: -2.6,
            ease: "linear",
            immediateRender: !1
        }),
        he.gsap.to(i.current.rotation, {
            scrollTrigger: {
                trigger: "#clients",
                scrub: .2,
                start: "bottom 50%",
                end: "bottom 0%"
            },
            z: 2.6,
            ease: "linear",
            immediateRender: !1
        });
        const f = ()=>{
            l.classList.add("final"),
            a.play()
        }
        ;
        oi.ScrollTrigger.create({
            trigger: "#final2",
            start: "top 1%",
            onEnter: f,
            onLeaveBack: h=>h.disable()
        })
    }
    , []),
    ot.jsx(Zl, {
        speed: 2,
        rotationIntensity: .5,
        floatIntensity: .5,
        floatingRange: [-.05, .05],
        children: ot.jsxs("group", {
            ...n,
            dispose: null,
            ref: o,
            scale: .1,
            position: [0, -8, 5],
            rotation: [Math.PI / 2, 0, 0],
            children: [ot.jsx("mesh", {
                ref: i,
                geometry: e.Asa1.geometry,
                material: e.Asa1.material,
                position: [-9.37, 19.58, 0]
            }), ot.jsx("mesh", {
                ref: s,
                geometry: e.Asa2.geometry,
                material: e.Asa2.material,
                position: [9.32, 19.62, 0]
            }), ot.jsx("mesh", {
                ref: r,
                geometry: e.Cesta.geometry,
                material: e.Cesta.material
            })]
        })
    })
}
ji.preload("/basket_c.glb");
he.gsap.registerPlugin(oi.ScrollTrigger);
function j5(n) {
    const e = we.useRef();
    function t() {
        const {active: r, progress: i, errors: s, item: o, loaded: a, total: l} = pP();
        document.querySelector("#wrapper");
        var f = document.querySelector("#aceptar");
        document.querySelector("#fixworks"),
        document.querySelector("#lateral"),
        document.querySelector("#superiorstart"),
        document.querySelector("#superior"),
        document.querySelector("#limited"),
        document.querySelector("#barcode1"),
        we.useEffect(()=>{
            r || setTimeout(function() {
                preloader.classList.add("ready"),
                setTimeout(function() {
                    f.classList.add("ready")
                }, 4e3),
                he.gsap.to("#silenciostart", {
                    duration: 1.5,
                    x: 0,
                    ease: "power4.easeOut",
                    immediateRender: !1
                }),
                he.gsap.to("#superiormask div", {
                    delay: 1,
                    duration: .8,
                    y: 0,
                    stagger: .3,
                    ease: "power4.easeOut",
                    immediateRender: !1
                }),
                he.gsap.from(e.current.position, {
                    y: -20,
                    duration: 4,
                    ease: "power4.easeInOut",
                    immediateRender: !1
                }),
                he.gsap.from(e.current.rotation, {
                    duration: 4,
                    y: Math.PI * 1.5,
                    ease: "power4.easeInOut",
                    immediateRender: !1
                }),
                he.gsap.to("#lateralinner", {
                    scrollTrigger: {
                        trigger: "#content",
                        start: "top top",
                        end: "bottom bottom",
                        scrub: .2
                    },
                    x: -innerHeight - innerWidth * 4.504,
                    ease: "linear",
                    immediateRender: !1
                });
                var h = document.querySelector("#content");
                h.classList.add("fix"),
                window.scrollTo(0, 0)
            }, 500)
        }
        , [a, i])
    }
    return we.useEffect(()=>{
        var r = new Audio("/print1.2.mp3");
        aceptar.onclick = function() {
            content.classList.remove("fix"),
            he.gsap.to(".charin", {
                delay: .3,
                y: 0,
                stagger: .03,
                duration: 1,
                ease: "power4.easeOut"
            }),
            he.gsap.to("#landing h3", {
                delay: 1,
                y: 0,
                duration: 1,
                ease: "power4.easeOut"
            }),
            he.gsap.to(".wordin", {
                delay: 1,
                y: 0,
                stagger: .015,
                duration: 1,
                ease: "power4.easeOut"
            }),
            setTimeout(function() {
                var i = document.querySelector("#scroll");
                i.classList.add("ready"),
                ticket.classList.add("start"),
                setTimeout(function() {
                    r.play()
                }, 100)
            }, 2e3),
            superiorstart.classList.add("ready"),
            setTimeout(function() {
                superiorstart.classList.add("out"),
                superior.classList.add("ready")
            }, 1e3),
            aceptar.classList.add("out"),
            wrapper.classList.add("ready"),
            fixworks.classList.add("ready"),
            lateral.classList.add("ready"),
            barcode1.classList.add("ready"),
            limited.classList.add("ready"),
            he.gsap.to(e.current.rotation, {
                duration: 2,
                x: 0,
                y: 0,
                z: 0,
                ease: "power4.easeInOut",
                immediateRender: !1
            }),
            he.gsap.to(e.current.position, {
                duration: 2,
                x: 0,
                y: 0,
                z: 0,
                ease: "power4.easeInOut",
                immediateRender: !1
            }),
            oi.ScrollTrigger.refresh()
        }
    }
    , []),
    ot.jsx(ot.Fragment, {
        children: ot.jsxs(we.Suspense, {
            fallback: ot.jsx(t, {}),
            children: [ot.jsxs("group", {
                ref: e,
                rotation: [1, 0, 0],
                position: [0, 0, -3],
                children: [ot.jsx(SP, {
                    files: "studio_small_09_1k_low.hdr",
                    blur: 0,
                    intensity: 1
                }), ot.jsx(H5, {
                    scale: .025,
                    position: [3.2, 0, 0]
                }), ot.jsx(V5, {
                    position: [0, -.5, 2],
                    scale: .025
                }), ot.jsx(W5, {
                    position: [-3.5, 0, 0],
                    scale: .03
                }), ot.jsx(X5, {
                    position: [.5, 1.5, -.7],
                    scale: .03
                })]
            }), ot.jsx(J5, {})]
        })
    })
}
he.gsap.registerPlugin(oi.ScrollTrigger);
function Y5(n) {
    const {nodes: e, materials: t} = ji("/zumo_silencio_c.glb")
      , r = we.useRef()
      , i = we.useRef()
      , s = we.useRef()
      , o = we.useRef();
    var a = document.querySelector("#marco3 .progressbar")
      , l = document.querySelector("#marco3 .purchased")
      , f = document.querySelector("#marco3 .lightbeep")
      , h = document.querySelector("#pant3")
      , d = document.querySelector("#marco3 .click");
    return we.useEffect(()=>{
        s.current.material.metalness = 0,
        s.current.material.roughness = 0,
        o.current.material.metalness = 0,
        o.current.material.roughness = .5;
        const p = ()=>{
            d.classList.add("on"),
            f.classList.add("on"),
            i.current.intensity = 2,
            he.gsap.to("#marco3 .progressbar", {
                duration: .5,
                width: innerWidth * .225,
                ease: "power4.easeInOut",
                immediateRender: !1
            }),
            setTimeout(function() {
                var x = document.getElementsByClassName("pantallas");
                let S;
                for (S = 0; S < x.length; S++)
                    x[S].classList.remove("on");
                h.classList.add("on"),
                a.classList.add("off"),
                l.classList.add("on"),
                f.classList.remove("on"),
                i.current.intensity = 0,
                he.gsap.to(r.current.scale, {
                    duration: .15,
                    y: 0,
                    x: 0,
                    z: 0,
                    ease: "power4.easeInOut",
                    immediateRender: !1
                })
            }, 500)
        }
        ;
        he.gsap.to(r.current.position, {
            scrollTrigger: {
                trigger: "#landing",
                scrub: .2,
                start: "top top",
                end: "bottom -100%"
            },
            y: 7,
            ease: "power4.easeInOut",
            immediateRender: !1
        }),
        he.gsap.to("#marco3 .progressbar", {
            scrollTrigger: {
                trigger: "#motion",
                scrub: .2,
                start: "bottom 0",
                end: "bottom -50%"
            },
            width: innerWidth * .063,
            ease: "power4.easeInOut",
            immediateRender: !1
        }),
        he.gsap.from("#marco3 .numero", {
            scrollTrigger: {
                trigger: ".etiqueta.tres",
                scrub: .2,
                start: "top 100%",
                end: "top 25%"
            },
            x: -innerHeight * .2,
            ease: "power4.easeInOut",
            immediateRender: !1
        }),
        he.gsap.from("#marco3 .lat2", {
            scrollTrigger: {
                trigger: "#marco3",
                scrub: .2,
                start: "top 100%",
                end: "top 25%"
            },
            x: innerHeight * .2,
            ease: "power4.easeInOut",
            immediateRender: !1
        }),
        he.gsap.from("#marco3 .abajoizq", {
            scrollTrigger: {
                trigger: "#marco3",
                scrub: .2,
                start: "top 80%",
                end: "top 25%"
            },
            x: -innerHeight * .2,
            ease: "power4.easeInOut",
            immediateRender: !1
        }),
        he.gsap.from("#marco3 .abajodch", {
            scrollTrigger: {
                trigger: "#marco3",
                scrub: .2,
                start: "top 80%",
                end: "top 25%"
            },
            x: innerHeight * .2,
            ease: "power4.easeInOut",
            immediateRender: !1
        }),
        he.gsap.to(r.current.position, {
            scrollTrigger: {
                trigger: "#motion",
                scrub: .2,
                start: "top 110%",
                end: "top bottom"
            },
            x: 0,
            ease: "power4.easeInOut",
            immediateRender: !1
        }),
        he.gsap.to(r.current.rotation, {
            scrollTrigger: {
                trigger: "#motion",
                scrub: .2,
                start: "top 110%",
                end: "top bottom"
            },
            y: 1,
            z: 2,
            ease: "power4.easeInOut",
            immediateRender: !1
        }),
        he.gsap.to(r.current.rotation, {
            scrollTrigger: {
                trigger: "#motion",
                scrub: .2,
                start: "top 50%",
                end: "bottom 0"
            },
            y: Math.PI * 2,
            z: Math.PI * 2 + .5,
            ease: "power4.easeInOut",
            immediateRender: !1
        }),
        he.gsap.to(r.current.position, {
            scrollTrigger: {
                trigger: "#motion",
                scrub: .2,
                start: "top 50%",
                end: "bottom 0"
            },
            y: .3,
            ease: "power4.easeInOut",
            immediateRender: !1
        }),
        he.gsap.to(r.current.position, {
            scrollTrigger: {
                trigger: ".etiqueta.tres",
                scrub: .2,
                start: "top 0",
                end: "bottom 0"
            },
            y: 8,
            ease: "linear",
            immediateRender: !1
        });
        var m = document.querySelector(".etiqueta.tres");
        m.onclick = function() {
            p();
            var x = new Audio("./beep.mp3");
            x.play()
        }
        ;
        const _ = ()=>{
            var x = document.querySelector("#marco3 .purchased");
            x.classList.contains("on") ? he.gsap.to(r.current.scale, {
                x: 0,
                y: 0,
                z: 0
            }) : he.gsap.to(r.current.scale, {
                x: .025,
                y: .025,
                z: .025
            })
        }
          , y = ()=>{
            var x = document.querySelector("#marco3 .purchased");
            x.classList.contains("on") ? he.gsap.to(r.current.scale, {
                x: .012,
                y: .012,
                z: .012
            }) : he.gsap.to(r.current.scale, {
                x: 0,
                y: 0,
                z: 0
            })
        }
        ;
        oi.ScrollTrigger.create({
            trigger: "#clients",
            start: "bottom 140%",
            end: "bottom 139%",
            onEnter: y,
            onEnterBack: _
        }),
        he.gsap.to(r.current.position, {
            scrollTrigger: {
                trigger: "#clients",
                scrub: .2,
                start: "bottom 120%",
                end: "bottom 110%"
            },
            x: -.5,
            y: 5,
            z: 2.5,
            ease: "linear",
            immediateRender: !1
        }),
        he.gsap.to(r.current.rotation, {
            scrollTrigger: {
                trigger: "#clients",
                scrub: .2,
                start: "bottom 120%",
                end: "bottom 110%"
            },
            x: 3,
            y: 0,
            z: 1,
            ease: "linear",
            immediateRender: !1
        }),
        he.gsap.to(r.current.position, {
            scrollTrigger: {
                trigger: "#clients",
                scrub: .2,
                start: "bottom 50%",
                end: "bottom 0"
            },
            x: -1.5,
            y: 0,
            z: .8,
            ease: "linear",
            immediateRender: !1
        }),
        he.gsap.to(r.current.rotation, {
            scrollTrigger: {
                trigger: "#clients",
                scrub: .2,
                start: "bottom 50%",
                end: "bottom 0"
            },
            x: 0,
            y: 0,
            z: .5,
            ease: "linear",
            immediateRender: !1
        })
    }
    , []),
    ot.jsx(ot.Fragment, {
        children: ot.jsxs(Zl, {
            speed: 5,
            rotationIntensity: 1,
            floatIntensity: 1,
            floatingRange: [-.05, .05],
            children: [ot.jsxs("group", {
                ...n,
                dispose: null,
                ref: r,
                rotation: [0, -.3, -.6],
                children: [ot.jsx("group", {
                    position: [0, -56.29, 0],
                    children: ot.jsx("mesh", {
                        geometry: e.Wrapper.geometry,
                        position: [-.76, 61.13, 18.16],
                        rotation: [0, 0, 2.88],
                        scale: [1, -1, 1],
                        children: ot.jsx(yP, {
                            background: new It(16777215),
                            backside: !0,
                            samples: 10,
                            resolution: 2048,
                            transmission: 1,
                            roughness: 0,
                            thickness: .1,
                            ior: 2.1,
                            anisotropy: .1,
                            attenuationDistance: 1,
                            attenuationColor: "#ffffff",
                            color: "#ffffff"
                        })
                    })
                }), ot.jsx("group", {
                    position: [0, -56.29, 0],
                    children: ot.jsx("mesh", {
                        ref: s,
                        geometry: e.Straw.geometry,
                        material: t["Straw.001"],
                        position: [32.15, 159.14, 19.83],
                        rotation: [Math.PI / 2, -.26, Math.PI],
                        scale: [1, -1, 1]
                    })
                }), ot.jsx("group", {
                    position: [0, -56.29, 0],
                    children: ot.jsxs("group", {
                        position: [2.8, .85, -2.27],
                        rotation: [-Math.PI / 2, 0, 0],
                        children: [ot.jsx("mesh", {
                            geometry: e["Packaging-Foil"].geometry,
                            material: t["Foil.001"]
                        }), ot.jsx("mesh", {
                            ref: o,
                            geometry: e["Packaging-Box"].geometry,
                            material: t["Box.001"]
                        })]
                    })
                })]
            }), ot.jsx("pointLight", {
                ref: i,
                color: "red",
                intensity: 0,
                position: [-5, -30, 5]
            })]
        })
    })
}
ji.preload("/zumo_silencio_c.glb");
he.gsap.registerPlugin(oi.ScrollTrigger);
function K5(n) {
    const {nodes: e, materials: t} = ji("/can_silencio_c.glb")
      , r = we.useRef();
    we.useRef();
    const i = we.useRef()
      , s = we.useRef()
      , o = we.useRef()
      , a = we.useRef()
      , l = we.useRef();
    var f = document.querySelector("#marco1 .lightbeep")
      , h = document.querySelector("#marco1 .progressbar")
      , d = document.querySelector("#marco1 .purchased")
      , p = document.querySelector("#pant1")
      , m = document.querySelector("#marco1 .click");
    const _ = ()=>{
        m.classList.add("on"),
        f.classList.add("on"),
        i.current.intensity = 2,
        he.gsap.to("#marco1 .progressbar", {
            duration: .5,
            width: innerWidth * .225,
            ease: "power4.easeInOut",
            immediateRender: !1
        }),
        setTimeout(function() {
            var y = document.getElementsByClassName("pantallas");
            let x;
            for (x = 0; x < y.length; x++)
                y[x].classList.remove("on");
            p.classList.add("on"),
            h.classList.add("off"),
            d.classList.add("on"),
            f.classList.remove("on"),
            i.current.intensity = 0,
            he.gsap.to(r.current.scale, {
                duration: .15,
                y: 0,
                x: 0,
                z: 0,
                ease: "power4.easeInOut",
                immediateRender: !1
            })
        }, 500)
    }
    ;
    return we.useEffect(()=>{
        s.current.material.metalness = 0,
        s.current.material.roughness = .2,
        o.current.material.roughness = .3,
        a.current.material.roughness = .3,
        he.gsap.to(r.current.position, {
            scrollTrigger: {
                trigger: "#landing",
                scrub: .2,
                start: "top top",
                end: "bottom -100%"
            },
            x: 0,
            z: 0,
            ease: "power4.easeInOut",
            immediateRender: !1
        }),
        he.gsap.to(r.current.rotation, {
            scrollTrigger: {
                trigger: "#landing",
                scrub: .2,
                start: "top top",
                end: "bottom -100%"
            },
            x: 0,
            y: -2,
            z: 3.14 * 2,
            ease: "power4.easeInOut",
            immediateRender: !1
        }),
        he.gsap.to(r.current.position, {
            scrollTrigger: {
                trigger: "#landing",
                scrub: .2,
                start: "top top",
                end: "bottom -100%"
            },
            y: .2,
            ease: "power4.easeInOut",
            immediateRender: !1
        }),
        he.gsap.to("#marco1 .progressbar", {
            scrollTrigger: {
                trigger: "#tercera",
                scrub: .2,
                start: "bottom 0",
                end: "bottom -50%"
            },
            width: innerWidth * .063,
            ease: "power4.easeInOut",
            immediateRender: !1
        }),
        he.gsap.from("#marco1 .numero", {
            scrollTrigger: {
                trigger: ".etiqueta.uno",
                scrub: .2,
                start: "top 100%",
                end: "top 25%"
            },
            x: -innerHeight * .2,
            ease: "power4.easeInOut",
            immediateRender: !1
        }),
        he.gsap.from("#marco1 .lat2", {
            scrollTrigger: {
                trigger: "#marco1",
                scrub: .2,
                start: "top 100%",
                end: "top 25%"
            },
            x: innerHeight * .2,
            ease: "power4.easeInOut",
            immediateRender: !1
        }),
        he.gsap.from("#marco1 .abajoizq", {
            scrollTrigger: {
                trigger: "#marco1",
                scrub: .2,
                start: "top 80%",
                end: "top 25%"
            },
            x: -innerHeight * .2,
            ease: "power4.easeInOut",
            immediateRender: !1
        }),
        he.gsap.from("#marco1 .abajodch", {
            scrollTrigger: {
                trigger: "#marco1",
                start: "top 80%",
                end: "top 25%"
            },
            x: innerHeight * .2,
            ease: "power4.easeInOut",
            immediateRender: !1
        }),
        he.gsap.to(r.current.position, {
            scrollTrigger: {
                trigger: ".etiqueta.uno",
                scrub: .2,
                start: "top 0",
                end: "bottom 0"
            },
            y: 8,
            ease: "linear",
            immediateRender: !1
        });
        var y = document.querySelector(".etiqueta.uno");
        y.onclick = function() {
            _();
            var M = new Audio("./beep.mp3");
            M.play()
        }
        ;
        const x = ()=>{
            var M = document.querySelector("#marco1 .purchased");
            M.classList.contains("on") ? he.gsap.to(r.current.scale, {
                x: 0,
                y: 0,
                z: 0
            }) : he.gsap.to(r.current.scale, {
                x: .025,
                y: .025,
                z: .025
            })
        }
          , S = ()=>{
            var M = document.querySelector("#marco1 .purchased");
            M.classList.contains("on") ? he.gsap.to(r.current.scale, {
                x: .012,
                y: .012,
                z: .012
            }) : he.gsap.to(r.current.scale, {
                x: 0,
                y: 0,
                z: 0
            })
        }
        ;
        oi.ScrollTrigger.create({
            trigger: "#clients",
            start: "bottom 140%",
            end: "bottom 139%",
            onEnter: S,
            onEnterBack: x
        }),
        he.gsap.to(r.current.position, {
            scrollTrigger: {
                trigger: "#clients",
                scrub: .2,
                start: "bottom 120%",
                end: "bottom 110%"
            },
            x: 3.3,
            y: 3,
            z: 3.8,
            ease: "linear",
            immediateRender: !1
        }),
        he.gsap.to(r.current.rotation, {
            scrollTrigger: {
                trigger: "#clients",
                scrub: .2,
                start: "bottom 120%",
                end: "bottom 110%"
            },
            x: 0,
            y: 2,
            z: 1.5,
            ease: "linear",
            immediateRender: !1
        }),
        he.gsap.to(r.current.position, {
            scrollTrigger: {
                trigger: "#clients",
                scrub: .2,
                start: "bottom 50%",
                end: "bottom 0"
            },
            x: .8,
            y: -.5,
            z: .3,
            ease: "linear",
            immediateRender: !1
        }),
        he.gsap.to(r.current.rotation, {
            scrollTrigger: {
                trigger: "#clients",
                scrub: .2,
                start: "bottom 50%",
                end: "bottom 0"
            },
            x: Math.PI / 2,
            y: .8,
            z: Math.PI / 2 + .1,
            ease: "linear",
            immediateRender: !1
        }),
        oi.ScrollTrigger.refresh()
    }
    , []),
    ot.jsx(ot.Fragment, {
        children: ot.jsxs(Zl, {
            speed: 5,
            rotationIntensity: .5,
            floatIntensity: .5,
            floatingRange: [-.01, .01],
            children: [ot.jsx("group", {
                ref: l,
                children: ot.jsxs("group", {
                    ...n,
                    dispose: null,
                    ref: r,
                    rotation: [.3, -2, -.2],
                    children: [ot.jsx("mesh", {
                        ref: o,
                        geometry: e.Aluminum_Standard_Can_330ml_v_22.geometry,
                        material: t["Mat.002"],
                        position: [0, 4.19, 0],
                        rotation: [-Math.PI / 2, 0, 0]
                    }), ot.jsx("mesh", {
                        ref: a,
                        geometry: e.Aluminum_Standard_Can_330ml_v_21.geometry,
                        material: t["Mat.002"],
                        position: [0, 4.19, 0],
                        rotation: [-Math.PI / 2, 0, 1.57]
                    }), ot.jsx("mesh", {
                        ref: s,
                        geometry: e.Aluminum_Standard_Can_330ml_v_2.geometry,
                        material: t["Mat.003"],
                        position: [0, 4.19, 0],
                        rotation: [-Math.PI / 2, 0, .37]
                    })]
                })
            }), ot.jsx("pointLight", {
                ref: i,
                color: "red",
                intensity: 0,
                position: [-5, -20, 5]
            })]
        })
    })
}
ji.preload("/can_silencio_c.glb");
he.gsap.registerPlugin(oi.ScrollTrigger);
function q5(n) {
    const {nodes: e, materials: t} = ji("/bolsa_silencio_c.glb")
      , r = we.useRef();
    we.useRef(),
    we.useRef();
    const i = we.useRef();
    var s = document.querySelector("#marco2 .lightbeep")
      , o = document.querySelector("#marco2 .progressbar")
      , a = document.querySelector("#marco2 .purchased")
      , l = document.querySelector("#pant2")
      , f = document.querySelector("#marco2 .click");
    return we.useEffect(()=>{
        r.current.material.metalness = 0,
        r.current.material.roughness = .15;
        const h = ()=>{
            f.classList.add("on"),
            s.classList.add("on"),
            i.current.intensity = 2,
            he.gsap.to("#marco2 .progressbar", {
                duration: .5,
                width: innerWidth * .225,
                ease: "power4.easeInOut",
                immediateRender: !1
            }),
            setTimeout(function() {
                var _ = document.getElementsByClassName("pantallas");
                let y;
                for (y = 0; y < _.length; y++)
                    _[y].classList.remove("on");
                l.classList.add("on"),
                s.classList.remove("on"),
                i.current.intensity = 0,
                o.classList.add("off"),
                a.classList.add("on"),
                he.gsap.to(r.current.scale, {
                    duration: .15,
                    x: 0,
                    z: 0,
                    ease: "power4.easeInOut",
                    immediateRender: !1
                })
            }, 500)
        }
        ;
        he.gsap.to(r.current.position, {
            scrollTrigger: {
                trigger: "#landing",
                scrub: .2,
                start: "top top",
                end: "bottom -100%"
            },
            y: 280,
            ease: "power4.easeInOut",
            immediateRender: !1
        }),
        he.gsap.to(r.current.position, {
            scrollTrigger: {
                trigger: "#aesthetics",
                scrub: .2,
                start: "top 120%",
                end: "top bottom"
            },
            x: 120,
            ease: "power4.easeInOut",
            immediateRender: !1
        }),
        he.gsap.to(r.current.rotation, {
            scrollTrigger: {
                trigger: "#aesthetics",
                scrub: .2,
                start: "top 75%",
                end: "bottom top"
            },
            z: 3 * 2,
            y: .1 + 3.1416 * 2,
            x: -1.5,
            ease: "power4.easeInOut",
            immediateRender: !1
        }),
        he.gsap.to(r.current.position, {
            scrollTrigger: {
                trigger: "#aesthetics",
                scrub: .2,
                start: "top 75%",
                end: "bottom top"
            },
            y: 0,
            z: 0,
            ease: "power4.easeInOut",
            immediateRender: !1
        }),
        he.gsap.from("#marco2 .numero", {
            scrollTrigger: {
                trigger: ".etiqueta.dos",
                scrub: .2,
                start: "top 100%",
                end: "top 25%"
            },
            x: -innerHeight * .2,
            ease: "power4.easeInOut",
            immediateRender: !1
        }),
        he.gsap.from("#marco2 .abajoizq", {
            scrollTrigger: {
                trigger: "#marco2",
                scrub: .2,
                start: "top 80%",
                end: "top 25%"
            },
            x: -innerHeight * .2,
            ease: "power4.easeInOut",
            immediateRender: !1
        }),
        he.gsap.to(r.current.position, {
            scrollTrigger: {
                trigger: ".etiqueta.dos",
                scrub: .2,
                start: "top 0",
                end: "bottom 0"
            },
            y: 310,
            ease: "linear",
            immediateRender: !1
        });
        var d = document.querySelector(".etiqueta.dos");
        d.onclick = function() {
            h();
            var _ = new Audio("./beep.mp3");
            _.play()
        }
        ;
        const p = ()=>{
            var _ = document.querySelector("#marco2 .purchased");
            _.classList.contains("on") ? he.gsap.to(r.current.scale, {
                x: 0,
                y: 0,
                z: 0
            }) : he.gsap.to(r.current.scale, {
                x: 100,
                y: 100,
                z: 100
            })
        }
          , m = ()=>{
            var _ = document.querySelector("#marco2 .purchased");
            _.classList.contains("on") ? he.gsap.to(r.current.scale, {
                x: 51,
                y: 51,
                z: 51
            }) : he.gsap.to(r.current.scale, {
                x: 0,
                y: 0,
                z: 0
            })
        }
        ;
        oi.ScrollTrigger.create({
            trigger: "#clients",
            start: "bottom 140%",
            end: "bottom 139%",
            onEnter: m,
            onEnterBack: p
        }),
        he.gsap.to(r.current.position, {
            scrollTrigger: {
                trigger: "#clients",
                scrub: .2,
                start: "bottom 120%",
                end: "bottom 110%"
            },
            x: 120,
            y: 300,
            z: 120,
            ease: "linear",
            immediateRender: !1
        }),
        he.gsap.to(r.current.rotation, {
            scrollTrigger: {
                trigger: "#clients",
                scrub: .2,
                start: "bottom 120%",
                end: "bottom 110%"
            },
            x: 0,
            y: 2,
            z: 0,
            ease: "linear",
            immediateRender: !1
        }),
        he.gsap.to(r.current.position, {
            scrollTrigger: {
                trigger: "#clients",
                scrub: .2,
                start: "bottom 50%",
                end: "bottom 0"
            },
            x: 120,
            y: 0,
            z: 0,
            ease: "linear",
            immediateRender: !1
        }),
        he.gsap.to(r.current.rotation, {
            scrollTrigger: {
                trigger: "#clients",
                scrub: .2,
                start: "bottom 50%",
                end: "bottom 0"
            },
            x: -Math.PI / 2,
            y: 0,
            z: 0,
            ease: "linear",
            immediateRender: !1
        })
    }
    , []),
    ot.jsxs(Zl, {
        speed: 5,
        rotationIntensity: 1,
        floatIntensity: 1,
        floatingRange: [-.05, .05],
        children: [ot.jsx("group", {
            children: ot.jsx("group", {
                ...n,
                dispose: null,
                children: ot.jsx("mesh", {
                    ref: r,
                    geometry: e.package_01.geometry,
                    material: t["Mat.004"],
                    rotation: [-Math.PI / 2, -.2, .1],
                    scale: 100
                })
            })
        }), ot.jsx("pointLight", {
            ref: i,
            color: "red",
            intensity: 0,
            position: [-5, -30, 5]
        })]
    })
}
ji.preload("/bolsa_silencio_c.glb");
he.gsap.registerPlugin(oi.ScrollTrigger);
function Q5(n) {
    const {nodes: e, materials: t} = ji("/chocolatina_silencio_c.glb")
      , r = we.useRef();
    we.useRef();
    const i = we.useRef();
    var s = document.querySelector("#marco4 .progressbar")
      , o = document.querySelector("#marco4 .purchased")
      , a = document.querySelector("#marco4 .lightbeep")
      , l = document.querySelector("#pant4")
      , f = document.querySelector("#marco4 .click");
    return we.useEffect(()=>{
        r.current.material.metalness = 0;
        const h = ()=>{
            f.classList.add("on"),
            a.classList.add("on"),
            i.current.intensity = 2,
            he.gsap.to("#marco4 .progressbar", {
                duration: .5,
                width: innerWidth * .225,
                ease: "power4.easeInOut",
                immediateRender: !1
            }),
            setTimeout(function() {
                var _ = document.getElementsByClassName("pantallas");
                let y;
                for (y = 0; y < _.length; y++)
                    _[y].classList.remove("on");
                l.classList.add("on"),
                s.classList.add("off"),
                o.classList.add("on"),
                a.classList.remove("on"),
                i.current.intensity = 0,
                he.gsap.to(r.current.scale, {
                    duration: .15,
                    y: 0,
                    x: 0,
                    z: 0,
                    ease: "power4.easeInOut",
                    immediateRender: !1
                })
            }, 500)
        }
        ;
        he.gsap.to(r.current.position, {
            scrollTrigger: {
                trigger: "#landing",
                scrub: .2,
                start: "top top",
                end: "bottom -100%"
            },
            y: 180,
            ease: "power4.easeInOut",
            immediateRender: !1
        }),
        he.gsap.to(r.current.position, {
            scrollTrigger: {
                trigger: "#disruptive",
                scrub: .2,
                start: "top 110%",
                end: "top bottom"
            },
            x: -15,
            ease: "power4.easeInOut",
            immediateRender: !1
        }),
        he.gsap.to(r.current.position, {
            scrollTrigger: {
                trigger: "#disruptive",
                scrub: .2,
                start: "top 60%",
                end: "bottom 0"
            },
            y: -30,
            ease: "power4.easeInOut",
            immediateRender: !1
        }),
        he.gsap.to(r.current.rotation, {
            scrollTrigger: {
                trigger: "#disruptive",
                scrub: .2,
                start: "top 60%",
                end: "bottom 0"
            },
            x: .2 + Math.PI * 2,
            y: .3 + Math.PI * 2,
            z: 1,
            ease: "power4.easeInOut",
            immediateRender: !1
        }),
        he.gsap.from("#marco4 .numero", {
            scrollTrigger: {
                trigger: ".etiqueta.cuatro",
                scrub: .2,
                start: "top 100%",
                end: "top 25%"
            },
            x: -innerHeight * .2,
            ease: "power4.easeInOut",
            immediateRender: !1
        }),
        he.gsap.from("#marco4 .lat2", {
            scrollTrigger: {
                trigger: "#marco4",
                scrub: .2,
                start: "top 100%",
                end: "top 25%"
            },
            x: innerHeight * .2,
            ease: "power4.easeInOut",
            immediateRender: !1
        }),
        he.gsap.from("#marco4 .abajoizq", {
            scrollTrigger: {
                trigger: "#marco4",
                scrub: .2,
                start: "top 80%",
                end: "top 25%"
            },
            x: -innerHeight * .2,
            ease: "power4.easeInOut",
            immediateRender: !1
        }),
        he.gsap.from("#marco4 .abajodch", {
            scrollTrigger: {
                trigger: "#marco4",
                scrub: .2,
                start: "top 80%",
                end: "top 25%"
            },
            x: innerHeight * .2,
            ease: "power4.easeInOut",
            immediateRender: !1
        }),
        he.gsap.to("#marco4 .progressbar", {
            scrollTrigger: {
                trigger: "#disruptive",
                scrub: .2,
                start: "bottom 0",
                end: "bottom -50%"
            },
            width: innerWidth * .063,
            ease: "power4.easeInOut",
            immediateRender: !1
        }),
        he.gsap.to(r.current.position, {
            scrollTrigger: {
                trigger: ".etiqueta.cuatro",
                scrub: .2,
                start: "top 0",
                end: "bottom 0"
            },
            y: 200,
            ease: "linear",
            immediateRender: !1
        });
        var d = document.querySelector(".etiqueta.cuatro");
        d.onclick = function() {
            h();
            var _ = new Audio("./beep.mp3");
            _.play()
        }
        ;
        const p = ()=>{
            var _ = document.querySelector("#marco4 .purchased");
            _.classList.contains("on") ? he.gsap.to(r.current.scale, {
                x: 0,
                y: 0,
                z: 0
            }) : he.gsap.to(r.current.scale, {
                x: 1,
                y: 1,
                z: 1
            })
        }
          , m = ()=>{
            var _ = document.querySelector("#marco4 .purchased");
            _.classList.contains("on") ? he.gsap.to(r.current.scale, {
                x: .37,
                y: .37,
                z: .37
            }) : he.gsap.to(r.current.scale, {
                x: 0,
                y: 0,
                z: 0
            })
        }
        ;
        oi.ScrollTrigger.create({
            trigger: "#clients",
            start: "bottom 140%",
            end: "bottom 139%",
            onEnter: m,
            onEnterBack: p
        }),
        he.gsap.to(r.current.position, {
            scrollTrigger: {
                trigger: "#clients",
                scrub: .2,
                start: "bottom 120%",
                end: "bottom 110%"
            },
            x: 0,
            y: 100,
            z: 90,
            ease: "linear",
            immediateRender: !1
        }),
        he.gsap.to(r.current.rotation, {
            scrollTrigger: {
                trigger: "#clients",
                scrub: .2,
                start: "bottom 120%",
                end: "bottom 110%"
            },
            x: 1,
            y: .5,
            z: 4,
            ease: "linear",
            immediateRender: !1
        }),
        he.gsap.to(r.current.position, {
            scrollTrigger: {
                trigger: "#clients",
                scrub: .2,
                start: "bottom 50%",
                end: "bottom 0"
            },
            x: -30,
            y: -80,
            z: 60,
            ease: "linear",
            immediateRender: !1
        }),
        he.gsap.to(r.current.rotation, {
            scrollTrigger: {
                trigger: "#clients",
                scrub: .2,
                start: "bottom 50%",
                end: "bottom 0"
            },
            x: 0,
            y: 0,
            z: .5,
            ease: "linear",
            immediateRender: !1
        })
    }
    , []),
    ot.jsx(ot.Fragment, {
        children: ot.jsxs(Zl, {
            speed: 5,
            rotationIntensity: 1,
            floatIntensity: 1,
            floatingRange: [-.05, .05],
            children: [ot.jsx("group", {
                ...n,
                dispose: null,
                children: ot.jsx("mesh", {
                    ref: r,
                    castShadow: !0,
                    receiveShadow: !0,
                    geometry: e.Candy_wrapper_v_8.geometry,
                    material: t.Candy_wrapper_v_8,
                    position: [0, 12, 0],
                    rotation: [.1, .4, .4]
                })
            }), ot.jsx("pointLight", {
                ref: i,
                color: "red",
                intensity: 0,
                position: [-5, -20, 5]
            })]
        })
    })
}
ji.preload("/chocolatina_silencio_c.glb");
he.gsap.registerPlugin(oi.ScrollTrigger);
function Z5(n) {
    const {nodes: e, materials: t} = ji("/basket_c.glb")
      , r = we.useRef()
      , i = we.useRef()
      , s = we.useRef()
      , o = we.useRef();
    return we.useEffect(()=>{
        r.current.material.metalness = 1,
        r.current.material.roughness = .2,
        i.current.material.metalness = 1,
        i.current.material.roughness = .2,
        s.current.material.metalness = 1,
        s.current.material.roughness = .2,
        he.gsap.to(o.current.position, {
            scrollTrigger: {
                trigger: "#clients",
                scrub: .2,
                start: "top 0%",
                end: "top -1%"
            },
            y: 0,
            ease: "linear",
            immediateRender: !1
        }),
        he.gsap.to(o.current.position, {
            scrollTrigger: {
                trigger: "#clients",
                scrub: .2,
                start: "bottom 100%",
                end: "bottom 0%"
            },
            x: 0,
            y: -1.6,
            z: 0,
            ease: "linear",
            immediateRender: !1
        }),
        he.gsap.to(o.current.rotation, {
            scrollTrigger: {
                trigger: "#clients",
                scrub: .2,
                start: "bottom 100%",
                end: "bottom 0%"
            },
            y: .8,
            x: .3,
            z: 0,
            ease: "linear",
            immediateRender: !1
        }),
        he.gsap.to(s.current.rotation, {
            scrollTrigger: {
                trigger: "#clients",
                scrub: .2,
                start: "bottom 50%",
                end: "bottom 0%"
            },
            z: -2.6,
            ease: "linear",
            immediateRender: !1
        }),
        he.gsap.to(i.current.rotation, {
            scrollTrigger: {
                trigger: "#clients",
                scrub: .2,
                start: "bottom 50%",
                end: "bottom 0%"
            },
            z: 2.6,
            ease: "linear",
            immediateRender: !1
        })
    }
    , []),
    ot.jsx(Zl, {
        speed: 2,
        rotationIntensity: .5,
        floatIntensity: .5,
        floatingRange: [-.05, .05],
        children: ot.jsxs("group", {
            ...n,
            dispose: null,
            ref: o,
            scale: .1,
            position: [0, -8, 5],
            rotation: [Math.PI / 2, 0, 0],
            children: [ot.jsx("mesh", {
                ref: i,
                geometry: e.Asa1.geometry,
                material: e.Asa1.material,
                position: [-9.37, 19.58, 0]
            }), ot.jsx("mesh", {
                ref: s,
                geometry: e.Asa2.geometry,
                material: e.Asa2.material,
                position: [9.32, 19.62, 0]
            }), ot.jsx("mesh", {
                ref: r,
                geometry: e.Cesta.geometry,
                material: e.Cesta.material
            })]
        })
    })
}
ji.preload("/basket_c.glb");
he.gsap.registerPlugin(oi.ScrollTrigger);
function $5(n) {
    const e = we.useRef();
    function t() {
        const {active: r, progress: i, errors: s, item: o, loaded: a, total: l} = pP();
        var f = document.querySelector("#wrapper")
          , h = document.querySelector("#limited")
          , d = document.querySelector("#barcode1");
        we.useEffect(()=>{
            r || setTimeout(function() {
                preloader.classList.add("ready"),
                he.gsap.to("#silenciostart", {
                    duration: 1.5,
                    x: 0,
                    ease: "power4.easeOut",
                    immediateRender: !1
                }),
                he.gsap.to("#superiormask div", {
                    delay: 1,
                    duration: .8,
                    y: 0,
                    stagger: .3,
                    ease: "power4.easeOut",
                    immediateRender: !1
                }),
                he.gsap.to("#landing h3", {
                    delay: 1,
                    y: 0,
                    duration: 1,
                    ease: "power4.easeOut"
                }),
                aceptar.classList.add("out"),
                f.classList.add("ready"),
                d.classList.add("ready"),
                h.classList.add("ready"),
                he.gsap.to(e.current.rotation, {
                    duration: 4,
                    x: 0,
                    y: 0,
                    z: 0,
                    ease: "power4.easeInOut",
                    immediateRender: !1
                }),
                he.gsap.to(e.current.position, {
                    duration: 2,
                    x: 0,
                    y: 0,
                    z: 0,
                    ease: "power4.easeInOut",
                    immediateRender: !1
                }),
                he.gsap.to("#lateralinner", {
                    scrollTrigger: {
                        trigger: "#content",
                        start: "top top",
                        end: "bottom bottom",
                        scrub: .2
                    },
                    x: -innerWidth * .64,
                    ease: "linear",
                    immediateRender: !1
                })
            }, 500)
        }
        , [a, i])
    }
    return ot.jsx(ot.Fragment, {
        children: ot.jsxs(we.Suspense, {
            fallback: ot.jsx(t, {}),
            children: [ot.jsxs("group", {
                ref: e,
                rotation: [1, 0, 0],
                position: [0, 0, -3],
                children: [ot.jsx(SP, {
                    files: "studio_small_09_1k_low.hdr",
                    blur: 0,
                    intensity: 1
                }), ot.jsx(Y5, {
                    scale: .025,
                    position: [3.2, 0, 0]
                }), ot.jsx(K5, {
                    position: [0, -.5, 2],
                    scale: .025
                }), ot.jsx(q5, {
                    position: [-3.5, 0, 0],
                    scale: .03
                }), ot.jsx(Q5, {
                    position: [.5, 1.5, -.7],
                    scale: .03
                })]
            }), ot.jsx(Z5, {})]
        })
    })
}
screen.width > 1024 && document.fonts.ready.then(function() {
    BS(document.getElementById("root")).render(ot.jsx(ot.Fragment, {
        children: ot.jsx(we.StrictMode, {
            children: ot.jsx(hP, {
                camera: {
                    fov: 50,
                    near: .1,
                    far: 30,
                    position: [0, 0, 8]
                },
                children: ot.jsx(j5, {})
            })
        })
    }))
});
screen.width < 1024 && BS(document.getElementById("canvasmov")).render(ot.jsx(ot.Fragment, {
    children: ot.jsx(we.StrictMode, {
        children: ot.jsxs(hP, {
            dpr: [1, 2],
            camera: {
                fov: 50,
                near: .1,
                far: 500,
                position: [0, 0, 8]
            },
            children: [ot.jsx(B5, {}), ot.jsx($5, {})]
        })
    })
}));
function cb(n, e) {
    for (var t = 0; t < e.length; t++) {
        var r = e[t];
        r.enumerable = r.enumerable || !1,
        r.configurable = !0,
        "value"in r && (r.writable = !0),
        Object.defineProperty(n, r.key, r)
    }
}
function eH(n, e, t) {
    return e && cb(n.prototype, e),
    t && cb(n, t),
    n
}
/*!
 * Observer 3.11.4
 * https://greensock.com
 *
 * @license Copyright 2008-2022, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/
var Hs, bw, va, cc, fc, oh, MP, df, Hp, AP, yu, dl, CP, EP = function() {
    return Hs || typeof window < "u" && (Hs = window.gsap) && Hs.registerPlugin && Hs
}, bP = 1, Yd = [], er = [], Yl = [], Vp = Date.now, Tw = function(e, t) {
    return t
}, tH = function() {
    var e = Hp.core
      , t = e.bridge || {}
      , r = e._scrollers
      , i = e._proxies;
    r.push.apply(r, er),
    i.push.apply(i, Yl),
    er = r,
    Yl = i,
    Tw = function(o, a) {
        return t[o](a)
    }
}, Mc = function(e, t) {
    return ~Yl.indexOf(e) && Yl[Yl.indexOf(e) + 1][t]
}, Wp = function(e) {
    return !!~AP.indexOf(e)
}, Jo = function(e, t, r, i, s) {
    return e.addEventListener(t, r, {
        passive: !i,
        capture: !!s
    })
}, xo = function(e, t, r, i) {
    return e.removeEventListener(t, r, !!i)
}, E0 = "scrollLeft", b0 = "scrollTop", Dw = function() {
    return yu && yu.isPressed || er.cache++
}, Yv = function(e, t) {
    var r = function i(s) {
        if (s || s === 0) {
            bP && (va.history.scrollRestoration = "manual");
            var o = yu && yu.isPressed;
            s = i.v = Math.round(s) || (yu && yu.iOS ? 1 : 0),
            e(s),
            i.cacheID = er.cache,
            o && Tw("ss", s)
        } else
            (t || er.cache !== i.cacheID || Tw("ref")) && (i.cacheID = er.cache,
            i.v = e());
        return i.v + i.offset
    };
    return r.offset = 0,
    e && r
}, Co = {
    s: E0,
    p: "left",
    p2: "Left",
    os: "right",
    os2: "Right",
    d: "width",
    d2: "Width",
    a: "x",
    sc: Yv(function(n) {
        return arguments.length ? va.scrollTo(n, ms.sc()) : va.pageXOffset || cc[E0] || fc[E0] || oh[E0] || 0
    })
}, ms = {
    s: b0,
    p: "top",
    p2: "Top",
    os: "bottom",
    os2: "Bottom",
    d: "height",
    d2: "Height",
    a: "y",
    op: Co,
    sc: Yv(function(n) {
        return arguments.length ? va.scrollTo(Co.sc(), n) : va.pageYOffset || cc[b0] || fc[b0] || oh[b0] || 0
    })
}, Yo = function(e) {
    return Hs.utils.toArray(e)[0] || (typeof e == "string" && Hs.config().nullTargetWarn !== !1 ? console.warn("Element not found:", e) : null)
}, Rc = function(e, t) {
    var r = t.s
      , i = t.sc;
    Wp(e) && (e = cc.scrollingElement || fc);
    var s = er.indexOf(e)
      , o = i === ms.sc ? 1 : 2;
    !~s && (s = er.push(e) - 1),
    er[s + o] || e.addEventListener("scroll", Dw);
    var a = er[s + o]
      , l = a || (er[s + o] = Yv(Mc(e, r), !0) || (Wp(e) ? i : Yv(function(f) {
        return arguments.length ? e[r] = f : e[r]
    })));
    return l.target = e,
    a || (l.smooth = Hs.getProperty(e, "scrollBehavior") === "smooth"),
    l
}, Pw = function(e, t, r) {
    var i = e
      , s = e
      , o = Vp()
      , a = o
      , l = t || 50
      , f = Math.max(500, l * 3)
      , h = function(_, y) {
        var x = Vp();
        y || x - o > l ? (s = i,
        i = _,
        a = o,
        o = x) : r ? i += _ : i = s + (_ - s) / (x - a) * (o - a)
    }
      , d = function() {
        s = i = r ? 0 : i,
        a = o = 0
    }
      , p = function(_) {
        var y = a
          , x = s
          , S = Vp();
        return (_ || _ === 0) && _ !== i && h(_),
        o === a || S - a > f ? 0 : (i + (r ? x : -x)) / ((r ? S : o) - y) * 1e3
    };
    return {
        update: h,
        reset: d,
        getVelocity: p
    }
}, gp = function(e, t) {
    return t && !e._gsapAllow && e.preventDefault(),
    e.changedTouches ? e.changedTouches[0] : e
}, fb = function(e) {
    var t = Math.max.apply(Math, e)
      , r = Math.min.apply(Math, e);
    return Math.abs(t) >= Math.abs(r) ? t : r
}, TP = function() {
    Hp = Hs.core.globals().ScrollTrigger,
    Hp && Hp.core && tH()
}, DP = function(e) {
    return Hs = e || EP(),
    Hs && typeof document < "u" && document.body && (va = window,
    cc = document,
    fc = cc.documentElement,
    oh = cc.body,
    AP = [va, cc, fc, oh],
    Hs.utils.clamp,
    CP = Hs.core.context || function() {}
    ,
    df = "onpointerenter"in oh ? "pointer" : "mouse",
    MP = ls.isTouch = va.matchMedia && va.matchMedia("(hover: none), (pointer: coarse)").matches ? 1 : "ontouchstart"in va || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0 ? 2 : 0,
    dl = ls.eventTypes = ("ontouchstart"in fc ? "touchstart,touchmove,touchcancel,touchend" : "onpointerdown"in fc ? "pointerdown,pointermove,pointercancel,pointerup" : "mousedown,mousemove,mouseup,mouseup").split(","),
    setTimeout(function() {
        return bP = 0
    }, 500),
    TP(),
    bw = 1),
    bw
};
Co.op = ms;
er.cache = 0;
var ls = function() {
    function n(t) {
        this.init(t)
    }
    var e = n.prototype;
    return e.init = function(r) {
        bw || DP(Hs) || console.warn("Please gsap.registerPlugin(Observer)"),
        Hp || TP();
        var i = r.tolerance
          , s = r.dragMinimum
          , o = r.type
          , a = r.target
          , l = r.lineHeight
          , f = r.debounce
          , h = r.preventDefault
          , d = r.onStop
          , p = r.onStopDelay
          , m = r.ignore
          , _ = r.wheelSpeed
          , y = r.event
          , x = r.onDragStart
          , S = r.onDragEnd
          , M = r.onDrag
          , w = r.onPress
          , T = r.onRelease
          , P = r.onRight
          , I = r.onLeft
          , k = r.onUp
          , R = r.onDown
          , O = r.onChangeX
          , H = r.onChangeY
          , W = r.onChange
          , te = r.onToggleX
          , ne = r.onToggleY
          , re = r.onHover
          , pe = r.onHoverEnd
          , ce = r.onMove
          , xe = r.ignoreCheck
          , G = r.isNormalizer
          , z = r.onGestureStart
          , U = r.onGestureEnd
          , fe = r.onWheel
          , oe = r.onEnable
          , Ae = r.onDisable
          , Ue = r.onClick
          , je = r.scrollSpeed
          , de = r.capture
          , qe = r.allowClicks
          , Ne = r.lockAxis
          , Tt = r.onLockAxis;
        this.target = a = Yo(a) || fc,
        this.vars = r,
        m && (m = Hs.utils.toArray(m)),
        i = i || 1e-9,
        s = s || 0,
        _ = _ || 1,
        je = je || 1,
        o = o || "wheel,touch,pointer",
        f = f !== !1,
        l || (l = parseFloat(va.getComputedStyle(oh).lineHeight) || 22);
        var He, gt, be, Ee, at, _t, Ce, ee = this, et = 0, Ze = 0, ft = Rc(a, Co), Pt = Rc(a, ms), Z = ft(), V = Pt(), ye = ~o.indexOf("touch") && !~o.indexOf("pointer") && dl[0] === "pointerdown", tt = Wp(a), Ve = a.ownerDocument || cc, Ke = [0, 0, 0], dt = [0, 0, 0], ct = 0, Fe = function() {
            return ct = Vp()
        }, Rt = function(St, ut) {
            return (ee.event = St) && m && ~m.indexOf(St.target) || ut && ye && St.pointerType !== "touch" || xe && xe(St, ut)
        }, le = function() {
            ee._vx.reset(),
            ee._vy.reset(),
            gt.pause(),
            d && d(ee)
        }, Le = function() {
            var St = ee.deltaX = fb(Ke)
              , ut = ee.deltaY = fb(dt)
              , Nt = Math.abs(St) >= i
              , $t = Math.abs(ut) >= i;
            W && (Nt || $t) && W(ee, St, ut, Ke, dt),
            Nt && (P && ee.deltaX > 0 && P(ee),
            I && ee.deltaX < 0 && I(ee),
            O && O(ee),
            te && ee.deltaX < 0 != et < 0 && te(ee),
            et = ee.deltaX,
            Ke[0] = Ke[1] = Ke[2] = 0),
            $t && (R && ee.deltaY > 0 && R(ee),
            k && ee.deltaY < 0 && k(ee),
            H && H(ee),
            ne && ee.deltaY < 0 != Ze < 0 && ne(ee),
            Ze = ee.deltaY,
            dt[0] = dt[1] = dt[2] = 0),
            (Ee || be) && (ce && ce(ee),
            be && (M(ee),
            be = !1),
            Ee = !1),
            _t && !(_t = !1) && Tt && Tt(ee),
            at && (fe(ee),
            at = !1),
            He = 0
        }, rt = function(St, ut, Nt) {
            Ke[Nt] += St,
            dt[Nt] += ut,
            ee._vx.update(St),
            ee._vy.update(ut),
            f ? He || (He = requestAnimationFrame(Le)) : Le()
        }, st = function(St, ut) {
            Ne && !Ce && (ee.axis = Ce = Math.abs(St) > Math.abs(ut) ? "x" : "y",
            _t = !0),
            Ce !== "y" && (Ke[2] += St,
            ee._vx.update(St, !0)),
            Ce !== "x" && (dt[2] += ut,
            ee._vy.update(ut, !0)),
            f ? He || (He = requestAnimationFrame(Le)) : Le()
        }, Ut = function(St) {
            if (!Rt(St, 1)) {
                St = gp(St, h);
                var ut = St.clientX
                  , Nt = St.clientY
                  , $t = ut - ee.x
                  , hn = Nt - ee.y
                  , Qn = ee.isDragging;
                ee.x = ut,
                ee.y = Nt,
                (Qn || Math.abs(ee.startX - ut) >= s || Math.abs(ee.startY - Nt) >= s) && (M && (be = !0),
                Qn || (ee.isDragging = !0),
                st($t, hn),
                Qn || x && x(ee))
            }
        }, Mt = ee.onPress = function(mn) {
            Rt(mn, 1) || (ee.axis = Ce = null,
            gt.pause(),
            ee.isPressed = !0,
            mn = gp(mn),
            et = Ze = 0,
            ee.startX = ee.x = mn.clientX,
            ee.startY = ee.y = mn.clientY,
            ee._vx.reset(),
            ee._vy.reset(),
            Jo(G ? a : Ve, dl[1], Ut, h, !0),
            ee.deltaX = ee.deltaY = 0,
            w && w(ee))
        }
        , wn = function(St) {
            if (!Rt(St, 1)) {
                xo(G ? a : Ve, dl[1], Ut, !0);
                var ut = !isNaN(ee.y - ee.startY)
                  , Nt = ee.isDragging && (Math.abs(ee.x - ee.startX) > 3 || Math.abs(ee.y - ee.startY) > 3)
                  , $t = gp(St);
                !Nt && ut && (ee._vx.reset(),
                ee._vy.reset(),
                h && qe && Hs.delayedCall(.08, function() {
                    if (Vp() - ct > 300 && !St.defaultPrevented) {
                        if (St.target.click)
                            St.target.click();
                        else if (Ve.createEvent) {
                            var hn = Ve.createEvent("MouseEvents");
                            hn.initMouseEvent("click", !0, !0, va, 1, $t.screenX, $t.screenY, $t.clientX, $t.clientY, !1, !1, !1, !1, 0, null),
                            St.target.dispatchEvent(hn)
                        }
                    }
                })),
                ee.isDragging = ee.isGesturing = ee.isPressed = !1,
                d && !G && gt.restart(!0),
                S && Nt && S(ee),
                T && T(ee, Nt)
            }
        }, ae = function(St) {
            return St.touches && St.touches.length > 1 && (ee.isGesturing = !0) && z(St, ee.isDragging)
        }, De = function() {
            return (ee.isGesturing = !1) || U(ee)
        }, Je = function(St) {
            if (!Rt(St)) {
                var ut = ft()
                  , Nt = Pt();
                rt((ut - Z) * je, (Nt - V) * je, 1),
                Z = ut,
                V = Nt,
                d && gt.restart(!0)
            }
        }, vt = function(St) {
            if (!Rt(St)) {
                St = gp(St, h),
                fe && (at = !0);
                var ut = (St.deltaMode === 1 ? l : St.deltaMode === 2 ? va.innerHeight : 1) * _;
                rt(St.deltaX * ut, St.deltaY * ut, 0),
                d && !G && gt.restart(!0)
            }
        }, Et = function(St) {
            if (!Rt(St)) {
                var ut = St.clientX
                  , Nt = St.clientY
                  , $t = ut - ee.x
                  , hn = Nt - ee.y;
                ee.x = ut,
                ee.y = Nt,
                Ee = !0,
                ($t || hn) && st($t, hn)
            }
        }, rn = function(St) {
            ee.event = St,
            re(ee)
        }, dn = function(St) {
            ee.event = St,
            pe(ee)
        }, or = function(St) {
            return Rt(St) || gp(St, h) && Ue(ee)
        };
        gt = ee._dc = Hs.delayedCall(p || .25, le).pause(),
        ee.deltaX = ee.deltaY = 0,
        ee._vx = Pw(0, 50, !0),
        ee._vy = Pw(0, 50, !0),
        ee.scrollX = ft,
        ee.scrollY = Pt,
        ee.isDragging = ee.isGesturing = ee.isPressed = !1,
        CP(this),
        ee.enable = function(mn) {
            return ee.isEnabled || (Jo(tt ? Ve : a, "scroll", Dw),
            o.indexOf("scroll") >= 0 && Jo(tt ? Ve : a, "scroll", Je, h, de),
            o.indexOf("wheel") >= 0 && Jo(a, "wheel", vt, h, de),
            (o.indexOf("touch") >= 0 && MP || o.indexOf("pointer") >= 0) && (Jo(a, dl[0], Mt, h, de),
            Jo(Ve, dl[2], wn),
            Jo(Ve, dl[3], wn),
            qe && Jo(a, "click", Fe, !1, !0),
            Ue && Jo(a, "click", or),
            z && Jo(Ve, "gesturestart", ae),
            U && Jo(Ve, "gestureend", De),
            re && Jo(a, df + "enter", rn),
            pe && Jo(a, df + "leave", dn),
            ce && Jo(a, df + "move", Et)),
            ee.isEnabled = !0,
            mn && mn.type && Mt(mn),
            oe && oe(ee)),
            ee
        }
        ,
        ee.disable = function() {
            ee.isEnabled && (Yd.filter(function(mn) {
                return mn !== ee && Wp(mn.target)
            }).length || xo(tt ? Ve : a, "scroll", Dw),
            ee.isPressed && (ee._vx.reset(),
            ee._vy.reset(),
            xo(G ? a : Ve, dl[1], Ut, !0)),
            xo(tt ? Ve : a, "scroll", Je, de),
            xo(a, "wheel", vt, de),
            xo(a, dl[0], Mt, de),
            xo(Ve, dl[2], wn),
            xo(Ve, dl[3], wn),
            xo(a, "click", Fe, !0),
            xo(a, "click", or),
            xo(Ve, "gesturestart", ae),
            xo(Ve, "gestureend", De),
            xo(a, df + "enter", rn),
            xo(a, df + "leave", dn),
            xo(a, df + "move", Et),
            ee.isEnabled = ee.isPressed = ee.isDragging = !1,
            Ae && Ae(ee))
        }
        ,
        ee.kill = ee.revert = function() {
            ee.disable();
            var mn = Yd.indexOf(ee);
            mn >= 0 && Yd.splice(mn, 1),
            yu === ee && (yu = 0)
        }
        ,
        Yd.push(ee),
        G && Wp(a) && (yu = ee),
        ee.enable(y)
    }
    ,
    eH(n, [{
        key: "velocityX",
        get: function() {
            return this._vx.getVelocity()
        }
    }, {
        key: "velocityY",
        get: function() {
            return this._vy.getVelocity()
        }
    }]),
    n
}();
ls.version = "3.11.4";
ls.create = function(n) {
    return new ls(n)
}
;
ls.register = DP;
ls.getAll = function() {
    return Yd.slice()
}
;
ls.getById = function(n) {
    return Yd.filter(function(e) {
        return e.vars.id === n
    })[0]
}
;
EP() && Hs.registerPlugin(ls);
/*!
 * ScrollTrigger 3.11.4
 * https://greensock.com
 *
 * @license Copyright 2008-2022, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/
var fn, Pd, sr, Mi, xl, Wi, PP, Kv, qv, Kd, cv, T0, so, L_, Rw, Mo, db, hb, Rd, RP, bx, BP, fa, IP, LP, FP, ec, Bw, RM, Tx, D0 = 1, Ao = Date.now, Dx = Ao(), qa = 0, P0 = 0, pb = function() {
    return L_ = 1
}, mb = function() {
    return L_ = 0
}, Ul = function(e) {
    return e
}, Cp = function(e) {
    return Math.round(e * 1e5) / 1e5 || 0
}, kP = function() {
    return typeof window < "u"
}, OP = function() {
    return fn || kP() && (fn = window.gsap) && fn.registerPlugin && fn
}, Jf = function(e) {
    return !!~PP.indexOf(e)
}, NP = function(e) {
    return Mc(e, "getBoundingClientRect") || (Jf(e) ? function() {
        return gv.width = sr.innerWidth,
        gv.height = sr.innerHeight,
        gv
    }
    : function() {
        return pu(e)
    }
    )
}, nH = function(e, t, r) {
    var i = r.d
      , s = r.d2
      , o = r.a;
    return (o = Mc(e, "getBoundingClientRect")) ? function() {
        return o()[i]
    }
    : function() {
        return (t ? sr["inner" + s] : e["client" + s]) || 0
    }
}, rH = function(e, t) {
    return !t || ~Yl.indexOf(e) ? NP(e) : function() {
        return gv
    }
}, dc = function(e, t) {
    var r = t.s
      , i = t.d2
      , s = t.d
      , o = t.a;
    return (r = "scroll" + i) && (o = Mc(e, r)) ? o() - NP(e)()[s] : Jf(e) ? (xl[r] || Wi[r]) - (sr["inner" + i] || xl["client" + i] || Wi["client" + i]) : e[r] - e["offset" + i]
}, R0 = function(e, t) {
    for (var r = 0; r < Rd.length; r += 3)
        (!t || ~t.indexOf(Rd[r + 1])) && e(Rd[r], Rd[r + 1], Rd[r + 2])
}, pl = function(e) {
    return typeof e == "string"
}, Eo = function(e) {
    return typeof e == "function"
}, Ep = function(e) {
    return typeof e == "number"
}, fv = function(e) {
    return typeof e == "object"
}, vp = function(e, t, r) {
    return e && e.progress(t ? 0 : 1) && r && e.pause()
}, Px = function(e, t) {
    if (e.enabled) {
        var r = t(e);
        r && r.totalTime && (e.callbackAnimation = r)
    }
}, Ed = Math.abs, zP = "left", GP = "top", BM = "right", IM = "bottom", If = "width", Lf = "height", Xp = "Right", Jp = "Left", jp = "Top", Yp = "Bottom", Qi = "padding", Wa = "margin", Ch = "Width", LM = "Height", Ns = "px", wl = function(e) {
    return sr.getComputedStyle(e)
}, iH = function(e) {
    var t = wl(e).position;
    e.style.position = t === "absolute" || t === "fixed" ? t : "relative"
}, gb = function(e, t) {
    for (var r in t)
        r in e || (e[r] = t[r]);
    return e
}, pu = function(e, t) {
    var r = t && wl(e)[Rw] !== "matrix(1, 0, 0, 1, 0, 0)" && fn.to(e, {
        x: 0,
        y: 0,
        xPercent: 0,
        yPercent: 0,
        rotation: 0,
        rotationX: 0,
        rotationY: 0,
        scale: 1,
        skewX: 0,
        skewY: 0
    }).progress(1)
      , i = e.getBoundingClientRect();
    return r && r.progress(0).kill(),
    i
}, Iw = function(e, t) {
    var r = t.d2;
    return e["offset" + r] || e["client" + r] || 0
}, UP = function(e) {
    var t = [], r = e.labels, i = e.duration(), s;
    for (s in r)
        t.push(r[s] / i);
    return t
}, sH = function(e) {
    return function(t) {
        return fn.utils.snap(UP(e), t)
    }
}, FM = function(e) {
    var t = fn.utils.snap(e)
      , r = Array.isArray(e) && e.slice(0).sort(function(i, s) {
        return i - s
    });
    return r ? function(i, s, o) {
        o === void 0 && (o = .001);
        var a;
        if (!s)
            return t(i);
        if (s > 0) {
            for (i -= o,
            a = 0; a < r.length; a++)
                if (r[a] >= i)
                    return r[a];
            return r[a - 1]
        } else
            for (a = r.length,
            i += o; a--; )
                if (r[a] <= i)
                    return r[a];
        return r[0]
    }
    : function(i, s, o) {
        o === void 0 && (o = .001);
        var a = t(i);
        return !s || Math.abs(a - i) < o || a - i < 0 == s < 0 ? a : t(s < 0 ? i - e : i + e)
    }
}, oH = function(e) {
    return function(t, r) {
        return FM(UP(e))(t, r.direction)
    }
}, B0 = function(e, t, r, i) {
    return r.split(",").forEach(function(s) {
        return e(t, s, i)
    })
}, Gs = function(e, t, r, i, s) {
    return e.addEventListener(t, r, {
        passive: !i,
        capture: !!s
    })
}, Ds = function(e, t, r, i) {
    return e.removeEventListener(t, r, !!i)
}, I0 = function(e, t, r) {
    return r && r.wheelHandler && e(t, "wheel", r)
}, vb = {
    startColor: "green",
    endColor: "red",
    indent: 0,
    fontSize: "16px",
    fontWeight: "normal"
}, L0 = {
    toggleActions: "play",
    anticipatePin: 0
}, Qv = {
    top: 0,
    left: 0,
    center: .5,
    bottom: 1,
    right: 1
}, dv = function(e, t) {
    if (pl(e)) {
        var r = e.indexOf("=")
          , i = ~r ? +(e.charAt(r - 1) + 1) * parseFloat(e.substr(r + 1)) : 0;
        ~r && (e.indexOf("%") > r && (i *= t / 100),
        e = e.substr(0, r - 1)),
        e = i + (e in Qv ? Qv[e] * t : ~e.indexOf("%") ? parseFloat(e) * t / 100 : parseFloat(e) || 0)
    }
    return e
}, F0 = function(e, t, r, i, s, o, a, l) {
    var f = s.startColor
      , h = s.endColor
      , d = s.fontSize
      , p = s.indent
      , m = s.fontWeight
      , _ = Mi.createElement("div")
      , y = Jf(r) || Mc(r, "pinType") === "fixed"
      , x = e.indexOf("scroller") !== -1
      , S = y ? Wi : r
      , M = e.indexOf("start") !== -1
      , w = M ? f : h
      , T = "border-color:" + w + ";font-size:" + d + ";color:" + w + ";font-weight:" + m + ";pointer-events:none;white-space:nowrap;font-family:sans-serif,Arial;z-index:1000;padding:4px 8px;border-width:0;border-style:solid;";
    return T += "position:" + ((x || l) && y ? "fixed;" : "absolute;"),
    (x || l || !y) && (T += (i === ms ? BM : IM) + ":" + (o + parseFloat(p)) + "px;"),
    a && (T += "box-sizing:border-box;text-align:left;width:" + a.offsetWidth + "px;"),
    _._isStart = M,
    _.setAttribute("class", "gsap-marker-" + e + (t ? " marker-" + t : "")),
    _.style.cssText = T,
    _.innerText = t || t === 0 ? e + "-" + t : e,
    S.children[0] ? S.insertBefore(_, S.children[0]) : S.appendChild(_),
    _._offset = _["offset" + i.op.d2],
    hv(_, 0, i, M),
    _
}, hv = function(e, t, r, i) {
    var s = {
        display: "block"
    }
      , o = r[i ? "os2" : "p2"]
      , a = r[i ? "p2" : "os2"];
    e._isFlipped = i,
    s[r.a + "Percent"] = i ? -100 : 0,
    s[r.a] = i ? "1px" : 0,
    s["border" + o + Ch] = 1,
    s["border" + a + Ch] = 0,
    s[r.p] = t + "px",
    fn.set(e, s)
}, qn = [], Lw = {}, bm, _b = function() {
    return Ao() - qa > 34 && (bm || (bm = requestAnimationFrame(Bc)))
}, bd = function() {
    (!fa || !fa.isPressed || fa.startX > Wi.clientWidth) && (er.cache++,
    fa ? bm || (bm = requestAnimationFrame(Bc)) : Bc(),
    qa || Yf("scrollStart"),
    qa = Ao())
}, Rx = function() {
    FP = sr.innerWidth,
    LP = sr.innerHeight
}, bp = function() {
    er.cache++,
    !so && !BP && !Mi.fullscreenElement && !Mi.webkitFullscreenElement && (!IP || FP !== sr.innerWidth || Math.abs(sr.innerHeight - LP) > sr.innerHeight * .25) && Kv.restart(!0)
}, jf = {}, aH = [], HP = function n() {
    return Ds(kn, "scrollEnd", n) || Af(!0)
}, Yf = function(e) {
    return jf[e] && jf[e].map(function(t) {
        return t()
    }) || aH
}, da = [], VP = function(e) {
    for (var t = 0; t < da.length; t += 5)
        (!e || da[t + 4] && da[t + 4].query === e) && (da[t].style.cssText = da[t + 1],
        da[t].getBBox && da[t].setAttribute("transform", da[t + 2] || ""),
        da[t + 3].uncache = 1)
}, kM = function(e, t) {
    var r;
    for (Mo = 0; Mo < qn.length; Mo++)
        r = qn[Mo],
        r && (!t || r._ctx === t) && (e ? r.kill(1) : r.revert(!0, !0));
    t && VP(t),
    t || Yf("revert")
}, WP = function(e, t) {
    er.cache++,
    (t || !vl) && er.forEach(function(r) {
        return Eo(r) && r.cacheID++ && (r.rec = 0)
    }),
    pl(e) && (sr.history.scrollRestoration = RM = e)
}, vl, Ff = 0, yb, lH = function() {
    if (yb !== Ff) {
        var e = yb = Ff;
        requestAnimationFrame(function() {
            return e === Ff && Af(!0)
        })
    }
}, Af = function(e, t) {
    if (qa && !e) {
        Gs(kn, "scrollEnd", HP);
        return
    }
    vl = kn.isRefreshing = !0,
    er.forEach(function(i) {
        return Eo(i) && i.cacheID++ && (i.rec = i())
    });
    var r = Yf("refreshInit");
    RP && kn.sort(),
    t || kM(),
    er.forEach(function(i) {
        Eo(i) && (i.smooth && (i.target.style.scrollBehavior = "auto"),
        i(0))
    }),
    qn.slice(0).forEach(function(i) {
        return i.refresh()
    }),
    qn.forEach(function(i, s) {
        if (i._subPinOffset && i.pin) {
            var o = i.vars.horizontal ? "offsetWidth" : "offsetHeight"
              , a = i.pin[o];
            i.revert(!0, 1),
            i.adjustPinSpacing(i.pin[o] - a),
            i.revert(!1, 1)
        }
    }),
    qn.forEach(function(i) {
        return i.vars.end === "max" && i.setPositions(i.start, Math.max(i.start + 1, dc(i.scroller, i._dir)))
    }),
    r.forEach(function(i) {
        return i && i.render && i.render(-1)
    }),
    er.forEach(function(i) {
        Eo(i) && (i.smooth && requestAnimationFrame(function() {
            return i.target.style.scrollBehavior = "smooth"
        }),
        i.rec && i(i.rec))
    }),
    WP(RM, 1),
    Kv.pause(),
    Ff++,
    Bc(2),
    qn.forEach(function(i) {
        return Eo(i.vars.onRefresh) && i.vars.onRefresh(i)
    }),
    vl = kn.isRefreshing = !1,
    Yf("refresh")
}, xb = 0, pv = 1, Kp, Bc = function(e) {
    if (!vl || e === 2) {
        kn.isUpdating = !0,
        Kp && Kp.update(0);
        var t = qn.length
          , r = Ao()
          , i = r - Dx >= 50
          , s = t && qn[0].scroll();
        if (pv = xb > s ? -1 : 1,
        xb = s,
        i && (qa && !L_ && r - qa > 200 && (qa = 0,
        Yf("scrollEnd")),
        cv = Dx,
        Dx = r),
        pv < 0) {
            for (Mo = t; Mo-- > 0; )
                qn[Mo] && qn[Mo].update(0, i);
            pv = 1
        } else
            for (Mo = 0; Mo < t; Mo++)
                qn[Mo] && qn[Mo].update(0, i);
        kn.isUpdating = !1
    }
    bm = 0
}, Fw = [zP, GP, IM, BM, Wa + Yp, Wa + Xp, Wa + jp, Wa + Jp, "display", "flexShrink", "float", "zIndex", "gridColumnStart", "gridColumnEnd", "gridRowStart", "gridRowEnd", "gridArea", "justifySelf", "alignSelf", "placeSelf", "order"], mv = Fw.concat([If, Lf, "boxSizing", "max" + Ch, "max" + LM, "position", Wa, Qi, Qi + jp, Qi + Xp, Qi + Yp, Qi + Jp]), uH = function(e, t, r) {
    ah(r);
    var i = e._gsap;
    if (i.spacerIsNative)
        ah(i.spacerState);
    else if (e._gsap.swappedIn) {
        var s = t.parentNode;
        s && (s.insertBefore(e, t),
        s.removeChild(t))
    }
    e._gsap.swappedIn = !1
}, Bx = function(e, t, r, i) {
    if (!e._gsap.swappedIn) {
        for (var s = Fw.length, o = t.style, a = e.style, l; s--; )
            l = Fw[s],
            o[l] = r[l];
        o.position = r.position === "absolute" ? "absolute" : "relative",
        r.display === "inline" && (o.display = "inline-block"),
        a[IM] = a[BM] = "auto",
        o.flexBasis = r.flexBasis || "auto",
        o.overflow = "visible",
        o.boxSizing = "border-box",
        o[If] = Iw(e, Co) + Ns,
        o[Lf] = Iw(e, ms) + Ns,
        o[Qi] = a[Wa] = a[GP] = a[zP] = "0",
        ah(i),
        a[If] = a["max" + Ch] = r[If],
        a[Lf] = a["max" + LM] = r[Lf],
        a[Qi] = r[Qi],
        e.parentNode !== t && (e.parentNode.insertBefore(t, e),
        t.appendChild(e)),
        e._gsap.swappedIn = !0
    }
}, cH = /([A-Z])/g, ah = function(e) {
    if (e) {
        var t = e.t.style, r = e.length, i = 0, s, o;
        for ((e.t._gsap || fn.core.getCache(e.t)).uncache = 1; i < r; i += 2)
            o = e[i + 1],
            s = e[i],
            o ? t[s] = o : t[s] && t.removeProperty(s.replace(cH, "-$1").toLowerCase())
    }
}, k0 = function(e) {
    for (var t = mv.length, r = e.style, i = [], s = 0; s < t; s++)
        i.push(mv[s], r[mv[s]]);
    return i.t = e,
    i
}, fH = function(e, t, r) {
    for (var i = [], s = e.length, o = r ? 8 : 0, a; o < s; o += 2)
        a = e[o],
        i.push(a, a in t ? t[a] : e[o + 1]);
    return i.t = e.t,
    i
}, gv = {
    left: 0,
    top: 0
}, wb = function(e, t, r, i, s, o, a, l, f, h, d, p, m) {
    Eo(e) && (e = e(l)),
    pl(e) && e.substr(0, 3) === "max" && (e = p + (e.charAt(4) === "=" ? dv("0" + e.substr(3), r) : 0));
    var _ = m ? m.time() : 0, y, x, S;
    if (m && m.seek(0),
    Ep(e))
        a && hv(a, r, i, !0);
    else {
        Eo(t) && (t = t(l));
        var M = (e || "0").split(" "), w, T, P, I;
        S = Yo(t) || Wi,
        w = pu(S) || {},
        (!w || !w.left && !w.top) && wl(S).display === "none" && (I = S.style.display,
        S.style.display = "block",
        w = pu(S),
        I ? S.style.display = I : S.style.removeProperty("display")),
        T = dv(M[0], w[i.d]),
        P = dv(M[1] || "0", r),
        e = w[i.p] - f[i.p] - h + T + s - P,
        a && hv(a, P, i, r - P < 20 || a._isStart && P > 20),
        r -= r - P
    }
    if (o) {
        var k = e + r
          , R = o._isStart;
        y = "scroll" + i.d2,
        hv(o, k, i, R && k > 20 || !R && (d ? Math.max(Wi[y], xl[y]) : o.parentNode[y]) <= k + 1),
        d && (f = pu(a),
        d && (o.style[i.op.p] = f[i.op.p] - i.op.m - o._offset + Ns))
    }
    return m && S && (y = pu(S),
    m.seek(p),
    x = pu(S),
    m._caScrollDist = y[i.p] - x[i.p],
    e = e / m._caScrollDist * p),
    m && m.seek(_),
    m ? e : Math.round(e)
}, dH = /(webkit|moz|length|cssText|inset)/i, Sb = function(e, t, r, i) {
    if (e.parentNode !== t) {
        var s = e.style, o, a;
        if (t === Wi) {
            e._stOrig = s.cssText,
            a = wl(e);
            for (o in a)
                !+o && !dH.test(o) && a[o] && typeof s[o] == "string" && o !== "0" && (s[o] = a[o]);
            s.top = r,
            s.left = i
        } else
            s.cssText = e._stOrig;
        fn.core.getCache(e).uncache = 1,
        t.appendChild(e)
    }
}, Mb = function(e, t) {
    var r = Rc(e, t), i = "_scroll" + t.p2, s, o, a = function l(f, h, d, p, m) {
        var _ = l.tween
          , y = h.onComplete
          , x = {};
        return d = d || r(),
        m = p && m || 0,
        p = p || f - d,
        _ && _.kill(),
        s = Math.round(d),
        h[i] = f,
        h.modifiers = x,
        x[i] = function(S) {
            return S = Math.round(r()),
            S !== s && S !== o && Math.abs(S - s) > 3 && Math.abs(S - o) > 3 ? (_.kill(),
            l.tween = 0) : S = d + p * _.ratio + m * _.ratio * _.ratio,
            o = s,
            s = Math.round(S)
        }
        ,
        h.onUpdate = function() {
            er.cache++,
            Bc()
        }
        ,
        h.onComplete = function() {
            l.tween = 0,
            y && y.call(_)
        }
        ,
        _ = l.tween = fn.to(e, h),
        _
    };
    return e[i] = r,
    r.wheelHandler = function() {
        return a.tween && a.tween.kill() && (a.tween = 0)
    }
    ,
    Gs(e, "wheel", r.wheelHandler),
    a
}, kn = function() {
    function n(t, r) {
        Pd || n.register(fn) || console.warn("Please gsap.registerPlugin(ScrollTrigger)"),
        this.init(t, r)
    }
    var e = n.prototype;
    return e.init = function(r, i) {
        if (this.progress = this.start = 0,
        this.vars && this.kill(!0, !0),
        !P0) {
            this.update = this.refresh = this.kill = Ul;
            return
        }
        r = gb(pl(r) || Ep(r) || r.nodeType ? {
            trigger: r
        } : r, L0);
        var s = r, o = s.onUpdate, a = s.toggleClass, l = s.id, f = s.onToggle, h = s.onRefresh, d = s.scrub, p = s.trigger, m = s.pin, _ = s.pinSpacing, y = s.invalidateOnRefresh, x = s.anticipatePin, S = s.onScrubComplete, M = s.onSnapComplete, w = s.once, T = s.snap, P = s.pinReparent, I = s.pinSpacer, k = s.containerAnimation, R = s.fastScrollEnd, O = s.preventOverlaps, H = r.horizontal || r.containerAnimation && r.horizontal !== !1 ? Co : ms, W = !d && d !== 0, te = Yo(r.scroller || sr), ne = fn.core.getCache(te), re = Jf(te), pe = ("pinType"in r ? r.pinType : Mc(te, "pinType") || re && "fixed") === "fixed", ce = [r.onEnter, r.onLeave, r.onEnterBack, r.onLeaveBack], xe = W && r.toggleActions.split(" "), G = "markers"in r ? r.markers : L0.markers, z = re ? 0 : parseFloat(wl(te)["border" + H.p2 + Ch]) || 0, U = this, fe = r.onRefreshInit && function() {
            return r.onRefreshInit(U)
        }
        , oe = nH(te, re, H), Ae = rH(te, re), Ue = 0, je = 0, de = Rc(te, H), qe, Ne, Tt, He, gt, be, Ee, at, _t, Ce, ee, et, Ze, ft, Pt, Z, V, ye, tt, Ve, Ke, dt, ct, Fe, Rt, le, Le, rt, st, Ut, Mt, wn, ae, De, Je, vt, Et, rn, dn;
        if (Bw(U),
        U._dir = H,
        x *= 45,
        U.scroller = te,
        U.scroll = k ? k.time.bind(k) : de,
        He = de(),
        U.vars = r,
        i = i || r.animation,
        "refreshPriority"in r && (RP = 1,
        r.refreshPriority === -9999 && (Kp = U)),
        ne.tweenScroll = ne.tweenScroll || {
            top: Mb(te, ms),
            left: Mb(te, Co)
        },
        U.tweenTo = qe = ne.tweenScroll[H.p],
        U.scrubDuration = function(ut) {
            wn = Ep(ut) && ut,
            wn ? Mt ? Mt.duration(ut) : Mt = fn.to(i, {
                ease: "expo",
                totalProgress: "+=0.001",
                duration: wn,
                paused: !0,
                onComplete: function() {
                    return S && S(U)
                }
            }) : (Mt && Mt.progress(1).kill(),
            Mt = 0)
        }
        ,
        i && (i.vars.lazy = !1,
        i._initted || i.vars.immediateRender !== !1 && r.immediateRender !== !1 && i.duration() && i.render(0, !0, !0),
        U.animation = i.pause(),
        i.scrollTrigger = U,
        U.scrubDuration(d),
        st = 0,
        l || (l = i.vars.id)),
        qn.push(U),
        T && ((!fv(T) || T.push) && (T = {
            snapTo: T
        }),
        "scrollBehavior"in Wi.style && fn.set(re ? [Wi, xl] : te, {
            scrollBehavior: "auto"
        }),
        er.forEach(function(ut) {
            return Eo(ut) && ut.target === (re ? Mi.scrollingElement || xl : te) && (ut.smooth = !1)
        }),
        Tt = Eo(T.snapTo) ? T.snapTo : T.snapTo === "labels" ? sH(i) : T.snapTo === "labelsDirectional" ? oH(i) : T.directional !== !1 ? function(ut, Nt) {
            return FM(T.snapTo)(ut, Ao() - je < 500 ? 0 : Nt.direction)
        }
        : fn.utils.snap(T.snapTo),
        ae = T.duration || {
            min: .1,
            max: 2
        },
        ae = fv(ae) ? Kd(ae.min, ae.max) : Kd(ae, ae),
        De = fn.delayedCall(T.delay || wn / 2 || .1, function() {
            var ut = de()
              , Nt = Ao() - je < 500
              , $t = qe.tween;
            if ((Nt || Math.abs(U.getVelocity()) < 10) && !$t && !L_ && Ue !== ut) {
                var hn = (ut - be) / Ze
                  , Qn = i && !W ? i.totalProgress() : hn
                  , vn = Nt ? 0 : (Qn - Ut) / (Ao() - cv) * 1e3 || 0
                  , j = fn.utils.clamp(-hn, 1 - hn, Ed(vn / 2) * vn / .185)
                  , me = hn + (T.inertia === !1 ? 0 : j)
                  , ze = Kd(0, 1, Tt(me, U))
                  , ge = Math.round(be + ze * Ze)
                  , Oe = T
                  , Vt = Oe.onStart
                  , Ft = Oe.onInterrupt
                  , Gt = Oe.onComplete;
                if (ut <= Ee && ut >= be && ge !== ut) {
                    if ($t && !$t._initted && $t.data <= Ed(ge - ut))
                        return;
                    T.inertia === !1 && (j = ze - hn),
                    qe(ge, {
                        duration: ae(Ed(Math.max(Ed(me - Qn), Ed(ze - Qn)) * .185 / vn / .05 || 0)),
                        ease: T.ease || "power3",
                        data: Ed(ge - ut),
                        onInterrupt: function() {
                            return De.restart(!0) && Ft && Ft(U)
                        },
                        onComplete: function() {
                            U.update(),
                            Ue = de(),
                            st = Ut = i && !W ? i.totalProgress() : U.progress,
                            M && M(U),
                            Gt && Gt(U)
                        }
                    }, ut, j * Ze, ge - ut - j * Ze),
                    Vt && Vt(U, qe.tween)
                }
            } else
                U.isActive && Ue !== ut && De.restart(!0)
        }).pause()),
        l && (Lw[l] = U),
        p = U.trigger = Yo(p || m),
        dn = p && p._gsap && p._gsap.stRevert,
        dn && (dn = dn(U)),
        m = m === !0 ? p : Yo(m),
        pl(a) && (a = {
            targets: p,
            className: a
        }),
        m && (_ === !1 || _ === Wa || (_ = !_ && m.parentNode && m.parentNode.style && wl(m.parentNode).display === "flex" ? !1 : Qi),
        U.pin = m,
        Ne = fn.core.getCache(m),
        Ne.spacer ? ft = Ne.pinState : (I && (I = Yo(I),
        I && !I.nodeType && (I = I.current || I.nativeElement),
        Ne.spacerIsNative = !!I,
        I && (Ne.spacerState = k0(I))),
        Ne.spacer = V = I || Mi.createElement("div"),
        V.classList.add("pin-spacer"),
        l && V.classList.add("pin-spacer-" + l),
        Ne.pinState = ft = k0(m)),
        r.force3D !== !1 && fn.set(m, {
            force3D: !0
        }),
        U.spacer = V = Ne.spacer,
        rt = wl(m),
        ct = rt[_ + H.os2],
        tt = fn.getProperty(m),
        Ve = fn.quickSetter(m, H.a, Ns),
        Bx(m, V, rt),
        Z = k0(m)),
        G) {
            et = fv(G) ? gb(G, vb) : vb,
            Ce = F0("scroller-start", l, te, H, et, 0),
            ee = F0("scroller-end", l, te, H, et, 0, Ce),
            ye = Ce["offset" + H.op.d2];
            var or = Yo(Mc(te, "content") || te);
            at = this.markerStart = F0("start", l, or, H, et, ye, 0, k),
            _t = this.markerEnd = F0("end", l, or, H, et, ye, 0, k),
            k && (rn = fn.quickSetter([at, _t], H.a, Ns)),
            !pe && !(Yl.length && Mc(te, "fixedMarkers") === !0) && (iH(re ? Wi : te),
            fn.set([Ce, ee], {
                force3D: !0
            }),
            Rt = fn.quickSetter(Ce, H.a, Ns),
            Le = fn.quickSetter(ee, H.a, Ns))
        }
        if (k) {
            var mn = k.vars.onUpdate
              , St = k.vars.onUpdateParams;
            k.eventCallback("onUpdate", function() {
                U.update(0, 0, 1),
                mn && mn.apply(St || [])
            })
        }
        U.previous = function() {
            return qn[qn.indexOf(U) - 1]
        }
        ,
        U.next = function() {
            return qn[qn.indexOf(U) + 1]
        }
        ,
        U.revert = function(ut, Nt) {
            if (!Nt)
                return U.kill(!0);
            var $t = ut !== !1 || !U.enabled
              , hn = so;
            $t !== U.isReverted && ($t && (vt = Math.max(de(), U.scroll.rec || 0),
            Je = U.progress,
            Et = i && i.progress()),
            at && [at, _t, Ce, ee].forEach(function(Qn) {
                return Qn.style.display = $t ? "none" : "block"
            }),
            $t && (so = 1,
            U.update($t)),
            m && (!P || !U.isActive) && ($t ? uH(m, V, ft) : Bx(m, V, wl(m), Fe)),
            $t || U.update($t),
            so = hn,
            U.isReverted = $t)
        }
        ,
        U.refresh = function(ut, Nt) {
            if (!((so || !U.enabled) && !Nt)) {
                if (m && ut && qa) {
                    Gs(n, "scrollEnd", HP);
                    return
                }
                !vl && fe && fe(U),
                so = 1,
                je = Ao(),
                qe.tween && (qe.tween.kill(),
                qe.tween = 0),
                Mt && Mt.pause(),
                y && i && i.revert({
                    kill: !1
                }).invalidate(),
                U.isReverted || U.revert(!0, !0),
                U._subPinOffset = !1;
                for (var $t = oe(), hn = Ae(), Qn = k ? k.duration() : dc(te, H), vn = 0, j = 0, me = r.end, ze = r.endTrigger || p, ge = r.start || (r.start === 0 || !p ? 0 : m ? "0 0" : "0 100%"), Oe = U.pinnedContainer = r.pinnedContainer && Yo(r.pinnedContainer), Vt = p && Math.max(0, qn.indexOf(U)) || 0, Ft = Vt, Gt, Yt, Sn, tn, Xt, en, Zn, Yn, es, Nn, kt; Ft--; )
                    en = qn[Ft],
                    en.end || en.refresh(0, 1) || (so = 1),
                    Zn = en.pin,
                    Zn && (Zn === p || Zn === m) && !en.isReverted && (Nn || (Nn = []),
                    Nn.unshift(en),
                    en.revert(!0, !0)),
                    en !== qn[Ft] && (Vt--,
                    Ft--);
                for (Eo(ge) && (ge = ge(U)),
                be = wb(ge, p, $t, H, de(), at, Ce, U, hn, z, pe, Qn, k) || (m ? -.001 : 0),
                Eo(me) && (me = me(U)),
                pl(me) && !me.indexOf("+=") && (~me.indexOf(" ") ? me = (pl(ge) ? ge.split(" ")[0] : "") + me : (vn = dv(me.substr(2), $t),
                me = pl(ge) ? ge : be + vn,
                ze = p)),
                Ee = Math.max(be, wb(me || (ze ? "100% 0" : Qn), ze, $t, H, de() + vn, _t, ee, U, hn, z, pe, Qn, k)) || -.001,
                Ze = Ee - be || (be -= .01) && .001,
                vn = 0,
                Ft = Vt; Ft--; )
                    en = qn[Ft],
                    Zn = en.pin,
                    Zn && en.start - en._pinPush <= be && !k && en.end > 0 && (Gt = en.end - en.start,
                    (Zn === p && en.start - en._pinPush < be || Zn === Oe) && !Ep(ge) && (vn += Gt * (1 - en.progress)),
                    Zn === m && (j += Gt));
                if (be += vn,
                Ee += vn,
                U._pinPush = j,
                at && vn && (Gt = {},
                Gt[H.a] = "+=" + vn,
                Oe && (Gt[H.p] = "-=" + de()),
                fn.set([at, _t], Gt)),
                m)
                    Gt = wl(m),
                    tn = H === ms,
                    Sn = de(),
                    Ke = parseFloat(tt(H.a)) + j,
                    !Qn && Ee > 1 && (kt = (re ? Mi.scrollingElement || xl : te).style,
                    kt = {
                        style: kt,
                        value: kt["overflow" + H.a.toUpperCase()]
                    },
                    kt["overflow" + H.a.toUpperCase()] = "scroll"),
                    Bx(m, V, Gt),
                    Z = k0(m),
                    Yt = pu(m, !0),
                    Yn = pe && Rc(te, tn ? Co : ms)(),
                    _ && (Fe = [_ + H.os2, Ze + j + Ns],
                    Fe.t = V,
                    Ft = _ === Qi ? Iw(m, H) + Ze + j : 0,
                    Ft && Fe.push(H.d, Ft + Ns),
                    ah(Fe),
                    Oe && qn.forEach(function(Ur) {
                        Ur.pin === Oe && Ur.vars.pinSpacing !== !1 && (Ur._subPinOffset = !0)
                    }),
                    pe && de(vt)),
                    pe && (Xt = {
                        top: Yt.top + (tn ? Sn - be : Yn) + Ns,
                        left: Yt.left + (tn ? Yn : Sn - be) + Ns,
                        boxSizing: "border-box",
                        position: "fixed"
                    },
                    Xt[If] = Xt["max" + Ch] = Math.ceil(Yt.width) + Ns,
                    Xt[Lf] = Xt["max" + LM] = Math.ceil(Yt.height) + Ns,
                    Xt[Wa] = Xt[Wa + jp] = Xt[Wa + Xp] = Xt[Wa + Yp] = Xt[Wa + Jp] = "0",
                    Xt[Qi] = Gt[Qi],
                    Xt[Qi + jp] = Gt[Qi + jp],
                    Xt[Qi + Xp] = Gt[Qi + Xp],
                    Xt[Qi + Yp] = Gt[Qi + Yp],
                    Xt[Qi + Jp] = Gt[Qi + Jp],
                    Pt = fH(ft, Xt, P),
                    vl && de(0)),
                    i ? (es = i._initted,
                    bx(1),
                    i.render(i.duration(), !0, !0),
                    dt = tt(H.a) - Ke + Ze + j,
                    le = Math.abs(Ze - dt) > 1,
                    pe && le && Pt.splice(Pt.length - 2, 2),
                    i.render(0, !0, !0),
                    es || i.invalidate(!0),
                    i.parent || i.totalTime(i.totalTime()),
                    bx(0)) : dt = Ze,
                    kt && (kt.value ? kt.style["overflow" + H.a.toUpperCase()] = kt.value : kt.style.removeProperty("overflow-" + H.a));
                else if (p && de() && !k)
                    for (Yt = p.parentNode; Yt && Yt !== Wi; )
                        Yt._pinOffset && (be -= Yt._pinOffset,
                        Ee -= Yt._pinOffset),
                        Yt = Yt.parentNode;
                Nn && Nn.forEach(function(Ur) {
                    return Ur.revert(!1, !0)
                }),
                U.start = be,
                U.end = Ee,
                He = gt = vl ? vt : de(),
                !k && !vl && (He < vt && de(vt),
                U.scroll.rec = 0),
                U.revert(!1, !0),
                De && (Ue = -1,
                U.isActive && de(be + Ze * Je),
                De.restart(!0)),
                so = 0,
                i && W && (i._initted || Et) && i.progress() !== Et && i.progress(Et, !0).render(i.time(), !0, !0),
                (Je !== U.progress || k) && (i && !W && i.totalProgress(Je, !0),
                U.progress = (He - be) / Ze === Je ? 0 : Je),
                m && _ && (V._pinOffset = Math.round(U.progress * dt)),
                h && !vl && h(U)
            }
        }
        ,
        U.getVelocity = function() {
            return (de() - gt) / (Ao() - cv) * 1e3 || 0
        }
        ,
        U.endAnimation = function() {
            vp(U.callbackAnimation),
            i && (Mt ? Mt.progress(1) : i.paused() ? W || vp(i, U.direction < 0, 1) : vp(i, i.reversed()))
        }
        ,
        U.labelToScroll = function(ut) {
            return i && i.labels && (be || U.refresh() || be) + i.labels[ut] / i.duration() * Ze || 0
        }
        ,
        U.getTrailing = function(ut) {
            var Nt = qn.indexOf(U)
              , $t = U.direction > 0 ? qn.slice(0, Nt).reverse() : qn.slice(Nt + 1);
            return (pl(ut) ? $t.filter(function(hn) {
                return hn.vars.preventOverlaps === ut
            }) : $t).filter(function(hn) {
                return U.direction > 0 ? hn.end <= be : hn.start >= Ee
            })
        }
        ,
        U.update = function(ut, Nt, $t) {
            if (!(k && !$t && !ut)) {
                var hn = vl ? vt : U.scroll(), Qn = ut ? 0 : (hn - be) / Ze, vn = Qn < 0 ? 0 : Qn > 1 ? 1 : Qn || 0, j = U.progress, me, ze, ge, Oe, Vt, Ft, Gt, Yt;
                if (Nt && (gt = He,
                He = k ? de() : hn,
                T && (Ut = st,
                st = i && !W ? i.totalProgress() : vn)),
                x && !vn && m && !so && !D0 && qa && be < hn + (hn - gt) / (Ao() - cv) * x && (vn = 1e-4),
                vn !== j && U.enabled) {
                    if (me = U.isActive = !!vn && vn < 1,
                    ze = !!j && j < 1,
                    Ft = me !== ze,
                    Vt = Ft || !!vn != !!j,
                    U.direction = vn > j ? 1 : -1,
                    U.progress = vn,
                    Vt && !so && (ge = vn && !j ? 0 : vn === 1 ? 1 : j === 1 ? 2 : 3,
                    W && (Oe = !Ft && xe[ge + 1] !== "none" && xe[ge + 1] || xe[ge],
                    Yt = i && (Oe === "complete" || Oe === "reset" || Oe in i))),
                    O && (Ft || Yt) && (Yt || d || !i) && (Eo(O) ? O(U) : U.getTrailing(O).forEach(function(en) {
                        return en.endAnimation()
                    })),
                    W || (Mt && !so && !D0 ? (Mt._dp._time - Mt._start !== Mt._time && Mt.render(Mt._dp._time - Mt._start),
                    Mt.resetTo ? Mt.resetTo("totalProgress", vn, i._tTime / i._tDur) : (Mt.vars.totalProgress = vn,
                    Mt.invalidate().restart())) : i && i.totalProgress(vn, !!so)),
                    m) {
                        if (ut && _ && (V.style[_ + H.os2] = ct),
                        !pe)
                            Ve(Cp(Ke + dt * vn));
                        else if (Vt) {
                            if (Gt = !ut && vn > j && Ee + 1 > hn && hn + 1 >= dc(te, H),
                            P)
                                if (!ut && (me || Gt)) {
                                    var Sn = pu(m, !0)
                                      , tn = hn - be;
                                    Sb(m, Wi, Sn.top + (H === ms ? tn : 0) + Ns, Sn.left + (H === ms ? 0 : tn) + Ns)
                                } else
                                    Sb(m, V);
                            ah(me || Gt ? Pt : Z),
                            le && vn < 1 && me || Ve(Ke + (vn === 1 && !Gt ? dt : 0))
                        }
                    }
                    T && !qe.tween && !so && !D0 && De.restart(!0),
                    a && (Ft || w && vn && (vn < 1 || !Tx)) && qv(a.targets).forEach(function(en) {
                        return en.classList[me || w ? "add" : "remove"](a.className)
                    }),
                    o && !W && !ut && o(U),
                    Vt && !so ? (W && (Yt && (Oe === "complete" ? i.pause().totalProgress(1) : Oe === "reset" ? i.restart(!0).pause() : Oe === "restart" ? i.restart(!0) : i[Oe]()),
                    o && o(U)),
                    (Ft || !Tx) && (f && Ft && Px(U, f),
                    ce[ge] && Px(U, ce[ge]),
                    w && (vn === 1 ? U.kill(!1, 1) : ce[ge] = 0),
                    Ft || (ge = vn === 1 ? 1 : 3,
                    ce[ge] && Px(U, ce[ge]))),
                    R && !me && Math.abs(U.getVelocity()) > (Ep(R) ? R : 2500) && (vp(U.callbackAnimation),
                    Mt ? Mt.progress(1) : vp(i, Oe === "reverse" ? 1 : !vn, 1))) : W && o && !so && o(U)
                }
                if (Le) {
                    var Xt = k ? hn / k.duration() * (k._caScrollDist || 0) : hn;
                    Rt(Xt + (Ce._isFlipped ? 1 : 0)),
                    Le(Xt)
                }
                rn && rn(-hn / k.duration() * (k._caScrollDist || 0))
            }
        }
        ,
        U.enable = function(ut, Nt) {
            U.enabled || (U.enabled = !0,
            Gs(te, "resize", bp),
            Gs(re ? Mi : te, "scroll", bd),
            fe && Gs(n, "refreshInit", fe),
            ut !== !1 && (U.progress = Je = 0,
            He = gt = Ue = de()),
            Nt !== !1 && U.refresh())
        }
        ,
        U.getTween = function(ut) {
            return ut && qe ? qe.tween : Mt
        }
        ,
        U.setPositions = function(ut, Nt) {
            m && (Ke += ut - be,
            dt += Nt - ut - Ze,
            _ === Qi && U.adjustPinSpacing(Nt - ut - Ze)),
            U.start = be = ut,
            U.end = Ee = Nt,
            Ze = Nt - ut,
            U.update()
        }
        ,
        U.adjustPinSpacing = function(ut) {
            if (Fe) {
                var Nt = Fe.indexOf(H.d) + 1;
                Fe[Nt] = parseFloat(Fe[Nt]) + ut + Ns,
                Fe[1] = parseFloat(Fe[1]) + ut + Ns,
                ah(Fe)
            }
        }
        ,
        U.disable = function(ut, Nt) {
            if (U.enabled && (ut !== !1 && U.revert(!0, !0),
            U.enabled = U.isActive = !1,
            Nt || Mt && Mt.pause(),
            vt = 0,
            Ne && (Ne.uncache = 1),
            fe && Ds(n, "refreshInit", fe),
            De && (De.pause(),
            qe.tween && qe.tween.kill() && (qe.tween = 0)),
            !re)) {
                for (var $t = qn.length; $t--; )
                    if (qn[$t].scroller === te && qn[$t] !== U)
                        return;
                Ds(te, "resize", bp),
                Ds(te, "scroll", bd)
            }
        }
        ,
        U.kill = function(ut, Nt) {
            U.disable(ut, Nt),
            Mt && !Nt && Mt.kill(),
            l && delete Lw[l];
            var $t = qn.indexOf(U);
            $t >= 0 && qn.splice($t, 1),
            $t === Mo && pv > 0 && Mo--,
            $t = 0,
            qn.forEach(function(hn) {
                return hn.scroller === U.scroller && ($t = 1)
            }),
            $t || vl || (U.scroll.rec = 0),
            i && (i.scrollTrigger = null,
            ut && i.revert({
                kill: !1
            }),
            Nt || i.kill()),
            at && [at, _t, Ce, ee].forEach(function(hn) {
                return hn.parentNode && hn.parentNode.removeChild(hn)
            }),
            Kp === U && (Kp = 0),
            m && (Ne && (Ne.uncache = 1),
            $t = 0,
            qn.forEach(function(hn) {
                return hn.pin === m && $t++
            }),
            $t || (Ne.spacer = 0)),
            r.onKill && r.onKill(U)
        }
        ,
        U.enable(!1, !1),
        dn && dn(U),
        !i || !i.add || Ze ? U.refresh() : fn.delayedCall(.01, function() {
            return be || Ee || U.refresh()
        }) && (Ze = .01) && (be = Ee = 0),
        m && lH()
    }
    ,
    n.register = function(r) {
        return Pd || (fn = r || OP(),
        kP() && window.document && n.enable(),
        Pd = P0),
        Pd
    }
    ,
    n.defaults = function(r) {
        if (r)
            for (var i in r)
                L0[i] = r[i];
        return L0
    }
    ,
    n.disable = function(r, i) {
        P0 = 0,
        qn.forEach(function(o) {
            return o[i ? "kill" : "disable"](r)
        }),
        Ds(sr, "wheel", bd),
        Ds(Mi, "scroll", bd),
        clearInterval(T0),
        Ds(Mi, "touchcancel", Ul),
        Ds(Wi, "touchstart", Ul),
        B0(Ds, Mi, "pointerdown,touchstart,mousedown", pb),
        B0(Ds, Mi, "pointerup,touchend,mouseup", mb),
        Kv.kill(),
        R0(Ds);
        for (var s = 0; s < er.length; s += 3)
            I0(Ds, er[s], er[s + 1]),
            I0(Ds, er[s], er[s + 2])
    }
    ,
    n.enable = function() {
        if (sr = window,
        Mi = document,
        xl = Mi.documentElement,
        Wi = Mi.body,
        fn && (qv = fn.utils.toArray,
        Kd = fn.utils.clamp,
        Bw = fn.core.context || Ul,
        bx = fn.core.suppressOverwrites || Ul,
        RM = sr.history.scrollRestoration || "auto",
        fn.core.globals("ScrollTrigger", n),
        Wi)) {
            P0 = 1,
            ls.register(fn),
            n.isTouch = ls.isTouch,
            ec = ls.isTouch && /(iPad|iPhone|iPod|Mac)/g.test(navigator.userAgent),
            Gs(sr, "wheel", bd),
            PP = [sr, Mi, xl, Wi],
            fn.matchMedia ? (n.matchMedia = function(l) {
                var f = fn.matchMedia(), h;
                for (h in l)
                    f.add(h, l[h]);
                return f
            }
            ,
            fn.addEventListener("matchMediaInit", function() {
                return kM()
            }),
            fn.addEventListener("matchMediaRevert", function() {
                return VP()
            }),
            fn.addEventListener("matchMedia", function() {
                Af(0, 1),
                Yf("matchMedia")
            }),
            fn.matchMedia("(orientation: portrait)", function() {
                return Rx(),
                Rx
            })) : console.warn("Requires GSAP 3.11.0 or later"),
            Rx(),
            Gs(Mi, "scroll", bd);
            var r = Wi.style, i = r.borderTopStyle, s = fn.core.Animation.prototype, o, a;
            for (s.revert || Object.defineProperty(s, "revert", {
                value: function() {
                    return this.time(-.01, !0)
                }
            }),
            r.borderTopStyle = "solid",
            o = pu(Wi),
            ms.m = Math.round(o.top + ms.sc()) || 0,
            Co.m = Math.round(o.left + Co.sc()) || 0,
            i ? r.borderTopStyle = i : r.removeProperty("border-top-style"),
            T0 = setInterval(_b, 250),
            fn.delayedCall(.5, function() {
                return D0 = 0
            }),
            Gs(Mi, "touchcancel", Ul),
            Gs(Wi, "touchstart", Ul),
            B0(Gs, Mi, "pointerdown,touchstart,mousedown", pb),
            B0(Gs, Mi, "pointerup,touchend,mouseup", mb),
            Rw = fn.utils.checkPrefix("transform"),
            mv.push(Rw),
            Pd = Ao(),
            Kv = fn.delayedCall(.2, Af).pause(),
            Rd = [Mi, "visibilitychange", function() {
                var l = sr.innerWidth
                  , f = sr.innerHeight;
                Mi.hidden ? (db = l,
                hb = f) : (db !== l || hb !== f) && bp()
            }
            , Mi, "DOMContentLoaded", Af, sr, "load", Af, sr, "resize", bp],
            R0(Gs),
            qn.forEach(function(l) {
                return l.enable(0, 1)
            }),
            a = 0; a < er.length; a += 3)
                I0(Ds, er[a], er[a + 1]),
                I0(Ds, er[a], er[a + 2])
        }
    }
    ,
    n.config = function(r) {
        "limitCallbacks"in r && (Tx = !!r.limitCallbacks);
        var i = r.syncInterval;
        i && clearInterval(T0) || (T0 = i) && setInterval(_b, i),
        "ignoreMobileResize"in r && (IP = n.isTouch === 1 && r.ignoreMobileResize),
        "autoRefreshEvents"in r && (R0(Ds) || R0(Gs, r.autoRefreshEvents || "none"),
        BP = (r.autoRefreshEvents + "").indexOf("resize") === -1)
    }
    ,
    n.scrollerProxy = function(r, i) {
        var s = Yo(r)
          , o = er.indexOf(s)
          , a = Jf(s);
        ~o && er.splice(o, a ? 6 : 2),
        i && (a ? Yl.unshift(sr, i, Wi, i, xl, i) : Yl.unshift(s, i))
    }
    ,
    n.clearMatchMedia = function(r) {
        qn.forEach(function(i) {
            return i._ctx && i._ctx.query === r && i._ctx.kill(!0, !0)
        })
    }
    ,
    n.isInViewport = function(r, i, s) {
        var o = (pl(r) ? Yo(r) : r).getBoundingClientRect()
          , a = o[s ? If : Lf] * i || 0;
        return s ? o.right - a > 0 && o.left + a < sr.innerWidth : o.bottom - a > 0 && o.top + a < sr.innerHeight
    }
    ,
    n.positionInViewport = function(r, i, s) {
        pl(r) && (r = Yo(r));
        var o = r.getBoundingClientRect()
          , a = o[s ? If : Lf]
          , l = i == null ? a / 2 : i in Qv ? Qv[i] * a : ~i.indexOf("%") ? parseFloat(i) * a / 100 : parseFloat(i) || 0;
        return s ? (o.left + l) / sr.innerWidth : (o.top + l) / sr.innerHeight
    }
    ,
    n.killAll = function(r) {
        if (qn.slice(0).forEach(function(s) {
            return s.vars.id !== "ScrollSmoother" && s.kill()
        }),
        r !== !0) {
            var i = jf.killAll || [];
            jf = {},
            i.forEach(function(s) {
                return s()
            })
        }
    }
    ,
    n
}();
kn.version = "3.11.4";
kn.saveStyles = function(n) {
    return n ? qv(n).forEach(function(e) {
        if (e && e.style) {
            var t = da.indexOf(e);
            t >= 0 && da.splice(t, 5),
            da.push(e, e.style.cssText, e.getBBox && e.getAttribute("transform"), fn.core.getCache(e), Bw())
        }
    }) : da
}
;
kn.revert = function(n, e) {
    return kM(!n, e)
}
;
kn.create = function(n, e) {
    return new kn(n,e)
}
;
kn.refresh = function(n) {
    return n ? bp() : (Pd || kn.register()) && Af(!0)
}
;
kn.update = function(n) {
    return ++er.cache && Bc(n === !0 ? 2 : 0)
}
;
kn.clearScrollMemory = WP;
kn.maxScroll = function(n, e) {
    return dc(n, e ? Co : ms)
}
;
kn.getScrollFunc = function(n, e) {
    return Rc(Yo(n), e ? Co : ms)
}
;
kn.getById = function(n) {
    return Lw[n]
}
;
kn.getAll = function() {
    return qn.filter(function(n) {
        return n.vars.id !== "ScrollSmoother"
    })
}
;
kn.isScrolling = function() {
    return !!qa
}
;
kn.snapDirectional = FM;
kn.addEventListener = function(n, e) {
    var t = jf[n] || (jf[n] = []);
    ~t.indexOf(e) || t.push(e)
}
;
kn.removeEventListener = function(n, e) {
    var t = jf[n]
      , r = t && t.indexOf(e);
    r >= 0 && t.splice(r, 1)
}
;
kn.batch = function(n, e) {
    var t = [], r = {}, i = e.interval || .016, s = e.batchMax || 1e9, o = function(f, h) {
        var d = []
          , p = []
          , m = fn.delayedCall(i, function() {
            h(d, p),
            d = [],
            p = []
        }).pause();
        return function(_) {
            d.length || m.restart(!0),
            d.push(_.trigger),
            p.push(_),
            s <= d.length && m.progress(1)
        }
    }, a;
    for (a in e)
        r[a] = a.substr(0, 2) === "on" && Eo(e[a]) && a !== "onRefreshInit" ? o(a, e[a]) : e[a];
    return Eo(s) && (s = s(),
    Gs(kn, "refresh", function() {
        return s = e.batchMax()
    })),
    qv(n).forEach(function(l) {
        var f = {};
        for (a in r)
            f[a] = r[a];
        f.trigger = l,
        t.push(kn.create(f))
    }),
    t
}
;
var Ab = function(e, t, r, i) {
    return t > i ? e(i) : t < 0 && e(0),
    r > i ? (i - t) / (r - t) : r < 0 ? t / (t - r) : 1
}, Ix = function n(e, t) {
    t === !0 ? e.style.removeProperty("touch-action") : e.style.touchAction = t === !0 ? "auto" : t ? "pan-" + t + (ls.isTouch ? " pinch-zoom" : "") : "none",
    e === xl && n(Wi, t)
}, O0 = {
    auto: 1,
    scroll: 1
}, hH = function(e) {
    var t = e.event, r = e.target, i = e.axis, s = (t.changedTouches ? t.changedTouches[0] : t).target, o = s._gsap || fn.core.getCache(s), a = Ao(), l;
    if (!o._isScrollT || a - o._isScrollT > 2e3) {
        for (; s && s !== Wi && (s.scrollHeight <= s.clientHeight && s.scrollWidth <= s.clientWidth || !(O0[(l = wl(s)).overflowY] || O0[l.overflowX])); )
            s = s.parentNode;
        o._isScroll = s && s !== r && !Jf(s) && (O0[(l = wl(s)).overflowY] || O0[l.overflowX]),
        o._isScrollT = a
    }
    (o._isScroll || i === "x") && (t.stopPropagation(),
    t._gsapAllow = !0)
}, XP = function(e, t, r, i) {
    return ls.create({
        target: e,
        capture: !0,
        debounce: !1,
        lockAxis: !0,
        type: t,
        onWheel: i = i && hH,
        onPress: i,
        onDrag: i,
        onScroll: i,
        onEnable: function() {
            return r && Gs(Mi, ls.eventTypes[0], Eb, !1, !0)
        },
        onDisable: function() {
            return Ds(Mi, ls.eventTypes[0], Eb, !0)
        }
    })
}, pH = /(input|label|select|textarea)/i, Cb, Eb = function(e) {
    var t = pH.test(e.target.tagName);
    (t || Cb) && (e._gsapAllow = !0,
    Cb = t)
}, mH = function(e) {
    fv(e) || (e = {}),
    e.preventDefault = e.isNormalizer = e.allowClicks = !0,
    e.type || (e.type = "wheel,touch"),
    e.debounce = !!e.debounce,
    e.id = e.id || "normalizer";
    var t = e, r = t.normalizeScrollX, i = t.momentum, s = t.allowNestedScroll, o, a, l = Yo(e.target) || xl, f = fn.core.globals().ScrollSmoother, h = f && f.get(), d = ec && (e.content && Yo(e.content) || h && e.content !== !1 && !h.smooth() && h.content()), p = Rc(l, ms), m = Rc(l, Co), _ = 1, y = (ls.isTouch && sr.visualViewport ? sr.visualViewport.scale * sr.visualViewport.width : sr.outerWidth) / sr.innerWidth, x = 0, S = Eo(i) ? function() {
        return i(o)
    }
    : function() {
        return i || 2.8
    }
    , M, w, T = XP(l, e.type, !0, s), P = function() {
        return w = !1
    }, I = Ul, k = Ul, R = function() {
        a = dc(l, ms),
        k = Kd(ec ? 1 : 0, a),
        r && (I = Kd(0, dc(l, Co))),
        M = Ff
    }, O = function() {
        d._gsap.y = Cp(parseFloat(d._gsap.y) + p.offset) + "px",
        d.style.transform = "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " + parseFloat(d._gsap.y) + ", 0, 1)",
        p.offset = p.cacheID = 0
    }, H = function() {
        if (w) {
            requestAnimationFrame(P);
            var xe = Cp(o.deltaY / 2)
              , G = k(p.v - xe);
            if (d && G !== p.v + p.offset) {
                p.offset = G - p.v;
                var z = Cp((parseFloat(d && d._gsap.y) || 0) - p.offset);
                d.style.transform = "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " + z + ", 0, 1)",
                d._gsap.y = z + "px",
                p.cacheID = er.cache,
                Bc()
            }
            return !0
        }
        p.offset && O(),
        w = !0
    }, W, te, ne, re, pe = function() {
        R(),
        W.isActive() && W.vars.scrollY > a && (p() > a ? W.progress(1) && p(a) : W.resetTo("scrollY", a))
    };
    return d && fn.set(d, {
        y: "+=0"
    }),
    e.ignoreCheck = function(ce) {
        return ec && ce.type === "touchmove" && H() || _ > 1.05 && ce.type !== "touchstart" || o.isGesturing || ce.touches && ce.touches.length > 1
    }
    ,
    e.onPress = function() {
        var ce = _;
        _ = Cp((sr.visualViewport && sr.visualViewport.scale || 1) / y),
        W.pause(),
        ce !== _ && Ix(l, _ > 1.01 ? !0 : r ? !1 : "x"),
        te = m(),
        ne = p(),
        R(),
        M = Ff
    }
    ,
    e.onRelease = e.onGestureStart = function(ce, xe) {
        if (p.offset && O(),
        !xe)
            re.restart(!0);
        else {
            er.cache++;
            var G = S(), z, U;
            r && (z = m(),
            U = z + G * .05 * -ce.velocityX / .227,
            G *= Ab(m, z, U, dc(l, Co)),
            W.vars.scrollX = I(U)),
            z = p(),
            U = z + G * .05 * -ce.velocityY / .227,
            G *= Ab(p, z, U, dc(l, ms)),
            W.vars.scrollY = k(U),
            W.invalidate().duration(G).play(.01),
            (ec && W.vars.scrollY >= a || z >= a - 1) && fn.to({}, {
                onUpdate: pe,
                duration: G
            })
        }
    }
    ,
    e.onWheel = function() {
        W._ts && W.pause(),
        Ao() - x > 1e3 && (M = 0,
        x = Ao())
    }
    ,
    e.onChange = function(ce, xe, G, z, U) {
        if (Ff !== M && R(),
        xe && r && m(I(z[2] === xe ? te + (ce.startX - ce.x) : m() + xe - z[1])),
        G) {
            p.offset && O();
            var fe = U[2] === G
              , oe = fe ? ne + ce.startY - ce.y : p() + G - U[1]
              , Ae = k(oe);
            fe && oe !== Ae && (ne += Ae - oe),
            p(Ae)
        }
        (G || xe) && Bc()
    }
    ,
    e.onEnable = function() {
        Ix(l, r ? !1 : "x"),
        kn.addEventListener("refresh", pe),
        Gs(sr, "resize", pe),
        p.smooth && (p.target.style.scrollBehavior = "auto",
        p.smooth = m.smooth = !1),
        T.enable()
    }
    ,
    e.onDisable = function() {
        Ix(l, !0),
        Ds(sr, "resize", pe),
        kn.removeEventListener("refresh", pe),
        T.kill()
    }
    ,
    e.lockAxis = e.lockAxis !== !1,
    o = new ls(e),
    o.iOS = ec,
    ec && !p() && p(1),
    ec && fn.ticker.add(Ul),
    re = o._dc,
    W = fn.to(o, {
        ease: "power4",
        paused: !0,
        scrollX: r ? "+=0.1" : "+=0",
        scrollY: "+=0.1",
        onComplete: re.vars.onComplete
    }),
    o
};
kn.sort = function(n) {
    return qn.sort(n || function(e, t) {
        return (e.vars.refreshPriority || 0) * -1e6 + e.start - (t.start + (t.vars.refreshPriority || 0) * -1e6)
    }
    )
}
;
kn.observe = function(n) {
    return new ls(n)
}
;
kn.normalizeScroll = function(n) {
    if (typeof n > "u")
        return fa;
    if (n === !0 && fa)
        return fa.enable();
    if (n === !1)
        return fa && fa.kill();
    var e = n instanceof ls ? n : mH(n);
    return fa && fa.target === e.target && fa.kill(),
    Jf(e.target) && (fa = e),
    e
}
;
kn.core = {
    _getVelocityProp: Pw,
    _inputObserver: XP,
    _scrollers: er,
    _proxies: Yl,
    bridge: {
        ss: function() {
            qa || Yf("scrollStart"),
            qa = Ao()
        },
        ref: function() {
            return so
        }
    }
};
OP() && fn.registerPlugin(kn);
function bb(n, e) {
    for (var t = 0; t < e.length; t++) {
        var r = e[t];
        r.enumerable = r.enumerable || !1,
        r.configurable = !0,
        "value"in r && (r.writable = !0),
        Object.defineProperty(n, r.key, r)
    }
}
function gH(n, e, t) {
    return e && bb(n.prototype, e),
    t && bb(n, t),
    n
}
/*!
 * ScrollSmoother 3.11.4
 * https://greensock.com
 *
 * @license Copyright 2008-2022, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/
var Tr, N0, io, qd, Tp, Nl, hf, Tb, $n, Hl, z0, Db, Pb, Rb, Bb, JP = function() {
    return typeof window < "u"
}, jP = function() {
    return Tr || JP() && (Tr = window.gsap) && Tr.registerPlugin && Tr
}, vH = function(e) {
    return Math.round(e * 1e5) / 1e5 || 0
}, _H = function(e, t) {
    var r = e.parentNode || Tp, i = e.getBoundingClientRect(), s = r.getBoundingClientRect(), o = s.top - i.top, a = s.bottom - i.bottom, l = (Math.abs(o) > Math.abs(a) ? o : a) / (1 - t), f = -l * t, h, d;
    return l > 0 && (h = s.height / (io.innerHeight + s.height),
    d = h === .5 ? s.height * 2 : Math.min(s.height, -l * h / (2 * h - 1)) * 2 * (t || 1),
    f += t ? -d * t : -d / 2,
    l += d),
    {
        change: l,
        offset: f
    }
}, yH = function(e) {
    var t = qd.querySelector(".ScrollSmoother-wrapper");
    return t || (t = qd.createElement("div"),
    t.classList.add("ScrollSmoother-wrapper"),
    e.parentNode.insertBefore(t, e),
    t.appendChild(e)),
    t
}, Kf = function() {
    function n(e) {
        var t = this;
        N0 || n.register(Tr) || console.warn("Please gsap.registerPlugin(ScrollSmoother)"),
        e = this.vars = e || {},
        Hl && Hl.kill(),
        Hl = this,
        Rb(this);
        var r = e, i = r.smoothTouch, s = r.onUpdate, o = r.onStop, a = r.smooth, l = r.onFocusIn, f = r.normalizeScroll, h = r.wholePixels, d, p, m, _, y, x, S, M, w, T, P, I, k, R = this, O = typeof ResizeObserver < "u" && e.autoResize !== !1 && new ResizeObserver(function() {
            return $n.isRefreshing || Bb.restart(!0)
        }
        ), H = e.effectsPrefix || "", W = $n.getScrollFunc(io), te = $n.isTouch === 1 ? i === !0 ? .8 : parseFloat(i) || 0 : a === 0 || a === !1 ? 0 : parseFloat(a) || .8, ne = te && +e.speed || 1, re = 0, pe = 0, ce = 1, xe = Db(0), G = function() {
            return xe.update(-re)
        }, z = {
            y: 0
        }, U = function() {
            return d.style.overflow = "visible"
        }, fe, oe = function(ee) {
            ee.update();
            var et = ee.getTween();
            et && (et.pause(),
            et._time = et._dur,
            et._tTime = et._tDur),
            fe = !1,
            ee.animation.progress(ee.progress, !0)
        }, Ae = function(ee, et) {
            (ee !== re && !T || et) && (h && (ee = Math.round(ee)),
            te && (d.style.transform = "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " + ee + ", 0, 1)",
            d._gsap.y = ee + "px"),
            pe = ee - re,
            re = ee,
            $n.isUpdating || $n.update())
        }, Ue = function(ee) {
            return arguments.length ? (ee < 0 && (ee = 0),
            z.y = -ee,
            fe = !0,
            T ? re = -ee : Ae(-ee),
            $n.isRefreshing ? _.update() : W(ee),
            this) : -re
        }, je, de = function(ee) {
            p.scrollTop = 0,
            !(ee.target.contains && ee.target.contains(p) || l && l(t, ee) === !1) && ($n.isInViewport(ee.target) || ee.target === je || t.scrollTo(ee.target, !1, "center center"),
            je = ee.target)
        }, qe = function(ee, et) {
            var Ze, ft, Pt, Z;
            y.forEach(function(V) {
                Ze = V.pins,
                Z = V.markers,
                ee.forEach(function(ye) {
                    V.trigger && ye.trigger && V !== ye && (ye.trigger === V.trigger || ye.pinnedContainer === V.trigger || V.trigger.contains(ye.trigger)) && (ft = ye.start,
                    Pt = (ft - V.start - V.offset) / V.ratio - (ft - V.start),
                    Ze.forEach(function(tt) {
                        return Pt -= tt.distance / V.ratio - tt.distance
                    }),
                    ye.setPositions(ft + Pt, ye.end + Pt),
                    ye.markerStart && Z.push(Tr.quickSetter([ye.markerStart, ye.markerEnd], "y", "px")),
                    ye.pin && ye.end > 0 && (Pt = ye.end - ye.start,
                    Ze.push({
                        start: ye.start,
                        end: ye.end,
                        distance: Pt,
                        trig: ye
                    }),
                    V.setPositions(V.start, V.end + Pt),
                    V.vars.onRefresh(V)))
                })
            })
        }, Ne = function() {
            U(),
            requestAnimationFrame(U),
            y && (y.forEach(function(ee) {
                var et = ee.start
                  , Ze = ee.auto ? Math.min($n.maxScroll(ee.scroller), ee.end) : et + (ee.end - et) / ee.ratio
                  , ft = (Ze - ee.end) / 2;
                et -= ft,
                Ze -= ft,
                ee.offset = ft || 1e-4,
                ee.pins.length = 0,
                ee.setPositions(Math.min(et, Ze), Math.max(et, Ze)),
                ee.vars.onRefresh(ee)
            }),
            qe($n.sort())),
            xe.reset()
        }, Tt = function() {
            return $n.addEventListener("refresh", Ne)
        }, He = function() {
            return y && y.forEach(function(ee) {
                return ee.vars.onRefresh(ee)
            })
        }, gt = function() {
            return y && y.forEach(function(ee) {
                return ee.vars.onRefreshInit(ee)
            }),
            He
        }, be = function(ee, et, Ze, ft) {
            return function() {
                var Pt = typeof et == "function" ? et(Ze, ft) : et;
                return Pt || Pt === 0 || (Pt = ft.getAttribute("data-" + H + ee) || (ee === "speed" ? 1 : 0)),
                ft.setAttribute("data-" + H + ee, Pt),
                Pt === "auto" ? Pt : parseFloat(Pt)
            }
        }, Ee = function(ee, et, Ze, ft, Pt) {
            Pt = (typeof Pt == "function" ? Pt(ft, ee) : Pt) || 0;
            var Z = be("speed", et, ft, ee), V = be("lag", Ze, ft, ee), ye = Tr.getProperty(ee, "y"), tt = ee._gsap, Ve, Ke, dt, ct, Fe, Rt, le = function() {
                et = Z(),
                Ze = V(),
                Ve = parseFloat(et) || 1,
                dt = et === "auto",
                Fe = dt ? 0 : .5,
                ct && ct.kill(),
                ct = Ze && Tr.to(ee, {
                    ease: z0,
                    overwrite: !1,
                    y: "+=0",
                    duration: Ze
                }),
                Ke && (Ke.ratio = Ve,
                Ke.autoSpeed = dt)
            }, Le = function() {
                tt.y = ye + "px",
                tt.renderTransform(1),
                le()
            }, rt = [], st = [], Ut = 0, Mt = function(ae) {
                if (dt) {
                    Le();
                    var De = _H(ee, Tb(0, 1, -ae.start / (ae.end - ae.start)));
                    Ut = De.change,
                    Rt = De.offset
                } else
                    Ut = (ae.end - ae.start) * (1 - Ve),
                    Rt = 0;
                rt.forEach(function(Je) {
                    return Ut -= Je.distance * (1 - Ve)
                }),
                ae.vars.onUpdate(ae),
                ct && ct.progress(1)
            };
            return le(),
            (Ve !== 1 || dt || ct) && (Ke = $n.create({
                trigger: dt ? ee.parentNode : ee,
                start: "top bottom+=" + Pt,
                end: "bottom top-=" + Pt,
                scroller: p,
                scrub: !0,
                refreshPriority: -999,
                onRefreshInit: Le,
                onRefresh: Mt,
                onKill: function(ae) {
                    var De = y.indexOf(ae);
                    De >= 0 && y.splice(De, 1),
                    Le()
                },
                onUpdate: function(ae) {
                    var De = ye + Ut * (ae.progress - Fe), Je = rt.length, vt = 0, Et, rn, dn;
                    if (ae.offset) {
                        if (Je) {
                            for (rn = -re,
                            dn = ae.end; Je--; ) {
                                if (Et = rt[Je],
                                Et.trig.isActive || rn >= Et.start && rn <= Et.end) {
                                    ct && (Et.trig.progress += Et.trig.direction < 0 ? .001 : -.001,
                                    Et.trig.update(0, 0, 1),
                                    ct.resetTo("y", parseFloat(tt.y), -pe, !0),
                                    ce && ct.progress(1));
                                    return
                                }
                                rn > Et.end && (vt += Et.distance),
                                dn -= Et.distance
                            }
                            De = ye + vt + Ut * ((Tr.utils.clamp(ae.start, ae.end, rn) - ae.start - vt) / (dn - ae.start) - Fe)
                        }
                        De = vH(De + Rt),
                        st.length && !dt && st.forEach(function(or) {
                            return or(De - vt)
                        }),
                        ct ? (ct.resetTo("y", De, -pe, !0),
                        ce && ct.progress(1)) : (tt.y = De + "px",
                        tt.renderTransform(1))
                    }
                }
            }),
            Mt(Ke),
            Tr.core.getCache(Ke.trigger).stRevert = gt,
            Ke.startY = ye,
            Ke.pins = rt,
            Ke.markers = st,
            Ke.ratio = Ve,
            Ke.autoSpeed = dt,
            ee.style.willChange = "transform"),
            Ke
        };
        Tt(),
        $n.addEventListener("killAll", Tt),
        Tr.delayedCall(.5, function() {
            return ce = 0
        }),
        this.scrollTop = Ue,
        this.scrollTo = function(Ce, ee, et) {
            var Ze = Tr.utils.clamp(0, $n.maxScroll(io), isNaN(Ce) ? t.offset(Ce, et) : +Ce);
            ee ? T ? Tr.to(t, {
                duration: te,
                scrollTop: Ze,
                overwrite: "auto",
                ease: z0
            }) : W(Ze) : Ue(Ze)
        }
        ,
        this.offset = function(Ce, ee) {
            Ce = hf(Ce)[0];
            var et = Ce.style.cssText, Ze = $n.create({
                trigger: Ce,
                start: ee || "top top"
            }), ft;
            return y && qe([Ze]),
            ft = Ze.start,
            Ze.kill(!1),
            Ce.style.cssText = et,
            Tr.core.getCache(Ce).uncache = 1,
            ft
        }
        ;
        function at() {
            return m = d.clientHeight,
            d.style.overflow = "visible",
            Nl.style.height = io.innerHeight + (m - io.innerHeight) / ne + "px",
            m - io.innerHeight
        }
        this.content = function(Ce) {
            if (arguments.length) {
                var ee = hf(Ce || "#smooth-content")[0] || console.warn("ScrollSmoother needs a valid content element.") || Nl.children[0];
                return ee !== d && (d = ee,
                w = d.getAttribute("style") || "",
                O && O.observe(d),
                Tr.set(d, {
                    overflow: "visible",
                    width: "100%",
                    boxSizing: "border-box",
                    y: "+=0"
                }),
                te || Tr.set(d, {
                    clearProps: "transform"
                })),
                this
            }
            return d
        }
        ,
        this.wrapper = function(Ce) {
            return arguments.length ? (p = hf(Ce || "#smooth-wrapper")[0] || yH(d),
            M = p.getAttribute("style") || "",
            at(),
            Tr.set(p, te ? {
                overflow: "hidden",
                position: "fixed",
                height: "100%",
                width: "100%",
                top: 0,
                left: 0,
                right: 0,
                bottom: 0
            } : {
                overflow: "visible",
                position: "relative",
                width: "100%",
                height: "auto",
                top: "auto",
                bottom: "auto",
                left: "auto",
                right: "auto"
            }),
            this) : p
        }
        ,
        this.effects = function(Ce, ee) {
            var et;
            if (y || (y = []),
            !Ce)
                return y.slice(0);
            Ce = hf(Ce),
            Ce.forEach(function(Ve) {
                for (var Ke = y.length; Ke--; )
                    y[Ke].trigger === Ve && y[Ke].kill()
            }),
            ee = ee || {};
            var Ze = ee, ft = Ze.speed, Pt = Ze.lag, Z = Ze.effectsPadding, V = [], ye, tt;
            for (ye = 0; ye < Ce.length; ye++)
                tt = Ee(Ce[ye], ft, Pt, ye, Z),
                tt && V.push(tt);
            return (et = y).push.apply(et, V),
            V
        }
        ,
        this.sections = function(Ce, ee) {
            var et;
            if (x || (x = []),
            !Ce)
                return x.slice(0);
            var Ze = hf(Ce).map(function(ft) {
                return $n.create({
                    trigger: ft,
                    start: "top 120%",
                    end: "bottom -20%",
                    onToggle: function(Z) {
                        ft.style.opacity = Z.isActive ? "1" : "0",
                        ft.style.pointerEvents = Z.isActive ? "all" : "none"
                    }
                })
            });
            return ee && ee.add ? (et = x).push.apply(et, Ze) : x = Ze.slice(0),
            Ze
        }
        ,
        this.content(e.content),
        this.wrapper(e.wrapper),
        this.render = function(Ce) {
            return Ae(Ce || Ce === 0 ? Ce : re)
        }
        ,
        this.getVelocity = function() {
            return xe.getVelocity(-re)
        }
        ,
        $n.scrollerProxy(p, {
            scrollTop: Ue,
            scrollHeight: function() {
                return at() && Nl.scrollHeight
            },
            fixedMarkers: e.fixedMarkers !== !1 && !!te,
            content: d,
            getBoundingClientRect: function() {
                return {
                    top: 0,
                    left: 0,
                    width: io.innerWidth,
                    height: io.innerHeight
                }
            }
        }),
        $n.defaults({
            scroller: p
        });
        var _t = $n.getAll().filter(function(Ce) {
            return Ce.scroller === io || Ce.scroller === p
        });
        _t.forEach(function(Ce) {
            return Ce.revert(!0, !0)
        }),
        _ = $n.create({
            animation: Tr.fromTo(z, {
                y: 0
            }, {
                y: function() {
                    return -at()
                },
                immediateRender: !1,
                ease: "none",
                data: "ScrollSmoother",
                duration: 100,
                onUpdate: function() {
                    if (this._dur) {
                        var ee = fe;
                        ee && (oe(_),
                        z.y = re),
                        Ae(z.y, ee),
                        G(),
                        s && !T && s(R)
                    }
                }
            }),
            onRefreshInit: function(ee) {
                if (y) {
                    var et = $n.getAll().filter(function(ft) {
                        return !!ft.pin
                    });
                    y.forEach(function(ft) {
                        ft.vars.pinnedContainer || et.forEach(function(Pt) {
                            if (Pt.pin.contains(ft.trigger)) {
                                var Z = ft.vars;
                                Z.pinnedContainer = Pt.pin,
                                ft.vars = null,
                                ft.init(Z, ft.animation)
                            }
                        })
                    })
                }
                var Ze = ee.getTween();
                k = Ze && Ze._end > Ze._dp._time,
                I = re,
                z.y = 0,
                te && (p.style.pointerEvents = "none",
                p.scrollTop = 0,
                setTimeout(function() {
                    return p.style.removeProperty("pointer-events")
                }, 50))
            },
            onRefresh: function(ee) {
                ee.animation.invalidate(),
                ee.setPositions(ee.start, at() / ne),
                k || oe(ee),
                z.y = -W(),
                Ae(z.y),
                ce || ee.animation.progress(Tr.utils.clamp(0, 1, I / -ee.end)),
                k && (ee.progress -= .001,
                ee.update())
            },
            id: "ScrollSmoother",
            scroller: io,
            invalidateOnRefresh: !0,
            start: 0,
            refreshPriority: -9999,
            end: function() {
                return at() / ne
            },
            onScrubComplete: function() {
                xe.reset(),
                o && o(t)
            },
            scrub: te || !0
        }),
        this.smooth = function(Ce) {
            return arguments.length && (te = Ce || 0,
            ne = te && +e.speed || 1,
            _.scrubDuration(Ce)),
            _.getTween() ? _.getTween().duration() : 0
        }
        ,
        _.getTween() && (_.getTween().vars.ease = e.ease || z0),
        this.scrollTrigger = _,
        e.effects && this.effects(e.effects === !0 ? "[data-" + H + "speed], [data-" + H + "lag]" : e.effects, {
            effectsPadding: e.effectsPadding
        }),
        e.sections && this.sections(e.sections === !0 ? "[data-section]" : e.sections),
        _t.forEach(function(Ce) {
            Ce.vars.scroller = p,
            Ce.revert(!1, !0),
            Ce.init(Ce.vars, Ce.animation)
        }),
        this.paused = function(Ce, ee) {
            return arguments.length ? (!!T !== Ce && (Ce ? (_.getTween() && _.getTween().pause(),
            W(-re),
            xe.reset(),
            P = $n.normalizeScroll(),
            P && P.disable(),
            T = $n.observe({
                preventDefault: !0,
                type: "wheel,touch,scroll",
                debounce: !1,
                allowClicks: !0,
                onChangeY: function() {
                    return Ue(-re)
                }
            }),
            T.nested = Pb(Tp, "wheel,touch,scroll", !0, ee !== !1)) : (T.nested.kill(),
            T.kill(),
            T = 0,
            P && P.enable(),
            _.progress = (-re - _.start) / (_.end - _.start),
            oe(_))),
            this) : !!T
        }
        ,
        this.kill = this.revert = function() {
            t.paused(!1),
            oe(_),
            _.kill();
            for (var Ce = (y || []).concat(x || []), ee = Ce.length; ee--; )
                Ce[ee].kill();
            $n.scrollerProxy(p),
            $n.removeEventListener("killAll", Tt),
            $n.removeEventListener("refresh", Ne),
            p.style.cssText = M,
            d.style.cssText = w;
            var et = $n.defaults({});
            et && et.scroller === p && $n.defaults({
                scroller: io
            }),
            t.normalizer && $n.normalizeScroll(!1),
            clearInterval(S),
            Hl = null,
            O && O.disconnect(),
            Nl.style.removeProperty("height"),
            io.removeEventListener("focusin", de)
        }
        ,
        this.refresh = function(Ce, ee) {
            return _.refresh(Ce, ee)
        }
        ,
        f && (this.normalizer = $n.normalizeScroll(f === !0 ? {
            debounce: !0,
            content: !te && d
        } : f)),
        $n.config(e),
        "overscrollBehavior"in io.getComputedStyle(Nl) && Tr.set([Nl, Tp], {
            overscrollBehavior: "none"
        }),
        "scrollBehavior"in io.getComputedStyle(Nl) && Tr.set([Nl, Tp], {
            scrollBehavior: "auto"
        }),
        io.addEventListener("focusin", de),
        S = setInterval(G, 250),
        qd.readyState === "loading" || requestAnimationFrame(function() {
            return $n.refresh()
        })
    }
    return n.register = function(t) {
        return N0 || (Tr = t || jP(),
        JP() && window.document && (io = window,
        qd = document,
        Tp = qd.documentElement,
        Nl = qd.body),
        Tr && (hf = Tr.utils.toArray,
        Tb = Tr.utils.clamp,
        z0 = Tr.parseEase("expo"),
        Rb = Tr.core.context || function() {}
        ,
        Bb = Tr.delayedCall(.2, function() {
            return $n.isRefreshing || Hl && Hl.refresh()
        }).pause(),
        $n = Tr.core.globals().ScrollTrigger,
        Tr.core.globals("ScrollSmoother", n),
        Nl && $n && (Db = $n.core._getVelocityProp,
        Pb = $n.core._inputObserver,
        n.refresh = $n.refresh,
        N0 = 1))),
        N0
    }
    ,
    gH(n, [{
        key: "progress",
        get: function() {
            return this.scrollTrigger ? this.scrollTrigger.animation._time / 100 : 0
        }
    }]),
    n
}();
Kf.version = "3.11.4";
Kf.create = function(n) {
    return Hl && n && Hl.content() === hf(n.content)[0] ? Hl : new Kf(n)
}
;
Kf.get = function() {
    return Hl
}
;
jP() && Tr.registerPlugin(Kf);
/*!
 * strings: 3.11.4
 * https://greensock.com
 *
 * Copyright 2008-2022, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/
var xH = /([\uD800-\uDBFF][\uDC00-\uDFFF](?:[\u200D\uFE0F][\uD800-\uDBFF][\uDC00-\uDFFF]){2,}|\uD83D\uDC69(?:\u200D(?:(?:\uD83D\uDC69\u200D)?\uD83D\uDC67|(?:\uD83D\uDC69\u200D)?\uD83D\uDC66)|\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC69\u200D(?:\uD83D\uDC69\u200D)?\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D(?:\uD83D\uDC69\u200D)?\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]\uFE0F|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC6F\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3C-\uDD3E\uDDD6-\uDDDF])\u200D[\u2640\u2642]\uFE0F|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF6\uD83C\uDDE6|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F\u200D[\u2640\u2642]|(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642])\uFE0F|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2695\u2696\u2708]|\uD83D\uDC69\u200D[\u2695\u2696\u2708]|\uD83D\uDC68(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708]))\uFE0F|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83D\uDC69\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69]))|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67)\uDB40\uDC7F|\uD83D\uDC68(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC66\u200D\uD83D\uDC66|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92])|(?:\uD83C[\uDFFB-\uDFFF])\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]))|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDD1-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\u200D(?:(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC67|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC66)|\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC69\uDC6E\uDC70-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD18-\uDD1C\uDD1E\uDD1F\uDD26\uDD30-\uDD39\uDD3D\uDD3E\uDDD1-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])?|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDEEB\uDEEC\uDEF4-\uDEF8]|\uD83E[\uDD10-\uDD3A\uDD3C-\uDD3E\uDD40-\uDD45\uDD47-\uDD4C\uDD50-\uDD6B\uDD80-\uDD97\uDDC0\uDDD0-\uDDE6])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u2660\u2663\u2665\u2666\u2668\u267B\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEF8]|\uD83E[\uDD10-\uDD3A\uDD3C-\uDD3E\uDD40-\uDD45\uDD47-\uDD4C\uDD50-\uDD6B\uDD80-\uDD97\uDDC0\uDDD0-\uDDE6])\uFE0F)/;
function YP(n) {
    var e = n.nodeType
      , t = "";
    if (e === 1 || e === 9 || e === 11) {
        if (typeof n.textContent == "string")
            return n.textContent;
        for (n = n.firstChild; n; n = n.nextSibling)
            t += YP(n)
    } else if (e === 3 || e === 4)
        return n.nodeValue;
    return t
}
/*!
 * SplitText: 3.11.4
 * https://greensock.com
 *
 * @license Copyright 2008-2022, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/
var Qd, kw, KP, _p, qP, F_, wH = /(?:\r|\n|\t\t)/g, SH = /(?:\s\s+)/g, QP = function(e) {
    Qd = document,
    kw = window,
    _p = _p || e || kw.gsap || console.warn("Please gsap.registerPlugin(SplitText)"),
    _p && (F_ = _p.utils.toArray,
    qP = _p.core.context || function() {}
    ,
    KP = 1)
}, ZP = function(e) {
    return kw.getComputedStyle(e)
}, OM = function(e) {
    return e.position === "absolute" || e.absolute === !0
}, MH = function(e, t) {
    for (var r = t.length, i; --r > -1; )
        if (i = t[r],
        e.substr(0, i.length) === i)
            return i.length
}, AH = " style='position:relative;display:inline-block;'", Ib = function(e, t) {
    e === void 0 && (e = "");
    var r = ~e.indexOf("++")
      , i = 1;
    return r && (e = e.split("++").join("")),
    function() {
        return "<" + t + AH + (e ? " class='" + e + (r ? i++ : "") + "'>" : ">")
    }
}, $P = function n(e, t, r) {
    var i = e.nodeType;
    if (i === 1 || i === 9 || i === 11)
        for (e = e.firstChild; e; e = e.nextSibling)
            n(e, t, r);
    else
        (i === 3 || i === 4) && (e.nodeValue = e.nodeValue.split(t).join(r))
}, Lx = function(e, t) {
    for (var r = t.length; --r > -1; )
        e.push(t[r])
}, Lb = function(e, t, r) {
    for (var i; e && e !== t; ) {
        if (i = e._next || e.nextSibling,
        i)
            return i.textContent.charAt(0) === r;
        e = e.parentNode || e._parent
    }
}, CH = function n(e) {
    var t = F_(e.childNodes), r = t.length, i, s;
    for (i = 0; i < r; i++)
        s = t[i],
        s._isSplit ? n(s) : i && s.previousSibling && s.previousSibling.nodeType === 3 ? (s.previousSibling.nodeValue += s.nodeType === 3 ? s.nodeValue : s.firstChild.nodeValue,
        e.removeChild(s)) : s.nodeType !== 3 && (e.insertBefore(s.firstChild, s),
        e.removeChild(s))
}, zl = function(e, t) {
    return parseFloat(t[e]) || 0
}, EH = function(e, t, r, i, s, o, a) {
    var l = ZP(e), f = zl("paddingLeft", l), h = -999, d = zl("borderBottomWidth", l) + zl("borderTopWidth", l), p = zl("borderLeftWidth", l) + zl("borderRightWidth", l), m = zl("paddingTop", l) + zl("paddingBottom", l), _ = zl("paddingLeft", l) + zl("paddingRight", l), y = zl("fontSize", l) * (t.lineThreshold || .2), x = l.textAlign, S = [], M = [], w = [], T = t.wordDelimiter || " ", P = t.tag ? t.tag : t.span ? "span" : "div", I = t.type || t.split || "chars,words,lines", k = s && ~I.indexOf("lines") ? [] : null, R = ~I.indexOf("words"), O = ~I.indexOf("chars"), H = OM(t), W = t.linesClass, te = ~(W || "").indexOf("++"), ne = [], re = l.display === "flex", pe = e.style.display, ce, xe, G, z, U, fe, oe, Ae, Ue, je, de, qe;
    for (te && (W = W.split("++").join("")),
    re && (e.style.display = "block"),
    xe = e.getElementsByTagName("*"),
    G = xe.length,
    U = [],
    ce = 0; ce < G; ce++)
        U[ce] = xe[ce];
    if (k || H)
        for (ce = 0; ce < G; ce++)
            z = U[ce],
            fe = z.parentNode === e,
            (fe || H || O && !R) && (qe = z.offsetTop,
            k && fe && Math.abs(qe - h) > y && (z.nodeName !== "BR" || ce === 0) && (oe = [],
            k.push(oe),
            h = qe),
            H && (z._x = z.offsetLeft,
            z._y = qe,
            z._w = z.offsetWidth,
            z._h = z.offsetHeight),
            k && ((z._isSplit && fe || !O && fe || R && fe || !R && z.parentNode.parentNode === e && !z.parentNode._isSplit) && (oe.push(z),
            z._x -= f,
            Lb(z, e, T) && (z._wordEnd = !0)),
            z.nodeName === "BR" && (z.nextSibling && z.nextSibling.nodeName === "BR" || ce === 0) && k.push([])));
    for (ce = 0; ce < G; ce++) {
        if (z = U[ce],
        fe = z.parentNode === e,
        z.nodeName === "BR") {
            k || H ? (z.parentNode && z.parentNode.removeChild(z),
            U.splice(ce--, 1),
            G--) : R || e.appendChild(z);
            continue
        }
        if (H && (Ue = z.style,
        !R && !fe && (z._x += z.parentNode._x,
        z._y += z.parentNode._y),
        Ue.left = z._x + "px",
        Ue.top = z._y + "px",
        Ue.position = "absolute",
        Ue.display = "block",
        Ue.width = z._w + 1 + "px",
        Ue.height = z._h + "px"),
        !R && O)
            if (z._isSplit)
                for (z._next = xe = z.nextSibling,
                z.parentNode.appendChild(z); xe && xe.nodeType === 3 && xe.textContent === " "; )
                    z._next = xe.nextSibling,
                    z.parentNode.appendChild(xe),
                    xe = xe.nextSibling;
            else
                z.parentNode._isSplit ? (z._parent = z.parentNode,
                !z.previousSibling && z.firstChild && (z.firstChild._isFirst = !0),
                z.nextSibling && z.nextSibling.textContent === " " && !z.nextSibling.nextSibling && ne.push(z.nextSibling),
                z._next = z.nextSibling && z.nextSibling._isFirst ? null : z.nextSibling,
                z.parentNode.removeChild(z),
                U.splice(ce--, 1),
                G--) : fe || (qe = !z.nextSibling && Lb(z.parentNode, e, T),
                z.parentNode._parent && z.parentNode._parent.appendChild(z),
                qe && z.parentNode.appendChild(Qd.createTextNode(" ")),
                P === "span" && (z.style.display = "inline"),
                S.push(z));
        else
            z.parentNode._isSplit && !z._isSplit && z.innerHTML !== "" ? M.push(z) : O && !z._isSplit && (P === "span" && (z.style.display = "inline"),
            S.push(z))
    }
    for (ce = ne.length; --ce > -1; )
        ne[ce].parentNode.removeChild(ne[ce]);
    if (k) {
        for (H && (je = Qd.createElement(P),
        e.appendChild(je),
        de = je.offsetWidth + "px",
        qe = je.offsetParent === e ? 0 : e.offsetLeft,
        e.removeChild(je)),
        Ue = e.style.cssText,
        e.style.cssText = "display:none;"; e.firstChild; )
            e.removeChild(e.firstChild);
        for (Ae = T === " " && (!H || !R && !O),
        ce = 0; ce < k.length; ce++) {
            for (oe = k[ce],
            je = Qd.createElement(P),
            je.style.cssText = "display:block;text-align:" + x + ";position:" + (H ? "absolute;" : "relative;"),
            W && (je.className = W + (te ? ce + 1 : "")),
            w.push(je),
            G = oe.length,
            xe = 0; xe < G; xe++)
                oe[xe].nodeName !== "BR" && (z = oe[xe],
                je.appendChild(z),
                Ae && z._wordEnd && je.appendChild(Qd.createTextNode(" ")),
                H && (xe === 0 && (je.style.top = z._y + "px",
                je.style.left = f + qe + "px"),
                z.style.top = "0px",
                qe && (z.style.left = z._x - qe + "px")));
            G === 0 ? je.innerHTML = "&nbsp;" : !R && !O && (CH(je),
            $P(je, String.fromCharCode(160), " ")),
            H && (je.style.width = de,
            je.style.height = z._h + "px"),
            e.appendChild(je)
        }
        e.style.cssText = Ue
    }
    H && (a > e.clientHeight && (e.style.height = a - m + "px",
    e.clientHeight < a && (e.style.height = a + d + "px")),
    o > e.clientWidth && (e.style.width = o - _ + "px",
    e.clientWidth < o && (e.style.width = o + p + "px"))),
    re && (pe ? e.style.display = pe : e.style.removeProperty("display")),
    Lx(r, S),
    R && Lx(i, M),
    Lx(s, w)
}, bH = function(e, t, r, i) {
    var s = t.tag ? t.tag : t.span ? "span" : "div", o = t.type || t.split || "chars,words,lines", a = ~o.indexOf("chars"), l = OM(t), f = t.wordDelimiter || " ", h = f !== " " ? "" : l ? "&#173; " : " ", d = "</" + s + ">", p = 1, m = t.specialChars ? typeof t.specialChars == "function" ? t.specialChars : MH : null, _, y, x, S, M, w, T, P, I = Qd.createElement("div"), k = e.parentNode;
    for (k.insertBefore(I, e),
    I.textContent = e.nodeValue,
    k.removeChild(e),
    e = I,
    _ = YP(e),
    T = _.indexOf("<") !== -1,
    t.reduceWhiteSpace !== !1 && (_ = _.replace(SH, " ").replace(wH, "")),
    T && (_ = _.split("<").join("{{LT}}")),
    M = _.length,
    y = (_.charAt(0) === " " ? h : "") + r(),
    x = 0; x < M; x++)
        if (w = _.charAt(x),
        m && (P = m(_.substr(x), t.specialChars)))
            w = _.substr(x, P || 1),
            y += a && w !== " " ? i() + w + "</" + s + ">" : w,
            x += P - 1;
        else if (w === f && _.charAt(x - 1) !== f && x) {
            for (y += p ? d : "",
            p = 0; _.charAt(x + 1) === f; )
                y += h,
                x++;
            x === M - 1 ? y += h : _.charAt(x + 1) !== ")" && (y += h + r(),
            p = 1)
        } else
            w === "{" && _.substr(x, 6) === "{{LT}}" ? (y += a ? i() + "{{LT}}</" + s + ">" : "{{LT}}",
            x += 5) : w.charCodeAt(0) >= 55296 && w.charCodeAt(0) <= 56319 || _.charCodeAt(x + 1) >= 65024 && _.charCodeAt(x + 1) <= 65039 ? (S = ((_.substr(x, 12).split(xH) || [])[1] || "").length || 2,
            y += a && w !== " " ? i() + _.substr(x, S) + "</" + s + ">" : _.substr(x, S),
            x += S - 1) : y += a && w !== " " ? i() + w + "</" + s + ">" : w;
    e.outerHTML = y + (p ? d : ""),
    T && $P(k, "{{LT}}", "<")
}, TH = function n(e, t, r, i) {
    var s = F_(e.childNodes), o = s.length, a = OM(t), l, f;
    if (e.nodeType !== 3 || o > 1) {
        for (t.absolute = !1,
        l = 0; l < o; l++)
            f = s[l],
            f._next = f._isFirst = f._parent = f._wordEnd = null,
            (f.nodeType !== 3 || /\S+/.test(f.nodeValue)) && (a && f.nodeType !== 3 && ZP(f).display === "inline" && (f.style.display = "inline-block",
            f.style.position = "relative"),
            f._isSplit = !0,
            n(f, t, r, i));
        t.absolute = a,
        e._isSplit = !0;
        return
    }
    bH(e, t, r, i)
}, jo = function() {
    function n(t, r) {
        KP || QP(),
        this.elements = F_(t),
        this.chars = [],
        this.words = [],
        this.lines = [],
        this._originals = [],
        this.vars = r || {},
        qP(this),
        this.split(r)
    }
    var e = n.prototype;
    return e.split = function(r) {
        this.isSplit && this.revert(),
        this.vars = r = r || this.vars,
        this._originals.length = this.chars.length = this.words.length = this.lines.length = 0;
        for (var i = this.elements.length, s = r.tag ? r.tag : r.span ? "span" : "div", o = Ib(r.wordsClass, s), a = Ib(r.charsClass, s), l, f, h; --i > -1; )
            h = this.elements[i],
            this._originals[i] = h.innerHTML,
            l = h.clientHeight,
            f = h.clientWidth,
            TH(h, r, o, a),
            EH(h, r, this.chars, this.words, this.lines, f, l);
        return this.chars.reverse(),
        this.words.reverse(),
        this.lines.reverse(),
        this.isSplit = !0,
        this
    }
    ,
    e.revert = function() {
        var r = this._originals;
        if (!r)
            throw "revert() call wasn't scoped properly.";
        return this.elements.forEach(function(i, s) {
            return i.innerHTML = r[s]
        }),
        this.chars = [],
        this.words = [],
        this.lines = [],
        this.isSplit = !1,
        this
    }
    ,
    n.create = function(r, i) {
        return new n(r,i)
    }
    ,
    n
}();
jo.version = "3.11.4";
jo.register = QP;
function Fb(n) {
    return n !== null && typeof n == "object" && "constructor"in n && n.constructor === Object
}
function NM(n={}, e={}) {
    Object.keys(e).forEach(t=>{
        typeof n[t] > "u" ? n[t] = e[t] : Fb(e[t]) && Fb(n[t]) && Object.keys(e[t]).length > 0 && NM(n[t], e[t])
    }
    )
}
const eR = {
    body: {},
    addEventListener() {},
    removeEventListener() {},
    activeElement: {
        blur() {},
        nodeName: ""
    },
    querySelector() {
        return null
    },
    querySelectorAll() {
        return []
    },
    getElementById() {
        return null
    },
    createEvent() {
        return {
            initEvent() {}
        }
    },
    createElement() {
        return {
            children: [],
            childNodes: [],
            style: {},
            setAttribute() {},
            getElementsByTagName() {
                return []
            }
        }
    },
    createElementNS() {
        return {}
    },
    importNode() {
        return null
    },
    location: {
        hash: "",
        host: "",
        hostname: "",
        href: "",
        origin: "",
        pathname: "",
        protocol: "",
        search: ""
    }
};
function nd() {
    const n = typeof document < "u" ? document : {};
    return NM(n, eR),
    n
}
const DH = {
    document: eR,
    navigator: {
        userAgent: ""
    },
    location: {
        hash: "",
        host: "",
        hostname: "",
        href: "",
        origin: "",
        pathname: "",
        protocol: "",
        search: ""
    },
    history: {
        replaceState() {},
        pushState() {},
        go() {},
        back() {}
    },
    CustomEvent: function() {
        return this
    },
    addEventListener() {},
    removeEventListener() {},
    getComputedStyle() {
        return {
            getPropertyValue() {
                return ""
            }
        }
    },
    Image() {},
    Date() {},
    screen: {},
    setTimeout() {},
    clearTimeout() {},
    matchMedia() {
        return {}
    },
    requestAnimationFrame(n) {
        return typeof setTimeout > "u" ? (n(),
        null) : setTimeout(n, 0)
    },
    cancelAnimationFrame(n) {
        typeof setTimeout > "u" || clearTimeout(n)
    }
};
function ba() {
    const n = typeof window < "u" ? window : {};
    return NM(n, DH),
    n
}
function PH(n) {
    const e = n;
    Object.keys(e).forEach(t=>{
        try {
            e[t] = null
        } catch {}
        try {
            delete e[t]
        } catch {}
    }
    )
}
function Ow(n, e=0) {
    return setTimeout(n, e)
}
function Tm() {
    return Date.now()
}
function RH(n) {
    const e = ba();
    let t;
    return e.getComputedStyle && (t = e.getComputedStyle(n, null)),
    !t && n.currentStyle && (t = n.currentStyle),
    t || (t = n.style),
    t
}
function BH(n, e="x") {
    const t = ba();
    let r, i, s;
    const o = RH(n);
    return t.WebKitCSSMatrix ? (i = o.transform || o.webkitTransform,
    i.split(",").length > 6 && (i = i.split(", ").map(a=>a.replace(",", ".")).join(", ")),
    s = new t.WebKitCSSMatrix(i === "none" ? "" : i)) : (s = o.MozTransform || o.OTransform || o.MsTransform || o.msTransform || o.transform || o.getPropertyValue("transform").replace("translate(", "matrix(1, 0, 0, 1,"),
    r = s.toString().split(",")),
    e === "x" && (t.WebKitCSSMatrix ? i = s.m41 : r.length === 16 ? i = parseFloat(r[12]) : i = parseFloat(r[4])),
    e === "y" && (t.WebKitCSSMatrix ? i = s.m42 : r.length === 16 ? i = parseFloat(r[13]) : i = parseFloat(r[5])),
    i || 0
}
function G0(n) {
    return typeof n == "object" && n !== null && n.constructor && Object.prototype.toString.call(n).slice(8, -1) === "Object"
}
function IH(n) {
    return typeof window < "u" && typeof window.HTMLElement < "u" ? n instanceof HTMLElement : n && (n.nodeType === 1 || n.nodeType === 11)
}
function ma(...n) {
    const e = Object(n[0])
      , t = ["__proto__", "constructor", "prototype"];
    for (let r = 1; r < n.length; r += 1) {
        const i = n[r];
        if (i != null && !IH(i)) {
            const s = Object.keys(Object(i)).filter(o=>t.indexOf(o) < 0);
            for (let o = 0, a = s.length; o < a; o += 1) {
                const l = s[o]
                  , f = Object.getOwnPropertyDescriptor(i, l);
                f !== void 0 && f.enumerable && (G0(e[l]) && G0(i[l]) ? i[l].__swiper__ ? e[l] = i[l] : ma(e[l], i[l]) : !G0(e[l]) && G0(i[l]) ? (e[l] = {},
                i[l].__swiper__ ? e[l] = i[l] : ma(e[l], i[l])) : e[l] = i[l])
            }
        }
    }
    return e
}
function U0(n, e, t) {
    n.style.setProperty(e, t)
}
function tR({swiper: n, targetPosition: e, side: t}) {
    const r = ba()
      , i = -n.translate;
    let s = null, o;
    const a = n.params.speed;
    n.wrapperEl.style.scrollSnapType = "none",
    r.cancelAnimationFrame(n.cssModeFrameID);
    const l = e > i ? "next" : "prev"
      , f = (d,p)=>l === "next" && d >= p || l === "prev" && d <= p
      , h = ()=>{
        o = new Date().getTime(),
        s === null && (s = o);
        const d = Math.max(Math.min((o - s) / a, 1), 0)
          , p = .5 - Math.cos(d * Math.PI) / 2;
        let m = i + p * (e - i);
        if (f(m, e) && (m = e),
        n.wrapperEl.scrollTo({
            [t]: m
        }),
        f(m, e)) {
            n.wrapperEl.style.overflow = "hidden",
            n.wrapperEl.style.scrollSnapType = "",
            setTimeout(()=>{
                n.wrapperEl.style.overflow = "",
                n.wrapperEl.scrollTo({
                    [t]: m
                })
            }
            ),
            r.cancelAnimationFrame(n.cssModeFrameID);
            return
        }
        n.cssModeFrameID = r.requestAnimationFrame(h)
    }
    ;
    h()
}
function xu(n, e="") {
    return [...n.children].filter(t=>t.matches(e))
}
function LH(n, e=[]) {
    const t = document.createElement(n);
    return t.classList.add(...Array.isArray(e) ? e : [e]),
    t
}
function FH(n, e) {
    const t = [];
    for (; n.previousElementSibling; ) {
        const r = n.previousElementSibling;
        e ? r.matches(e) && t.push(r) : t.push(r),
        n = r
    }
    return t
}
function kH(n, e) {
    const t = [];
    for (; n.nextElementSibling; ) {
        const r = n.nextElementSibling;
        e ? r.matches(e) && t.push(r) : t.push(r),
        n = r
    }
    return t
}
function hc(n, e) {
    return ba().getComputedStyle(n, null).getPropertyValue(e)
}
function kb(n) {
    let e = n, t;
    if (e) {
        for (t = 0; (e = e.previousSibling) !== null; )
            e.nodeType === 1 && (t += 1);
        return t
    }
}
function OH(n, e) {
    const t = [];
    let r = n.parentElement;
    for (; r; )
        e ? r.matches(e) && t.push(r) : t.push(r),
        r = r.parentElement;
    return t
}
function Ob(n, e, t) {
    const r = ba();
    return t ? n[e === "width" ? "offsetWidth" : "offsetHeight"] + parseFloat(r.getComputedStyle(n, null).getPropertyValue(e === "width" ? "margin-right" : "margin-top")) + parseFloat(r.getComputedStyle(n, null).getPropertyValue(e === "width" ? "margin-left" : "margin-bottom")) : n.offsetWidth
}
let Fx;
function NH() {
    const n = ba()
      , e = nd();
    return {
        smoothScroll: e.documentElement && "scrollBehavior"in e.documentElement.style,
        touch: !!("ontouchstart"in n || n.DocumentTouch && e instanceof n.DocumentTouch)
    }
}
function nR() {
    return Fx || (Fx = NH()),
    Fx
}
let kx;
function zH({userAgent: n}={}) {
    const e = nR()
      , t = ba()
      , r = t.navigator.platform
      , i = n || t.navigator.userAgent
      , s = {
        ios: !1,
        android: !1
    }
      , o = t.screen.width
      , a = t.screen.height
      , l = i.match(/(Android);?[\s\/]+([\d.]+)?/);
    let f = i.match(/(iPad).*OS\s([\d_]+)/);
    const h = i.match(/(iPod)(.*OS\s([\d_]+))?/)
      , d = !f && i.match(/(iPhone\sOS|iOS)\s([\d_]+)/)
      , p = r === "Win32";
    let m = r === "MacIntel";
    const _ = ["1024x1366", "1366x1024", "834x1194", "1194x834", "834x1112", "1112x834", "768x1024", "1024x768", "820x1180", "1180x820", "810x1080", "1080x810"];
    return !f && m && e.touch && _.indexOf(`${o}x ${a}`) >= 0 && (f = i.match(/(Version)\/([\d.]+)/),
    f || (f = [0, 1, "13_0_0"]),
    m = !1),
    l && !p && (s.os = "android",
    s.android = !0),
    (f || d || h) && (s.os = "ios",
    s.ios = !0),
    s
}
function GH(n={}) {
    return kx || (kx = zH(n)),
    kx
}
let Ox;
function UH() {
    const n = ba();
    let e = !1;
    function t() {
        const r = n.navigator.userAgent.toLowerCase();
        return r.indexOf("safari") >= 0 && r.indexOf("chrome") < 0 && r.indexOf("android") < 0
    }
    if (t()) {
        const r = String(n.navigator.userAgent);
        if (r.includes("Version/")) {
            const [i,s] = r.split("Version/")[1].split(" ")[0].split(".").map(o=>Number(o));
            e = i < 16 || i === 16 && s < 2
        }
    }
    return {
        isSafari: e || t(),
        needPerspectiveFix: e,
        isWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(n.navigator.userAgent)
    }
}
function HH() {
    return Ox || (Ox = UH()),
    Ox
}
function VH({swiper: n, on: e, emit: t}) {
    const r = ba();
    let i = null
      , s = null;
    const o = ()=>{
        !n || n.destroyed || !n.initialized || (t("beforeResize"),
        t("resize"))
    }
      , a = ()=>{
        !n || n.destroyed || !n.initialized || (i = new ResizeObserver(h=>{
            s = r.requestAnimationFrame(()=>{
                const {width: d, height: p} = n;
                let m = d
                  , _ = p;
                h.forEach(({contentBoxSize: y, contentRect: x, target: S})=>{
                    S && S !== n.el || (m = x ? x.width : (y[0] || y).inlineSize,
                    _ = x ? x.height : (y[0] || y).blockSize)
                }
                ),
                (m !== d || _ !== p) && o()
            }
            )
        }
        ),
        i.observe(n.el))
    }
      , l = ()=>{
        s && r.cancelAnimationFrame(s),
        i && i.unobserve && n.el && (i.unobserve(n.el),
        i = null)
    }
      , f = ()=>{
        !n || n.destroyed || !n.initialized || t("orientationchange")
    }
    ;
    e("init", ()=>{
        if (n.params.resizeObserver && typeof r.ResizeObserver < "u") {
            a();
            return
        }
        r.addEventListener("resize", o),
        r.addEventListener("orientationchange", f)
    }
    ),
    e("destroy", ()=>{
        l(),
        r.removeEventListener("resize", o),
        r.removeEventListener("orientationchange", f)
    }
    )
}
function WH({swiper: n, extendParams: e, on: t, emit: r}) {
    const i = []
      , s = ba()
      , o = (f,h={})=>{
        const d = s.MutationObserver || s.WebkitMutationObserver
          , p = new d(m=>{
            if (n.__preventObserver__)
                return;
            if (m.length === 1) {
                r("observerUpdate", m[0]);
                return
            }
            const _ = function() {
                r("observerUpdate", m[0])
            };
            s.requestAnimationFrame ? s.requestAnimationFrame(_) : s.setTimeout(_, 0)
        }
        );
        p.observe(f, {
            attributes: typeof h.attributes > "u" ? !0 : h.attributes,
            childList: typeof h.childList > "u" ? !0 : h.childList,
            characterData: typeof h.characterData > "u" ? !0 : h.characterData
        }),
        i.push(p)
    }
      , a = ()=>{
        if (n.params.observer) {
            if (n.params.observeParents) {
                const f = OH(n.el);
                for (let h = 0; h < f.length; h += 1)
                    o(f[h])
            }
            o(n.el, {
                childList: n.params.observeSlideChildren
            }),
            o(n.wrapperEl, {
                attributes: !1
            })
        }
    }
      , l = ()=>{
        i.forEach(f=>{
            f.disconnect()
        }
        ),
        i.splice(0, i.length)
    }
    ;
    e({
        observer: !1,
        observeParents: !1,
        observeSlideChildren: !1
    }),
    t("init", a),
    t("destroy", l)
}
const XH = {
    on(n, e, t) {
        const r = this;
        if (!r.eventsListeners || r.destroyed || typeof e != "function")
            return r;
        const i = t ? "unshift" : "push";
        return n.split(" ").forEach(s=>{
            r.eventsListeners[s] || (r.eventsListeners[s] = []),
            r.eventsListeners[s][i](e)
        }
        ),
        r
    },
    once(n, e, t) {
        const r = this;
        if (!r.eventsListeners || r.destroyed || typeof e != "function")
            return r;
        function i(...s) {
            r.off(n, i),
            i.__emitterProxy && delete i.__emitterProxy,
            e.apply(r, s)
        }
        return i.__emitterProxy = e,
        r.on(n, i, t)
    },
    onAny(n, e) {
        const t = this;
        if (!t.eventsListeners || t.destroyed || typeof n != "function")
            return t;
        const r = e ? "unshift" : "push";
        return t.eventsAnyListeners.indexOf(n) < 0 && t.eventsAnyListeners[r](n),
        t
    },
    offAny(n) {
        const e = this;
        if (!e.eventsListeners || e.destroyed || !e.eventsAnyListeners)
            return e;
        const t = e.eventsAnyListeners.indexOf(n);
        return t >= 0 && e.eventsAnyListeners.splice(t, 1),
        e
    },
    off(n, e) {
        const t = this;
        return !t.eventsListeners || t.destroyed || !t.eventsListeners || n.split(" ").forEach(r=>{
            typeof e > "u" ? t.eventsListeners[r] = [] : t.eventsListeners[r] && t.eventsListeners[r].forEach((i,s)=>{
                (i === e || i.__emitterProxy && i.__emitterProxy === e) && t.eventsListeners[r].splice(s, 1)
            }
            )
        }
        ),
        t
    },
    emit(...n) {
        const e = this;
        if (!e.eventsListeners || e.destroyed || !e.eventsListeners)
            return e;
        let t, r, i;
        return typeof n[0] == "string" || Array.isArray(n[0]) ? (t = n[0],
        r = n.slice(1, n.length),
        i = e) : (t = n[0].events,
        r = n[0].data,
        i = n[0].context || e),
        r.unshift(i),
        (Array.isArray(t) ? t : t.split(" ")).forEach(o=>{
            e.eventsAnyListeners && e.eventsAnyListeners.length && e.eventsAnyListeners.forEach(a=>{
                a.apply(i, [o, ...r])
            }
            ),
            e.eventsListeners && e.eventsListeners[o] && e.eventsListeners[o].forEach(a=>{
                a.apply(i, r)
            }
            )
        }
        ),
        e
    }
};
function JH() {
    const n = this;
    let e, t;
    const r = n.el;
    typeof n.params.width < "u" && n.params.width !== null ? e = n.params.width : e = r.clientWidth,
    typeof n.params.height < "u" && n.params.height !== null ? t = n.params.height : t = r.clientHeight,
    !(e === 0 && n.isHorizontal() || t === 0 && n.isVertical()) && (e = e - parseInt(hc(r, "padding-left") || 0, 10) - parseInt(hc(r, "padding-right") || 0, 10),
    t = t - parseInt(hc(r, "padding-top") || 0, 10) - parseInt(hc(r, "padding-bottom") || 0, 10),
    Number.isNaN(e) && (e = 0),
    Number.isNaN(t) && (t = 0),
    Object.assign(n, {
        width: e,
        height: t,
        size: n.isHorizontal() ? e : t
    }))
}
function jH() {
    const n = this;
    function e(W) {
        return n.isHorizontal() ? W : {
            width: "height",
            "margin-top": "margin-left",
            "margin-bottom ": "margin-right",
            "margin-left": "margin-top",
            "margin-right": "margin-bottom",
            "padding-left": "padding-top",
            "padding-right": "padding-bottom",
            marginRight: "marginBottom"
        }[W]
    }
    function t(W, te) {
        return parseFloat(W.getPropertyValue(e(te)) || 0)
    }
    const r = n.params
      , {wrapperEl: i, slidesEl: s, size: o, rtlTranslate: a, wrongRTL: l} = n
      , f = n.virtual && r.virtual.enabled
      , h = f ? n.virtual.slides.length : n.slides.length
      , d = xu(s, `.${n.params.slideClass}, swiper-slide`)
      , p = f ? n.virtual.slides.length : d.length;
    let m = [];
    const _ = []
      , y = [];
    let x = r.slidesOffsetBefore;
    typeof x == "function" && (x = r.slidesOffsetBefore.call(n));
    let S = r.slidesOffsetAfter;
    typeof S == "function" && (S = r.slidesOffsetAfter.call(n));
    const M = n.snapGrid.length
      , w = n.slidesGrid.length;
    let T = r.spaceBetween
      , P = -x
      , I = 0
      , k = 0;
    if (typeof o > "u")
        return;
    typeof T == "string" && T.indexOf("%") >= 0 && (T = parseFloat(T.replace("%", "")) / 100 * o),
    n.virtualSize = -T,
    d.forEach(W=>{
        a ? W.style.marginLeft = "" : W.style.marginRight = "",
        W.style.marginBottom = "",
        W.style.marginTop = ""
    }
    ),
    r.centeredSlides && r.cssMode && (U0(i, "--swiper-centered-offset-before", ""),
    U0(i, "--swiper-centered-offset-after", ""));
    const R = r.grid && r.grid.rows > 1 && n.grid;
    R && n.grid.initSlides(p);
    let O;
    const H = r.slidesPerView === "auto" && r.breakpoints && Object.keys(r.breakpoints).filter(W=>typeof r.breakpoints[W].slidesPerView < "u").length > 0;
    for (let W = 0; W < p; W += 1) {
        O = 0;
        let te;
        if (d[W] && (te = d[W]),
        R && n.grid.updateSlide(W, te, p, e),
        !(d[W] && hc(te, "display") === "none")) {
            if (r.slidesPerView === "auto") {
                H && (d[W].style[e("width")] = "");
                const ne = getComputedStyle(te)
                  , re = te.style.transform
                  , pe = te.style.webkitTransform;
                if (re && (te.style.transform = "none"),
                pe && (te.style.webkitTransform = "none"),
                r.roundLengths)
                    O = n.isHorizontal() ? Ob(te, "width", !0) : Ob(te, "height", !0);
                else {
                    const ce = t(ne, "width")
                      , xe = t(ne, "padding-left")
                      , G = t(ne, "padding-right")
                      , z = t(ne, "margin-left")
                      , U = t(ne, "margin-right")
                      , fe = ne.getPropertyValue("box-sizing");
                    if (fe && fe === "border-box")
                        O = ce + z + U;
                    else {
                        const {clientWidth: oe, offsetWidth: Ae} = te;
                        O = ce + xe + G + z + U + (Ae - oe)
                    }
                }
                re && (te.style.transform = re),
                pe && (te.style.webkitTransform = pe),
                r.roundLengths && (O = Math.floor(O))
            } else
                O = (o - (r.slidesPerView - 1) * T) / r.slidesPerView,
                r.roundLengths && (O = Math.floor(O)),
                d[W] && (d[W].style[e("width")] = `${O}px`);
            d[W] && (d[W].swiperSlideSize = O),
            y.push(O),
            r.centeredSlides ? (P = P + O / 2 + I / 2 + T,
            I === 0 && W !== 0 && (P = P - o / 2 - T),
            W === 0 && (P = P - o / 2 - T),
            Math.abs(P) < 1 / 1e3 && (P = 0),
            r.roundLengths && (P = Math.floor(P)),
            k % r.slidesPerGroup === 0 && m.push(P),
            _.push(P)) : (r.roundLengths && (P = Math.floor(P)),
            (k - Math.min(n.params.slidesPerGroupSkip, k)) % n.params.slidesPerGroup === 0 && m.push(P),
            _.push(P),
            P = P + O + T),
            n.virtualSize += O + T,
            I = O,
            k += 1
        }
    }
    if (n.virtualSize = Math.max(n.virtualSize, o) + S,
    a && l && (r.effect === "slide" || r.effect === "coverflow") && (i.style.width = `${n.virtualSize + r.spaceBetween}px`),
    r.setWrapperSize && (i.style[e("width")] = `${n.virtualSize + r.spaceBetween}px`),
    R && n.grid.updateWrapperSize(O, m, e),
    !r.centeredSlides) {
        const W = [];
        for (let te = 0; te < m.length; te += 1) {
            let ne = m[te];
            r.roundLengths && (ne = Math.floor(ne)),
            m[te] <= n.virtualSize - o && W.push(ne)
        }
        m = W,
        Math.floor(n.virtualSize - o) - Math.floor(m[m.length - 1]) > 1 && m.push(n.virtualSize - o)
    }
    if (f && r.loop) {
        const W = y[0] + T;
        if (r.slidesPerGroup > 1) {
            const te = Math.ceil((n.virtual.slidesBefore + n.virtual.slidesAfter) / r.slidesPerGroup)
              , ne = W * r.slidesPerGroup;
            for (let re = 0; re < te; re += 1)
                m.push(m[m.length - 1] + ne)
        }
        for (let te = 0; te < n.virtual.slidesBefore + n.virtual.slidesAfter; te += 1)
            r.slidesPerGroup === 1 && m.push(m[m.length - 1] + W),
            _.push(_[_.length - 1] + W),
            n.virtualSize += W
    }
    if (m.length === 0 && (m = [0]),
    r.spaceBetween !== 0) {
        const W = n.isHorizontal() && a ? "marginLeft" : e("marginRight");
        d.filter((te,ne)=>!r.cssMode || r.loop ? !0 : ne !== d.length - 1).forEach(te=>{
            te.style[W] = `${T}px`
        }
        )
    }
    if (r.centeredSlides && r.centeredSlidesBounds) {
        let W = 0;
        y.forEach(ne=>{
            W += ne + (r.spaceBetween ? r.spaceBetween : 0)
        }
        ),
        W -= r.spaceBetween;
        const te = W - o;
        m = m.map(ne=>ne < 0 ? -x : ne > te ? te + S : ne)
    }
    if (r.centerInsufficientSlides) {
        let W = 0;
        if (y.forEach(te=>{
            W += te + (r.spaceBetween ? r.spaceBetween : 0)
        }
        ),
        W -= r.spaceBetween,
        W < o) {
            const te = (o - W) / 2;
            m.forEach((ne,re)=>{
                m[re] = ne - te
            }
            ),
            _.forEach((ne,re)=>{
                _[re] = ne + te
            }
            )
        }
    }
    if (Object.assign(n, {
        slides: d,
        snapGrid: m,
        slidesGrid: _,
        slidesSizesGrid: y
    }),
    r.centeredSlides && r.cssMode && !r.centeredSlidesBounds) {
        U0(i, "--swiper-centered-offset-before", `${-m[0]}px`),
        U0(i, "--swiper-centered-offset-after", `${n.size / 2 - y[y.length - 1] / 2}px`);
        const W = -n.snapGrid[0]
          , te = -n.slidesGrid[0];
        n.snapGrid = n.snapGrid.map(ne=>ne + W),
        n.slidesGrid = n.slidesGrid.map(ne=>ne + te)
    }
    if (p !== h && n.emit("slidesLengthChange"),
    m.length !== M && (n.params.watchOverflow && n.checkOverflow(),
    n.emit("snapGridLengthChange")),
    _.length !== w && n.emit("slidesGridLengthChange"),
    r.watchSlidesProgress && n.updateSlidesOffset(),
    !f && !r.cssMode && (r.effect === "slide" || r.effect === "fade")) {
        const W = `${r.containerModifierClass}backface-hidden`
          , te = n.el.classList.contains(W);
        p <= r.maxBackfaceHiddenSlides ? te || n.el.classList.add(W) : te && n.el.classList.remove(W)
    }
}
function YH(n) {
    const e = this
      , t = []
      , r = e.virtual && e.params.virtual.enabled;
    let i = 0, s;
    typeof n == "number" ? e.setTransition(n) : n === !0 && e.setTransition(e.params.speed);
    const o = a=>r ? e.getSlideIndexByData(a) : e.slides[a];
    if (e.params.slidesPerView !== "auto" && e.params.slidesPerView > 1)
        if (e.params.centeredSlides)
            (e.visibleSlides || []).forEach(a=>{
                t.push(a)
            }
            );
        else
            for (s = 0; s < Math.ceil(e.params.slidesPerView); s += 1) {
                const a = e.activeIndex + s;
                if (a > e.slides.length && !r)
                    break;
                t.push(o(a))
            }
    else
        t.push(o(e.activeIndex));
    for (s = 0; s < t.length; s += 1)
        if (typeof t[s] < "u") {
            const a = t[s].offsetHeight;
            i = a > i ? a : i
        }
    (i || i === 0) && (e.wrapperEl.style.height = `${i}px`)
}
function KH() {
    const n = this
      , e = n.slides
      , t = n.isElement ? n.isHorizontal() ? n.wrapperEl.offsetLeft : n.wrapperEl.offsetTop : 0;
    for (let r = 0; r < e.length; r += 1)
        e[r].swiperSlideOffset = (n.isHorizontal() ? e[r].offsetLeft : e[r].offsetTop) - t
}
function qH(n=this && this.translate || 0) {
    const e = this
      , t = e.params
      , {slides: r, rtlTranslate: i, snapGrid: s} = e;
    if (r.length === 0)
        return;
    typeof r[0].swiperSlideOffset > "u" && e.updateSlidesOffset();
    let o = -n;
    i && (o = n),
    r.forEach(a=>{
        a.classList.remove(t.slideVisibleClass)
    }
    ),
    e.visibleSlidesIndexes = [],
    e.visibleSlides = [];
    for (let a = 0; a < r.length; a += 1) {
        const l = r[a];
        let f = l.swiperSlideOffset;
        t.cssMode && t.centeredSlides && (f -= r[0].swiperSlideOffset);
        const h = (o + (t.centeredSlides ? e.minTranslate() : 0) - f) / (l.swiperSlideSize + t.spaceBetween)
          , d = (o - s[0] + (t.centeredSlides ? e.minTranslate() : 0) - f) / (l.swiperSlideSize + t.spaceBetween)
          , p = -(o - f)
          , m = p + e.slidesSizesGrid[a];
        (p >= 0 && p < e.size - 1 || m > 1 && m <= e.size || p <= 0 && m >= e.size) && (e.visibleSlides.push(l),
        e.visibleSlidesIndexes.push(a),
        r[a].classList.add(t.slideVisibleClass)),
        l.progress = i ? -h : h,
        l.originalProgress = i ? -d : d
    }
}
function QH(n) {
    const e = this;
    if (typeof n > "u") {
        const h = e.rtlTranslate ? -1 : 1;
        n = e && e.translate && e.translate * h || 0
    }
    const t = e.params
      , r = e.maxTranslate() - e.minTranslate();
    let {progress: i, isBeginning: s, isEnd: o, progressLoop: a} = e;
    const l = s
      , f = o;
    if (r === 0)
        i = 0,
        s = !0,
        o = !0;
    else {
        i = (n - e.minTranslate()) / r;
        const h = Math.abs(n - e.minTranslate()) < 1
          , d = Math.abs(n - e.maxTranslate()) < 1;
        s = h || i <= 0,
        o = d || i >= 1,
        h && (i = 0),
        d && (i = 1)
    }
    if (t.loop) {
        const h = e.getSlideIndexByData(0)
          , d = e.getSlideIndexByData(e.slides.length - 1)
          , p = e.slidesGrid[h]
          , m = e.slidesGrid[d]
          , _ = e.slidesGrid[e.slidesGrid.length - 1]
          , y = Math.abs(n);
        y >= p ? a = (y - p) / _ : a = (y + _ - m) / _,
        a > 1 && (a -= 1)
    }
    Object.assign(e, {
        progress: i,
        progressLoop: a,
        isBeginning: s,
        isEnd: o
    }),
    (t.watchSlidesProgress || t.centeredSlides && t.autoHeight) && e.updateSlidesProgress(n),
    s && !l && e.emit("reachBeginning toEdge"),
    o && !f && e.emit("reachEnd toEdge"),
    (l && !s || f && !o) && e.emit("fromEdge"),
    e.emit("progress", i)
}
function ZH() {
    const n = this
      , {slides: e, params: t, slidesEl: r, activeIndex: i} = n
      , s = n.virtual && t.virtual.enabled
      , o = l=>xu(r, `.${t.slideClass}${l}, swiper-slide ${l}`)[0];
    e.forEach(l=>{
        l.classList.remove(t.slideActiveClass, t.slideNextClass, t.slidePrevClass)
    }
    );
    let a;
    if (s)
        if (t.loop) {
            let l = i - n.virtual.slidesBefore;
            l < 0 && (l = n.virtual.slides.length + l),
            l >= n.virtual.slides.length && (l -= n.virtual.slides.length),
            a = o(`[data-swiper-slide-index="${l}"]`)
        } else
            a = o(`[data-swiper-slide-index="${i}"]`);
    else
        a = e[i];
    if (a) {
        a.classList.add(t.slideActiveClass);
        let l = kH(a, `.${t.slideClass}, swiper-slide`)[0];
        t.loop && !l && (l = e[0]),
        l && l.classList.add(t.slideNextClass);
        let f = FH(a, `.${t.slideClass}, swiper-slide`)[0];
        t.loop && !f === 0 && (f = e[e.length - 1]),
        f && f.classList.add(t.slidePrevClass)
    }
    n.emitSlidesClasses()
}
function $H(n) {
    const {slidesGrid: e, params: t} = n
      , r = n.rtlTranslate ? n.translate : -n.translate;
    let i;
    for (let s = 0; s < e.length; s += 1)
        typeof e[s + 1] < "u" ? r >= e[s] && r < e[s + 1] - (e[s + 1] - e[s]) / 2 ? i = s : r >= e[s] && r < e[s + 1] && (i = s + 1) : r >= e[s] && (i = s);
    return t.normalizeSlideIndex && (i < 0 || typeof i > "u") && (i = 0),
    i
}
function e8(n) {
    const e = this
      , t = e.rtlTranslate ? e.translate : -e.translate
      , {snapGrid: r, params: i, activeIndex: s, realIndex: o, snapIndex: a} = e;
    let l = n, f;
    const h = p=>{
        let m = p - e.virtual.slidesBefore;
        return m < 0 && (m = e.virtual.slides.length + m),
        m >= e.virtual.slides.length && (m -= e.virtual.slides.length),
        m
    }
    ;
    if (typeof l > "u" && (l = $H(e)),
    r.indexOf(t) >= 0)
        f = r.indexOf(t);
    else {
        const p = Math.min(i.slidesPerGroupSkip, l);
        f = p + Math.floor((l - p) / i.slidesPerGroup)
    }
    if (f >= r.length && (f = r.length - 1),
    l === s) {
        f !== a && (e.snapIndex = f,
        e.emit("snapIndexChange")),
        e.params.loop && e.virtual && e.params.virtual.enabled && (e.realIndex = h(l));
        return
    }
    let d;
    e.virtual && i.virtual.enabled && i.loop ? d = h(l) : e.slides[l] ? d = parseInt(e.slides[l].getAttribute("data-swiper-slide-index") || l, 10) : d = l,
    Object.assign(e, {
        snapIndex: f,
        realIndex: d,
        previousIndex: s,
        activeIndex: l
    }),
    e.emit("activeIndexChange"),
    e.emit("snapIndexChange"),
    o !== d && e.emit("realIndexChange"),
    (e.initialized || e.params.runCallbacksOnInit) && e.emit("slideChange")
}
function t8(n) {
    const e = this
      , t = e.params
      , r = n.closest(`.${t.slideClass}, swiper-slide`);
    let i = !1, s;
    if (r) {
        for (let o = 0; o < e.slides.length; o += 1)
            if (e.slides[o] === r) {
                i = !0,
                s = o;
                break
            }
    }
    if (r && i)
        e.clickedSlide = r,
        e.virtual && e.params.virtual.enabled ? e.clickedIndex = parseInt(r.getAttribute("data-swiper-slide-index"), 10) : e.clickedIndex = s;
    else {
        e.clickedSlide = void 0,
        e.clickedIndex = void 0;
        return
    }
    t.slideToClickedSlide && e.clickedIndex !== void 0 && e.clickedIndex !== e.activeIndex && e.slideToClickedSlide()
}
const n8 = {
    updateSize: JH,
    updateSlides: jH,
    updateAutoHeight: YH,
    updateSlidesOffset: KH,
    updateSlidesProgress: qH,
    updateProgress: QH,
    updateSlidesClasses: ZH,
    updateActiveIndex: e8,
    updateClickedSlide: t8
};
function r8(n=this.isHorizontal() ? "x" : "y") {
    const e = this
      , {params: t, rtlTranslate: r, translate: i, wrapperEl: s} = e;
    if (t.virtualTranslate)
        return r ? -i : i;
    if (t.cssMode)
        return i;
    let o = BH(s, n);
    return r && (o = -o),
    o || 0
}
function i8(n, e) {
    const t = this
      , {rtlTranslate: r, params: i, wrapperEl: s, progress: o} = t;
    let a = 0
      , l = 0;
    const f = 0;
    t.isHorizontal() ? a = r ? -n : n : l = n,
    i.roundLengths && (a = Math.floor(a),
    l = Math.floor(l)),
    i.cssMode ? s[t.isHorizontal() ? "scrollLeft" : "scrollTop"] = t.isHorizontal() ? -a : -l : i.virtualTranslate || (s.style.transform = `translate3d(${a}px, ${l}px, ${f}px)`),
    t.previousTranslate = t.translate,
    t.translate = t.isHorizontal() ? a : l;
    let h;
    const d = t.maxTranslate() - t.minTranslate();
    d === 0 ? h = 0 : h = (n - t.minTranslate()) / d,
    h !== o && t.updateProgress(n),
    t.emit("setTranslate", t.translate, e)
}
function s8() {
    return -this.snapGrid[0]
}
function o8() {
    return -this.snapGrid[this.snapGrid.length - 1]
}
function a8(n=0, e=this.params.speed, t=!0, r=!0, i) {
    const s = this
      , {params: o, wrapperEl: a} = s;
    if (s.animating && o.preventInteractionOnTransition)
        return !1;
    const l = s.minTranslate()
      , f = s.maxTranslate();
    let h;
    if (r && n > l ? h = l : r && n < f ? h = f : h = n,
    s.updateProgress(h),
    o.cssMode) {
        const d = s.isHorizontal();
        if (e === 0)
            a[d ? "scrollLeft" : "scrollTop"] = -h;
        else {
            if (!s.support.smoothScroll)
                return tR({
                    swiper: s,
                    targetPosition: -h,
                    side: d ? "left" : "top"
                }),
                !0;
            a.scrollTo({
                [d ? "left" : "top"]: -h,
                behavior: "smooth"
            })
        }
        return !0
    }
    return e === 0 ? (s.setTransition(0),
    s.setTranslate(h),
    t && (s.emit("beforeTransitionStart", e, i),
    s.emit("transitionEnd"))) : (s.setTransition(e),
    s.setTranslate(h),
    t && (s.emit("beforeTransitionStart", e, i),
    s.emit("transitionStart")),
    s.animating || (s.animating = !0,
    s.onTranslateToWrapperTransitionEnd || (s.onTranslateToWrapperTransitionEnd = function(p) {
        !s || s.destroyed || p.target === this && (s.wrapperEl.removeEventListener("transitionend", s.onTranslateToWrapperTransitionEnd),
        s.onTranslateToWrapperTransitionEnd = null,
        delete s.onTranslateToWrapperTransitionEnd,
        t && s.emit("transitionEnd"))
    }
    ),
    s.wrapperEl.addEventListener("transitionend", s.onTranslateToWrapperTransitionEnd))),
    !0
}
const l8 = {
    getTranslate: r8,
    setTranslate: i8,
    minTranslate: s8,
    maxTranslate: o8,
    translateTo: a8
};
function u8(n, e) {
    const t = this;
    t.params.cssMode || (t.wrapperEl.style.transitionDuration = `${n}ms`),
    t.emit("setTransition", n, e)
}
function rR({swiper: n, runCallbacks: e, direction: t, step: r}) {
    const {activeIndex: i, previousIndex: s} = n;
    let o = t;
    if (o || (i > s ? o = "next" : i < s ? o = "prev" : o = "reset"),
    n.emit(`transition ${r}`),
    e && i !== s) {
        if (o === "reset") {
            n.emit(`slideResetTransition ${r}`);
            return
        }
        n.emit(`slideChangeTransition ${r}`),
        o === "next" ? n.emit(`slideNextTransition ${r}`) : n.emit(`slidePrevTransition ${r}`)
    }
}
function c8(n=!0, e) {
    const t = this
      , {params: r} = t;
    r.cssMode || (r.autoHeight && t.updateAutoHeight(),
    rR({
        swiper: t,
        runCallbacks: n,
        direction: e,
        step: "Start"
    }))
}
function f8(n=!0, e) {
    const t = this
      , {params: r} = t;
    t.animating = !1,
    !r.cssMode && (t.setTransition(0),
    rR({
        swiper: t,
        runCallbacks: n,
        direction: e,
        step: "End"
    }))
}
const d8 = {
    setTransition: u8,
    transitionStart: c8,
    transitionEnd: f8
};
function h8(n=0, e=this.params.speed, t=!0, r, i) {
    typeof n == "string" && (n = parseInt(n, 10));
    const s = this;
    let o = n;
    o < 0 && (o = 0);
    const {params: a, snapGrid: l, slidesGrid: f, previousIndex: h, activeIndex: d, rtlTranslate: p, wrapperEl: m, enabled: _} = s;
    if (s.animating && a.preventInteractionOnTransition || !_ && !r && !i)
        return !1;
    const y = Math.min(s.params.slidesPerGroupSkip, o);
    let x = y + Math.floor((o - y) / s.params.slidesPerGroup);
    x >= l.length && (x = l.length - 1);
    const S = -l[x];
    if (a.normalizeSlideIndex)
        for (let w = 0; w < f.length; w += 1) {
            const T = -Math.floor(S * 100)
              , P = Math.floor(f[w] * 100)
              , I = Math.floor(f[w + 1] * 100);
            typeof f[w + 1] < "u" ? T >= P && T < I - (I - P) / 2 ? o = w : T >= P && T < I && (o = w + 1) : T >= P && (o = w)
        }
    if (s.initialized && o !== d && (!s.allowSlideNext && S < s.translate && S < s.minTranslate() || !s.allowSlidePrev && S > s.translate && S > s.maxTranslate() && (d || 0) !== o))
        return !1;
    o !== (h || 0) && t && s.emit("beforeSlideChangeStart"),
    s.updateProgress(S);
    let M;
    if (o > d ? M = "next" : o < d ? M = "prev" : M = "reset",
    p && -S === s.translate || !p && S === s.translate)
        return s.updateActiveIndex(o),
        a.autoHeight && s.updateAutoHeight(),
        s.updateSlidesClasses(),
        a.effect !== "slide" && s.setTranslate(S),
        M !== "reset" && (s.transitionStart(t, M),
        s.transitionEnd(t, M)),
        !1;
    if (a.cssMode) {
        const w = s.isHorizontal()
          , T = p ? S : -S;
        if (e === 0) {
            const P = s.virtual && s.params.virtual.enabled;
            P && (s.wrapperEl.style.scrollSnapType = "none",
            s._immediateVirtual = !0),
            P && !s._cssModeVirtualInitialSet && s.params.initialSlide > 0 ? (s._cssModeVirtualInitialSet = !0,
            requestAnimationFrame(()=>{
                m[w ? "scrollLeft" : "scrollTop"] = T
            }
            )) : m[w ? "scrollLeft" : "scrollTop"] = T,
            P && requestAnimationFrame(()=>{
                s.wrapperEl.style.scrollSnapType = "",
                s._immediateVirtual = !1
            }
            )
        } else {
            if (!s.support.smoothScroll)
                return tR({
                    swiper: s,
                    targetPosition: T,
                    side: w ? "left" : "top"
                }),
                !0;
            m.scrollTo({
                [w ? "left" : "top"]: T,
                behavior: "smooth"
            })
        }
        return !0
    }
    return s.setTransition(e),
    s.setTranslate(S),
    s.updateActiveIndex(o),
    s.updateSlidesClasses(),
    s.emit("beforeTransitionStart", e, r),
    s.transitionStart(t, M),
    e === 0 ? s.transitionEnd(t, M) : s.animating || (s.animating = !0,
    s.onSlideToWrapperTransitionEnd || (s.onSlideToWrapperTransitionEnd = function(T) {
        !s || s.destroyed || T.target === this && (s.wrapperEl.removeEventListener("transitionend", s.onSlideToWrapperTransitionEnd),
        s.onSlideToWrapperTransitionEnd = null,
        delete s.onSlideToWrapperTransitionEnd,
        s.transitionEnd(t, M))
    }
    ),
    s.wrapperEl.addEventListener("transitionend", s.onSlideToWrapperTransitionEnd)),
    !0
}
function p8(n=0, e=this.params.speed, t=!0, r) {
    typeof n == "string" && (n = parseInt(n, 10));
    const i = this;
    let s = n;
    return i.params.loop && (i.virtual && i.params.virtual.enabled ? s = s + i.virtual.slidesBefore : s = i.getSlideIndexByData(s)),
    i.slideTo(s, e, t, r)
}
function m8(n=this.params.speed, e=!0, t) {
    const r = this
      , {enabled: i, params: s, animating: o} = r;
    if (!i)
        return r;
    let a = s.slidesPerGroup;
    s.slidesPerView === "auto" && s.slidesPerGroup === 1 && s.slidesPerGroupAuto && (a = Math.max(r.slidesPerViewDynamic("current", !0), 1));
    const l = r.activeIndex < s.slidesPerGroupSkip ? 1 : a
      , f = r.virtual && s.virtual.enabled;
    if (s.loop) {
        if (o && !f && s.loopPreventsSliding)
            return !1;
        r.loopFix({
            direction: "next"
        }),
        r._clientLeft = r.wrapperEl.clientLeft
    }
    return s.rewind && r.isEnd ? r.slideTo(0, n, e, t) : r.slideTo(r.activeIndex + l, n, e, t)
}
function g8(n=this.params.speed, e=!0, t) {
    const r = this
      , {params: i, snapGrid: s, slidesGrid: o, rtlTranslate: a, enabled: l, animating: f} = r;
    if (!l)
        return r;
    const h = r.virtual && i.virtual.enabled;
    if (i.loop) {
        if (f && !h && i.loopPreventsSliding)
            return !1;
        r.loopFix({
            direction: "prev"
        }),
        r._clientLeft = r.wrapperEl.clientLeft
    }
    const d = a ? r.translate : -r.translate;
    function p(S) {
        return S < 0 ? -Math.floor(Math.abs(S)) : Math.floor(S)
    }
    const m = p(d)
      , _ = s.map(S=>p(S));
    let y = s[_.indexOf(m) - 1];
    if (typeof y > "u" && i.cssMode) {
        let S;
        s.forEach((M,w)=>{
            m >= M && (S = w)
        }
        ),
        typeof S < "u" && (y = s[S > 0 ? S - 1 : S])
    }
    let x = 0;
    if (typeof y < "u" && (x = o.indexOf(y),
    x < 0 && (x = r.activeIndex - 1),
    i.slidesPerView === "auto" && i.slidesPerGroup === 1 && i.slidesPerGroupAuto && (x = x - r.slidesPerViewDynamic("previous", !0) + 1,
    x = Math.max(x, 0))),
    i.rewind && r.isBeginning) {
        const S = r.params.virtual && r.params.virtual.enabled && r.virtual ? r.virtual.slides.length - 1 : r.slides.length - 1;
        return r.slideTo(S, n, e, t)
    }
    return r.slideTo(x, n, e, t)
}
function v8(n=this.params.speed, e=!0, t) {
    const r = this;
    return r.slideTo(r.activeIndex, n, e, t)
}
function _8(n=this.params.speed, e=!0, t, r=.5) {
    const i = this;
    let s = i.activeIndex;
    const o = Math.min(i.params.slidesPerGroupSkip, s)
      , a = o + Math.floor((s - o) / i.params.slidesPerGroup)
      , l = i.rtlTranslate ? i.translate : -i.translate;
    if (l >= i.snapGrid[a]) {
        const f = i.snapGrid[a]
          , h = i.snapGrid[a + 1];
        l - f > (h - f) * r && (s += i.params.slidesPerGroup)
    } else {
        const f = i.snapGrid[a - 1]
          , h = i.snapGrid[a];
        l - f <= (h - f) * r && (s -= i.params.slidesPerGroup)
    }
    return s = Math.max(s, 0),
    s = Math.min(s, i.slidesGrid.length - 1),
    i.slideTo(s, n, e, t)
}
function y8() {
    const n = this
      , {params: e, slidesEl: t} = n
      , r = e.slidesPerView === "auto" ? n.slidesPerViewDynamic() : e.slidesPerView;
    let i = n.clickedIndex, s;
    const o = n.isElement ? "swiper-slide" : `.${e.slideClass}`;
    if (e.loop) {
        if (n.animating)
            return;
        s = parseInt(n.clickedSlide.getAttribute("data-swiper-slide-index"), 10),
        e.centeredSlides ? i < n.loopedSlides - r / 2 || i > n.slides.length - n.loopedSlides + r / 2 ? (n.loopFix(),
        i = n.getSlideIndex(xu(t, `${o}[data-swiper-slide-index="${s}"]`)[0]),
        Ow(()=>{
            n.slideTo(i)
        }
        )) : n.slideTo(i) : i > n.slides.length - r ? (n.loopFix(),
        i = n.getSlideIndex(xu(t, `${o}[data-swiper-slide-index="${s}"]`)[0]),
        Ow(()=>{
            n.slideTo(i)
        }
        )) : n.slideTo(i)
    } else
        n.slideTo(i)
}
const x8 = {
    slideTo: h8,
    slideToLoop: p8,
    slideNext: m8,
    slidePrev: g8,
    slideReset: v8,
    slideToClosest: _8,
    slideToClickedSlide: y8
};
function w8(n) {
    const e = this
      , {params: t, slidesEl: r} = e;
    if (!t.loop || e.virtual && e.params.virtual.enabled)
        return;
    xu(r, `.${t.slideClass}, swiper-slide`).forEach((s,o)=>{
        s.setAttribute("data-swiper-slide-index", o)
    }
    ),
    e.loopFix({
        slideRealIndex: n,
        direction: t.centeredSlides ? void 0 : "next"
    })
}
function S8({slideRealIndex: n, slideTo: e=!0, direction: t, setTranslate: r, activeSlideIndex: i, byController: s, byMousewheel: o}={}) {
    const a = this;
    if (!a.params.loop)
        return;
    a.emit("beforeLoopFix");
    const {slides: l, allowSlidePrev: f, allowSlideNext: h, slidesEl: d, params: p} = a;
    if (a.allowSlidePrev = !0,
    a.allowSlideNext = !0,
    a.virtual && p.virtual.enabled) {
        e && (!p.centeredSlides && a.snapIndex === 0 ? a.slideTo(a.virtual.slides.length, 0, !1, !0) : p.centeredSlides && a.snapIndex < p.slidesPerView ? a.slideTo(a.virtual.slides.length + a.snapIndex, 0, !1, !0) : a.snapIndex === a.snapGrid.length - 1 && a.slideTo(a.virtual.slidesBefore, 0, !1, !0)),
        a.allowSlidePrev = f,
        a.allowSlideNext = h,
        a.emit("loopFix");
        return
    }
    const m = p.slidesPerView === "auto" ? a.slidesPerViewDynamic() : Math.ceil(parseFloat(p.slidesPerView, 10));
    let _ = p.loopedSlides || m;
    _ % p.slidesPerGroup !== 0 && (_ += p.slidesPerGroup - _ % p.slidesPerGroup),
    a.loopedSlides = _;
    const y = []
      , x = [];
    let S = a.activeIndex;
    typeof i > "u" ? i = a.getSlideIndex(a.slides.filter(I=>I.classList.contains(p.slideActiveClass))[0]) : S = i;
    const M = t === "next" || !t
      , w = t === "prev" || !t;
    let T = 0
      , P = 0;
    if (i < _) {
        T = Math.max(_ - i, p.slidesPerGroup);
        for (let I = 0; I < _ - i; I += 1) {
            const k = I - Math.floor(I / l.length) * l.length;
            y.push(l.length - k - 1)
        }
    } else if (i > a.slides.length - _ * 2) {
        P = Math.max(i - (a.slides.length - _ * 2), p.slidesPerGroup);
        for (let I = 0; I < P; I += 1) {
            const k = I - Math.floor(I / l.length) * l.length;
            x.push(k)
        }
    }
    if (w && y.forEach(I=>{
        d.prepend(a.slides[I])
    }
    ),
    M && x.forEach(I=>{
        d.append(a.slides[I])
    }
    ),
    a.recalcSlides(),
    p.watchSlidesProgress && a.updateSlidesOffset(),
    e) {
        if (y.length > 0 && w)
            if (typeof n > "u") {
                const I = a.slidesGrid[S]
                  , R = a.slidesGrid[S + T] - I;
                o ? a.setTranslate(a.translate - R) : (a.slideTo(S + T, 0, !1, !0),
                r && (a.touches[a.isHorizontal() ? "startX" : "startY"] += R))
            } else
                r && a.slideToLoop(n, 0, !1, !0);
        else if (x.length > 0 && M)
            if (typeof n > "u") {
                const I = a.slidesGrid[S]
                  , R = a.slidesGrid[S - P] - I;
                o ? a.setTranslate(a.translate - R) : (a.slideTo(S - P, 0, !1, !0),
                r && (a.touches[a.isHorizontal() ? "startX" : "startY"] += R))
            } else
                a.slideToLoop(n, 0, !1, !0)
    }
    if (a.allowSlidePrev = f,
    a.allowSlideNext = h,
    a.controller && a.controller.control && !s) {
        const I = {
            slideRealIndex: n,
            slideTo: !1,
            direction: t,
            setTranslate: r,
            activeSlideIndex: i,
            byController: !0
        };
        Array.isArray(a.controller.control) ? a.controller.control.forEach(k=>{
            !k.destroyed && k.params.loop && k.loopFix(I)
        }
        ) : a.controller.control instanceof a.constructor && a.controller.control.params.loop && a.controller.control.loopFix(I)
    }
    a.emit("loopFix")
}
function M8() {
    const n = this
      , {params: e, slidesEl: t} = n;
    if (!e.loop || n.virtual && n.params.virtual.enabled)
        return;
    n.recalcSlides();
    const r = [];
    n.slides.forEach(i=>{
        const s = typeof i.swiperSlideIndex > "u" ? i.getAttribute("data-swiper-slide-index") * 1 : i.swiperSlideIndex;
        r[s] = i
    }
    ),
    n.slides.forEach(i=>{
        i.removeAttribute("data-swiper-slide-index")
    }
    ),
    r.forEach(i=>{
        t.append(i)
    }
    ),
    n.recalcSlides(),
    n.slideTo(n.realIndex, 0)
}
const A8 = {
    loopCreate: w8,
    loopFix: S8,
    loopDestroy: M8
};
function C8(n) {
    const e = this;
    if (!e.params.simulateTouch || e.params.watchOverflow && e.isLocked || e.params.cssMode)
        return;
    const t = e.params.touchEventsTarget === "container" ? e.el : e.wrapperEl;
    e.isElement && (e.__preventObserver__ = !0),
    t.style.cursor = "move",
    t.style.cursor = n ? "grabbing" : "grab",
    e.isElement && requestAnimationFrame(()=>{
        e.__preventObserver__ = !1
    }
    )
}
function E8() {
    const n = this;
    n.params.watchOverflow && n.isLocked || n.params.cssMode || (n.isElement && (n.__preventObserver__ = !0),
    n[n.params.touchEventsTarget === "container" ? "el" : "wrapperEl"].style.cursor = "",
    n.isElement && requestAnimationFrame(()=>{
        n.__preventObserver__ = !1
    }
    ))
}
const b8 = {
    setGrabCursor: C8,
    unsetGrabCursor: E8
};
function T8(n, e=this) {
    function t(r) {
        if (!r || r === nd() || r === ba())
            return null;
        r.assignedSlot && (r = r.assignedSlot);
        const i = r.closest(n);
        return !i && !r.getRootNode ? null : i || t(r.getRootNode().host)
    }
    return t(e)
}
function D8(n) {
    const e = this
      , t = nd()
      , r = ba()
      , i = e.touchEventsData;
    i.evCache.push(n);
    const {params: s, touches: o, enabled: a} = e;
    if (!a || !s.simulateTouch && n.pointerType === "mouse" || e.animating && s.preventInteractionOnTransition)
        return;
    !e.animating && s.cssMode && s.loop && e.loopFix();
    let l = n;
    l.originalEvent && (l = l.originalEvent);
    let f = l.target;
    if (s.touchEventsTarget === "wrapper" && !e.wrapperEl.contains(f) || "which"in l && l.which === 3 || "button"in l && l.button > 0 || i.isTouched && i.isMoved)
        return;
    const h = !!s.noSwipingClass && s.noSwipingClass !== ""
      , d = n.composedPath ? n.composedPath() : n.path;
    h && l.target && l.target.shadowRoot && d && (f = d[0]);
    const p = s.noSwipingSelector ? s.noSwipingSelector : `.${s.noSwipingClass}`
      , m = !!(l.target && l.target.shadowRoot);
    if (s.noSwiping && (m ? T8(p, f) : f.closest(p))) {
        e.allowClick = !0;
        return
    }
    if (s.swipeHandler && !f.closest(s.swipeHandler))
        return;
    o.currentX = l.pageX,
    o.currentY = l.pageY;
    const _ = o.currentX
      , y = o.currentY
      , x = s.edgeSwipeDetection || s.iOSEdgeSwipeDetection
      , S = s.edgeSwipeThreshold || s.iOSEdgeSwipeThreshold;
    if (x && (_ <= S || _ >= r.innerWidth - S))
        if (x === "prevent")
            n.preventDefault();
        else
            return;
    Object.assign(i, {
        isTouched: !0,
        isMoved: !1,
        allowTouchCallbacks: !0,
        isScrolling: void 0,
        startMoving: void 0
    }),
    o.startX = _,
    o.startY = y,
    i.touchStartTime = Tm(),
    e.allowClick = !0,
    e.updateSize(),
    e.swipeDirection = void 0,
    s.threshold > 0 && (i.allowThresholdMove = !1);
    let M = !0;
    f.matches(i.focusableElements) && (M = !1,
    f.nodeName === "SELECT" && (i.isTouched = !1)),
    t.activeElement && t.activeElement.matches(i.focusableElements) && t.activeElement !== f && t.activeElement.blur();
    const w = M && e.allowTouchMove && s.touchStartPreventDefault;
    (s.touchStartForcePreventDefault || w) && !f.isContentEditable && l.preventDefault(),
    e.params.freeMode && e.params.freeMode.enabled && e.freeMode && e.animating && !s.cssMode && e.freeMode.onTouchStart(),
    e.emit("touchStart", l)
}
function P8(n) {
    const e = nd()
      , t = this
      , r = t.touchEventsData
      , {params: i, touches: s, rtlTranslate: o, enabled: a} = t;
    if (!a || !i.simulateTouch && n.pointerType === "mouse")
        return;
    let l = n;
    if (l.originalEvent && (l = l.originalEvent),
    !r.isTouched) {
        r.startMoving && r.isScrolling && t.emit("touchMoveOpposite", l);
        return
    }
    const f = r.evCache.findIndex(I=>I.pointerId === l.pointerId);
    f >= 0 && (r.evCache[f] = l);
    const h = r.evCache.length > 1 ? r.evCache[0] : l
      , d = h.pageX
      , p = h.pageY;
    if (l.preventedByNestedSwiper) {
        s.startX = d,
        s.startY = p;
        return
    }
    if (!t.allowTouchMove) {
        l.target.matches(r.focusableElements) || (t.allowClick = !1),
        r.isTouched && (Object.assign(s, {
            startX: d,
            startY: p,
            prevX: t.touches.currentX,
            prevY: t.touches.currentY,
            currentX: d,
            currentY: p
        }),
        r.touchStartTime = Tm());
        return
    }
    if (i.touchReleaseOnEdges && !i.loop) {
        if (t.isVertical()) {
            if (p < s.startY && t.translate <= t.maxTranslate() || p > s.startY && t.translate >= t.minTranslate()) {
                r.isTouched = !1,
                r.isMoved = !1;
                return
            }
        } else if (d < s.startX && t.translate <= t.maxTranslate() || d > s.startX && t.translate >= t.minTranslate())
            return
    }
    if (e.activeElement && l.target === e.activeElement && l.target.matches(r.focusableElements)) {
        r.isMoved = !0,
        t.allowClick = !1;
        return
    }
    if (r.allowTouchCallbacks && t.emit("touchMove", l),
    l.targetTouches && l.targetTouches.length > 1)
        return;
    s.currentX = d,
    s.currentY = p;
    const m = s.currentX - s.startX
      , _ = s.currentY - s.startY;
    if (t.params.threshold && Math.sqrt(m ** 2 + _ ** 2) < t.params.threshold)
        return;
    if (typeof r.isScrolling > "u") {
        let I;
        t.isHorizontal() && s.currentY === s.startY || t.isVertical() && s.currentX === s.startX ? r.isScrolling = !1 : m * m + _ * _ >= 25 && (I = Math.atan2(Math.abs(_), Math.abs(m)) * 180 / Math.PI,
        r.isScrolling = t.isHorizontal() ? I > i.touchAngle : 90 - I > i.touchAngle)
    }
    if (r.isScrolling && t.emit("touchMoveOpposite", l),
    typeof r.startMoving > "u" && (s.currentX !== s.startX || s.currentY !== s.startY) && (r.startMoving = !0),
    r.isScrolling || t.zoom && t.params.zoom && t.params.zoom.enabled && r.evCache.length > 1) {
        r.isTouched = !1;
        return
    }
    if (!r.startMoving)
        return;
    t.allowClick = !1,
    !i.cssMode && l.cancelable && l.preventDefault(),
    i.touchMoveStopPropagation && !i.nested && l.stopPropagation();
    let y = t.isHorizontal() ? m : _
      , x = t.isHorizontal() ? s.currentX - s.previousX : s.currentY - s.previousY;
    i.oneWayMovement && (y = Math.abs(y) * (o ? 1 : -1),
    x = Math.abs(x) * (o ? 1 : -1)),
    s.diff = y,
    y *= i.touchRatio,
    o && (y = -y,
    x = -x);
    const S = t.touchesDirection;
    t.swipeDirection = y > 0 ? "prev" : "next",
    t.touchesDirection = x > 0 ? "prev" : "next";
    const M = t.params.loop && !i.cssMode;
    if (!r.isMoved) {
        if (M && t.loopFix({
            direction: t.swipeDirection
        }),
        r.startTranslate = t.getTranslate(),
        t.setTransition(0),
        t.animating) {
            const I = new window.CustomEvent("transitionend",{
                bubbles: !0,
                cancelable: !0
            });
            t.wrapperEl.dispatchEvent(I)
        }
        r.allowMomentumBounce = !1,
        i.grabCursor && (t.allowSlideNext === !0 || t.allowSlidePrev === !0) && t.setGrabCursor(!0),
        t.emit("sliderFirstMove", l)
    }
    let w;
    r.isMoved && S !== t.touchesDirection && M && Math.abs(y) >= 1 && (t.loopFix({
        direction: t.swipeDirection,
        setTranslate: !0
    }),
    w = !0),
    t.emit("sliderMove", l),
    r.isMoved = !0,
    r.currentTranslate = y + r.startTranslate;
    let T = !0
      , P = i.resistanceRatio;
    if (i.touchReleaseOnEdges && (P = 0),
    y > 0 ? (M && !w && r.currentTranslate > (i.centeredSlides ? t.minTranslate() - t.size / 2 : t.minTranslate()) && t.loopFix({
        direction: "prev",
        setTranslate: !0,
        activeSlideIndex: 0
    }),
    r.currentTranslate > t.minTranslate() && (T = !1,
    i.resistance && (r.currentTranslate = t.minTranslate() - 1 + (-t.minTranslate() + r.startTranslate + y) ** P))) : y < 0 && (M && !w && r.currentTranslate < (i.centeredSlides ? t.maxTranslate() + t.size / 2 : t.maxTranslate()) && t.loopFix({
        direction: "next",
        setTranslate: !0,
        activeSlideIndex: t.slides.length - (i.slidesPerView === "auto" ? t.slidesPerViewDynamic() : Math.ceil(parseFloat(i.slidesPerView, 10)))
    }),
    r.currentTranslate < t.maxTranslate() && (T = !1,
    i.resistance && (r.currentTranslate = t.maxTranslate() + 1 - (t.maxTranslate() - r.startTranslate - y) ** P))),
    T && (l.preventedByNestedSwiper = !0),
    !t.allowSlideNext && t.swipeDirection === "next" && r.currentTranslate < r.startTranslate && (r.currentTranslate = r.startTranslate),
    !t.allowSlidePrev && t.swipeDirection === "prev" && r.currentTranslate > r.startTranslate && (r.currentTranslate = r.startTranslate),
    !t.allowSlidePrev && !t.allowSlideNext && (r.currentTranslate = r.startTranslate),
    i.threshold > 0)
        if (Math.abs(y) > i.threshold || r.allowThresholdMove) {
            if (!r.allowThresholdMove) {
                r.allowThresholdMove = !0,
                s.startX = s.currentX,
                s.startY = s.currentY,
                r.currentTranslate = r.startTranslate,
                s.diff = t.isHorizontal() ? s.currentX - s.startX : s.currentY - s.startY;
                return
            }
        } else {
            r.currentTranslate = r.startTranslate;
            return
        }
    !i.followFinger || i.cssMode || ((i.freeMode && i.freeMode.enabled && t.freeMode || i.watchSlidesProgress) && (t.updateActiveIndex(),
    t.updateSlidesClasses()),
    t.params.freeMode && i.freeMode.enabled && t.freeMode && t.freeMode.onTouchMove(),
    t.updateProgress(r.currentTranslate),
    t.setTranslate(r.currentTranslate))
}
function R8(n) {
    const e = this
      , t = e.touchEventsData
      , r = t.evCache.findIndex(w=>w.pointerId === n.pointerId);
    if (r >= 0 && t.evCache.splice(r, 1),
    ["pointercancel", "pointerout", "pointerleave"].includes(n.type) && !(n.type === "pointercancel" && (e.browser.isSafari || e.browser.isWebView)))
        return;
    const {params: i, touches: s, rtlTranslate: o, slidesGrid: a, enabled: l} = e;
    if (!l || !i.simulateTouch && n.pointerType === "mouse")
        return;
    let f = n;
    if (f.originalEvent && (f = f.originalEvent),
    t.allowTouchCallbacks && e.emit("touchEnd", f),
    t.allowTouchCallbacks = !1,
    !t.isTouched) {
        t.isMoved && i.grabCursor && e.setGrabCursor(!1),
        t.isMoved = !1,
        t.startMoving = !1;
        return
    }
    i.grabCursor && t.isMoved && t.isTouched && (e.allowSlideNext === !0 || e.allowSlidePrev === !0) && e.setGrabCursor(!1);
    const h = Tm()
      , d = h - t.touchStartTime;
    if (e.allowClick) {
        const w = f.path || f.composedPath && f.composedPath();
        e.updateClickedSlide(w && w[0] || f.target),
        e.emit("tap click", f),
        d < 300 && h - t.lastClickTime < 300 && e.emit("doubleTap doubleClick", f)
    }
    if (t.lastClickTime = Tm(),
    Ow(()=>{
        e.destroyed || (e.allowClick = !0)
    }
    ),
    !t.isTouched || !t.isMoved || !e.swipeDirection || s.diff === 0 || t.currentTranslate === t.startTranslate) {
        t.isTouched = !1,
        t.isMoved = !1,
        t.startMoving = !1;
        return
    }
    t.isTouched = !1,
    t.isMoved = !1,
    t.startMoving = !1;
    let p;
    if (i.followFinger ? p = o ? e.translate : -e.translate : p = -t.currentTranslate,
    i.cssMode)
        return;
    if (e.params.freeMode && i.freeMode.enabled) {
        e.freeMode.onTouchEnd({
            currentPos: p
        });
        return
    }
    let m = 0
      , _ = e.slidesSizesGrid[0];
    for (let w = 0; w < a.length; w += w < i.slidesPerGroupSkip ? 1 : i.slidesPerGroup) {
        const T = w < i.slidesPerGroupSkip - 1 ? 1 : i.slidesPerGroup;
        typeof a[w + T] < "u" ? p >= a[w] && p < a[w + T] && (m = w,
        _ = a[w + T] - a[w]) : p >= a[w] && (m = w,
        _ = a[a.length - 1] - a[a.length - 2])
    }
    let y = null
      , x = null;
    i.rewind && (e.isBeginning ? x = e.params.virtual && e.params.virtual.enabled && e.virtual ? e.virtual.slides.length - 1 : e.slides.length - 1 : e.isEnd && (y = 0));
    const S = (p - a[m]) / _
      , M = m < i.slidesPerGroupSkip - 1 ? 1 : i.slidesPerGroup;
    if (d > i.longSwipesMs) {
        if (!i.longSwipes) {
            e.slideTo(e.activeIndex);
            return
        }
        e.swipeDirection === "next" && (S >= i.longSwipesRatio ? e.slideTo(i.rewind && e.isEnd ? y : m + M) : e.slideTo(m)),
        e.swipeDirection === "prev" && (S > 1 - i.longSwipesRatio ? e.slideTo(m + M) : x !== null && S < 0 && Math.abs(S) > i.longSwipesRatio ? e.slideTo(x) : e.slideTo(m))
    } else {
        if (!i.shortSwipes) {
            e.slideTo(e.activeIndex);
            return
        }
        e.navigation && (f.target === e.navigation.nextEl || f.target === e.navigation.prevEl) ? f.target === e.navigation.nextEl ? e.slideTo(m + M) : e.slideTo(m) : (e.swipeDirection === "next" && e.slideTo(y !== null ? y : m + M),
        e.swipeDirection === "prev" && e.slideTo(x !== null ? x : m))
    }
}
let Nb;
function zb() {
    const n = this
      , {params: e, el: t} = n;
    if (t && t.offsetWidth === 0)
        return;
    e.breakpoints && n.setBreakpoint();
    const {allowSlideNext: r, allowSlidePrev: i, snapGrid: s} = n
      , o = n.virtual && n.params.virtual.enabled;
    n.allowSlideNext = !0,
    n.allowSlidePrev = !0,
    n.updateSize(),
    n.updateSlides(),
    n.updateSlidesClasses();
    const a = o && e.loop;
    (e.slidesPerView === "auto" || e.slidesPerView > 1) && n.isEnd && !n.isBeginning && !n.params.centeredSlides && !a ? n.slideTo(n.slides.length - 1, 0, !1, !0) : n.params.loop && !o ? n.slideToLoop(n.realIndex, 0, !1, !0) : n.slideTo(n.activeIndex, 0, !1, !0),
    n.autoplay && n.autoplay.running && n.autoplay.paused && (clearTimeout(Nb),
    Nb = setTimeout(()=>{
        n.autoplay && n.autoplay.running && n.autoplay.paused && n.autoplay.resume()
    }
    , 500)),
    n.allowSlidePrev = i,
    n.allowSlideNext = r,
    n.params.watchOverflow && s !== n.snapGrid && n.checkOverflow()
}
function B8(n) {
    const e = this;
    e.enabled && (e.allowClick || (e.params.preventClicks && n.preventDefault(),
    e.params.preventClicksPropagation && e.animating && (n.stopPropagation(),
    n.stopImmediatePropagation())))
}
function I8() {
    const n = this
      , {wrapperEl: e, rtlTranslate: t, enabled: r} = n;
    if (!r)
        return;
    n.previousTranslate = n.translate,
    n.isHorizontal() ? n.translate = -e.scrollLeft : n.translate = -e.scrollTop,
    n.translate === 0 && (n.translate = 0),
    n.updateActiveIndex(),
    n.updateSlidesClasses();
    let i;
    const s = n.maxTranslate() - n.minTranslate();
    s === 0 ? i = 0 : i = (n.translate - n.minTranslate()) / s,
    i !== n.progress && n.updateProgress(t ? -n.translate : n.translate),
    n.emit("setTranslate", n.translate, !1)
}
const vv = (n,e)=>{
    if (!n || n.destroyed || !n.params)
        return;
    const t = ()=>n.isElement ? "swiper-slide" : `.${n.params.slideClass}`
      , r = e.closest(t());
    if (r) {
        const i = r.querySelector(`.${n.params.lazyPreloaderClass}`);
        i && i.remove()
    }
}
;
function L8(n) {
    const e = this;
    vv(e, n.target),
    e.update()
}
let Gb = !1;
function F8() {}
const iR = (n,e)=>{
    const t = nd()
      , {params: r, el: i, wrapperEl: s, device: o} = n
      , a = !!r.nested
      , l = e === "on" ? "addEventListener" : "removeEventListener"
      , f = e;
    i[l]("pointerdown", n.onTouchStart, {
        passive: !1
    }),
    t[l]("pointermove", n.onTouchMove, {
        passive: !1,
        capture: a
    }),
    t[l]("pointerup", n.onTouchEnd, {
        passive: !0
    }),
    t[l]("pointercancel", n.onTouchEnd, {
        passive: !0
    }),
    t[l]("pointerout", n.onTouchEnd, {
        passive: !0
    }),
    t[l]("pointerleave", n.onTouchEnd, {
        passive: !0
    }),
    (r.preventClicks || r.preventClicksPropagation) && i[l]("click", n.onClick, !0),
    r.cssMode && s[l]("scroll", n.onScroll),
    r.updateOnWindowResize ? n[f](o.ios || o.android ? "resize orientationchange observerUpdate" : "resize observerUpdate", zb, !0) : n[f]("observerUpdate", zb, !0),
    i[l]("load", n.onLoad, {
        capture: !0
    })
}
;
function k8() {
    const n = this
      , e = nd()
      , {params: t} = n;
    n.onTouchStart = D8.bind(n),
    n.onTouchMove = P8.bind(n),
    n.onTouchEnd = R8.bind(n),
    t.cssMode && (n.onScroll = I8.bind(n)),
    n.onClick = B8.bind(n),
    n.onLoad = L8.bind(n),
    Gb || (e.addEventListener("touchstart", F8),
    Gb = !0),
    iR(n, "on")
}
function O8() {
    iR(this, "off")
}
const N8 = {
    attachEvents: k8,
    detachEvents: O8
}
  , Ub = (n,e)=>n.grid && e.grid && e.grid.rows > 1;
function z8() {
    const n = this
      , {realIndex: e, initialized: t, params: r, el: i} = n
      , s = r.breakpoints;
    if (!s || s && Object.keys(s).length === 0)
        return;
    const o = n.getBreakpoint(s, n.params.breakpointsBase, n.el);
    if (!o || n.currentBreakpoint === o)
        return;
    const l = (o in s ? s[o] : void 0) || n.originalParams
      , f = Ub(n, r)
      , h = Ub(n, l)
      , d = r.enabled;
    f && !h ? (i.classList.remove(`${r.containerModifierClass}grid`, `${r.containerModifierClass}grid-column`),
    n.emitContainerClasses()) : !f && h && (i.classList.add(`${r.containerModifierClass}grid`),
    (l.grid.fill && l.grid.fill === "column" || !l.grid.fill && r.grid.fill === "column") && i.classList.add(`${r.containerModifierClass}grid-column`),
    n.emitContainerClasses()),
    ["navigation", "pagination", "scrollbar"].forEach(y=>{
        const x = r[y] && r[y].enabled
          , S = l[y] && l[y].enabled;
        x && !S && n[y].disable(),
        !x && S && n[y].enable()
    }
    );
    const p = l.direction && l.direction !== r.direction
      , m = r.loop && (l.slidesPerView !== r.slidesPerView || p);
    p && t && n.changeDirection(),
    ma(n.params, l);
    const _ = n.params.enabled;
    Object.assign(n, {
        allowTouchMove: n.params.allowTouchMove,
        allowSlideNext: n.params.allowSlideNext,
        allowSlidePrev: n.params.allowSlidePrev
    }),
    d && !_ ? n.disable() : !d && _ && n.enable(),
    n.currentBreakpoint = o,
    n.emit("_beforeBreakpoint", l),
    m && t && (n.loopDestroy(),
    n.loopCreate(e),
    n.updateSlides()),
    n.emit("breakpoint", l)
}
function G8(n, e="window", t) {
    if (!n || e === "container" && !t)
        return;
    let r = !1;
    const i = ba()
      , s = e === "window" ? i.innerHeight : t.clientHeight
      , o = Object.keys(n).map(a=>{
        if (typeof a == "string" && a.indexOf("@") === 0) {
            const l = parseFloat(a.substr(1));
            return {
                value: s * l,
                point: a
            }
        }
        return {
            value: a,
            point: a
        }
    }
    );
    o.sort((a,l)=>parseInt(a.value, 10) - parseInt(l.value, 10));
    for (let a = 0; a < o.length; a += 1) {
        const {point: l, value: f} = o[a];
        e === "window" ? i.matchMedia(`(min-width: ${f}px)`).matches && (r = l) : f <= t.clientWidth && (r = l)
    }
    return r || "max"
}
const U8 = {
    setBreakpoint: z8,
    getBreakpoint: G8
};
function H8(n, e) {
    const t = [];
    return n.forEach(r=>{
        typeof r == "object" ? Object.keys(r).forEach(i=>{
            r[i] && t.push(e + i)
        }
        ) : typeof r == "string" && t.push(e + r)
    }
    ),
    t
}
function V8() {
    const n = this
      , {classNames: e, params: t, rtl: r, el: i, device: s} = n
      , o = H8(["initialized", t.direction, {
        "free-mode": n.params.freeMode && t.freeMode.enabled
    }, {
        autoheight: t.autoHeight
    }, {
        rtl: r
    }, {
        grid: t.grid && t.grid.rows > 1
    }, {
        "grid-column": t.grid && t.grid.rows > 1 && t.grid.fill === "column"
    }, {
        android: s.android
    }, {
        ios: s.ios
    }, {
        "css-mode": t.cssMode
    }, {
        centered: t.cssMode && t.centeredSlides
    }, {
        "watch-progress": t.watchSlidesProgress
    }], t.containerModifierClass);
    e.push(...o),
    i.classList.add(...e),
    n.emitContainerClasses()
}
function W8() {
    const n = this
      , {el: e, classNames: t} = n;
    e.classList.remove(...t),
    n.emitContainerClasses()
}
const X8 = {
    addClasses: V8,
    removeClasses: W8
};
function J8() {
    const n = this
      , {isLocked: e, params: t} = n
      , {slidesOffsetBefore: r} = t;
    if (r) {
        const i = n.slides.length - 1
          , s = n.slidesGrid[i] + n.slidesSizesGrid[i] + r * 2;
        n.isLocked = n.size > s
    } else
        n.isLocked = n.snapGrid.length === 1;
    t.allowSlideNext === !0 && (n.allowSlideNext = !n.isLocked),
    t.allowSlidePrev === !0 && (n.allowSlidePrev = !n.isLocked),
    e && e !== n.isLocked && (n.isEnd = !1),
    e !== n.isLocked && n.emit(n.isLocked ? "lock" : "unlock")
}
const j8 = {
    checkOverflow: J8
}
  , Hb = {
    init: !0,
    direction: "horizontal",
    oneWayMovement: !1,
    touchEventsTarget: "wrapper",
    initialSlide: 0,
    speed: 300,
    cssMode: !1,
    updateOnWindowResize: !0,
    resizeObserver: !0,
    nested: !1,
    createElements: !1,
    enabled: !0,
    focusableElements: "input, select, option, textarea, button, video, label",
    width: null,
    height: null,
    preventInteractionOnTransition: !1,
    userAgent: null,
    url: null,
    edgeSwipeDetection: !1,
    edgeSwipeThreshold: 20,
    autoHeight: !1,
    setWrapperSize: !1,
    virtualTranslate: !1,
    effect: "slide",
    breakpoints: void 0,
    breakpointsBase: "window",
    spaceBetween: 0,
    slidesPerView: 1,
    slidesPerGroup: 1,
    slidesPerGroupSkip: 0,
    slidesPerGroupAuto: !1,
    centeredSlides: !1,
    centeredSlidesBounds: !1,
    slidesOffsetBefore: 0,
    slidesOffsetAfter: 0,
    normalizeSlideIndex: !0,
    centerInsufficientSlides: !1,
    watchOverflow: !0,
    roundLengths: !1,
    touchRatio: 1,
    touchAngle: 45,
    simulateTouch: !0,
    shortSwipes: !0,
    longSwipes: !0,
    longSwipesRatio: .5,
    longSwipesMs: 300,
    followFinger: !0,
    allowTouchMove: !0,
    threshold: 5,
    touchMoveStopPropagation: !1,
    touchStartPreventDefault: !0,
    touchStartForcePreventDefault: !1,
    touchReleaseOnEdges: !1,
    uniqueNavElements: !0,
    resistance: !0,
    resistanceRatio: .85,
    watchSlidesProgress: !1,
    grabCursor: !1,
    preventClicks: !0,
    preventClicksPropagation: !0,
    slideToClickedSlide: !1,
    loop: !1,
    loopedSlides: null,
    loopPreventsSliding: !0,
    rewind: !1,
    allowSlidePrev: !0,
    allowSlideNext: !0,
    swipeHandler: null,
    noSwiping: !0,
    noSwipingClass: "swiper-no-swiping",
    noSwipingSelector: null,
    passiveListeners: !0,
    maxBackfaceHiddenSlides: 10,
    containerModifierClass: "swiper-",
    slideClass: "swiper-slide",
    slideActiveClass: "swiper-slide-active",
    slideVisibleClass: "swiper-slide-visible",
    slideNextClass: "swiper-slide-next",
    slidePrevClass: "swiper-slide-prev",
    wrapperClass: "swiper-wrapper",
    lazyPreloaderClass: "swiper-lazy-preloader",
    runCallbacksOnInit: !0,
    _emitClasses: !1
};
function Y8(n, e) {
    return function(r={}) {
        const i = Object.keys(r)[0]
          , s = r[i];
        if (typeof s != "object" || s === null) {
            ma(e, r);
            return
        }
        if (["navigation", "pagination", "scrollbar"].indexOf(i) >= 0 && n[i] === !0 && (n[i] = {
            auto: !0
        }),
        !(i in n && "enabled"in s)) {
            ma(e, r);
            return
        }
        n[i] === !0 && (n[i] = {
            enabled: !0
        }),
        typeof n[i] == "object" && !("enabled"in n[i]) && (n[i].enabled = !0),
        n[i] || (n[i] = {
            enabled: !1
        }),
        ma(e, r)
    }
}
const Nx = {
    eventsEmitter: XH,
    update: n8,
    translate: l8,
    transition: d8,
    slide: x8,
    loop: A8,
    grabCursor: b8,
    events: N8,
    breakpoints: U8,
    checkOverflow: j8,
    classes: X8
}
  , zx = {};
class Ua {
    constructor(...e) {
        let t, r;
        e.length === 1 && e[0].constructor && Object.prototype.toString.call(e[0]).slice(8, -1) === "Object" ? r = e[0] : [t,r] = e,
        r || (r = {}),
        r = ma({}, r),
        t && !r.el && (r.el = t);
        const i = nd();
        if (r.el && typeof r.el == "string" && i.querySelectorAll(r.el).length > 1) {
            const l = [];
            return i.querySelectorAll(r.el).forEach(f=>{
                const h = ma({}, r, {
                    el: f
                });
                l.push(new Ua(h))
            }
            ),
            l
        }
        const s = this;
        s.__swiper__ = !0,
        s.support = nR(),
        s.device = GH({
            userAgent: r.userAgent
        }),
        s.browser = HH(),
        s.eventsListeners = {},
        s.eventsAnyListeners = [],
        s.modules = [...s.__modules__],
        r.modules && Array.isArray(r.modules) && s.modules.push(...r.modules);
        const o = {};
        s.modules.forEach(l=>{
            l({
                params: r,
                swiper: s,
                extendParams: Y8(r, o),
                on: s.on.bind(s),
                once: s.once.bind(s),
                off: s.off.bind(s),
                emit: s.emit.bind(s)
            })
        }
        );
        const a = ma({}, Hb, o);
        return s.params = ma({}, a, zx, r),
        s.originalParams = ma({}, s.params),
        s.passedParams = ma({}, r),
        s.params && s.params.on && Object.keys(s.params.on).forEach(l=>{
            s.on(l, s.params.on[l])
        }
        ),
        s.params && s.params.onAny && s.onAny(s.params.onAny),
        Object.assign(s, {
            enabled: s.params.enabled,
            el: t,
            classNames: [],
            slides: [],
            slidesGrid: [],
            snapGrid: [],
            slidesSizesGrid: [],
            isHorizontal() {
                return s.params.direction === "horizontal"
            },
            isVertical() {
                return s.params.direction === "vertical"
            },
            activeIndex: 0,
            realIndex: 0,
            isBeginning: !0,
            isEnd: !1,
            translate: 0,
            previousTranslate: 0,
            progress: 0,
            velocity: 0,
            animating: !1,
            allowSlideNext: s.params.allowSlideNext,
            allowSlidePrev: s.params.allowSlidePrev,
            touchEventsData: {
                isTouched: void 0,
                isMoved: void 0,
                allowTouchCallbacks: void 0,
                touchStartTime: void 0,
                isScrolling: void 0,
                currentTranslate: void 0,
                startTranslate: void 0,
                allowThresholdMove: void 0,
                focusableElements: s.params.focusableElements,
                lastClickTime: Tm(),
                clickTimeout: void 0,
                velocities: [],
                allowMomentumBounce: void 0,
                startMoving: void 0,
                evCache: []
            },
            allowClick: !0,
            allowTouchMove: s.params.allowTouchMove,
            touches: {
                startX: 0,
                startY: 0,
                currentX: 0,
                currentY: 0,
                diff: 0
            },
            imagesToLoad: [],
            imagesLoaded: 0
        }),
        s.emit("_swiper"),
        s.params.init && s.init(),
        s
    }
    getSlideIndex(e) {
        const {slidesEl: t, params: r} = this
          , i = xu(t, `.${r.slideClass}, swiper-slide`)
          , s = kb(i[0]);
        return kb(e) - s
    }
    getSlideIndexByData(e) {
        return this.getSlideIndex(this.slides.filter(t=>t.getAttribute("data-swiper-slide-index") * 1 === e)[0])
    }
    recalcSlides() {
        const e = this
          , {slidesEl: t, params: r} = e;
        e.slides = xu(t, `.${r.slideClass}, swiper-slide`)
    }
    enable() {
        const e = this;
        e.enabled || (e.enabled = !0,
        e.params.grabCursor && e.setGrabCursor(),
        e.emit("enable"))
    }
    disable() {
        const e = this;
        e.enabled && (e.enabled = !1,
        e.params.grabCursor && e.unsetGrabCursor(),
        e.emit("disable"))
    }
    setProgress(e, t) {
        const r = this;
        e = Math.min(Math.max(e, 0), 1);
        const i = r.minTranslate()
          , o = (r.maxTranslate() - i) * e + i;
        r.translateTo(o, typeof t > "u" ? 0 : t),
        r.updateActiveIndex(),
        r.updateSlidesClasses()
    }
    emitContainerClasses() {
        const e = this;
        if (!e.params._emitClasses || !e.el)
            return;
        const t = e.el.className.split(" ").filter(r=>r.indexOf("swiper") === 0 || r.indexOf(e.params.containerModifierClass) === 0);
        e.emit("_containerClasses", t.join(" "))
    }
    getSlideClasses(e) {
        const t = this;
        return t.destroyed ? "" : e.className.split(" ").filter(r=>r.indexOf("swiper-slide") === 0 || r.indexOf(t.params.slideClass) === 0).join(" ")
    }
    emitSlidesClasses() {
        const e = this;
        if (!e.params._emitClasses || !e.el)
            return;
        const t = [];
        e.slides.forEach(r=>{
            const i = e.getSlideClasses(r);
            t.push({
                slideEl: r,
                classNames: i
            }),
            e.emit("_slideClass", r, i)
        }
        ),
        e.emit("_slideClasses", t)
    }
    slidesPerViewDynamic(e="current", t=!1) {
        const r = this
          , {params: i, slides: s, slidesGrid: o, slidesSizesGrid: a, size: l, activeIndex: f} = r;
        let h = 1;
        if (i.centeredSlides) {
            let d = s[f].swiperSlideSize, p;
            for (let m = f + 1; m < s.length; m += 1)
                s[m] && !p && (d += s[m].swiperSlideSize,
                h += 1,
                d > l && (p = !0));
            for (let m = f - 1; m >= 0; m -= 1)
                s[m] && !p && (d += s[m].swiperSlideSize,
                h += 1,
                d > l && (p = !0))
        } else if (e === "current")
            for (let d = f + 1; d < s.length; d += 1)
                (t ? o[d] + a[d] - o[f] < l : o[d] - o[f] < l) && (h += 1);
        else
            for (let d = f - 1; d >= 0; d -= 1)
                o[f] - o[d] < l && (h += 1);
        return h
    }
    update() {
        const e = this;
        if (!e || e.destroyed)
            return;
        const {snapGrid: t, params: r} = e;
        r.breakpoints && e.setBreakpoint(),
        [...e.el.querySelectorAll('[loading="lazy"]')].forEach(o=>{
            o.complete && vv(e, o)
        }
        ),
        e.updateSize(),
        e.updateSlides(),
        e.updateProgress(),
        e.updateSlidesClasses();
        function i() {
            const o = e.rtlTranslate ? e.translate * -1 : e.translate
              , a = Math.min(Math.max(o, e.maxTranslate()), e.minTranslate());
            e.setTranslate(a),
            e.updateActiveIndex(),
            e.updateSlidesClasses()
        }
        let s;
        e.params.freeMode && e.params.freeMode.enabled ? (i(),
        e.params.autoHeight && e.updateAutoHeight()) : ((e.params.slidesPerView === "auto" || e.params.slidesPerView > 1) && e.isEnd && !e.params.centeredSlides ? s = e.slideTo(e.slides.length - 1, 0, !1, !0) : s = e.slideTo(e.activeIndex, 0, !1, !0),
        s || i()),
        r.watchOverflow && t !== e.snapGrid && e.checkOverflow(),
        e.emit("update")
    }
    changeDirection(e, t=!0) {
        const r = this
          , i = r.params.direction;
        return e || (e = i === "horizontal" ? "vertical" : "horizontal"),
        e === i || e !== "horizontal" && e !== "vertical" || (r.el.classList.remove(`${r.params.containerModifierClass}${i}`),
        r.el.classList.add(`${r.params.containerModifierClass}${e}`),
        r.emitContainerClasses(),
        r.params.direction = e,
        r.slides.forEach(s=>{
            e === "vertical" ? s.style.width = "" : s.style.height = ""
        }
        ),
        r.emit("changeDirection"),
        t && r.update()),
        r
    }
    changeLanguageDirection(e) {
        const t = this;
        t.rtl && e === "rtl" || !t.rtl && e === "ltr" || (t.rtl = e === "rtl",
        t.rtlTranslate = t.params.direction === "horizontal" && t.rtl,
        t.rtl ? (t.el.classList.add(`${t.params.containerModifierClass}rtl`),
        t.el.dir = "rtl") : (t.el.classList.remove(`${t.params.containerModifierClass}rtl`),
        t.el.dir = "ltr"),
        t.update())
    }
    mount(e) {
        const t = this;
        if (t.mounted)
            return !0;
        let r = e || t.params.el;
        if (typeof r == "string" && (r = document.querySelector(r)),
        !r)
            return !1;
        r.swiper = t,
        r.shadowEl && (t.isElement = !0);
        const i = ()=>`.${(t.params.wrapperClass || "").trim().split(" ").join(".")}`;
        let o = (()=>r && r.shadowRoot && r.shadowRoot.querySelector ? r.shadowRoot.querySelector(i()) : xu(r, i())[0])();
        return !o && t.params.createElements && (o = LH("div", t.params.wrapperClass),
        r.append(o),
        xu(r, `.${t.params.slideClass}`).forEach(a=>{
            o.append(a)
        }
        )),
        Object.assign(t, {
            el: r,
            wrapperEl: o,
            slidesEl: t.isElement ? r : o,
            mounted: !0,
            rtl: r.dir.toLowerCase() === "rtl" || hc(r, "direction") === "rtl",
            rtlTranslate: t.params.direction === "horizontal" && (r.dir.toLowerCase() === "rtl" || hc(r, "direction") === "rtl"),
            wrongRTL: hc(o, "display") === "-webkit-box"
        }),
        !0
    }
    init(e) {
        const t = this;
        return t.initialized || t.mount(e) === !1 || (t.emit("beforeInit"),
        t.params.breakpoints && t.setBreakpoint(),
        t.addClasses(),
        t.updateSize(),
        t.updateSlides(),
        t.params.watchOverflow && t.checkOverflow(),
        t.params.grabCursor && t.enabled && t.setGrabCursor(),
        t.params.loop && t.virtual && t.params.virtual.enabled ? t.slideTo(t.params.initialSlide + t.virtual.slidesBefore, 0, t.params.runCallbacksOnInit, !1, !0) : t.slideTo(t.params.initialSlide, 0, t.params.runCallbacksOnInit, !1, !0),
        t.params.loop && t.loopCreate(),
        t.attachEvents(),
        [...t.el.querySelectorAll('[loading="lazy"]')].forEach(i=>{
            i.complete ? vv(t, i) : i.addEventListener("load", s=>{
                vv(t, s.target)
            }
            )
        }
        ),
        t.initialized = !0,
        t.emit("init"),
        t.emit("afterInit")),
        t
    }
    destroy(e=!0, t=!0) {
        const r = this
          , {params: i, el: s, wrapperEl: o, slides: a} = r;
        return typeof r.params > "u" || r.destroyed || (r.emit("beforeDestroy"),
        r.initialized = !1,
        r.detachEvents(),
        i.loop && r.loopDestroy(),
        t && (r.removeClasses(),
        s.removeAttribute("style"),
        o.removeAttribute("style"),
        a && a.length && a.forEach(l=>{
            l.classList.remove(i.slideVisibleClass, i.slideActiveClass, i.slideNextClass, i.slidePrevClass),
            l.removeAttribute("style"),
            l.removeAttribute("data-swiper-slide-index")
        }
        )),
        r.emit("destroy"),
        Object.keys(r.eventsListeners).forEach(l=>{
            r.off(l)
        }
        ),
        e !== !1 && (r.el.swiper = null,
        PH(r)),
        r.destroyed = !0),
        null
    }
    static extendDefaults(e) {
        ma(zx, e)
    }
    static get extendedDefaults() {
        return zx
    }
    static get defaults() {
        return Hb
    }
    static installModule(e) {
        Ua.prototype.__modules__ || (Ua.prototype.__modules__ = []);
        const t = Ua.prototype.__modules__;
        typeof e == "function" && t.indexOf(e) < 0 && t.push(e)
    }
    static use(e) {
        return Array.isArray(e) ? (e.forEach(t=>Ua.installModule(t)),
        Ua) : (Ua.installModule(e),
        Ua)
    }
}
Object.keys(Nx).forEach(n=>{
    Object.keys(Nx[n]).forEach(e=>{
        Ua.prototype[e] = Nx[n][e]
    }
    )
}
);
Ua.use([VH, WH]);
he.gsap.registerPlugin(kn, Kf, jo);
if (screen.width > 1024) {
    const n = Kf.create({
        wrapper: "#wrapper",
        content: "#content",
        smooth: 1,
        normalizeScroll: !0,
        ignoreMobileResize: !0,
        effects: !0,
        preventDefault: !0
    });
    kn.create({
        trigger: "#root",
        start: "top 0",
        end: "top -20000%",
        scrub: .2,
        pin: "#root",
        pinSpacing: !1
    });
    const e = function(t, r) {
        he.gsap.to("#aceptar div", {
            x: t,
            y: r,
            duration: .1,
            ease: "power4.easeInOut",
            immediateRender: !1
        })
    };
    document.addEventListener("mousemove", function(t) {
        e(t.pageX, t.pageY)
    }),
    document.fonts.ready.then(function() {
        var t = document.querySelector("#aceptar")
          , r = document.querySelector("#silenciostart")
          , i = document.querySelector("#fixworks")
          , s = document.querySelector("#barcode1");
        t.classList.add("fonts"),
        r.classList.add("ready");
        const o = ()=>{
            i.classList.add("open"),
            s.classList.remove("ready")
        }
        ;
        he.gsap.to("#scroll div", {
            scrollTrigger: {
                trigger: "#landing",
                start: "top 0",
                end: "top -30%",
                scrub: .2
            },
            autoAlpha: 0,
            ease: "power4.easeInOut",
            immediateRender: !1
        }),
        he.gsap.to("#inferior div", {
            scrollTrigger: {
                trigger: "#segunda",
                start: "top 80%",
                end: "top 50%",
                scrub: .2
            },
            stagger: .5,
            autoAlpha: 1,
            ease: "power4.easeInOut",
            immediateRender: !1
        }),
        kn.create({
            trigger: "#landing",
            start: "top -40%",
            end: "top -41%",
            onEnter: o
        }),
        kn.create({
            trigger: ".etiqueta.uno",
            start: "top 0",
            end: "top -200%",
            scrub: .2,
            pin: ".etiqueta.uno"
        }),
        he.gsap.to("#border1", {
            scrollTrigger: {
                trigger: "#tercera",
                start: "bottom -70%",
                end: "bottom -100%",
                scrub: .2
            },
            width: innerWidth * .07,
            height: innerWidth * .07,
            ease: "power4.easeInOut",
            immediateRender: !1
        }),
        he.gsap.to("#marco1 .numeroin", {
            scrollTrigger: {
                trigger: "#tercera",
                start: "bottom -100%",
                end: "bottom -180%",
                scrub: .2
            },
            x: -innerWidth * .053,
            ease: "power4.easeInOut",
            immediateRender: !1
        }),
        he.gsap.to("#border1", {
            scrollTrigger: {
                trigger: "#tercera",
                start: "bottom -100%",
                end: "bottom -180%",
                scrub: .2
            },
            x: innerWidth * .325,
            ease: "power4.easeInOut",
            immediateRender: !1
        }),
        he.gsap.to(".interactive", {
            scrollTrigger: {
                trigger: "#tercera",
                start: "bottom -200%",
                end: "bottom -220%",
                scrub: .2
            },
            autoAlpha: 1,
            ease: "power4.easeInOut",
            immediateRender: !1
        }),
        kn.create({
            trigger: ".etiqueta.dos",
            start: "top 0",
            end: "top -100%",
            scrub: .2,
            pin: ".etiqueta.dos"
        }),
        he.gsap.to("#border2", {
            scrollTrigger: {
                trigger: "#aesthetics",
                start: "bottom -70%",
                end: "bottom -100%",
                scrub: .2
            },
            x: 0,
            y: innerHeight * .3,
            width: innerWidth * .07,
            height: innerWidth * .07,
            ease: "power4.easeInOut",
            immediateRender: !1
        }),
        he.gsap.to("#marco2 .numeroin", {
            scrollTrigger: {
                trigger: "#tercera",
                trigger: "#aesthetics",
                start: "bottom -100%",
                end: "bottom -130%",
                scrub: .2
            },
            y: 0,
            ease: "power4.easeInOut",
            immediateRender: !1
        }),
        he.gsap.to(".websites", {
            scrollTrigger: {
                trigger: "#tercera",
                trigger: "#aesthetics",
                start: "bottom -100%",
                end: "bottom -120%",
                scrub: .2
            },
            autoAlpha: 1,
            ease: "power4.easeInOut",
            immediateRender: !1
        }),
        kn.create({
            trigger: ".etiqueta.tres",
            start: "top 0",
            end: "top -200%",
            scrub: .2,
            pin: ".etiqueta.tres"
        }),
        he.gsap.to("#border3", {
            scrollTrigger: {
                trigger: "#motion",
                start: "bottom -70%",
                end: "bottom -100%",
                scrub: .2
            },
            width: innerWidth * .07,
            height: innerWidth * .07,
            ease: "power4.easeInOut",
            immediateRender: !1
        }),
        he.gsap.to("#border3", {
            scrollTrigger: {
                trigger: "#motion",
                start: "bottom -100%",
                end: "bottom -180%",
                scrub: .2
            },
            x: -innerWidth * .325,
            ease: "power4.easeInOut",
            immediateRender: !1
        }),
        he.gsap.to("#marco3 .numeroin", {
            scrollTrigger: {
                trigger: "#motion",
                start: "bottom -100%",
                end: "bottom -180%",
                scrub: .2
            },
            x: innerWidth * .057,
            ease: "power4.easeInOut",
            immediateRender: !1
        }),
        he.gsap.to(".communication", {
            scrollTrigger: {
                trigger: "#motion",
                start: "bottom -200%",
                end: "bottom -220%",
                scrub: .2
            },
            autoAlpha: 1,
            ease: "power4.easeInOut",
            immediateRender: !1
        }),
        kn.create({
            trigger: ".etiqueta.cuatro",
            start: "top 0",
            end: "top -300%",
            scrub: .2,
            pin: ".etiqueta.cuatro"
        }),
        kn.create({
            trigger: "#final",
            start: "top 0",
            end: "top -100%",
            scrub: .2,
            pin: "#final"
        }),
        he.gsap.to("#border4", {
            scrollTrigger: {
                trigger: "#disruptive",
                start: "bottom -70%",
                end: "bottom -100%",
                scrub: .2
            },
            width: innerWidth * .07,
            height: innerWidth * .07,
            ease: "power4.easeInOut",
            immediateRender: !1
        }),
        he.gsap.to("#border4", {
            scrollTrigger: {
                trigger: "#disruptive",
                start: "bottom -100%",
                end: "bottom -180%",
                scrub: .2
            },
            x: 0,
            ease: "power4.easeInOut",
            immediateRender: !1
        }),
        he.gsap.to("#root", {
            scrollTrigger: {
                trigger: "#landing",
                start: "top 0",
                end: "top -200%",
                scrub: .2
            },
            filter: "blur(0px)",
            ease: "power4.easeInOut",
            immediateRender: !1
        }),
        he.gsap.to("#backtop", {
            scrollTrigger: {
                trigger: "#clients",
                start: "bottom 10%",
                end: "bottom 0",
                scrub: .2
            },
            autoAlpha: 1,
            ease: "power4.easeInOut",
            immediateRender: !1
        });
        var a = document.querySelector("#backtop");
        a.onclick = function() {
            n.scrollTo(0, 10)
        }
        ;
        const l = document.querySelectorAll(".tit");
        function f() {
            l.forEach(M=>{
                M.split = new jo(M,{
                    type: "chars, lines",
                    charsClass: "char"
                }),
                M.split = new jo(M,{
                    type: "chars, lines",
                    charsClass: "charin"
                })
            }
            )
        }
        f();
        const h = document.querySelectorAll(".tit1");
        function d() {
            h.forEach(M=>{
                M.split = new jo(M,{
                    type: "words, lines",
                    wordsClass: "word"
                }),
                M.split = new jo(M,{
                    type: "words",
                    wordsClass: "wordin"
                })
            }
            )
        }
        d();
        const p = document.querySelectorAll(".titulos2");
        function m() {
            p.forEach(M=>{
                M.split = new jo(M,{
                    type: "lines,chars",
                    charsClass: "tit2"
                }),
                M.split = new jo(M,{
                    type: "chars",
                    charsClass: "tit2in"
                }),
                M.anim = he.gsap.to(M.split.chars, {
                    scrollTrigger: {
                        trigger: M,
                        start: "top 90%"
                    },
                    y: 0,
                    stagger: .03,
                    duration: 1
                })
            }
            )
        }
        m();
        const _ = document.querySelectorAll(".titulos3");
        function y() {
            _.forEach(M=>{
                M.split = new jo(M,{
                    type: "lines,words",
                    linesClass: "tit3"
                }),
                M.split = new jo(M,{
                    type: "words",
                    wordsClass: "tit3in"
                }),
                M.anim = he.gsap.to(M.split.words, {
                    scrollTrigger: {
                        trigger: M,
                        start: "top 100%"
                    },
                    y: 0,
                    stagger: .1,
                    duration: .8
                })
            }
            )
        }
        y();
        const x = document.querySelectorAll(".text");
        function S() {
            x.forEach(M=>{
                M.split = new jo(M,{
                    type: "lines, words",
                    linesClass: "linein"
                }),
                M.anim = he.gsap.from(M.split.lines, {
                    scrollTrigger: {
                        trigger: M,
                        start: "top 100%"
                    },
                    duration: .8,
                    ease: "Power4.easeOut",
                    y: .05 * innerWidth,
                    stagger: .08
                })
            }
            )
        }
        S(),
        new jo(".text",{
            type: "lines",
            linesClass: "line"
        })
    });
    var K8 = document.querySelector("#copymail")
      , Vb = document.querySelector("#copied");
    K8.onclick = function() {
        navigator.clipboard.writeText("porfavor@silencio.es"),
        Vb.classList.add("on"),
        setTimeout(function() {
            Vb.classList.remove("on")
        }, 2e3)
    }
    ,
    console.log("silencio.es :x")
}
if (screen.width < 1024) {
    document.fonts.ready.then(function() {
        new jo("#largemov div",{
            type: "words"
        })
    }),
    new Ua(".mySwiper",{
        centeredSlides: !0,
        slidesPerView: "auto"
    });
    var H0 = document.querySelector("#infosmov")
      , Wb = document.querySelector("#ticket");
    H0.onclick = function() {
        if (H0.classList.contains("on"))
            Wb.classList.remove("up"),
            H0.classList.remove("on");
        else {
            var n = new Audio("/print2.1.mp3");
            Wb.classList.add("up"),
            H0.classList.add("on"),
            n.play()
        }
    }
}
window.onunload = function() {
    window.scrollTo(0, 0)
}
;
//# sourceMappingURL=index-d92960aa.js.map
